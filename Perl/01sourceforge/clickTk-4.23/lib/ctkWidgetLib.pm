#!/usr/lib/perl
##              -w -d:ptkdb

=pod

=head1 ctkWidgetLib

	Class ctkWidgetLib models a widget class library in the ctk environment.
	It controls all widgets which may be generated by ctk,
	in order to keep them ready to be used (accessed) while
	ctk sessions.

	That means it registers, loads and saves the widget definitions,
	whereby

	'register' a widget means make it known to ctk,
	'save' means make the widget definitions persistent into a dedicated folder of ctk,
	'load' means make the saved widget accessable while a ctk session for use.

	Standard TK-widget are automatically registered.

	Derived or composite widget should be individually and explicitely registered.

=head2 Widget class properties

	classname the name of the widget class: valid class name,
	          optional, default file name whithout extension

	filename  the file name of the widget definition: valid file name,
	          optional, default classname.'.pl'

	defaultwidgetoptions list of the default widget options,
	                     optional, no default.

	geom       the widget needs the geometry manager, mandatory,
	           0 | 1

	defaultgeometrymanager name of the geometry manager to be be proposed,
	                       default 'pack' .

	defaultgeometryoptions list of the default options, optional.

	use        package name to be given in the use statement, optional,
	           default 'Tk::'.classname,
	           '  ' suppress tne generation of the use statement for the widget.

	balloon    set up an hint to the widget, mandatory,
	           0 | 1

	icon       name of the image file to be used as icon
	           (may be any file supported by widget Photo),
	           default (missing.gif)

	attr       supported widget's attribute list.

=head2 Syntax

	$widgetClassLib = ctkWidgetLib->new(widgetlib => <widget library folder>, widgets => <ref to widget list>);

	$widgetClassLib->create(<classname>);

	$widgetClassLib->createNonVisualClass(<classname>);

	$widgetClassLib->loadAll();

	$widgetList = $widgetClassLib->widgets;

	$pathToWidgetLib = $widgetClassLib->widgetlib;

	$widgetClassLib->register(<ref to parent widget>[,<classname>]);


	$widgetClassDef = $widgetClassLib->load(<classname>);

	$widgetClassLib->saveAll();

	$widgetClassLib->save(<widgetClass>)

	$widgetClassLib->dlg_widgetRegistrationsParam(<ref to parent widget>,<classname>);

	$widgetClassLib->registerWidgetClassDefinition();

	$widgetClassLib->editWidgetOptions(<ref to dialog widget>,<classname>,<useFileName>,<attr>);

	$widgetClassLib->deleteWidgetClass(<widgetClass>);

	$widgetClassLib->validateUseName(<use>,<library,<version>,<askuser>);

=head2 Programming notes

=over

=item Actually the individual class definitions are ref to HASH.

=item Run time environment

	Almost all methods need the active run time env of ctk_w.
		- cwd must be the clickTk folder
		- widget library
		- widget class definition list

=back

=head2 Maintenance

	Author: mam
	date:   01.01.2005
	History
	        01.01.2005 MO000xx mam First draft
	        25.10.2005 MO00704 version 1.02
	        28.10.2005 MO00705 version 1.03
	        15.09.2006 version 1.04
			02.10.2006 version 1.05
			05.10.2006 version 1.06
			20.11.2007 version 1.07
			14.03.2008 version 1.09
			27.05.2008 version 1.10
			28.10.2008 version 1.11
			23.11.2009 version 1.12 (pathName)
			08.02.2011 version 1.13
			04.04.2011 version 1.14
			21.02.2012 version 1.15
			02.11.2013 version 1.16 P106 edit options

=head2 Methods

=head3 Summary

	new
	destroy

	_backup
	_init

	create
	createNonVisualClass
	deleteWidgetClass
	dlg_widgetRegistrationsParam
	editNonVisualClassOptions
	editWidgetOptions
	fileName
	load
	loadAll
	register
	registerWidgetClassDefinition
	save
	saveAll
	validateUseName

=cut

package ctkWidgetLib;

use strict;
use base (qw/ctkBase/);

our $VERSION = 1.16;

my $FS = ($^O =~ /^mswin/i) ? '\\' : '/';

my @optionsTyp= sort (qw/array int int+ text color float callback file text- text+ menu() menu(0|1) menu(normal|disabled) menu(s|os|e|oe|w|ow|n|on|se|ose|soe|osoe|sw|osw|sow|ne|one|noe|onoe|nw|onw|now|onow) variable relief widget justify anchor side photo list/);

=head2 Properties

	widgetlib
	widgets
	class
	use
	optionsTyp

=cut

sub widgetlib { shift->{widgetlib} }
sub widgets {shift->{widgets}}
sub class {shift->{class}}
sub use {return shift->use}
sub optionsTyp { wantarray ? @optionsTyp : scalar(@optionsTyp) }

=head2 new

	Construct the instance

	- save the argument list
	- set up class name
	- send message new to SUPER class (arguments)
	- bless the instance returned from SUPER
	- initialize the instance by mean of message $self->_init

=cut

sub new {
	my $class = shift;
	my (%args) = @_;
	$class = ref($class) || $class ;
	my $self = $class->SUPER::new(%args);
	bless  $self, $class;
	$self->_init(%args);

	return $self
}

=head2 destroy

	Destruct the instance.

=cut

sub destroy {
	my $self = shift;
	$self->SUPER::destroy();
	$self = undef;
}

## --------------------------------------------------------

=head2 _init

	Intialize the instance

	-set up properties


=cut

sub _init {
	my $self = shift;
	my (%args) = @_;
	if (exists $args{widgetlib}) {
			$self->{widgetlib} = delete $args{widgetlib}
	} else {
		$self->{widgetlib} = 'widgets';
	}
	if (exists $args{widgets}) {
			$self->{widgets} = delete $args{widgets}
	} else {
		$self->{widgets} = {};
	}
	if (exists $args{widget}) {
			$self->{widget} = delete $args{widget}
	} else {
		$self->{widget} = {};
	}
	return 1
}

=head2 fileName

	Build the standard file name of a widget class definition.
	It returns the file name corresponding to the given widget class

	Note : this method doesn't check whether the file exists.

=cut

sub fileName {
	my $self = shift;
	my ($widgetClass) = @_;
	my $rv ='';
	my $fName = $self->widgets->{$widgetClass}->{'file'} if (exists $self->widgets->{$widgetClass});
	$fName =~ s/\.pl$//;
	$fName = $widgetClass unless ($fName);
	my $p = $self->widgetlib();
	$p .= $FS unless $p =~ /[\\\/]$/;
	$rv = $p . $fName . '.pl';
	return $rv
}

=head2 _backup

	move the widget definition file to a backup image.

	That is done unlinking the actually existing backup and
	renaming the existing file to <fileName>.bak .

	It returns true if the rename worked fine.

=cut

sub _backup {
	my $self = shift;
	my ($className) = @_;
	my $rv;
	my $fName = $self->fileName($className);
	unlink "$fName.bak" if (-f "$fName.bak");
	$rv = rename "$fName","$fName.bak";
	return $rv
}

=head2 register

	- Register a single widget class to ctk_w .
	- send message registerWidgetClassDefinition to do the job.

=cut

sub register {
	my $self = shift;
	my ($hwnd,$type) = @_;
	my $rv ;
	if (defined($type)) {
		$rv = $self->registerWidgetClassDefinition($hwnd,$type);
	} else {
		$rv = $self->registerWidgetClassDefinition($hwnd);
	}
	return $rv;
}

=head2 create

	This method returns a ref to HASH which contains all data members
	of a widgetLib intance. All memeber but classname are initialized
	to their default values.
	Classname is given the value passed to as argument.

		geom        = 1,
		nonVisual   = 0,
		balloon     = 1,
		use         = '',
		file        = '',
		classname   = $classname,
		defaultgeometrymanager = 'pack',
		defaultgeometryoptions = '',
		defaultwidgetoptions   = '',
		icon        = 'default',
		pathName    => ''
		attr        = {}

=over

=item Arguments

	class name (mandatory)

=item Returns

	ref to HASH.

=item Notes

	None.

=back

=cut

sub create {
	my $self = shift;
	my ($type) = @_;
	$type = 'unknown' unless defined $type;
	my $rv = {
		'geom'		=> 1,
		'nonVisual'	=> 0,
		'balloon'	=> 1,
		'use'		=> '',
		'file'		=> '',
		'classname'	=> "$type",
		'defaultgeometrymanager' => 'pack',
		'defaultgeometryoptions' => '',
		'defaultwidgetoptions'	=> '',
		'icon'		=> 'default',
		'pathName'	=> '',
		'attr'		=> {}
		};
	return $rv;
}

=head2 createNonVisualClass

	Same as create but specialized for nonvisual classes.

=cut

sub createNonVisualClass {
	my $self = shift;
	my ($class) = @_;
	my $rv = $self->create($class);
	$rv->{'nonVisual'} = 1;
	$rv->{'geom'} = 0;
	$rv->{'icon'} = 'nonvisual';
	$rv->{'use'} = $class;
	return $rv;
}

=head2 loadAll

	Load all widget into memory.

	This method returns ref to hash containing all actually registered widgets.

	It creates the widget list and always saves a ref to that list into
	the property 'widgets'.

	Additionally it returns that ref to the issuer.

	Note: this method scans the widgets folder for file names ending with '.pl'
	      which are assumed to be class definitions.
	      Once loaded the definition are stored using the value of the item 'classname'
	      If this item doesn't exists then the file name without extension is used as class name instead.

=cut

sub loadAll {
	my $self = shift;
	my $rv = {};
	my @defsInError=();
	local *DIR;
	opendir(DIR, $self->{widgetlib});
	my @wDefs;
	@wDefs = grep {
			/\w+\.pl$/
			} readdir(DIR);
	closedir DIR;
	foreach my $def (@wDefs) {
		my $w = $self->load($def);
		my $id =$def; $id =~ s/\.pl$//;
		$id = $w->{'classname'} if(exists $w->{'classname'});
		if (exists $w->{'use'}) {
			unless ($w->{'use'} =~ /^\s*$/) { ## empty value suppresses use
				my $n = $w->{'use'};
				my $lib;
				if ($n =~ /\S+/) {
					if (exists $w->{'pathName'}) {
						$lib = $w->{'pathName'}
					} else {
						if (exists($w->{'useApplFolderAsPathName'}) && $w->{'useApplFolderAsPathName'}) {
							$lib = $ctkApplication::applFolder;
						} else {
						}
					}
				} else {
					$n = 'Tk::'.$id
				}
				unless ($self->validateUseName($n,$lib,undef,0)) {
					&main::Log("Definition $def: package $id could not be found, discarded.");
					push @defsInError,$def;
					next
				}
			}
		} else {
			my $n = 'Tk::'.$id;
			unless ($self->validateUseName($n,undef,undef,0)) {
				&main::Log("Definition $def: package $id could not be found, discarded.");
				push @defsInError,$def;
				next
			}
		}
		$w->{'filename'} = $def;
		if (!exists($rv->{$id})) {
			$rv->{$id} = $w if(defined($w));
		} else {
			&main::Log("Class def for '$id' already exists, '$def' discarded.");
			push @defsInError,$def;
		}
	}
	if ($main::debug && @defsInError &&
		not &std::askYN("Following widget defs could not be loaded\n\n" .
					join("\n",@defsInError) .
					"\n\nSee log for the exceptions" .
					"\n\nContinue anyway?")) {
			main::abandon()
	}
	$self->{widgets} = $rv;
	return $rv
}

=head2 load

	Load a definition into memory.

	This method returns a ref to an instance of type ctkWidgetLib
	if the job has been well done, undef otherwise.

	Arguments

		self
		file name of the def

	Return

	ref to the definition or
	UNDEF in case of errors.

=cut

sub load {
	my $self = shift;
	my ($fName) = @_;
	my $rv;
	local *WD;
	my $path = $self->widgetlib;
	$path .= $FS unless($path =~ /[\\\/]$/);
	open (WD,"<$path$fName");
	unless (*WD) {
		&std::ShowDialog(-title=>'Error:',-text=>"Could not open '$fName',\ncannot save widget!",-buttons=>['Continue']);
		};
	my @s = <WD>;
	close WD;

	$rv = eval 'my '.join '',@s;
	if ($@) {
		&main::log("Could not load widget def '$fName' because of ",$@,'definition ignored ');
		$rv = undef
	}
	$rv->{nonVisual} = 0 unless exists $rv->{nonVisual};
	return $rv
}

=head2 save

	The method saves the currently active widget class definition
	into the persistent widget definition's library.

	To do that task it accesses the widget class list applying the given classname and uses Data::Dumper->Dump and returns
	the file name.

=cut

sub save {
	my $self = shift;
	my ($w) = @_;
	my $w_attr = $self->widgets;

	return undef unless exists $w_attr->{$w};

	my $file = $self->fileName($w);

	$self->_backup("$w") if (-f $file);

	require Data::Dumper;
	open (WD,">$file");
	unless (*WD) {
			&std::ShowDialog(-title=>'Error:',-text=>"Could not open '$file',\ncannot save work!",-buttons=>['Continue']);
			return undef;
		};
	$Data::Dumper::Indent = 1;		# turn indentation to a minimum
	my $s = Data::Dumper->Dump([$w_attr->{$w}],['rDef']);
	print WD $s;
	close WD;
	return $file;
}


=head2 saveAll

	Save all widgets persistently to disk.

	Method saveAll returns true if the job has been well done
	undef otherwise.

=cut

sub saveAll {
	my $self = shift;
	my $rv = 1;
	my $w_attr = $self->{widgets};
	foreach my $w (keys %$w_attr) {
		my $f = $self->save($w);
		if (defined($f)) {
			&main::Log("Widget definition '$w' saved into 'widget$FS$f'");
		} else {
			$rv = undef;
		}
	}
	return $rv
}

=head2 dlg_widgetRegistrationsParam

	This method sets up modal dialog to enter options.

	It returns a ref to HASH containing all definition's options,
	or undef if the user dismissed the action.

=cut

sub dlg_widgetRegistrationsParam {
my $self = shift;
my ($hwnd,$type) = @_;
my $rv;

my $db = $hwnd->ctkDialogBox(
	-title=> 'Enter widget registration parameters',
	-buttons=> ['OK','Cancel']);


my ($attr,$geom,$nonVisual,$balloon, $geomManager,$geomOptions,$widgetOptions,$defFileName,$useFileName,$className,$iconName,$pathName);

	if (defined($type)) {
		my $w_attr = $self->widgets;
		$geom          = $w_attr->{$type}->{'geom'};
		$nonVisual     = $w_attr->{$type}->{'nonVisual'};
		$balloon       = $w_attr->{$type}->{'balloon'};
		$useFileName   = $w_attr->{$type}->{'use'};
		$defFileName   = $w_attr->{$type}->{'file'};
		$className     = $w_attr->{$type}->{'classname'};
		$geomManager   = $w_attr->{$type}->{'defaultgeometrymanager'};
		$geomOptions   = $w_attr->{$type}->{'defaultgeometryoptions'};
		$widgetOptions = $w_attr->{$type}->{'defaultwidgetoptions'};
		$iconName      = $w_attr->{$type}->{'icon'};
		$attr          = $w_attr->{$type}->{'attr'};
		$pathName      = $w_attr->{$type}->{'pathName'};
		$className = $type unless ($className);
	} else {
		$attr = {}; $geom = $balloon = 0;
		$geomManager = 'pack';
		$defFileName = $useFileName = $className = '';
		$iconName = 'default';
	}
## ctk: gcode

## ctk: gcode
## ctk: code generated by ctk_w version '2.018'
## ctk: lexically scoped variables for widgets

my $rW001 ;
my $rW013 ;
my $rW017 ;
my $rW002 ;
my $rW011 ;
my $rW_register ;
my $rW_widgetOptionsList ;
my $rWgeomMan ;
my $rW_geomOpt ;
my $rW_widgetOpt ;
my $rW_geom ;
my $rW_nonVisual ;
my $rW_balloon ;
my $rW_defFile ;
my $rW_use ;
my $rW_classname ;
my $rW_icon ;
my $rW_pathName;
## ctk: instantiate and display widgets

$rW001 = $db -> LabFrame ( -label=>'Widget definition options', -borderwidth=>1, -relief=>'ridge', -labelside=>'acrosstop' ) -> pack(-anchor=>'nw', -fill=>'both', -side=>'top', -expand=>1);
$rW017 = $rW001 -> Frame ( -relief=>'solid' ) -> pack(-anchor=>'nw', -pady=>10, -fill=>'x', -side=>'top', -expand=>1);
$rW013 = $rW001 -> Frame ( -borderwidth=>2, -relief=>'flat' ) -> pack(-anchor=>'nw', -fill=>'y', -side=>'top', -expand=>1);
$rW002 = $db -> LabFrame ( -label=>'Default options', -borderwidth=>1, -relief=>'ridge', -labelside=>'acrosstop' ) -> pack(-anchor=>'nw', -pady=>3, -fill=>'both', -side=>'top', -expand=>1, -padx=>5);
$rW011 = $db -> Frame ( -relief=>'flat' ) -> pack(-anchor=>'nw', -pady=>2, -fill=>'both', -side=>'top', -expand=>1, -padx=>5);

$rW_widgetOptionsList = $rW011 -> Button ( -background=>'#ffffff', -command=>sub{
					$useFileName = "Tk::$className" unless (defined($useFileName) && $useFileName =~ /\S/);
					my $attrNew = ($nonVisual) ?
					$self->editNonVisualClassOptions($db,$className,$useFileName,$attr,$pathName)
					:
					$self->editWidgetOptions($db,$className,$useFileName,$attr,$pathName);
					$attr = $attrNew if defined($attrNew);
					}, -state=>'normal', -text=>'Widgets options list' ) -> pack(-anchor=>'nw', -fill=>'x', -side=>'left', -expand=>1);

$rWgeomMan = $rW002 -> BrowseEntry ( -background=>'#ffffff', -label=>'geometry manager', -labelPack=>[-side,'left',-anchor,'nw'], -state=>'normal', -justify=>'left', -variable=>\$geomManager, -choices => [qw/pack grid place form/] ) -> grid(-row=>0, -pady=>10, -column=>0, -sticky=>'we', -padx=>20);
$rW_geomOpt = $rW002 -> LabEntry ( -background=>'#ffffff', -label=>'geometry options', -labelPack=>[-side,'left',-anchor,'nw'], -state=>'normal', -justify=>'left', -relief=>'sunken', -textvariable=>\$geomOptions ) -> grid(-row=>1, -pady=>10, -column=>0, -sticky=>'we', -padx=>20);
$rW_widgetOpt = $rW002 -> LabEntry ( -background=>'#ffffff', -label=>'widget options', -labelPack=>[-side,'left',-anchor,'nw'], -state=>'normal', -justify=>'left', -relief=>'sunken', -textvariable=>\$widgetOptions ) -> grid(-row=>2, -pady=>10, -column=>0, -sticky=>'we', -padx=>20);
$rW_nonVisual = $rW013 -> Checkbutton ( -state=>'normal', -justify=>'left', -text=>'non-visual class', -relief=>'flat', -onvalue=>1 , -variable => \$nonVisual) -> grid(-row=>2, -pady=>5, -column=>0, -sticky=>'w');
$rW_geom = $rW013 -> Checkbutton ( -state=>'normal', -justify=>'left', -text=>'needs geometry manager', -relief=>'flat', -onvalue=>1 , -variable => \$geom) -> grid(-row=>1, -pady=>5, -column=>0, -sticky=>'w');
$rW_balloon = $rW013 -> Checkbutton ( -state=>'normal', -justify=>'left', -text=>'show widget code as balloon', -relief=>'flat', -variable => \$balloon ) -> grid(-row=>0, -pady=>5, -column=>0, -sticky=>'w');
$rW_classname = $rW017 -> LabEntry ( -background=>($className) ? '#E4E4E4':'#ffffff', -label=>'class name', -labelPack=>[-side,'left',-anchor,'n'], -state=>($className)? 'disabled':'normal', -justify=>'left', -relief=>'sunken', -textvariable=>\$className ) -> pack(-anchor=>'nw', -pady=>3, -fill=>'x', -side=>'top', -expand=>1);
$rW_defFile = $rW017 -> LabEntry ( -background=>'#ffffff', -label=>'definitions file name', -labelPack=>[-side,'left',-anchor,'n'], -state=>'normal', -justify=>'left', -relief=>'sunken', -textvariable=>\$defFileName ) -> pack(-anchor=>'nw', -pady=>3, -fill=>'x', -side=>'top', -expand=>1);
$rW_use = $rW017 -> LabEntry ( -background=>'#ffffff', -label=>'use name', -labelPack=>[-side,'left',-anchor,'n'], -state=>'normal', -justify=>'left', -relief=>'sunken', -textvariable=>\$useFileName ) -> pack(-anchor=>'nw', -pady=>3, -fill=>'x', -side=>'top', -expand=>1);
$rW_icon = $rW017 -> LabEntry ( -background=>'#ffffff', -label=>'icon name', -labelPack=>[-side,'left',-anchor,'n'], -state=>'normal', -justify=>'left', -relief=>'sunken', -textvariable=>\$iconName ) -> pack(-anchor=>'nw', -pady=>3, -fill=>'x', -side=>'top', -expand=>1);
$rW_pathName = $rW017 -> LabEntry ( -background=>'#ffffff', -label=>'file path', -labelPack=>[-side,'left',-anchor,'n'], -state=>'normal', -justify=>'left', -relief=>'sunken', -textvariable=>\$pathName ) -> pack(-anchor=>'nw', -pady=>3, -fill=>'x', -side=>'top', -expand=>1);

$rW_geomOpt->Subwidget('label')->configure(-width => 20);
$rW_widgetOpt->Subwidget('label')->configure(-width => 20);
$rW_classname->Subwidget('label')->configure(-width => 20);
$rW_defFile->Subwidget('label')->configure(-width => 20);
$rW_use->Subwidget('label')->configure(-width => 20);
$rW_icon->Subwidget('label')->configure(-width => 20);

## ctk: end of gened Tk-code

$rv =  $db->Show();

return undef if($rv =~ /Cancel/i);

$useFileName = "Tk::$className" unless ($useFileName);
$defFileName = $className unless ($defFileName);
$iconName = "$className" unless ($iconName);
$geomManager ='' unless ($geom);

if ($self->validateUseName($useFileName,1)) {
	$rv = {
		'geom' => $geom,
		'nonVisual' => $nonVisual,
		'balloon' => $balloon,
		'use' => $useFileName,
		'file' => $defFileName,
		'classname' => $className,
		'defaultgeometrymanager' => $geomManager,
		'defaultgeometryoptions' => $geomOptions,
		'defaultwidgetoptions' => $widgetOptions,
		'icon' => $iconName,
		'pathName' => $pathName,
		'attr' => $attr};
} else {
	$rv = undef
}
return $rv;

} ## end of dlg_widgetRegistrationsParam

=head2 validateUseName

	Method validateUseName validates the existence of the given widget class.

	It returns true if the widget class can be used or required
	false otherwise.

	Arguments

		- name to be used for use (mandatory)
		- library to be used (optional)
		- version of the module (optional)
		- ask user for decision on error (optional)
		  1 ask user to decide
		  0 don't ask the user (default)

	Notes

		- use names prefixed by 'Tk::' are used

		- other names are first suffixed with '.pm' and
		  then required.

=cut

sub validateUseName {
	my $self = shift;
	my ($module,$lib,$version,$askUser) = @_;
	my $rv;
	$lib = '' unless defined $lib;
	$version = '' unless defined $version;
	$askUser = 0 unless defined $askUser;
	if ($lib =~/\S+/) {
		$lib =~ s/\\$// if($lib =~ /\\$/);
		eval <<EOE;
use lib '$lib';
use $module  $version;
no lib '$lib';
EOE
	} else {
		eval <<EOE1;
use $module  $version;
EOE1
	}
	if ($@) {
			$rv = &std::askYN("Could not use module '$module',\n$@',\n\nsave anyway?") if ($askUser);
	} else {
			$rv = 1;
	}
	return $rv
}

=head2 registerWidgetClassDefinition

	This method executes an registration process.

	First it sends dlg_widgetRegistrationsParam to
	accept options and than depending on the user's action
	saves the definition.

	It returns true if the definition has been save , false otherwise.

=cut

sub registerWidgetClassDefinition {
	my $self = shift;
	my $rv;
	$rv = $self->dlg_widgetRegistrationsParam(@_);
	if (defined($rv)) {
		my $wlib = $self->widgets;
		my $className = $rv->{'classname'};
		if (exists ($wlib->{$className})) {
			if (&std::askYN("Widget class '$className' already exists, do you want to overwrite?")) {
				$wlib->{$className} = $rv;
				$rv = $self->save($className);
			} else {
				$rv = undef;
			}
		} else {
			$wlib->{$className} = $rv;
			$rv = $self->save($className);
		}
	}
	$rv = (defined($rv)) ? 1 : 0;
	return $rv
}

=head2 editWidgetOptions

	This method edits the options of a widget class definition:
		- setup a local toplevel
		- use the requested widget
		- instantiate a widget
		- get the option's list
		- set up the edit dialog arguments
		- show the edit dialog
		- get rid of the options marked as 'default'
		- return a ref to the edited option's hash

	Arguments

		- className
		- useFileName
		- attr
		- pathName

	Returns

		- ref to hash with changed attributes

	Notes

=cut

sub editWidgetOptions {
	my $self = shift;
	my ($hwnd,$className,$useFileName,$attr,$pathName) = @_;
	my $rv;
	$useFileName = $className unless($useFileName);
	my $uselib ="use lib '$pathName'" if(defined $pathName && $pathName =~/\S/ && -d $pathName);
	##
	## get widget options for element attr: setup widget ;  $TkAnalysis->getOptions($widget)
	my $mw = MainWindow->new();
	## $useFileName .= '.pm' unless ($useFileName =~ /\.p[ml]$/);
	eval "$uselib ; use $useFileName";
	if ($@) {
		&std::ShowWarningDialog("Could not use '$useFileName' because of\n\n$@ .");
		$mw->DESTROY();
		return undef
	} ## else {}
	my $o = eval "\$mw->$className()";
	if ($@) {
		&std::ShowWarningDialog("Could not instantiate '$className' because of\n\n$@ .");
		$hwnd->Subwidget('B_OK')->configure(-state => 'disabled');
		$mw->DESTROY();
		return undef;
	} else {
		$hwnd->Subwidget('B_OK')->configure(-state => 'normal')
	}

	unless (defined($o)) {
		$mw->DESTROY();
		return undef
	}
	my @opt = $o->configure();

	$mw->DESTROY();

	my @dropDown = $self->optionsTyp();
	unshift @dropDown, 'default';

	my %val = ();
	my %wOptions=();
	foreach my $o (@opt) {
		$val{$o->[0]} = (exists $attr->{$o->[0]}) ? $attr->{$o->[0]} : 'default';
		my @w = eval "(-textvariable , \\\$val{'$o->[0]'},-width ,14,-options ,[\@dropDown],-bg , 'white')";
		$wOptions{$o->[0]} = \@w;
	}
	foreach my $o (keys %$attr) {
		unless (exists $val{$o}) {
			$val{$o} = $attr->{$o};
			my @w = eval "(-textvariable , \\\$val{'$o'},-width ,14,-options ,[\@dropDown],-bg , 'white')";
			$wOptions{$o} = \@w;
		}
	}


	my $db=$hwnd->ctkDialogBox(-title=>"Widget options of $className",-buttons=>['Accept','Cancel']);

	my $db_lf = $db->LabFrame(-labelside=>'acrosstop',-label=>"Widget ".$className." options:")->pack();
	my $db_lft= $db_lf->Scrolled('ctkTiler',-columns,1, -scrollbars=>'oe',-rows,6)->pack();
	my $wM = 0;
	foreach  ( keys %wOptions) {
		$wM = length if ($wM < length);
	}

	map {
		my $name= $_;
		my $f = $db_lf->Frame();
		$db_lft->Manage($f);
		$f->Label(-text,$name, -width, $wM)->pack(-side ,'left',-expand, 1, -fill, 'x');
		$f->Optionmenu(@{$wOptions{$_}})->pack(-side ,'left',-expand, 0, );
	} sort keys %wOptions;
	my $reply=$db->Show();

	return undef if($reply eq 'Cancel');
	map {delete $val{$_} if ($val{$_} =~ /default/)} keys %val;
	$rv = \%val;
	return $rv
}

=head2 editNonVisualClassOptions

	This method edits the options of a non-visual widget definition.

	Arguments

		- className
		- useFileName
		- attr
		-pathName

	Returns

		- ref to hash with changed attributes

	Notes

=cut

sub editNonVisualClassOptions {
	my $self = shift;
	my ($hwnd,$className,$useFileName,$attr) = @_;
	my $rv;
	$useFileName = $className unless($useFileName);

	my @dropDown = $self->optionsTyp();
	unshift @dropDown, 'default';
	my @right_pack=(qw/-side right -padx 7/);
	my $db=$hwnd->ctkDialogBox(-title=>"Widget options of $className",-buttons=>['Accept','Cancel']);

	my $db_lf = $db->LabFrame(-labelside=>'acrosstop',-label=>"Widget ".$className." options:")->pack(-expand, 1, -fill, 'both');
	my $db_lfb = $db->Frame()->pack(-expand, 1, -fill, 'x');
	my $db_lft = $db_lf->Scrolled('ctkTiler', -columns => 1, -scrollbars=>'oe',-rows,6)->pack(-expand, 1, -fill, 'both');
	my $tiler = $db_lft->Subwidget('scrolled');
	my $bAdd   = $db_lfb->Button(-bg,'white',-relief,'raised',-text, ' New ',-command, sub{1})->pack(-side,'left',-expand , 1,-fill, 'x',-padx,3,-pady,3);
	my %val = %$attr;
	my %wOptions=();
	my ($onDelete,$onAdd);

	my $refreshTiler = sub {
		my $db = shift;
		my ($tiler,$val) = @_;
		my @w;
		$tiler->clearAll();
		foreach my $o (sort keys %$val) {
			my $f = $tiler->Frame();
			@w = eval "(-text , '$o') " ;
			$f->Label(@w)->pack(-padx=>7,-pady=>10,-side=>'left');
			$f->Button(-relief,'raised',-text, 'Del',-command, [$onDelete,$db,"$o",$tiler,$val])->pack(-side,'right',-expand,0,-fill,'x');
			@w = eval "(-bg,'white', -variable , \\\$val->{'$o'},-width ,14,-choices , \\\@dropDown)";
			$f->BrowseEntry(@w)->pack(@right_pack);
			$tiler->Manage($f);
		}
	};
	$onAdd = sub{
			my $db = shift;
			my ($name,$tiler,$val) = @_;
			my $dlg;
			if (defined $name && exists $val->{$name}) {
				$dlg = $db->ctkDlgEnterWidgetOptions(
					-title , 'Edit option definition',
					-buttons,['OK','Cancel'],
					-name , $name,
					-value , ' ',
					-type , $val->{$name}
					);
			} else {
				$dlg = $db->ctkDlgEnterWidgetOptions(
					-title , 'New option definition',
					-buttons,['OK','Cancel'],
					-name , '',
					-value , '',
					-type , 'text'
					);
			}
			if ($dlg->Show() =~ /^ok/i) {
					$val->{$dlg->name} = $dlg->type;
					&$refreshTiler($db,$tiler,$val);
			}

		};
	$onDelete = sub{
			my $db = shift;
			my ($name,$tiler,$val) = @_;
			delete $val->{$name} if exists $val->{$name};
			&$refreshTiler($db,$tiler,$val);
		};

	$bAdd->configure(-command, [$onAdd,$db,undef,$tiler,\%val]);
	&$refreshTiler($db,$tiler,\%val);
	my $reply=$db->Show();

	return undef if($reply eq 'Cancel');
	map {delete $val{$_} if ($val{$_} =~ /default/)} keys %val;
	$rv = \%val;
	return $rv
}

=head2 deleteWidgetClass

	This method deletes a widget class definition from the
	registration's library.
	The definition is deleted from the library actually in memory
	and the persistent instance is simply turned to a backup copy.

	This method always returns true.

	Note: this message can be issued only while a ctk_w session!

	Arguments

		- className

	Returns

		- True if the deletion including the backup did fine,
		  undef otherwise.

	Notes

=cut

sub deleteWidgetClass {
	my $self = shift;
	my ($widgetClass) = @_;
	my $rv;
	my $w_attr = $self->widgets;
	delete $w_attr->{$widgetClass};
	$rv = $self->_backup($widgetClass);
	return $rv
}

1; ## -----------------------------------
