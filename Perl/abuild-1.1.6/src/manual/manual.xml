<?xml version='1.0'?>
<!DOCTYPE book [
<!ENTITY Abuild "Abuild">
<!ENTITY abuild "abuild">
<!ENTITY ldquo "&#x201C;">
<!ENTITY rdquo "&#x201D;">
<!ENTITY mdash "&#x2014;">
<!ENTITY nbsp "&#xA0;">
<!ENTITY indent "&#x2014;/">
<!ENTITY swversion "1.1.6">
<!ENTITY lastreleased "June 30, 2011">
]>
<!--

BEFORE EACH RELEASE

 * update swversion and lastreleased above

 * make sure a real date has been included in the release notes

 * Update copyright notice, if needed, in this file, Abuild-init.cc,
   LICENSE.txt, README.source-distribution, and README.release.

Possible fop/stylesheet bugs (as of fop 1.0, stylesheets 1.73.2):

 * A line break can occur before either of the +'s in "C++" and
   after hyphens in command-line options

 * <indexterm/> generates a hard space.

 * Index terms after a chapter title before the first paragraph of the
   chapter do not work.  The same is not true in sections.

Possible stylesheet considerations:

 * Consider putting "example" and maybe "qtest" processing
   instructions in a formal listing/example element if we can get it
   to have a title of "Listing" instead of "Example".  See also
   Program listings chapter in DocBook XSL.

PLEASE READ THESE IMPORTANT NOTES ABOUT EDITING THIS DOCUMENT.

This document confirms to docbook 4.4.  In order to make maintaining
this document as convenient as possible, we explicitly do not deviate
from strict docbook by doing things like adding additional elements.
Instead, we adopt certain conventions.

Place a blank line before each <programlisting> start tag.  This
prevents fill-paragraph in nxml-mode from filling the contents of the
programlisting element when run from the text preceding the
programlisting.  Do not put an extra blank line after the end tag or
put the start tag flush left as these will interfere with future line
indentation.

Each chapter, section, or appendix is given an id that starts with
"ref.".  Each example section is given an id that starts with
"ref.example.".  We use the "example" processing instruction to
include the contents of a file from doc/example.  Our processing
program requires the example to appear in a section whose id starts
with "ref.example.".  In order for this check to work, the id
attribute must be on the same line as the opening tag for the
section.  The list-of-examples processing instruction is used at the
end of the document to generate a list of links to each example in the
document.  Since we have examples spread throughout the document, this
makes it easier for people who just want examples to find them
quickly.

We also make use of the "qtest" processing instruction to pull files
from the "../src/qtest/abuild-examples" directory, and the
general-purpose "include-file" processing instruction to include the
various files from the source tree.  Our processing program requires
processing instructions to be on a line by themselves, so it is
technically not a purely xml-aware processor.

In normal writing when "abuild" is not part of a command, use the
entities "&Abuild;" for "Abuild" at the beginning of a sentence (or
when it would be capitalized such as in a title) and "&abuild;"
otherwise.  We typeset it as a plan unadorned word because doing
otherwise makes the document visually jarring.

We use the phrase "depend on" rather than "depend upon" to refer to
dependency relationships among build items.  Also, remember that the
word "dependent", when used as a noun, refers to the one doing the
depending, not the one being depended on.

Whenever appropriate, this document makes use of the following
technical character classes (definitions below from "Docbook: The
Definitive Guide"):

   classname - The name of a class, in the object-oriented programming sense
   command - The name of an executable program or other software command
   constant - A programming or system constant
   envar - A software environment variable
   filename - The name of a file
   firstterm - The first occurrence of a term
   function - The name of a function or subroutine, as in a programming language
   literal - Inline text that is some literal value
   option - An option for a software command
   replaceable - Content that may or must be replaced by the user
   type - The classification of a value
   varname - The name of a variable

We somewhat misuse the firstterm element in this document as a way to
italicize terms when they are used for the first time in a given
section of the document.  Some terms may appear more than once inside
the firstterm element.

Several types of items discussed in the document do not fit neatly
into one of the categories above.  For those, we have adopted
conventions which are illustrated in the Typographic Conventions
section.  Please see that to find out exactly what the conventions
are, and please follow them when editing this document.

When maintaining this document, keep in mind that if a section is
modified, you should check for references to that section to make sure
that the referencing text remains accurate.

There are certain conventions that we follow in the figures.  Please
see README-dia in the figures directory.

Before releasing this document after making major edits, do the
following checks:

 * Make sure all files are checked in and abuild passes its test
   suite.  The documentation extracts materials from the test suite
   and assumes that the test suite passes.

 * Make sure swversion and lastreleased are set appropriately and
   referenced in the document.

 * Make sure there are no occurrences of the straight double-quote
   character outside of examples or comments.

-->
<book>
 <bookinfo>
  <title>&Abuild; Users' Manual</title>
  <subtitle>For &Abuild; Version &swversion;, &lastreleased;</subtitle>
  <author>
   <firstname>Jay</firstname><surname>Berkenbilt</surname>
  </author>
  <copyright>
   <year>2007-2011</year>
   <holder>Jay Berkenbilt, Argon ST</holder>
  </copyright>
  <legalnotice>
   <para>
    This software and documentation may be distributed under the terms
    of version 2 of the Artistic License which may be found in the
    source and binary distributions.  They are provided &ldquo;as
    is&rdquo; without express or implied warranty.
   </para>
  </legalnotice>
 </bookinfo>
 <preface id="ref.for-1.0-users">
  <title>Notes For Users of &Abuild; Version 1.0</title>
  <para>
   This manual is written for &abuild; version 1.1.  If you are a user
   of &abuild; version 1.0 and are just looking for a summary of what
   changed, please see <xref linkend="ref.changes-in-1.1"/>.  The
   material there includes a summary of a change along with cross
   references to relevant sections of documentation.
  </para>
  <para>
   Please note that, with a small handful of exceptions, &abuild;
   version 1.1 is be able to build software that used &abuild; 1.0
   with few if any modifications.  The section on changes in version
   1.1 (<xref linkend="ref.changes-in-1.1"/>) includes a detailed list
   of things to watch out for during upgrading and when running in
   1.0-compatibility mode.
  </para>
 </preface>
 <preface id="ref.how-to-read-this-manual">
  <title>How to Read This Manual</title>
  <para>
   Welcome to the &abuild; manual!  You may always find the latest
   copy of this manual on <ulink
   url="http://www.abuild.org">&abuild;'s website</ulink>.  This
   manual is designed to get you up and running with &abuild; quickly:
   the most essential and common topics are presented first so that
   you can just start at the beginning and stop reading when you feel
   that you've seen enough to get going.  Then, when you are ready,
   you can come back for documentation on the full depth of &abuild;'s
   functionality.  If you come across something in the first reading
   that you don't understand, it's probably safe to skip it and come
   back when you're more comfortable.  As each new concept is
   presented, it is enhanced with examples.  A list of all the
   examples in the document can be found in <xref
   linkend="ref.list-of-examples"/>.  If you are just looking for
   changes from previous versions of &abuild;, please see <xref
   linkend="ref.release-notes"/> and <xref
   linkend="ref.changes-in-1.1"/>.
  </para>
  <para>
   This manual is divided into four parts.  Each part of the document
   draws on material introduced in the earlier parts.  Although
   earlier parts of the documentation are intended to be
   understandable without the material from the later parts, they
   contain forward cross references where appropriate.
  </para>
  <para>
   In <xref linkend="ref.part1"/>, we cover basic information that
   should help you come up to speed on using &abuild; for day-to-day
   work.  It is geared toward people who are working on an existing
   software baseline that uses &abuild;.  In Part I, you will learn
   about what &abuild; is and the types of problems it was designed to
   solve, be introduced to some basic terminology, and see a few
   examples of how to perform some simple build operations.  This part
   of the manual is very short and is designed to be readable in one
   sitting.  Casual users of &abuild; may have no need to read past
   Part I.
  </para>
  <para>
   In <xref linkend="ref.part2"/>, we introduce the most common
   features of &abuild;.  All the basic features are covered, and a
   few advanced features are covered.  All the information you need
   for simple projects has been presented by the end of Part II.
  </para>
  <para>
   In <xref linkend="ref.part3"/>, we introduce advanced topics.  By
   the end of Part III, you will have been exposed to every feature of
   &abuild;.
  </para>
  <para>
   <xref linkend="ref.part4"/> consists of a small handful of
   appendices.
  </para>
  <para>
   For those wishing to go still deeper, the &abuild; source code is
   heavily commented, and the software comes with a thorough automated
   test suite that covers every feature of the software and many error
   conditions as well.
  </para>
 </preface>
 <preface id="ref.acknowledgments">
  <title>Acknowledgments</title>
  <para>
   The creation of &abuild; would not have been possible without the
   enthusiastic support of my employer, <ulink
   url="http://www.argonst.com">Argon ST</ulink>.  Argon not only
   recognized the important role of a strong build tool in
   contributing to the overall quality and reliability of its
   software, but saw the value of releasing it to the open source
   community in hopes of making an even broader contribution.
  </para>
  <para>
   There are many people within Argon who helped take &abuild; to
   where it is now, but among these, a handful of people deserve
   special mention:
   <itemizedlist>
    <listitem>
     <para>
      Brian Reid, who first introduced me to Groovy, the language that
      is at the heart of &abuild; version 1.1's significantly improved
      Java support, and who kept the momentum going for making
      &abuild;'s Groovy-based Java framework a reality
     </para>
    </listitem>
    <listitem>
     <para>
      Brian Reid, Joe Schettino, Kathleen Friesen, and Brandon Barlow
      who met with me many times to help hammer out and test early
      versions of the Groovy-based Java framework
     </para>
    </listitem>
    <listitem>
     <para>
      Brandon Barlow for tirelessly testing numerous builds with
      &abuild; 1.1 during its alpha period.
     </para>
    </listitem>
    <listitem>
     <para>
      Cass Dalton, who has frequently served as a sounding board as I
      think about new &abuild; capabilities, and who has played a
      significant role in helping to ensure that &abuild; is as stable
      and widely usable as possible
     </para>
    </listitem>
    <listitem>
     <para>
      Chris Costa, who served as a sounding board and contributed
      numerous ideas throughout the entire development process of
      &abuild;, including conducting a thorough review of the &abuild;
      1.0 documentation
     </para>
    </listitem>
    <listitem>
     <para>
      Andrew Hayden, who spent many hours reviewing and critiquing the
      entire manual prior to the release of version 1.0 and who
      contributed many feature ideas designed to ease implementation
      of an &abuild; Eclipse plugin
     </para>
    </listitem>
    <listitem>
     <para>
      Joe Davidson, the first &abuild; evangelist who has been
      invaluable in getting &abuild; to become as widely accepted
      within Argon ST as it is
     </para>
    </listitem>
    <listitem>
     <para>
      Gavin Mulligan, who has consistently taken the time to report
      any problem, no matter how small, and who probably reported more
      issues than everyone else combined during &abuild;'s pre-1.0
      alpha period
     </para>
    </listitem>
    <listitem>
     <para>
      Bob Tamaru, who in addition to being a mentor and supporter for
      most of my career, provided considerable assistance to me as I
      presented the case to Argon ST to allow me to release &abuild;
      as an open source project
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </preface>
 <preface id="ref.preface-documentation-format">
  <title>Notes About Documentation Formatting</title>
  <para>
   This manual is written in docbook.  The PDF version of the manual
   was generated with Apache fop, which as of this writing, is still
   incomplete.  There are a few known issues with the PDF version of
   the documentation.  Hopefully these issues will all be addressed as
   fop matures.
   <itemizedlist>
    <listitem>
     <para>
      There are many bad line breaks.  Sometimes words are incorrectly
      hyphenated, and line breaks also occur between two dashes in
      command line options and even between the two
      <literal>+</literal> characters of &ldquo;C++&rdquo;.
     </para>
    </listitem>
    <listitem>
     <para>
      In many of the example listings, there are lines that would be
      longer than the shaded boxes in the PDF output.  We wrap those
      lines and place a backslash (<literal>\</literal>) character
      just before and after the extra line breaks.  This is done for
      both the HTML and the PDF output even though the long lines are
      only a problem for the PDF output.
     </para>
    </listitem>
    <listitem>
     <para>
      Some paragraphs appear to have extra indentation.  This is
      because the formatting software generates a hard space whenever
      we have an index term marker in the text.
     </para>
    </listitem>
    <listitem>
     <para>
      There are no bookmarks.  It would be good if we could create
      bookmarks to the chapter headings, but as of this writing, the
      documented procedure for doing this does not appear to work.
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </preface>
 <part id="ref.part1" label="I">
  <title>Quick Start</title>
  <partintro id="ref.part1.intro">
   <para>
    The material contained in this part is geared toward new and
    casual users of &abuild;.  Without going into excessive detail,
    this part gives you a quick tour of &abuild;'s functionality and
    presents a few examples of routine build operations.  By the end
    of this part, you should be able to use &abuild; for simple build
    operations, and you should have begun to get a feel for the basic
    configuration files.
   </para>
  </partintro>
  <chapter id="ref.introduction">
   <title>Introduction</title>
   <sect1 id="ref.introduction.overview">
    <title>&Abuild; Overview</title>
    <para>
     &Abuild; is a system designed to build large software projects or
     related families of software projects that are divided into a
     potentially large number of components.  It is specifically
     designed for software projects that are continually evolving and
     that may span multiple languages and platforms.  The basic idea
     behind &abuild; is simple: when building a single component
     (module, unit, etc.) of a software package, the developer should
     be able to focus on that component exclusively.  &Abuild;
     requires each component developer to declare, by name, the list
     of other components on which his or her component depends.  It is
     then &abuild;'s responsibility to provide whatever is needed to
     the build environment to make other required items visible.
    </para>
    <para>
     You might want to think of &abuild; as an
     <firstterm>object-oriented build system</firstterm>.  When
     working with &abuild;, the fundamental unit is the
     <firstterm>build item</firstterm>.  A build item is essentially a
     single collection of code, usually contained within one
     directory, that is built as a unit.  A build item may produce one
     or more products (libraries, executables, JAR files, etc.) that
     other build items may want to use.  It is the responsibility of
     each build item to provide information about its products that
     may be used by other items that depend on it.  This information
     is provided by a build item in its &abuild;
     <firstterm>interface</firstterm>.  In this way, knowledge about
     how to use a build item is encapsulated within that build item
     rather than being spread around throughout the other components
     of a system.
    </para>
    <para>
     To implement this core functionality, &abuild; provides its own
     system for managing build items as well as the dependencies and
     relationships among them.  It also provides various build rules
     implemented with underlying tools, specifically <application>GNU
     Make</application> and <application>Apache Ant</application>
     accessed using the <application>Groovy</application> programming
     language, to perform the actual build steps.  We refer to these
     underlying tools as <firstterm>backends</firstterm>.  Although
     the bulk of the functionality and sophistication of &abuild;
     comes from its own core capabilities rather than the build rules,
     the rules have rich functionality as well.  &Abuild; is intended
     to <emphasis>be</emphasis> your build system.  It is not
     intended, as some other tools are, to wrap around your existing
     build system.
     <footnote>
      <para>
       &Abuild; can, however, interoperate with other build systems as
       needed, which may be useful while transitioning a software
       development effort to using &abuild;.
      </para>
     </footnote>
    </para>
    <para>
     Support for compilation in multiple programming languages and on
     multiple platforms, including embedded platforms, is central to
     &abuild;'s design.  &Abuild; is designed to allow build items to
     be built on multiple platforms simultaneously.  An important way
     in which &abuild; achieves this functionality is to do all of its
     work inside of an <firstterm>output directory</firstterm>.  When
     &abuild; performs the actual build, it always creates an output
     directory named
     <filename>abuild-<replaceable>platform</replaceable></filename>.
     When &abuild; invokes <application>make</application>, it does so
     in that directory.  By actually invoking the backend in the
     output directory, &abuild; avoids the situation of temporary
     files conflicting with each other on multiple simultaneous builds
     of a given build item on multiple platforms.  For ant-based
     builds (using either the supported Groovy backend or the
     deprecated xml-based ant backend), each build is given a private
     ant <classname>Project</classname> object whose
     <varname>basedir</varname> is set to the output directory.
     &Abuild; is designed to never create or remove any output files
     outside of its output directories.  This enables &abuild;'s
     cleanup operation to simply remove all output directories created
     by any instance of &abuild;, and also reduces the likelihood of
     unintentionally mixing generated products with version-controlled
     sources.
    </para>
   </sect1>
   <sect1 id="ref.typographic-conventions">
    <title>Typographic Conventions</title>
    <para>
     The following list shows the font conventions used throughout
     this document for the names of different kinds of items.
     <simplelist>
      <member><literal>literal text</literal></member>
      <member><replaceable>replaceable text</replaceable></member>
      <member>
       <classname>build items</classname> and <classname>build item
       scope names</classname>
      </member>
      <member>
       <property>Abuild.conf keys</property>,
       <property>flags</property>, and <property>traits</property>
      </member>
      <member>
       <varname>Abuild.interface variables</varname>, <varname>java
       properties</varname>, and <varname>make variables</varname>
      </member>
      <member>
       <function>Abuild.interface keywords</function>
      </member>
      <member>
       <command>commands</command> and <command>build
       targets</command>
      </member>
      <member>
       <option>command line options</option> and <option>build
       sets</option>
      </member>
      <member>
       <envar>environment variables</envar>
      </member>
      <member>
       <filename>file names</filename> and <filename>make/Groovy rule
       sets</filename>
      </member>
      <member>
       <type>platforms</type>, <type>platform types</type>, and
       <type>target types</type>
      </member>
     </simplelist>
    </para>
   </sect1>
   <sect1 id="ref.release-policy">
    <title>&Abuild; Version Numbers and Release Policy</title>
    <para>
     This section describes what you can expect in terms of &abuild;
     version numbers and non-compatible changes.
    </para>
    <sect2 id="ref.version-numbering">
     <title>&Abuild; Version Numbers</title>
     <para>
      Each &abuild; release is assigned a version number.  For
      &abuild; releases, we use the following version numbering
      convention:

      <programlisting><replaceable>major</replaceable>.<replaceable>minor</replaceable>.<replaceable>prerelease-or-update</replaceable>
</programlisting>
     </para>
     <para>
      The <replaceable>major</replaceable> field of the version number
      indicates the major version number.  It changes whenever a major
      release is made.  A new major release of &abuild; represents a
      wholesale change in the way &abuild; works.  Major release are
      expected to be very infrequent.
     </para>
     <para>
      The <replaceable>minor</replaceable> field of the version number
      indicates the minor version number.  It changes whenever a minor
      release is made.  A minor release is an incremental release that
      may introduce significant new features, fix bugs, or change the
      way some things work, but it will not fundamentally shift the
      way &abuild; works.  We impose tight restrictions on the
      introduction of non-backward-compatible changes in minor
      releases as discussed below.
     </para>
     <para>
      The <replaceable>prerelease-or-update</replaceable> field can
      indicate either a prerelease version or an update release of a
      specific minor version.  A prerelease is an alpha or beta
      release or a release candidate that precedes a regular release.
      An update release may contain bug fixes or new features as long
      as no non-compatible changes are made to existing functionality.
      Allowing new non-breaking features to be introduced in an update
      release makes it possible to add features to &abuild;
      incrementally while still guaranteeing as much compatibility as
      possible.  There is no support for a prerelease of an update to
      a specific minor version (like 1.1.1.b1).
     </para>
     <para>
      Before a regular major or minor release, there may be a series
      of alpha releases, beta releases, and release candidates.  In
      those cases, the <replaceable>prerelease-or-update</replaceable>
      field of the version number is either
      &ldquo;<literal>a</literal>&rdquo;,
      &ldquo;<literal>b</literal>&rdquo;, or
      &ldquo;<literal>rc</literal>&rdquo; followed by a number.  The
      prerelease version numbers clearly indicate which regular
      release the prerelease applies to.  For example, version
      <literal>1.3.a4</literal> would be the fourth alpha release
      preceding the release of version <literal>1.3.0</literal>.
     </para>
     <para>
      After any major or minor release, it is possible that a small
      problem may be corrected in a bug-fix release.  In such a
      release, the <replaceable>prerelease-or-update</replaceable>
      field contains a number that indicates which bug-fix release
      this is.  For example, version <literal>1.2.1</literal> would be
      a bug-fix release to version <literal>1.2.0</literal>.
     </para>
     <para>
      Historical note: the first release of &abuild; 1.0 was just
      version 1.0, not version 1.0.0.  The use of &ldquo;x.y.0&rdquo;
      was introduced with version 1.1.0 so that &ldquo;abuild
      x.y&rdquo; could unambiguously refer to all update releases of
      minor version x.y rather than just the first.
     </para>
    </sect2>
    <sect2 id="ref.compatibility-policy">
     <title>Backward Compatibility Policy</title>
     <para>
      In a new major release of &abuild; (e.g., version 2.0.0), there
      is no promise that changes will be backward compatible, nor is
      there any expectation that configuration files from older
      &abuild; releases will work with the new version.  When
      possible, care will be taken to mitigate any inconvenience such
      as providing upgrade scripts.
     </para>
     <para>
      In each new minor release of &abuild;, there may be new features
      and backward-compatible changes.  In minor releases, we adopt a
      stricter policy regarding non-backward-compatible changes.
      Specifically, non-backward-compatible changes may be introduced
      only if the changed construct generated a deprecation warning in
      the previous minor release.  In other words, if particular
      construct in version <literal>1.3</literal> is going to be
      dropped or changed in a non-compatible way, the change can't be
      made until version <literal>1.5</literal>.  In version
      <literal>1.4</literal>, the new way may work, but use of the
      deprecated construct must still work and must generate a
      warning.  The old way can be dropped entirely in version
      <literal>1.5</literal> once users have had a chance to adjust
      their configuration files.  In that way, users who take every
      minor release upgrade can be guaranteed that they will not
      experience surprise non-compatible changes, and they will not
      have to update their configuration files at the same time that
      they upgrade &abuild;.
     </para>
     <para>
      With alpha releases, there is no commitment to avoiding
      non-compatible changes.  In particular, a feature that was
      introduced into &abuild; during an alpha testing period may be
      modified in non-compatible ways or dropped entirely during the
      course of alpha testing.  During beta testing, every effort will
      be made to avoid non-compatible changes, but they are still
      allowed.  No non-compatible changes will be made from the first
      release candidate through the next minor release.
     </para>
     <para>
      Specific exceptions may be made to any of the above rules, but
      any such exceptions will be clearly stated in the release notes
      or the documentation.  It may happen, for example, that a
      particular new feature is still in development when a release is
      made.  In that case, the release notes may declare that feature
      to still be alpha, in which case non-compatible changes can be
      introduced in the next release.
     </para>
     <para>
      We'll clarify with some concrete examples.  Suppose a new
      feature is planned for version <literal>1.4</literal> of
      &abuild;.  It would be okay if the first implementation of that
      feature appeared in version <literal>1.4.a2</literal> and if the
      feature were changed in a non-compatible way in
      <literal>1.4.a6</literal>.  However, after version
      <literal>1.4.0</literal> was released, the next non-compatible
      change would not be permitted until version
      <literal>1.5.a1</literal>, and even then, the feature as it
      worked in version <literal>1.4.0</literal> would still have to
      work, though a deprecation warning would be issued.  The old
      version <literal>1.4.x</literal> way of doing things could stop
      working altogether in version <literal>1.6.a1</literal>.  It is
      also okay to add a new feature <emphasis>within</emphasis> a
      minor release.  For example, it's okay if
      <literal>1.0.3</literal> adds some feature that wasn't there in
      <literal>1.0.2</literal> as long as everything that worked in
      <literal>1.0.2</literal> works the same way in
      <literal>1.0.3</literal>.  In other words, although everything
      that worked in <literal>1.0.2</literal> must work in
      <literal>1.0.3 </literal>, there's no expectation that
      everything that works in <literal>1.0.3</literal> must have
      worked in <literal>1.0.2</literal>.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.introduction.design-features">
    <title>Design Features</title>
    <para>
     This section describes many of the principles upon which &abuild;
     was designed.  Understanding this material is not critical to
     being able to use &abuild; just to do simple compiles, but knowing
     these things will help you use &abuild; better and will provide a
     context for understanding what it does.
    </para>
    <!--
        Terms in this list should grammatically finish the sentence:
        "Abuild conforms to the principle of ...".  Use title case for
        the items below.
    -->
    <indexterm>
     <primary>build</primary>
     <secondary>parallel</secondary>
    </indexterm>
    <indexterm>
     <primary>build</primary>
     <secondary>distributed</secondary>
    </indexterm>
    <indexterm>
     <primary>parallel build</primary>
    </indexterm>
    <indexterm>
     <primary>distributed build</primary>
    </indexterm>
    <indexterm>
     <primary>backend</primary>
    </indexterm>
    <variablelist>
     <varlistentry>
      <term>Build Integrity</term>
      <listitem>
       <para>
        &Abuild; puts the integrity of the build over all other
        concerns.  &Abuild; includes several rigorously enforced
        integrity checks throughout its implementation in order to
        prevent many of the most common causes of build integrity
        problems.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Strict Dependency Management</term>
      <listitem>
       <para>
        Build items must explicitly declare dependencies on other build
        items.  These dependencies are declared by name, not by path.
        The same mechanism within &abuild; that is used to declare a
        dependency is also used to provide visibility to the dependent
        build item.  (A build item reads the interfaces of only those
        build items on which it directly or indirectly depends.)  In
        this way, it is impossible to <emphasis>accidentally</emphasis>
        become dependent on something by unwittingly using files that
        it provides.  &Abuild; guarantees that there are no circular
        dependencies among build items and also provides a fundamental
        guarantee that all build items in a dependency chain resolve
        names to paths in a consistent way within the dependency tree.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Directory Structure Neutrality</term>
      <listitem>
       <para>
        Build items refer to each other only by name and never by
        path.  &Abuild; resolves build item names to paths internally
        and provides path information at runtime as needed.  This
        makes any specific &abuild; installation agnostic about
        directory structure and makes it possible to move things
        around without changing any build rules.  In this way,
        &abuild; stays out of the way when it's time to reorganize
        your project.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Focus on One Item at a Time</term>
      <listitem>
       <para>
        When using &abuild;, you are generally able to focus on
        building just the item you are working on without having to
        worry about the details of the items it depends on.  &Abuild;
        does all the work of figuring out what your environment has to
        look like to give you access to your dependencies.  It can
        then start a local build from anywhere and pass the right
        information to that local build.  This is achieved through
        encapsulation of knowledge about a build item's products
        inside the build item itself and making that knowledge
        available to its users through an &abuild;-specific interface.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Environment Independence</term>
      <listitem>
       <para>
        &Abuild; does not require you to have any project-specific or
        source tree-specific environment variables set, be using any
        particular shell or operating system, or have the &abuild;
        software itself installed in any particular location.
        &Abuild; is designed so that having the
        <command>abuild</command> command in your path is sufficient
        for doing a build.  This keeps &abuild; independent from any
        specific source tree or project.  &Abuild; can be used to
        build a single-source-file, stand-alone program or an
        elaborate product line consisting of hundreds or thousands of
        components.  It can be also used for multiple projects on the
        same system at the same time.  No special path settings or
        environment variable settings are required to use &abuild;,
        other than ensuring that the external tools that your build
        requires (GNU Make, compilers, etc.) are available and in your
        path.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Support for Parallel and Distributed Builds</term>
      <listitem>
       <para>
        When building multiple items, &abuild; creates a
        <firstterm>build set</firstterm> consisting of all the items
        to be built.  It computes the directories in which it needs to
        build and invokes the build iteratively in those directories.
        &Abuild; automatically figures out what can be built in
        parallel and what the build order should be by inspecting the
        dependency graph.  &Abuild; avoids many of the pitfalls that
        get in the way of parallel and distributed operation including
        recursive execution, shell-based loops for iteration, file
        system-based traversal, and writing files to the source
        directory.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Support for Multiple Platforms</term>
      <listitem>
       <para>
        &Abuild; was designed to work on multiple platforms.  It
        includes a structure for referring to platforms and for
        encapsulating platform-specific knowledge.  This makes it
        easier to create portable build structures for portable code.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Efficiency</term>
      <listitem>
       <para>
        &Abuild; aims to be as efficient as possible without
        compromising build integrity.  &Abuild; calculates as much as
        possible up front when it is first invoked, and it passes that
        information to backend build programs through
        automatically-generated files created inside its own output
        directories.  By computing the information one time, &abuild;
        significantly reduces the degree to which its backend build
        programs' rules have to use external helper applications to
        compute information they need.  &Abuild;'s configuration files
        and build tree traversal steps are designed in such a way that
        &abuild; never has to perform unbounded searches of a build
        tree.  This enables startup to be fast even on build trees
        containing thousands of build items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Encapsulation</term>
      <listitem>
       <para>
        Build items encapsulate knowledge about what is required by
        their users in order to make use of them at build time.  The
        user may also create build items with restricted scope, thus
        allowing private things to be kept private.  This makes it
        possible to refactor or reorganize individual components of a
        system without affecting the build files of other build items
        that depend on them.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Declarative Build Files</term>
      <listitem>
       <para>
        The majority of build item configuration files are
        declarative: they contain descriptions of what needs to be
        done, rather than information about how to do it.  Most end
        user configuration files contain nothing but variable settings
        or key/value pairs and are independent of the platform or
        compiler used to build the item.  For those cases in which a
        declarative system is insufficient to express what needs to do
        be done, &abuild; provides several mechanisms for specific
        steps to be defined and made available to the items that need
        them.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Support for Multiple Backends</term>
      <listitem>
       <para>
        The parts of &abuild; that manage dependencies and build
        integrity are distinct from the parts of &abuild; that
        actually perform builds.  &Abuild; current uses either
        <application>GNU Make</application> or <application>Apache
        Ant</application>, accessed through a
        <application>Groovy</application> language front end, to
        perform builds.
        <footnote>
         <para>
          There is also support for ant using xml files.  This was the
          primary mechanism for using ant in &abuild; 1.0, but it is
          deprecated in version 1.1 in favor of the much more flexible
          and capable Groovy-based backend.  Throughout this document,
          we refer to it as the &ldquo;deprecated xml-based ant&rdquo;
          framework.
         </para>
        </footnote>
        The internal integration between &abuild; and
        its backend build programs is fairly loose, and adding
        additional backends requires relatively minor and localized
        code changes.  In addition, &abuild; requires only the
        backends that a particular build tree uses to be present on
        your system when you are performing a build.  That is, if you
        are building only Java code, you don't need <application>GNU
        Make</application>, and if you're building only C and C++
        code, you don't need a Java or ant environment.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
  </chapter>
  <chapter id="ref.installation">
   <title>Building and Installing &Abuild;</title>
   <sect1 id="ref.system.requirements">
    <title>System Requirements</title>
    <para>
     You may always find the latest version of &abuild; by following
     the links on <ulink url="http://www.abuild.org">&abuild;'s
     website</ulink>.  To use &abuild;, the following items must be
     available on your system:
     <itemizedlist>
      <listitem>
       <para>
        <ulink url="http://www.gnu.org/software/make/"><application>GNU
        Make</application></ulink> version 3.81 or higher is required
        if you are building any build items that use <application>GNU
        Make</application> as a backend.  This would include
        platform-independent code and C/C++ code, but not Java code.
       </para>
      </listitem>
      <listitem>
       <para>
        A Java 5 or newer Java SDK is required if you are going to use
        &abuild; to build Java code.  &Abuild; is known to work with
        OpenJDK 1.6.
       </para>
      </listitem>
      <listitem>
       <para>
        <ulink url="http://ant.apache.org/"><application>Apache
        Ant</application></ulink> version 1.7.0 or newer is required if
        you are building any Java code.  If you are using &abuild;'s
        deprecated xml-based ant framework, then you also need <ulink
        url="http://ant-contrib.sourceforge.net/"><application>ant-contrib</application></ulink>
        version 1.0.b3 or later installed in either ant's or &abuild;'s
        lib directory.
       </para>
      </listitem>
      <listitem>
       <para>
        <ulink url="http://www.perl.com/">Perl</ulink> version 5.8 or
        newer is required if you are performing any GNU Make-based
        builds.
       </para>
      </listitem>
      <listitem>
       <para>
        Perl version 5.8 or newer and <ulink
        url="http://qtest.qbilt.org/">qtest</ulink> version 1.0 or
        newer are required if you are using the qtest automated test
        framework.  &Abuild;'s own test suite uses qtest.  Note also
        that qtest requires <ulink
        url="http://www.gnu.org/software/diffutils">GNU
        diffutils</ulink>.  Any version should do.
       </para>
      </listitem>
      <listitem>
       <para>
        In order to use &abuild;'s autoconf support, you need <ulink
        url="http://www.gnu.org/software/autoconf">autoconf</ulink>
        version 2.59 or newer, <ulink
        url="http://www.gnu.org/software/automake">automake</ulink>
        version 1.9 or newer.  These are also required for &abuild;'s
        test suite to pass since the test suite exercises its autoconf
        support.
       </para>
      </listitem>
      <listitem>
       <para>
        If you are planning on building any GNU Make-based build items
        on Windows, <ulink url="http://www.cygwin.com/">Cygwin</ulink>
        is required.  For a Java-only &abuild; installation on Windows,
        Cygwin and Perl are not required.  It is hoped that a future
        version of &abuild; will not require Cygwin.  For details on
        using Cygwin with &abuild;, please see <xref
        linkend="ref.windows-requirements"/>.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     To build &abuild;, you must also have version 1.35 or newer of
     <ulink url="http://www.boost.org/">boost</ulink>.  &Abuild; uses
     several boost libraries, including regex, thread, system,
     filesystem, and date_time as well as several header-only
     libraries such as asio, bind, and function.  &Abuild; is known to
     buildable by gcc and Microsoft Visual C++ (7.1 or newer), but it
     should be buildable by any compiler that supports boost 1.35.  In
     order for shared library support to work properly with gcc, gcc
     must be configured to use the GNU linker.
     <footnote>
      <para>
       The only reason for the GNU linker requirement is that &abuild;
       currently knows about <command>-fPIC</command>.  It would be
       better to have a more robust way of configuring flags for
       position-independent-code, but it's not clear how to do this
       without replicating all the knowledge built into
       <application>libtool</application> or having some autoconf-like
       method of configuring &abuild; at runtime.
      </para>
     </footnote>
     &Abuild; itself contains C++ code and Java code, so all the
     runtime requirements for both systems are required to build
     &abuild;.
    </para>
    <para>
     In order to build &abuild;'s Java code, which is required if you
     are doing any Java-based builds, you must have at least version
     1.5.7 of <ulink url="http://groovy.codehaus.org">Groovy</ulink>.
     It is recommended that you have at least version 1.6.0.  It is
     not required that you have Groovy to <emphasis>run</emphasis>
     &abuild; because &abuild; includes an embedded version of the
     Groovy environment, but a full installation of Groovy is required
     in order to do the initial bootstrapping build of &abuild;'s Java
     code.
     <footnote>
      <para>
       Besides, every Java programmer should have a copy of Groovy
       installed!
      </para>
     </footnote>
    </para>
    <para>
     As of &abuild; version 1.1.0, &abuild; is known to work with
     Groovy versions 1.6.7 and 1.7-RC-1, which were the latest
     available versions at the time of the release.  Upgrading
     &abuild;'s embedded version of Groovy is as simple as just
     replacing the embeddable Groovy JAR file inside of &abuild;'s lib
     directory.  Just delete the old one and copy the new one in.
     &abuild; will automatically find it even though its name will
     have changed to include the later version number.  Ideally, you
     should also rebuild &abuild;'s java support from source and rerun
     &abuild;'s test suite just to be sure &abuild; still works
     properly with the latest Groovy.
    </para>
    <para>
     Since &abuild; determines where it is being run from when it is
     invoked, a binary distribution of &abuild; is not tied to a
     particular installation path.  It finds the root of its
     installation directory by walking up the path from the &abuild;
     executable until it finds a directory that contains
     <filename>make/abuild.mk</filename>.  This makes it easy to have
     multiple versions of &abuild; installed simultaneously, and it
     also makes it easy to create relocatable binary distributions of
     &abuild;.
    </para>
    <para>
     &Abuild; itself does not require any environment variables to be
     set, but <application>ant</application> and/or the Java
     development environment may.  If you have the
     <envar>JAVA_HOME</envar> and <envar>ANT_HOME</envar> environment
     variables set, &abuild; will honor them when selecting which copy
     of java to run and where to find the ant JAR files.  Otherwise,
     it will run <application>java</application> and
     <application>ant</application> from your path to make those
     determinations.  Although &abuild; is explicitly tested to work
     without either <envar>ANT_HOME</envar> or
     <envar>JAVA_HOME</envar> set, if any Java builds are being done,
     &abuild; will start up a little more quickly if they are set.  As
     many other applications expect these to be set, it is recommended
     that you set <envar>JAVA_HOME</envar> and
     <envar>ANT_HOME</envar>.  When &abuild; invokes Java for any of
     the Java-based backends, it will automatically add all the JAR
     files in <filename>$ANT_HOME/lib</filename> to the classpath as
     well as all JAR files in &abuild;'s own <filename>lib</filename>
     directory.  &Abuild; includes a copy of Groovy's embeddable JAR
     in its own <filename>lib</filename> directory.  You can copy
     additional JAR files into <filename>lib</filename> as well, but
     if you do so, just remember that those JAR files will not
     automatically be available to users whose &abuild; installations
     do not include them.
    </para>
    <para>
     As you begin using &abuild;, you may find yourself generating a
     collection of useful utility build items for things like specific
     third-party libraries, external compilers, documentation
     generators, or test frameworks.  There is a small collection of
     contributed build items in the
     <filename>abuild-contrib</filename> package, which is available
     at <ulink url="http://www.abuild.org">&abuild;'s web
     site</ulink>.  These may have additional requirements.  For
     details, please see the information about
     <filename>abuild-contrib</filename> on the website.
    </para>
   </sect1>
   <sect1 id="ref.installation.build">
    <title>Building &Abuild;</title>
    <para>
     &Abuild; is self-hosting: it can be built with itself, or for
     bootstrapping, it can be built with a GNU Makefile that uses
     &abuild;'s internal <application>GNU Make</application> support.
     To build &abuild;'s Java code, you also need
     <application>Groovy</application>, <application>Apache
     Ant</application> and a Java development environment.  Please see
     the file <filename>src/README.build</filename> in the source
     distribution for instructions on building abuild.
    </para>
   </sect1>
   <sect1 id="ref.installation.install">
    <title>Installing &Abuild;</title>
    <para>
     If you are creating a binary distribution or installing from
     source, please see the file <filename>src/README.build</filename>
     in the source directory.  If you are installing from a pre-built
     binary distribution, simply extract the binary distribution in
     any directory.  &Abuild; imposes no requirements on where the
     directory should be or what it should be called as long as its
     contents remain in the correct relative locations.  You may make
     a symbolic link to the actual <filename>bin/abuild</filename>
     executable from a directory in your path.  &Abuild; will follow
     this link when attempting to discover the path of its
     installation directory.  You may also add the &abuild;
     distribution's <filename>bin</filename> directory to your path,
     or invoke &abuild; by the full path to its executable.
     <footnote>
      <para>
       If &abuild; is not invoked as an absolute path, it will iterate
       through the directories in your <envar>PATH</envar> trying to
       find itself.  Therefore, &abuild; may fail to work properly if
       you invoke it programmatically, pass
       \&ldquo;<literal>abuild</literal>&rdquo; to it as
       <literal>argv[0]</literal>, and do not have the copy of
       &abuild; you are invoking in your path before any other copy of
       &abuild;.  This limitation should never impact users who are
       invoking &abuild; normally from the command line or through a
       shell or other program that searches the path.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.windows-requirements">
    <title>Additional Requirements for Windows Environments</title>
    <indexterm>
     <primary>Windows</primary>
    </indexterm>
    <indexterm>
     <primary>Cygwin</primary>
    </indexterm>
    <para>
     To build &abuild; and use it in a Windows environment for
     <application>make</application>-based builds, certain pieces of
     the <ulink url="http://www.cygwin.com/">Cygwin</ulink>
     environment are required.
     <footnote>
      <para>
       This may cease to be true in a future version of &abuild;.
      </para>
     </footnote>
     Note that &abuild; is able to build with and be built by Visual
     C++ on Windows.  It uses Cygwin only for its development tools.
     Cygwin is not required to run executables built by &abuild; in a
     Windows environment, including &abuild; itself.  However, Cygwin
     is required to supply <command>make</command> and
     <command>perl</command> to &abuild;.  The following parts of
     Cygwin are required:
     <variablelist>
      <varlistentry>
       <term>Devel</term>
       <listitem>
        <simplelist>
         <member>autoconf</member>
         <member>automake</member>
         <member>make</member>
        </simplelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>System</term>
       <listitem>
        <simplelist>
         <member>rebase</member>
        </simplelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Util</term>
       <listitem>
        <simplelist>
         <member>diffutils</member>
        </simplelist>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Perl is required, but appears to be installed by default in recent
     Cygwin installations.
    </para>
    <para>
     Note that rebaseall (from the rebase package) may need to be run
     in order for <function>fork</function> to work from perl with
     certain modules.  (Although &abuild; itself doesn't call
     <function>fork</function> from perl,
     <application>qtest</application>, which is used for &abuild;'s
     test suite, does.)
    </para>
    <para>
     Other modules may also be desirable.  In particular,
     <filename>libxml2</filename> from the <filename>Text</filename>
     section is required in order to run certain parts of &abuild;'s
     test suite, though the test suite will just issue a warning and
     skip those tests without failing if it can't find
     <command>xmllint</command>.
    </para>
    <para>
     If you intend to use autoconf from Windows and you have Rational
     Rose installed, you may need to create
     <filename>/usr/bin/hostinfo</filename> (inside of the Cygwin
     environment) as

     <programlisting>#!/bin/false
</programlisting>
     so that <command>./configure</command>'s running of
     <command>hostinfo</command> doesn't run
     <command>hostinfo</command> from Rational Rose.
    </para>
    <para>
     In order to use Visual C++ with &abuild;, you must have your
     environment set up to invoke Visual C++ command line tools.  This
     can be achieved by running the shortcut supplied with Visual
     Studio, or you can create a batch file on your own.  The
     following batch file would enable you to run &abuild; from a
     Cygwin environment with the environment set up for running Visual
     C++ from Visual Studio 7.1 (.NET 2003):

     <programlisting>@echo off
call "%VS71COMNTOOLS%"\vsvars32.bat
C:\cygwin\cygwin.bat
</programlisting>
     Adjust as needed if your Cygwin is installed other than in
     <filename>C:\cygwin</filename> or you have a different version of
     Visual C++ installed.
    </para>
    <para>
     In order to use <application>qtest</application> with &abuild;
     under Windows, the Cygwin version of Perl must be the first
     <command>perl</command> in your path.
    </para>
   </sect1>
   <sect1 id="ref.version-control">
    <title>Version Control Considerations</title>
    <para>
     &Abuild; creates output directories in the source directory, and
     all generated files are created inside of these
     &abuild;-generated directories.  All output directories are named
     <filename>abuild-*</filename>.  It is recommended that you
     configure hooks or triggers in your version control system to
     prevent these directories or their contents from being
     accidentally checked in.  It may also be useful to prevent
     <filename>Abuild.backing</filename> from being checked in since
     this file always contains information about the local
     configuration rather than something that would be CM controlled.
     If it is your policy to allow these to be checked in, they should
     be prevented from appearing in shared areas such as the trunk.
     <footnote>
      <para>
       Note, however, that the &abuild; test suite contains
       <filename>Abuild.backing</filename> files, so any CM system
       that contains &abuild; must have an exception for &abuild;
       itself.  It's conceivable that other tools could also have
       reasons to have checked in <filename>Abuild.backing</filename>
       files in test suites or as templates.
      </para>
     </footnote>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.basic-operation">
   <title>Basic Operation</title>
   <para>
    In this chapter, we will describe the basics of running &abuild;
    on a few simple build items, and we will describe how those build
    items are constructed.  We will gloss over many details that will
    be covered later in the documentation.  The goal of this chapter
    is to give you enough information to work on simple build items
    that belong to existing build trees.  Definitions of
    <firstterm>build item</firstterm> and <firstterm>build
    tree</firstterm> appear below.  More detailed information on them
    can be found in <xref linkend="ref.build-items-and-trees"/>.  The
    examples we refer to in this chapter can be found in
    <filename>doc/example/basic</filename> in your &abuild; source or
    binary distribution.
   </para>
   <sect1 id="ref.system-considerations">
    <title>System Considerations</title>
    <para>
     &Abuild; imposes few system-based restrictions on how you set it
     up and use it, but here are a few important things to keep in
     mind:
     <itemizedlist>
      <listitem>
       <para>
        Avoid putting spaces in path names wherever possible.
        Although &abuild; tries to behave properly with respect to
        spaces in path names and is known to handle many cases
        correctly, <application>make</application> is notoriously bad
        at it.  If you try to use spaces in path names, it is very
        likely that you will eventually run into problems as they
        generally cause trouble in a command-line environment.
       </para>
      </listitem>
      <listitem>
       <para>
        Be careful about the lengths of path names.  Although &abuild;
        itself imposes no limits on this, you may run up against
        operating system limits if your paths are too long.  In
        particular, Windows has a maximum path name length of 260
        characters.  If you have a build tree whose root already has a
        long path and you then have Java classes that are buried deep
        within a package-based directory structure, you can bump into
        the 260-character limit faster than you'd think.  On Windows,
        it is recommended that you keep your build tree roots as close
        to the root of the drive as possible.  On any modern UNIX
        system, you should not run into any path name length issues.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
   <sect1 id="ref.basic-terminology">
    <title>Basic Terminology</title>
    <para>
     Here are a few basic terms you'll need to get started:
     <variablelist>
      <varlistentry>
       <term>build item</term>
       <listitem>
        <para>
         <indexterm>
          <primary>build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>current</secondary>
         </indexterm>
         A <firstterm>build item</firstterm> is the most basic item
         that is built by &abuild;.  It usually consists of a directory
         that contains files that are built.  Any directory that
         contains an <filename>Abuild.conf</filename> file is a build
         item.  We refer to the build item whose
         <filename>Abuild.conf</filename> resides in the current
         directory as the <firstterm>current build item</firstterm>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>build tree</term>
       <listitem>
        <para>
         <indexterm>
          <primary>build tree</primary>
         </indexterm>
         A <firstterm>build tree</firstterm> is a collection of build
         items arranged hierarchically in the file system.  All build
         items in a build tree may refer to each other by name.  Each
         build item knows the locations of its children within the
         file system hierarchy and the names of the build items on
         which it depends.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>build forest</term>
       <listitem>
        <para>
         <indexterm>
          <primary>build forest</primary>
         </indexterm>
         A <firstterm>build forest</firstterm> is a collection of build
         trees.  If there are multiple build trees in a forest, there
         may be one-way visibility relationships among the trees,
         which are declared similarly to dependency relationships
         among build items.  We will return to this concept later in
         the documentation.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>target</term>
       <listitem>
        <para>
         <indexterm>
          <primary>
           target
          </primary>
         </indexterm>
         A <firstterm>target</firstterm> is some specific product to
         be built.  The term &ldquo;target&rdquo; means exactly the
         same thing with &abuild; as it does with other build systems
         such as <application>make</application> or
         <application>ant</application>.  In fact, with the exception
         of a small handful of &ldquo;special&rdquo; targets, &abuild;
         simply passes any targets given to it onto the backend build
         system for processing.  The most common targets are
         <command>all</command> and <command>clean</command>.  For a
         more complete discussion of targets, see <xref
         linkend="ref.targets"/>.  Be careful not to confuse
         <firstterm>target</firstterm> with <firstterm>target
         type</firstterm>, defined in <xref
         linkend="ref.platform-structure"/>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     For a more complete description of build items, build trees, and
     build forests, please see <xref
     linkend="ref.build-items-and-trees"/>.
    </para>
   </sect1>
   <sect1 id="ref.compiler-selection">
    <title>Compiler Selection</title>
    <para>
     Full details on compiler support and compiler selection are
     covered in <xref linkend="ref.platform-selection"/>.  To get
     started, on Linux systems, &abuild; will build with
     <application>gcc</application> by default.  On Windows, if you
     run &abuild; from a shell that is appropriately set up to run
     Microsoft Visual C++ (as by following the command prompt shortcut
     provided as part of your Visual C++ implementation), &abuild;
     will automatically use Visual C++.  If you have cygwin installed
     with gcc and the mingw runtime environment, &abuild; will attempt
     to use <command>gcc -mno-cygwin</command> to build as long as you
     set the <envar>MINGW</envar> environment variable to
     <literal>1</literal>, though bear in mind that &abuild;'s mingw
     support is not entirely complete.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.cxx-library">
    <title>Building a C++ Library</title>
    <para>
     The directory <filename>cxx-library</filename> under
     <filename>doc/example/basic</filename> contains a simple C++
     library.  Our library is called
     <filename>basic-library</filename>.  It implements the single C++
     class called <classname>BasicLibrary</classname> using the header
     file <filename>BasicLibrary.hh</filename> and the source file
     <filename>BasicLibrary.cc</filename>.  Here are the contents of
     those files:
     <?example basic/cxx-library/BasicLibrary.hh?>
     <?example basic/cxx-library/BasicLibrary.cc?>
     Building this library is quite straightforward.  &Abuild;'s build
     files are generally declarative in nature: they describe what
     needs to be done rather than how it is done.  Building a C or C++
     library is a simple matter of creating an
     <filename>Abuild.mk</filename> file that describes what the names
     of the library targets are and what each library's sources are,
     and then tells &abuild; to build the targets using the C and C++
     rules.  Here is this library's <filename>Abuild.mk</filename>
     file:
     <?example basic/cxx-library/Abuild.mk?>
     The string <filename>ccxx</filename> as the value of the
     <varname>RULES</varname> variable indicates that this is C or C++
     code (&ldquo;c&rdquo; or &ldquo;cxx&rdquo;).  In order for
     &abuild; to actually build this item, we also need to create an
     <filename>Abuild.conf</filename> file for it.  The existence of
     this file is what makes this into a build item.  We present the
     file here:
     <?example basic/cxx-library/Abuild.conf?>
     In this file, the <property>name</property> key is used to
     specify the name of the build item and the
     <property>platform-types</property> key is used to help &abuild;
     figure out on which platforms it should attempt to build this
     item.  Finally, we want this build item to be able to make the
     resulting library and header file available to other build items.
     This is done in its <filename>Abuild.interface</filename> file:
     <?example basic/cxx-library/Abuild.interface?>
     This tells &abuild; to add the directory containing this file to
     the include path, the output directory in which the generated
     targets were created to the library path, and the
     <filename>basic-library</filename> library to the list of
     libraries to be linked with.  Notice that the name of the library
     assigned to the <varname>LIBS</varname> variable is the same as
     the value assigned to the <varname>TARGETS_lib</varname> variable
     in the <filename>Abuild.mk</filename> file, and that the
     &abuild;-provided variable
     <varname>$(ABUILD_OUTPUT_DIR)</varname> is used as the library
     directory.  All relative paths specified in the
     <filename>Abuild.interface</filename> file are relative to the
     directory that contains the <filename>Abuild.interface</filename>
     file.  They are automatically converted internally by &abuild; to
     absolute paths, which helps to keep build items
     location-independent.
    </para>
    <para>
     To build this item, you would run the command
     <command>abuild</command> in the
     <filename>basic/cxx-library</filename> directory.  &Abuild; will
     create an output directory whose name would start with
     <filename>abuild-</filename> and be based on the platform or
     platforms on which &abuild; was building this item.  This is the
     directory to which the variable
     <varname>$(ABUILD_OUTPUT_DIR)</varname> refers in the
     <filename>Abuild.interface</filename> file.
    </para>
    <para>
     There is a lot of capability hiding beneath the surface here and
     quite a bit of flexibility in the exact way in which this can be
     done, but this is the basic pattern you will observe for the
     majority of C and C++ library build items.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.cxx-program">
    <title>Building a C++ Program</title>
    <para>
     The directory <filename>basic/cxx-program</filename> contains a
     simple C++ program.  This program links against the library
     created in our previous example.  Here is the main body of our
     program:
     <?example basic/cxx-program/program.cc?>
     This program includes the <filename>BasicLibrary.hh</filename>
     header file from the <classname>cxx-library</classname> build
     item.  Here is the <filename>Abuild.mk</filename> for this build
     item:
     <?example basic/cxx-program/Abuild.mk?>
     Notice that this is very similar to the
     <filename>Abuild.mk</filename> from the library build item.  The
     only real difference is that the <varname>TARGETS</varname> and
     <varname>SRCS</varname> variables contain the word
     <varname>bin</varname> instead of <varname>lib</varname>.  This
     tells &abuild; that these are executable targets rather than
     library targets.  Notice the conspicuous lack of any references to
     the library build item or the location of the headers or libraries
     that it makes available.  A principal feature of &abuild; is that
     this program build item does not need to know that information.
     Instead, it merely declares a dependency on the
     <classname>cxx-library</classname> build item by name.  This is
     done in its <filename>Abuild.conf</filename>:
     <?example basic/cxx-program/Abuild.conf?>
     Notice the addition of the <property>deps</property> key in this
     file.  This tells &abuild; that our program build item
     <firstterm>depends</firstterm> on the library build item.  When
     &abuild; sees this, it automatically makes all the information in
     <classname>cxx-library</classname>'s
     <filename>Abuild.interface</filename> available to
     <classname>cxx-program</classname>'s build, alleviating the need
     for the <classname>cxx-program</classname> build item to know the
     locations of these files.  This will also tell &abuild; that
     <classname>cxx-library</classname> must be built before we can
     build <classname>cxx-program</classname>.
    </para>
    <para>
     To build this item, we just run the <command>abuild</command>
     command as we did for <classname>cxx-library</classname>.  This
     will automatically build dependency
     <classname>cxx-library</classname> before building
     <classname>cxx-program</classname>.  In this way, you can can
     start a build from any build item and let &abuild; automatically
     take care of building all of its dependencies in the correct
     order.
    </para>
    <para>
     The output of running <command>abuild</command> in the
     <filename>cxx-program</filename> directory when starting from a
     clean build is shown below.  Your actual output will differ
     slightly from this.  In particular, the output below has the
     string <literal>--topdir--</literal> in place of the path to
     <filename>doc/example</filename>, and the string
     <literal>&lt;native&gt;</literal> in place of your native
     platform.
     <footnote>
      <para>
       All example output in this document is normalized this way
       since it all comes directly from &abuild;'s test suite.
       Testing all the examples in the test suite guarantees the
       accuracy of the examples and ensures that they work as
       advertised on all platforms for which &abuild; is released.
       Should you wish to study &abuild;'s test suite with the
       examples, be aware that the bold italicized text preceding each
       block of example output is the name of the expected output file
       from the test suite.
      </para>
     </footnote>
     Notice that &abuild; builds
     <classname>cxx-library</classname> first and then
     <classname>cxx-program</classname>:
     <?qtest basic-cxx-program.out?>
    </para>
    <para>
     To remove all of the files that &abuild; created in any build
     item's directory, you can run <command>abuild clean</command> in
     that directory.  To clean everything in the build tree, run
     <command>abuild --clean=all</command>.  More details of how to
     specify what to build and what to clean can be found in <xref
     linkend="ref.what-to-build"/>.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.java-library">
    <title>Building a Java Library</title>
    <para>
     In our next example, we'll demonstrate how to build a simple Java
     library.  You will find the Java example in
     <filename>basic/java-library</filename>.  The files here are
     analogous to those in our C++ library example.  First, here is a
     Java implementation of our <classname>BasicLibrary</classname>
     class:
     <?example basic/java-library/src/java/com/example/basic/BasicLibrary.java?>
     Next, look at <filename>Abuild.conf</filename>:
     <?example basic/java-library/Abuild.conf?>
     This is essentially identical to our C++ library except that the
     <property>platform-types</property> key has the value
     <property>java</property> instead of the value
     <property>native</property>.  This is always true for Java build
     items.  Next, we'll look at the
     <filename>Abuild.groovy</filename> file:
     <?example basic/java-library/Abuild.groovy?>
     Java build items have this file instead of
     <filename>Abuild.mk</filename>.  The contents are very similar.
     The <filename>Abuild.groovy</filename> file contains Groovy code
     that is executed inside a particular context provided by
     &abuild;.  Most <filename>Abuild.groovy</filename> files will
     simply set <firstterm>parameters</firstterm> that describe what
     will be built.  In this file, we set the
     <varname>java.jarName</varname> parameter to the name of the JAR
     file we are creating, and we set the
     <varname>abuild.rules</varname> parameter to the value
     <literal>'java'</literal> to indicate that we are using the
     <filename>java</filename> rules.  For Java build items, we don't
     explicitly list the source files.  Instead &abuild; automatically
     finds sources in a source directory which is, by default,
     <filename>src/java</filename>.  There are many more parameters
     that can be set, and you have considerable flexibility about how
     to arrange things and how to get files into your Java archives.
     &Abuild; aims to allow you to <emphasis>build by
     convention</emphasis>, but it gives you the flexibility to do
     things your own way when you want to.  We provide detailed
     information about the directory structure for Java builds in
     <xref linkend="ref.groovy.directory-structure"/>.
    </para>
    <para>
     Finally, look at the <filename>Abuild.interface</filename> file.
     This file provides information to other build items about what
     they should add to their classpaths in order to make use of the
     JAR file created by this build item:
     <?example basic/java-library/Abuild.interface?>
     You'll notice here that we are actually setting four different
     variables.  Not all of these are required, but the pattern here
     is one that you may well wish to adopt, especially if you are
     working in a Java Enterprise environment.  The first statement in
     the interface file declares a variable called
     <varname>java-library.archiveName</varname> as a string and
     initializes it to the value <literal>java-library.jar</literal>.
     This syntax of declaring and initializing an interface variable
     was introduced into &abuild; with version 1.1.  Here we adopt a
     convention of using the build item name as the first field of the
     variable name, and the literal string
     <varname>archiveName</varname> as the second field.  By including
     the name of the build item in the name of the interface variable,
     we reduce the possibility of creating a name clash.  By providing
     a variable to hold the name of the archive provided by this build
     item, we allow other build items to refer to this JAR file by
     name without having to know what it is called.  The second
     interface variable, <varname>java-library.archivePath</varname>,
     contains the full path to the archive.  (Notice that &abuild;
     puts the JAR file in the <filename>dist</filename> subdirectory
     of the &abuild; output directory.)  This enables other build
     items to refer to this archive by path without knowing any
     details beyond this naming convention and the name of the
     providing build item.  Making this type of information available
     in this way is not necessarily a straight Java &ldquo;SE&rdquo;
     environment, but it can be very useful in a Java &ldquo;EE&rdquo;
     environment where build items that create EAR files may have to
     reach into other build items to package their artifacts in higher
     level archives.  Experience has shown that adopting a convention
     like this and following it consistently will pay dividends in the
     end.
    </para>
    <para>
     After setting these two build-item-specific variables, we assign
     to two built-in variables: <varname>abuild.classpath</varname>,
     and <varname>abuild.classpath.manifest</varname>.  Most simple
     JAR-providing build items will do this.  &Abuild; actually
     provides multiple classpath variables, each of which is intended
     to be used in a particular way.  For a discussion, please see
     <xref linkend="ref.interface.java"/>.
    </para>
    <para>
     As with the C++ library, it is possible to build this item by
     running <command>abuild</command> from the
     <filename>basic/java-library</filename> directory.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.java-program">
    <title>Building a Java Program</title>
    <para>
     In Java, there is no deep distinction between a
     &ldquo;library&rdquo; and a &ldquo;program&rdquo; except that a
     JAR file that provides a program must have a
     <function>main</function> method.  If a JAR file contains a main
     method, it can be executed, though it can also be used as a
     library.  Here are the relevant files for the program example:
     <?example basic/java-program/src/java/com/example/basic/BasicProgram.java?>
     <?example basic/java-program/Abuild.conf?>
     <?example basic/java-program/Abuild.groovy?>
     A JAR file's manifest file may identify a class that contains a
     <function>main</function> method.  &Abuild; adds the
     <property>Main-Class</property> attribute to the manifest file
     when the <varname>java.mainClass</varname> parameter is set in
     the <filename>Abuild.groovy</filename>.  In addition, &abuild;
     will create a wrapper script if the
     <varname>java.wrapperName</varname> parameter is set.  The
     wrapper script that &abuild; creates may be useful for casual
     execution of the Java program for testing purposes, but it is
     generally not a substitution for having your own deployment
     mechanism.  In particular, the wrapper script references items
     from your classpath by their paths within the build structure,
     and additionally, &abuild;'s wrapper scripts are not as portable
     as the Java code that they help to invoke.
     <footnote>
      <para>
       Specifically, &abuild; generates different wrapper scripts
       depending on whether you're running on Windows or not.
       Although it would work to build Java code on UNIX and run it on
       Windows, or vice versa, wrapper scripts generated on one
       platform are not portable to the other.
      </para>
     </footnote>
    </para>
    <para>
     Here is the output of running <command>abuild</command> in this
     directory.  As in the C++ program example, the output has been
     modified slightly: in addition to the
     <literal>--topdir--</literal> substitution, we have also filtered
     out time stamps and other strings that could potentially differ
     between platforms:
     <?qtest basic-java-program.out?>
    </para>
   </sect1>
  </chapter>
 </part>
 <part id="ref.part2" label="II">
  <title>Normal Operation</title>
  <partintro id="ref.part2.intro">
   <para>
    In this part of the manual, we discuss the standard features of
    &abuild;.  For most ordinary build problems, these chapters
    provide all the information you will need.  A few advanced topics
    are presented here.  Where appropriate, they include cross
    references to later parts of the document where functionality is
    covered in more depth.  By the end of this part, you should have a
    reasonably complete understanding of the structure of &abuild;'s
    build trees, and a fairly complete picture of &abuild;'s overall
    functionality.  You will know enough about &abuild; to be able to
    use it for tasks of moderate complexity.
   </para>
  </partintro>
  <chapter id="ref.build-items-and-trees">
   <title>Build Items and Build Trees</title>
   <para>
    Now that we've had a chance to see &abuild; in action for a simple
    case, it's time to go into more detail about how things fit
    together.  In <xref linkend="ref.basic-terminology"/>, we briefly
    defined the terms <firstterm>build item</firstterm>,
    <firstterm>build tree</firstterm>, and <firstterm>build
    forest</firstterm>.  In this chapter, we will describe them in bit
    more detail and briefly introduce a number of concepts that apply
    to them.
   </para>
   <sect1 id="ref.build-items-as-objects">
    <title>Build Items as Objects</title>
    <indexterm>
     <primary>build item</primary>
    </indexterm>
    <para>
     A precise definition of <firstterm>build item</firstterm> would
     state that a build item is any directory that contains an
     <filename>Abuild.conf</filename>.  Perhaps a more useful
     definition would say that a build item is the basic object that
     participates in &abuild;'s object-oriented view of a software
     build.  A build item provides some <emphasis>service</emphasis>
     within a build tree.  Most build items build some kind of code:
     most often a library, executable, or Java archive.  Build items
     may provide other kinds of services as well.  For example, a
     build item may implement a code generator, support for a new
     compiler, or the ability to make use of a third-party software
     library.  In addition, a build item may have certain attributes
     including a list of <firstterm>dependencies</firstterm>, a list
     of <firstterm>supported flags</firstterm>, information about what
     types of platforms the build item may be built on, a list of
     <firstterm>traits</firstterm>, and other non-dependency
     relationships to other build items.  Each of these concepts is
     explored in more depth later in the document.
    </para>
    <para>
     All build items that provide a service are required to have a
     name.  Build item names must be unique within their build tree
     and all other build trees accessible to their build tree since
     the build item name is how &abuild; addresses a build item.
     Build item names consist of period-separated segments.  Each
     segment may contain mixed case alphanumeric characters,
     underscores, and dashes.  Build item names are case-sensitive.
    </para>
    <para>
     The primary mechanism for describing build items is the
     <filename>Abuild.conf</filename> file.  This file consists of
     colon-separated key/value pairs.  A complete description of the
     <filename>Abuild.conf</filename> file may be found in <xref
     linkend="ref.abuild.conf"/>.  In the mean time, we will
     introduce keys as they become relevant to our discussion.
    </para>
   </sect1>
   <sect1 id="ref.build-item-files">
    <title>Build Item Files</title>
    <para>
     Although every build item has an <filename>Abuild.conf</filename>
     file, there are various other files that a build item may have.
     We defer a complete list and detailed discussion these files for
     later in the document, but we touch briefly upon a few of the
     common ones here.
    </para>
    <indexterm>
     <primary>Abuild.conf</primary>
    </indexterm>
    <indexterm>
     <primary>Abuild.mk</primary>
    </indexterm>
    <indexterm>
     <primary>Abuild.groovy</primary>
    </indexterm>
    <indexterm>
     <primary>build file</primary>
    </indexterm>
    <indexterm>
     <primary>interface file</primary>
    </indexterm>
    <variablelist>
     <varlistentry>
      <term><filename>Abuild.conf</filename></term>
      <listitem>
       <para>
        This is the most basic of the build item files, and it is the
        only file that must be present for every build item.  We
        sometimes refer to this as the <firstterm>build item
        configuration file</firstterm>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>Abuild.mk</filename></term>
      <term><filename>Abuild.groovy</filename></term>
      <listitem>
       <para>
        These are the files that direct &abuild; what to actually
        build in a given build item.  Each build file is associated
        with a specific backend.  Exactly one of these files must be
        present in order for &abuild; to attempt to build a build
        item.  As such, these files are known as <firstterm>build
        files</firstterm>.  When we say that a build item has or does
        not have a build file, we are specifically talking about one
        of these files.  In particular, it is important to note that
        <filename>Abuild.conf</filename> and
        <filename>Abuild.interface</filename> are not considered build
        files.
        <footnote>
         <para>
          Additionally, the files
          <filename>Abuild-ant.properties</filename> and
          <filename>Abuild-ant.xml</filename> are recognized as build
          files, associated with the deprecated xml-based ant backend.
         </para>
        </footnote>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>Abuild.interface</filename></term>
      <listitem>
       <para>
        The <filename>Abuild.interface</filename> file is present for
        every build item that wants to make some product of its build
        accessible to other build items.  We refer to this as the
        build item's <firstterm>interface file</firstterm>.  There has
        been some confusion among some &abuild; users about the term
        <firstterm>interface</firstterm>.  Please understand that
        &abuild; interfaces are distinct from Java interfaces, C++
        header files, and so forth, though they serve essentially the
        same function.  If you view a build item as an object, the
        &abuild; interface contains information about what services
        that object provides.  It exposes the interfaces through which
        other build items will access a given build item's products.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.build-trees">
    <title>Build Trees</title>
    <indexterm>
     <primary>build tree</primary>
    </indexterm>
    <para>
     A build tree, as defined before, is a collection of build items
     arranged hierarchically in the file system.  Like build items,
     build trees have names, and are only referred to from other build
     trees by name.  The root of a build tree is a build item whose
     <filename>Abuild.conf</filename> contains the
     <property>tree-name</property> key.  We refer to this item as the
     tree's <firstterm>root build item</firstterm>.
    </para>
    <para>
     A build tree is formed as a result of the items it contains
     holding references to the locations of their children within the
     file system hierarchy.  These locations are named as relative
     paths in the <property>child-dirs</property> keys of the items'
     <filename>Abuild.conf</filename> files.  It is customary to have
     the value of <property>child-dirs</property> contain single path
     elements (<emphasis>i.e.</emphasis>just a directory without any
     subdirectories), but this is also not a requirement:
     <property>child-dirs</property> entries may contain multiple path
     elements as long as there are no <filename>Abuild.conf</filename>
     files in any of the intermediate directories.  If a build item's
     child contains its own <property>tree-name</property> key, that
     child build item is the root of a separate build tree that is
     part of the same forest, defined below.  Otherwise, the child
     build item is part of the same tree as its parent.
    </para>
    <para>
     In addition to containing build items, build trees can contain
     other attributes.  Among these are references to other build
     trees, a list of <firstterm>supported traits</firstterm>, and a
     list of <firstterm>plugins</firstterm>.  We will discuss these
     topics later in the document.  These attributes are defined using
     keys in the root build item's <filename>Abuild.conf</filename>
     file.
    </para>
   </sect1>
   <sect1 id="ref.build-forests">
    <title>Build Forests</title>
    <indexterm>
     <primary>build forest</primary>
    </indexterm>
    <para>
     A build forest is a collection of build trees that are connected
     to each other by virtue of one tree's root build item being
     referenced as a child of a build item in another tree in the
     forest.  When &abuild; starts up, it looks for an
     <filename>Abuild.conf</filename> in the current directory.  It
     then walks up the file system one directory at a time looking for
     additional <filename>Abuild.conf</filename> files.  Eventually,
     it will either find the topmost <filename>Abuild.conf</filename>
     file, or it will find an <filename>Abuild.conf</filename> file
     that is not listed as a child of the next higher one.  Whichever
     of these cases is found first, the resulting
     <filename>Abuild.conf</filename> file is the root of the build
     forest.  The forest then consists of all the trees encountered by
     following all the <property>child-dirs</property> pointers from
     the forest root.
    </para>
    <para>
     Note that, unlike with build items and trees, forests do not have
     names.  Note also that, unlike with trees, there is no explicit
     marker of the root of a build forest.  This is very important as
     it allows you to extend a forest from above without modifying the
     forest itself.  For a more in-depth discussion, see
     <xref linkend="ref.multiple-trees"/>.
    </para>
    <para>
     Note that the hierarchy defined by the layout of build items in
     the file system is a file system hierarchy and nothing more.  It
     doesn't have to have any bearing at all on the dependency
     relationships among the build items.  That said, it is sensible
     to organize build items in a manner that relates to the
     architecture of the system, and this in turn usually has
     implications about dependencies.  Still, it is important to keep
     in mind that &abuild; is not file-system driven but rather is
     dependency driven.
    </para>
   </sect1>
   <sect1 id="ref.build-item-types">
    <title>Special Types of Build Items</title>
    <para>
     In further describing build items and their attributes, it is
     useful to classify build items into several types.  Most build
     items serve the purpose of providing code to be compiled.  There
     are a number of special types of build items that serve other
     purposes.  We discuss these here:
     <variablelist>
      <varlistentry>
       <term>root</term>
       <listitem>
        <para>
         <indexterm>
          <primary>root build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>root</secondary>
         </indexterm>
         The root build item of a build tree is the topmost item in
         that tree.  It has a <property>tree-name</property> key that
         gives the name of the build tree.  It is often the case that
         the root build item serves no purpose other than to hold onto
         tree-wide attributes.  It is therefore permissible for a root
         build item to lack a <property>name</property> key.  (See
         below for a discussion of unnamed build items.)  Keys that
         define attributes of the build tree may appear only in the
         root build item's <filename>Abuild.conf</filename>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>unnamed</term>
       <listitem>
        <para>
         <indexterm>
          <primary>unnamed build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>unnamed</secondary>
         </indexterm>
         In order to refer to one build item from another, both build
         items must have names.  &Abuild; requires that every named
         build item in a build forest be named uniquely within that
         forest.  A name is given to a build item by setting the
         <property>name</property> key in its
         <filename>Abuild.conf</filename>.  Sometimes, a build item
         exists for the sole purpose of bridging its parent with its
         children in the file system.  Such items do not need to be
         referenced by other build items, so they do not need names.
         The only use of an unnamed build item is to serve as an
         intermediary during traversal of the file system.  Such a
         build item's <filename>Abuild.conf</filename> may only
         contain the <property>child-dirs</property> key.  &Abuild;
         doesn't retain any information about these build items.  It
         simply traverses through them when locating build items at
         startup time.  Unnamed build items are the only types of
         build items that don't have to belong to any particular build
         tree.  It is common for the root of a forest to be an unnamed
         build item whose children are all roots of build trees.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>interface-only</term>
       <listitem>
        <para>
         <indexterm>
          <primary>interface-only build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>interface-only</secondary>
         </indexterm>
         Interface-only build items are build items that contain (in
         addition to <filename>Abuild.conf</filename>) an
         <filename>Abuild.interface</filename> file.  They do not
         build anything and therefore do not contain build files (such
         as <filename>Abuild.mk</filename> or
         <filename>Abuild.groovy</filename>).  Since they have nothing
         to build, &abuild; never actually invokes a backend on them.
         They are, however, included in all dependency and integrity
         checks.  A typical use of interface-only build items would be
         to add the locations of external libraries to the include and
         library paths (or to the classpaths for Java items).  There
         may also be some interface-only build items that consist
         solely of static files (templated C++ classes, lists of
         constants, etc.).  Interface-only build items may also be
         used to declare interface variables that are used by other
         build items.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>pass-through</term>
       <listitem>
        <para>
         <indexterm>
          <primary>pass-through build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>pass-through</secondary>
         </indexterm>
         Pass-through build items are useful for solving certain
         advanced &abuild; problems.  As such, there are aspects of
         this definition that may not be clear on the first reading.
         Pass-through build items contain no build or interface files,
         but they are named and have dependencies.  This makes
         pass-through build items useful as top-level facades for
         hiding more complicated build item structures.  This could
         include build items that have private names relative to the
         pass-through item, and it could also include structures
         containing build items that cross language and platform
         boundaries.  Several examples in the documentation use
         pass-through build items to hide private build item names.
         For further discussion of using pass-through build items in a
         cross-platform environment, please see <xref
         linkend="ref.pass-through-dependencies"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>plugin</term>
       <listitem>
        <para>
         Plugins are capable of extending the functionality of
         &abuild; beyond what can be accomplished in regular build
         items.  Plugins must be named and not have any dependencies.
         No other build items may depend on them.  Plugins are a topic
         in their own right.  They are discussed in depth in <xref
         linkend="ref.plugins"/>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect1>
   <sect1 id="ref.third-party-software">
    <title>Integrating with Third-Party Software</title>
    <para>
     Virtually every software development project has some need to
     integrate with third-party software libraries.  In a traditional
     build system, you might list the include paths, libraries, and
     library directories right in your <filename>Makefile</filename>,
     <filename>build.xml</filename>, or configuration file for
     whatever build system you are using.  With &abuild;, the best way
     to integrate with a third-party library is to use a build item
     whose sole purpose is to export that library's information using
     an <filename>Abuild.interface</filename> file.  In the simplest
     cases, a third-party library build item might be an interface
     only build item (described above) that just includes the
     appropriate library directives in a static
     <filename>Abuild.interface</filename> file.  For example, a build
     item that provides access to the PCRE (Perl-compatible regular
     expression) libraries on a Linux distribution that has them
     installed in the system's standard include path might just
     include an <filename>Abuild.interface</filename> with the
     following contents:

     <programlisting>LIBS = pcrecpp pcre
</programlisting>
     For Java build items, a third-party JAR build item would
     typically append the path to the JAR file to the
     <varname>abuild.classpath.external</varname> interface variable.
     (For a discussion of the various classpath variables, see <xref
     linkend="ref.interface.java"/>.)
    </para>
    <para>
     Sometimes, the process may be more involved.  For example, on a
     UNIX system, it is often desirable to use
     <application>autoconf</application> to determine what interface
     is required for a particular library.  We present an example of
     using <application>autoconf</application> with &abuild; in <xref
     linkend="ref.example.autoconf"/>.  Still other libraries may use
     <application>pkg-config</application>.  For those libraries, it
     may make sense to create a simple set of build rules that
     automatically generate an <filename>Abuild.interface</filename>
     <function>after-build</function> file (also discussed in <xref
     linkend="ref.example.autoconf"/>) by running the
     <command>pkg-config</command> command.  An example
     <application>pkg-config</application> build item may be found in
     the <filename>abuild-contrib</filename> package available at
     <ulink url="http://www.abuild.org">&abuild;'s web site</ulink>.
    </para>
    <para>
     Whichever way you do it for a given package, the idea is that you
     should always create a build item whose job it is to provide the
     glue between &abuild; and the third-party library.  Other build
     items that need to use the third-party library can then just
     declare a dependency on the build item that provides the
     third-party library's interface.  This simplifies the process of
     using third-party libraries and makes it possible to create a
     uniform standard for doing so within any specific &abuild; build
     tree.  It also alleviates the need to duplicate information about
     the third-party library throughout your source tree.
     <emphasis>Whenever you are duplicating knowledge about the path
     of some entity, you would probably be better off creating a
     separate build item to encapsulate that knowledge.</emphasis>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.platforms">
   <title>Target Types, Platform Types, and Platforms</title>
   <para>
    &Abuild; was designed with multiplatform operation in mind from
    the beginning.  Up to this point, we have largely glossed over how
    &abuild; deals with multiple platforms.  In this chapter, we will
    cover this aspect of &abuild;'s operation in detail.
   </para>
   <sect1 id="ref.platform-structure">
    <title>Platform Structure</title>
    <para>
     &Abuild; classifies platforms into a three-level hierarchy.  The
     three levels are described by the following terms:
    </para>
    <variablelist>
     <varlistentry>
      <term>target type</term>
      <listitem>
       <para>
        <indexterm>
         <primary>target type</primary>
        </indexterm>
        A <firstterm>target type</firstterm> encompasses the overall
        kind of targets that are being built.  A target type
        essentially encapsulates a build paradigm.  &Abuild;
        understands three target types:
        <type>platform-independent</type> for truly
        platform-independent products like scripts and documentation,
        <type>object-code</type> for compiled object code like C and
        C++, and <type>java</type> for Java byte code and related
        products.  One could argue that Java code is
        platform-independent, but since Java code has its own build
        paradigm, &abuild; considers it to be a separate target type.
        Be careful not to confuse <firstterm>target type</firstterm>
        with <firstterm>target</firstterm>, defined in <xref
        linkend="ref.basic-terminology"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>platform type</term>
      <listitem>
       <para>
        <indexterm>
         <primary>platform type</primary>
        </indexterm>
        A <firstterm>platform type</firstterm> essentially defines a
        grouping of platforms.  Platform types belong to target types
        and contain platforms.  When configuring build items,
        developers assign build items to platform types rather than to
        platforms or target types.  The
        <type>platform-independent</type> target type has only platform
        type: <type>indep</type>.  The <type>java</type> target type
        has only one platform type: <type>java</type>.
        <footnote>
         <para>
          At one time, it was planned for &abuild; to support
          different platform types for different versions of Java byte
          code.  Although this would have been useful for build trees
          that had complex requirements for mixing JDKs of different
          versions, this capability would have added a lot of
          complexity to support a practice that is unusual and largely
          undesirable.
         </para>
        </footnote>
        Platform types are most useful in the <type>object-code</type>
        target type.  &Abuild; has only one built-in platform type in
        the <type>object-code</type> target type: <type>native</type>.
        The <type>native</type> platform type applies to build items
        that are expected to be able to be built and run on the host
        platform.  Additional platform types to support embedded
        platforms or cross compilers can be added in plugins (see
        <xref linkend="ref.adding-platform-types-and-platforms"/>).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>platform</term>
      <listitem>
       <para>
        <indexterm>
         <primary>platform</primary>
        </indexterm>
        The &abuild; <firstterm>platform</firstterm> is the lowest
        level of detail in describing the environment in which a
        target is intended to be used.  The expectation is that
        compiled products (object files, libraries, binary
        executables, java class files, etc.) produced for one platform
        are always compatible with other products produced for that
        platform but are not necessarily compatible with products
        produced for a different platform.  If two different versions
        of a compiler generate incompatible object code (because of
        incompatible runtime library versions or different C++ name
        mangling conventions, for example), then a host running one
        compiler may generate output belonging to a different platform
        from the same host running a different version of the
        compiler.  For the <type>indep</type> platform type in the
        <type>platform-independent</type> target type, there is only
        one platform, which has the same name as the platform type:
        <type>indep</type>.  For the <type>java</type> platform type
        in the <type>java</type> target type, there is also only one
        platform, which also shares its name with the platform type:
        <type>java</type>.  Platforms become interesting within the
        <type>object-code</type> target type.  When we refer to
        platforms, we are almost always talking about
        <type>object-code</type> platforms.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     This table (<xref linkend="table.platforms"/>) shows the target
     types along with the built-in platform types and platforms that
     belong to them.
     <table id="table.platforms" frame="all">
      <title>Built-in Platforms, Platform Types, and Target Types</title>
      <tgroup cols="3" align="left" colsep="1" rowsep="1">
       <thead>
        <row>
         <entry>Target Type</entry>
         <entry>Platform Type</entry>
         <entry>Platform</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><type>object-code</type></entry>
         <entry><type>native</type></entry>
         <entry>based on available tools</entry>
        </row>
        <row>
         <entry><type>java</type></entry>
         <entry><type>java</type></entry>
         <entry><type>java</type></entry>
        </row>
        <row>
         <entry><type>platform-independent</type></entry>
         <entry><type>indep</type></entry>
         <entry><type>indep</type></entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     When a build item is defined with multiple platform types, they
     must all belong to the same target type.  (Since the only target
     type that has more than one platform type is
     <type>object-code</type>, this means the target type of a build
     item with multiple platform types will always be
     <type>object-code</type>.)  Some interface variables are also
     based on target type.  For example, it may be permissible for a
     java build item to depend on a C++ build item if the C++ build
     item exports native code or provides an executable code
     generator, but it would never make sense for a java build item to
     have an include path or library path in the sense of a C/C++
     build item.  When one build item depends on another, the
     platforms on which the two build items are being built come into
     play.  We discuss this in <xref
     linkend="ref.cross-platform-support"/>.
    </para>
   </sect1>
   <sect1 id="ref.platforms.object-code">
    <title>Object-Code Platforms</title>
    <para>
     For target type <type>object-code</type>, platform identifiers
     are of the form
     <type>os</type>.<type>cpu</type>.<type>toolset</type>.<type>compiler</type>[.<type>option</type>],
     described below.  In all cases, each field of the platform
     identifier must consist only of lower-case letters, numbers,
     dash, or underscore.  The fields of the platform identifier are
     as follows:
    </para>
    <variablelist>
     <varlistentry>
      <term>os</term>
      <listitem>
       <para>
        A broad description of the operating system, such as
        <type>linux</type>, <type>solaris</type>,
        <type>windows</type>, <type>cygwin</type>, or
        <type>vxworks</type>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>cpu</term>
      <listitem>
       <para>
        A CPU type identifier such as <type>ix86</type>,
        <type>x86_64</type>, <type>ppc</type>, <type>ppc64</type>, or
        <type>sparc</type>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>toolset</term>
      <listitem>
       <para>
        A user-defined label for a collection of tools.  This is a
        convenience field to separate things like different versions
        of compilers or runtime libraries.  It can be set to any
        string, at which point the user is responsible for ensuring
        that it does in fact define a meaningful collection of tools.
        By default, &abuild; will create a toolset name based on the
        operating system distribution or similar factors.  Examples
        include <type>rhel4</type> on a Red Hat Enterprise Linux 4
        system, or <type>deb5</type> on a Debian GNU/Linux 5.x system.
        <footnote>
         <para>
          At present, it is possible to add new toolsets easily with
          plugins, but the only way to <emphasis>override</emphasis>
          the built-in default toolset would be to edit
          <filename>private/bin/get_native_platform_data</filename>,
          the perl script &abuild; uses to determine this information
          at startup.  This may be addressed in a future version of
          &abuild;.
         </para>
        </footnote>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>compiler</term>
      <listitem>
       <para>
        An identifier for the compiler C/C++ compiler toolchain to be
        used.  &Abuild; has built-in support for gcc on UNIX systems
        and for Microsoft Visual C++ and mingw on Windows systems.
        Users can provide their own compiler toolchains in addition to
        these.  The mechanism for adding new compilers is described in
        <xref linkend="ref.adding-platform-types-and-platforms"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>option</term>
      <listitem>
       <para>
        An optional field that is used to pass additional information
        to the <application>GNU Make</application> code that
        implements support for the compiler.  Typical uses for options
        would be to define different debugging, profiling, or
        optimization levels.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <indexterm>
     <primary>CCXX_TOOLCHAIN</primary>
    </indexterm>
    <para>
     All of the fields of the platform identifier are made available
     in separate variables within the interface parsing system.  In
     addition, for <type>object-code</type> build items, the make
     variable <varname>$(CCXX_TOOLCHAIN)</varname> is set to the value
     of the compiler field.  Here are some example platform
     identifiers:
     <simplelist>
      <member>linux.ppc64.proj1default.gcc</member>
      <member>linux.ppc64.proj1default.gcc.release</member>
      <member>linux.ppc64.proj1default.gcc.debug</member>
      <member>linux.x86.fc5.gcc</member>
      <member>linux.x86.fc5.gcc.release</member>
      <member>linux.x86.fc5.gcc.debug</member>
      <member>windows.ix86.nt5.msvc</member>
      <member>windows.ix86.cygwin-nt5.mingw</member>
      <member>vxworks.pc604.windriver.vxgcc</member>
     </simplelist>
    </para>
   </sect1>
   <sect1 id="ref.output-directories">
    <title>Output Directories</title>
    <indexterm>
     <primary>output directories</primary>
    </indexterm>
    <para>
     When &abuild; builds an item, it creates an output directory
     under that item's directory for every platform on which that item
     is built.  The output directory is of the form
     <filename>abuild-<replaceable>platform-name</replaceable></filename>.
     &Abuild; itself and all &abuild;-supplied rules create files only
     inside of &abuild; output directories.
     <footnote>
      <para>
       &Abuild; considers any directory whose name starts with
       <filename>abuild-</filename> and which contains a file named
       <filename>.abuild</filename> to be an output directory.
      </para>
     </footnote>
    </para>
    <para>
     When &abuild; invokes make, it always does so from an output
     directory.  This is true even for platform-independent build
     items.  In this way, even temporary files created by compilers or
     other build systems will not appear in the build item's local
     directory.  This makes it possible to build a specific item for
     multiple platforms in parallel without having to be concerned
     about the separate builds overwriting each other's files.
    </para>
    <para>
     When &abuild; builds items using the Groovy backend (and also
     using the deprecated xml-based ant backend), it performs those
     builds inside a single Java virtual machine instance.  As such,
     it does not change its working directory to the output directory.
     (Java does not support changing current directories, and besides,
     there could be multiple builds going on simultaneously in
     different threads.)  However, each Java-based build has its own
     private ant <classname>Project</classname> whose
     <varname>basedir</varname> property is set to the output
     directory.  As such, all well-behaved ant tasks will only create
     files in the output directory.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.build-item-dependencies">
   <title>Build Item Dependencies</title>
   <para>
    <indexterm>
     <primary>dependency</primary>
    </indexterm>
    Management of dependencies among build items is central to
    &abuild;'s functionality.  We have already gotten a taste of this
    capability in the basic examples included in <xref
    linkend="ref.basic-operation"/>.  In this chapter, we will examine
    dependencies in more depth.
   </para>
   <sect1 id="ref.dependencies.direct-and-indirect">
    <title>Direct and Indirect Dependencies</title>
    <indexterm>
     <primary>dependency</primary>
     <secondary>direct</secondary>
    </indexterm>
    <indexterm>
     <primary>dependency</primary>
     <secondary>indirect</secondary>
    </indexterm>
    <indexterm>
     <primary>dependency</primary>
     <secondary>circular</secondary>
    </indexterm>
    <indexterm>
     <primary>dependency</primary>
     <secondary>transitive</secondary>
    </indexterm>
    <para>
     The sole mechanism for declaring dependencies among build items
     in &abuild; is the <property>deps</property> key in a build
     item's <filename>Abuild.conf</filename>.  Suppose build item
     <classname>A</classname> declares build item
     <classname>B</classname> as a dependency.  The following line
     would appear in <classname>A</classname>'s
     <filename>Abuild.conf</filename>:

     <programlisting>deps: B
</programlisting>
     This declaration causes two things to happen:
     <itemizedlist>
      <listitem>
       <para>
        It ensures that <classname>B</classname> will be built before
        <classname>A</classname>.
       </para>
      </listitem>
      <listitem>
       <para>
        It enables <classname>A</classname> to see all of the variable
        declarations and assignments in <classname>B</classname>'s
        <filename>Abuild.interface</filename> file.
       </para>
      </listitem>
     </itemizedlist>
     We illustrate both of these principles later in this chapter.
     For an in-depth discussion of build ordering and dependency-aware
     builds, see <xref linkend="ref.what-to-build"/>.  For an in-depth
     discussion of &abuild;'s interface system, see <xref
     linkend="ref.abuild-interface-system"/>.
    </para>
    <para>
     Another very important point about dependencies in &abuild; is
     that they are <firstterm>transitive</firstterm>.  In other words,
     if <classname>A</classname> depends on <classname>B</classname>
     and <classname>B</classname> depends on <classname>C</classname>,
     then <classname>A</classname> also implicitly depends on
     <classname>C</classname>.  This means that the conditions above
     apply to <classname>A</classname> and <classname>C</classname>.
     That is, <classname>C</classname> is built before
     <classname>A</classname> (which it would be anyway since it is
     built before <classname>B</classname> and
     <classname>B</classname> is built before
     <classname>A</classname>), and <classname>A</classname> sees
     <classname>C</classname>'s interface in addition to seeing
     <classname>B</classname>'s interface.
     <footnote>
      <para>
       In fact, since <classname>B</classname> depends on
       <classname>C</classname>, <classname>C</classname>'s interface
       is effectively included as part of <classname>B</classname>'s
       interface.  This makes <classname>C</classname>'s interface
       visible to all build items that depend on
       <classname>B</classname>.  The exact mechanism by which this
       works is described in <xref
       linkend="ref.abuild-interface-system"/>.
      </para>
     </footnote>
     Assuming that
     <classname>A</classname> does not explicitly list
     <classname>C</classname> in its <property>deps</property> key, we
     would call <classname>B</classname> a <firstterm>direct
     dependency</firstterm> of <classname>A</classname> and
     <classname>C</classname> an <firstterm>indirect
     dependency</firstterm> of <classname>A</classname>.  We also say
     that build item dependencies are <firstterm>inherited</firstterm>
     when we wish to refer to the fact that build ordering and
     interface visibility are influenced by both direct and indirect
     dependencies.
    </para>
    <para>
     &Abuild; performs various validations on dependencies.  The most
     important of these is that no cyclic dependencies are permitted.
     <footnote>
      <para>
       Stated formally, &abuild; requires that build item dependencies
       form a directed acyclic graph.
      </para>
     </footnote>
     In other words, if <classname>A</classname> depends on
     <classname>B</classname> either directly or indirectly, then
     <classname>B</classname> cannot depend on
     <classname>A</classname> directly or indirectly.  There are other
     dependency validations which are discussed in various places
     throughout this document.
    </para>
    <para>
     By default, any build item can depend on any other build item by
     name.  &Abuild; offers two mechanisms to restrict which items can
     depend on which other items.  One mechanism is through build item
     name scoping rules, discussed below.  The other mechanism is
     through use of multiple build trees, discussed in <xref
     linkend="ref.multiple-trees"/>.
    </para>
   </sect1>
   <sect1 id="ref.build-ordering">
    <title>Build Order</title>
    <para>
     &Abuild; makes no specific commitments about the order in which
     items will be built except that no item is ever built before its
     dependencies are built.  The exact order in which build items are
     built, other than that dependencies are built before items that
     depend on them, should be considered an implementation detail and
     not relied upon.  When &abuild; is invoked in with multiple
     threads (using the <option>--jobs</option> option, as discussed
     in <xref linkend="ref.command-line"/>), it may build multiple
     items in parallel.  Even in this mode, &abuild; will never start
     building one build item until all of its dependencies have been
     built successfully.
    </para>
   </sect1>
   <sect1 id="ref.build-item-name-scoping">
    <title>Build Item Name Scoping</title>
    <para>
     In this section, we discuss build item name scoping rules.  Build
     item name scoping is one mechanism that can be used to restrict
     which build items may directly depend on which other build items.
    </para>
    <para>
     <indexterm>
      <primary>build item</primary>
      <secondary>scope</secondary>
     </indexterm>
     <indexterm>
      <primary>scope</primary>
     </indexterm>
     <indexterm>
      <primary>scope</primary>
      <secondary>ancestor</secondary>
     </indexterm>
     <indexterm>
      <primary>scope</primary>
      <secondary>descendant</secondary>
     </indexterm>
     Build item names consist of period-separated segments.  The
     period separator in a build item's name is a namespace scope
     delimiter that is used to determine which build items may
     directly refer to which other build items in their
     <filename>Abuild.conf</filename> files.  It is a useful mechanism
     for allowing a build item to hide the fact that it is composed of
     lower-level build items by blocking others from accessing those
     lower-level items directly.
    </para>
    <para>
     Each build item belongs to a namespace scope equal to the name of
     the build item after removing the last period and everything
     following it.  For example, the build item
     &ldquo;<classname>A.B.C.D</classname>&rdquo; is in the scope
     called &ldquo;<classname>A.B.C</classname>&rdquo;.  We would
     consider &ldquo;<classname>A.B</classname>&rdquo; and
     &ldquo;<classname>A</classname>&rdquo; to be <firstterm>ancestor
     scopes</firstterm>.  The build item name itself also defines a
     scope.  In this case, the scope
     &ldquo;<classname>A.B.C.D</classname>&rdquo; would contain
     &ldquo;<classname>A.B.C.D.E</classname>&rdquo;.  Any build item
     name scope that starts with
     &ldquo;<classname>A.B.C.D.</classname>&rdquo; (including the
     period) would be a <firstterm>descendant scope</firstterm> to
     &ldquo;<classname>A.B.C.D</classname>&rdquo;.  Any build item
     whose name does not contain a period is considered to belong to
     the global scope and is accessible by all build items.
    </para>
    <para>
     One build item is allowed to access another build item by name if
     the referenced build item belongs to the accessing build item's
     scope or any of its ancestor scopes.  <xref
     linkend="fig.build-item-scopes"/>, shows a number of build items
     arranged by scope.  In this figure, each build item defines a
     scope whose members appear in a gray box at the end of a
     semicircular arrowhead originating from the defining build item.
     Each build item in this figure can see the build items that are
     direct members of the scope that it defines, the build items that
     are siblings to it in its own scope, and the build items inside
     of any of its ancestor scopes.  You may wish to study the figure
     while you follow along with the text below.
     <figure id="fig.build-item-scopes">
      <title>Build Item Scopes</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="build-item-scopes.png"/>
       </imageobject>
       <caption>
        <para>
         Build items are shown here grouped by scope.  Each build item
         is connected to the scope that it defines.
        </para>
       </caption>
      </mediaobject>
     </figure>
     To illustrate, we will consider item
     <classname>A1.B1.C1</classname>.  The build item
     <classname>A1.B1.C1</classname> can access the following items
     for the following reasons:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B1.C1.D1</classname> because it belongs to the
        scope that <classname>A1.B1.C1</classname> defines:
        <classname>A1.B1.C1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2</classname> because it is in the same
        scope as <classname>A1.B1.C1</classname>:
        <classname>A1.B1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1</classname> and <classname>A1.B2</classname>
        because they belong to an ancestor scope:
        <classname>A1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1</classname> and <classname>Q</classname> because
        they are global
       </para>
      </listitem>
     </itemizedlist>
     It cannot access these items:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B1.C1.D1.E1</classname> because it is hidden in
        scope <classname>A1.B1.C1.D1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2.D1</classname> because it is hidden in
        scope <classname>A1.B1.C2</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>Q.R</classname> because it is hidden in scope
        <classname>Q</classname>
       </para>
      </listitem>
     </itemizedlist>
     The item <classname>A1.B1.C1</classname> can <emphasis>be
     accessed by</emphasis> the following items:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B1</classname> because it is its parent
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2</classname> because it is its sibling
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C1.D1</classname> and
        <classname>A1.B1.C1.D1.E1</classname> because they are its
        descendants
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2.D1</classname> because it can see
        <classname>A1.B1.C1</classname> as a member of its ancestor
        scope <classname>A1.B1</classname>
       </para>
      </listitem>
     </itemizedlist>
     It cannot be accessed by these items:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B2</classname>, <classname>A1</classname>,
        <classname>Q</classname>, and <classname>Q.R</classname>, none
        of which can see inside of <classname>A1.B1</classname>
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     To give a more concrete example, suppose you have a globally
     accessible build item called <classname>networking</classname> that
     was internally divided into private build items
     <classname>networking.src</classname> and
     <classname>networking.test</classname>.  A separate build item
     called <classname>logger</classname> would be permitted to declare a
     dependency on <classname>networking</classname> but not on
     <classname>networking.src</classname> or
     <classname>networking.test</classname>.  Assuming that it did not
     create any circular dependencies,
     <classname>networking.test</classname> would also be allowed to
     depend on <classname>logger</classname>.
    </para>
    <para>
     Note that these restrictions apply only to explicitly declared
     dependencies.  It is common practice to implement a
     &ldquo;public&rdquo; build item as multiple &ldquo;private&rdquo;
     build items.  The public build item itself would not have an
     <filename>Abuild.interface</filename> file, but would instead
     depend on whichever of its own private build items contain
     interfaces it wants to export.  It would, in fact, be a
     pass-through build item.  Because dependencies are inherited,
     items that depend on the public build item will see the
     interfaces of those private build items even though they would
     not be able to depend on them directly.  In this way, the public
     build item becomes a facade for the private build items that
     actually do the work.  For example, the build item
     <classname>networking</classname> would most likely not have its
     own <filename>Abuild.interface</filename> or
     <filename>Abuild.mk</filename> files.  Instead, it might depend
     on <classname>networking.src</classname> which would have those
     files.  It would probably not depend on
     <classname>networking.test</classname> since
     <classname>networking.test</classname> doesn't have to be built
     in order to use <classname>networking</classname>.
     <footnote>
      <para>
       Although <classname>networking</classname> doesn't have to
       depend on <classname>networking.test</classname>, you might be
       tempted to put the dependency in so that when you run the
       <command>check</command> target for all dependencies of
       <classname>networking</classname>, you would get the test suite
       implemented in <classname>networking.test</classname>.  Rather
       than using a dependency for this purpose, you can use a trait
       instead.  For information about traits, see <xref
       linkend="ref.traits"/>.  A specific example of using traits for
       this purpose appears in that section.
      </para>
     </footnote>
     This means that it would be okay for
     <classname>networking.test</classname> to depend on
     <classname>networking</classname> since doing so would not create
     any circular dependencies.  Then, any build items that depend on
     <classname>networking</classname> indirectly depend on
     <classname>networking.src</classname> and would see
     <classname>networking.src</classname>'s
     <filename>Abuild.interface</filename>.
    </para>
    <para>
     There is nothing that a build item can do to allow itself to
     declare a direct dependency on another build item that is hidden
     within another scope: the only way to gain direct access to a
     build item is to be its ancestor or to be a descendant of its
     parent.  (There are no restrictions on indirect access.)  There
     are times, however, when it is desirable for a build item to
     allow itself to <emphasis>be seen</emphasis> by build items who
     would ordinarily not have access to it.  This is accomplished by
     using the <property>visible-to</property> key in
     <filename>Abuild.conf</filename>.  We defer discussion of this
     feature until later; see <xref
     linkend="ref.build-item-visibility"/>.
    </para>
   </sect1>
   <sect1 id="ref.example.simple-build-tree">
    <title>Simple Build Tree Example</title>
    <para>
     Now that the topic of build items and build trees has been
     explored in somewhat more depth, let's take a look at a simple
     but complete build tree.  The build tree in
     <filename>doc/example/general/reference/common</filename>
     illustrates many of the concepts described above.
    </para>
    <para>
     The first file to look at is the <filename>Abuild.conf</filename>
     belonging to this tree's root build item:
     <?example general/reference/common/Abuild.conf?>
     This is a root build item configuration file, as you can see by
     the presence of the <property>tree-name</property> key.  Notice
     that it lacks a <property>name</property> key, as is often the
     case with the root build item.  This
     <filename>Abuild.conf</filename> contains the names of some child
     directories and also a build tree attribute:
     <property>supported-traits</property>, which lists the traits
     that are allowed in the build tree.  We will return to the topic
     of traits in <xref linkend="ref.traits"/>.  In the mean time, we
     will direct our focus to the child build items.
    </para>
    <para>
     The first child of the root build item of this tree is in the
     <filename>lib1</filename> directory.  We examine its
     <filename>Abuild.conf</filename>:
     <?example general/reference/common/lib1/Abuild.conf?>
     This build item is called <classname>common-lib1</classname>.
     Notice that the name of the build item is not the same as the
     name of the directory, but it is based on the name of the
     directory.  This is a typical strategy for naming build items.
     &Abuild; doesn't care how you name build items as long as they
     conform to the syntactic restrictions and are unique within a
     build tree.  Coming up with a naming structure that parallels
     your system's architecture is a good way to help ensure that you
     do not create conflicting build item names.  However, you should
     avoid creating build item names that slavishly follow your
     directory structure since doing so will make it needlessly
     difficult for you to move things around.  A major feature of
     &abuild; is that nothing cares where a build item is located, so
     don't set a trap for yourself in which you have to rename a build
     item when you move it!
    </para>
    <para>
     This build item does not have any build or interface files.  It is
     a <firstterm>pass-through build item</firstterm>.  It declares a
     single dependency: <classname>common-lib1.src</classname>, and two
     child directories: <filename>src</filename> and
     <filename>test</filename>.
    </para>
    <para>
     Next, look at the <classname>common-lib1.src</classname> build
     item's <filename>Abuild.conf</filename> in the
     <filename>common/lib1/src</filename> directory:
     <?example general/reference/common/lib1/src/Abuild.conf?>
     The first thing to notice is this build item's name.  It contains
     a period and is therefore private to the
     <classname>common-lib1</classname> scope.  That means that it is
     not accessible to build items whose names are not also under that
     scope.  In particular, a build item called
     <classname>common-lib2</classname> would not be able to depend
     directly on <classname>common-lib1.src</classname>.  It would
     instead depend on <classname>common-lib1</classname> and would
     inherit the dependency on <classname>common-lib1.src</classname>
     indirectly.
    </para>
    <para>
     This build item doesn't list any child directories and, as such,
     is a leaf in the file system hierarchy.  It also happens not to
     declare any dependencies, so it is also a leaf in the dependency
     tree, though one does not imply the other.  This build item
     configuration file contains the
     <property>platform-types</property> key, as is required for all
     build items that contain build or interface files.  In addition
     to the <filename>Abuild.conf</filename> file, we have an
     <filename>Abuild.mk</filename> file and an
     <filename>Abuild.interface</filename> file:
     <?example general/reference/common/lib1/src/Abuild.mk?>
     <?example general/reference/common/lib1/src/Abuild.interface?>
     There is nothing in these files that is fundamentally different
     from the basic C++ library example shown in <xref
     linkend="ref.example.basic.cxx-library"/>.  We can observe,
     however, that the <varname>INCLUDES</varname> variable in
     <filename>Abuild.interface</filename> actually points to
     <filename>../include</filename> rather than the current
     directory.  This simply illustrates that &abuild; doesn't impose
     any restrictions on how you might want to lay out your build
     items, though it is recommended that you pick a consistent way
     and stick with it for any given build tree.  You should also
     avoid paths that point into other build items.  Instead, depend
     on the other item and put the variable there.  As a rule, if you
     ever have two interface variables or assignments that resolve to
     the same path, you are probably doing something wrong: a
     significant feature of &abuild; is that allows you to encapsulate
     the location of any given thing in only one place.  Instead,
     figure out who <emphasis>owns</emphasis> a given file or
     directory and export it from that build item's interface.  We
     will not study the source and header files in this example here,
     but you are encouraged to go to the
     <filename>doc/example/general/reference/common</filename>
     directory in your &abuild; source tree or installation directory
     to study the files further on your own.
    </para>
    <para>
     Next, look at the <filename>test</filename> directory.  Here is
     its <filename>Abuild.conf</filename>:
     <?example general/reference/common/lib1/test/Abuild.conf?>
     Notice that it declares a dependency on
     <classname>common-lib1</classname>.  Since its name is also
     private to the <classname>common-lib1</classname> scope, it would
     have been okay for it to declare a dependency directly on
     <classname>common-lib1.src</classname>.  Declaring its dependency
     on <classname>common-lib1</classname> instead means that this
     test code is guaranteed to see the same interfaces as would be
     seen by any outside user of <classname>common-lib1</classname>.
     This may be appropriate in some cases and not in others, but it
     demonstrates that it is okay for a build item that is inside of a
     particular namespace scope to depend on its parent in the
     namespace hierarchy.  This build item also declares a trait, but
     we will revisit this when we discuss traits later in the document
     (see <xref linkend="ref.traits"/>).
    </para>
    <para>
     In addition to the <filename>lib1</filename> directory, we also
     have <filename>lib2</filename> and <filename>lib3</filename>.
     These are set up analogously to <filename>lib1</filename>, so we
     will not inspect every file.  We will draw your attention to one
     file in particular: observe that the
     <classname>common-lib2.src</classname> build item in
     <filename>reference/common/lib2/src</filename> declares a dependency
     on <classname>common-lib3</classname>:
     <?example general/reference/common/lib2/src/Abuild.conf?>
    </para>
    <para>
     We will return to this build tree later to study build sets,
     traits, and examples of various ways to run builds.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.multiple-trees">
   <title>Multiple Build Trees</title>
   <para>
    In large development environments, it is common to have
    collections of code that may be shared across multiple projects,
    and it's also common to have multiple development efforts being
    worked in parallel with the intention of integrating them at a
    later date.  Ideally, such collections of shared code should be
    accessible by multiple projects but should not be able to access
    code from the those projects, and parallel development efforts
    should be kept independent to the maximum possible extent.  In
    order to support this distributed and parallel style of software
    development, &abuild; allows you to divide your work up into
    multiple build trees, which coexist in a <firstterm>build
    forest</firstterm>.  These trees can remain completely independent
    from each other, and you can also establish one-way dependency
    relationships among trees.
   </para>
   <para>
    We define the following additional terms:
    <variablelist>
     <varlistentry>
      <term>local build tree</term>
      <listitem>
       <para>
        <indexterm>
         <primary>build tree</primary>
         <secondary>local</secondary>
        </indexterm>
        <indexterm>
         <primary>local build tree</primary>
        </indexterm>
        The <firstterm>local build tree</firstterm> is the build tree
        that contains the current directory.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>tree dependency</term>
      <listitem>
       <para>
        <indexterm>
         <primary>tree dependency</primary>
        </indexterm>
        A <firstterm>tree dependency</firstterm> is a separate build
        tree whose items can supplement the local build tree.  Build
        items in the local build tree can resolve the names of build
        items in the tree named as a tree dependency, but build items
        in the dependency cannot see items in the dependent (local)
        build tree.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>top-level <filename>Abuild.conf</filename></term>
      <listitem>
       <para>
        <indexterm>
         <primary>top-level <filename>Abuild.conf</filename></primary>
        </indexterm>
        The <firstterm>top-level Abuild.conf</firstterm> is an
        <filename>Abuild.conf</filename> file that is higher in th
        file system than any other <filename>Abuild.conf</filename>
        file in the build forest.  If you are building a single tree,
        the top-level <filename>Abuild.conf</filename> file is
        typically the root build item of that tree.  If you are
        building multiple trees, you have to create a higher-level
        <filename>Abuild.conf</filename> file that can reach the roots
        of all the trees you are going to use, directly or indirectly,
        through its <property>child-dirs</property> key.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <sect1 id="ref.using-tree-deps">
    <title>Using Tree Dependencies</title>
    <para>
     Even when &abuild; knows about multiple trees, it still won't
     allow items in one build tree to refer to items in other trees
     without an explicit instruction to do so.  This makes it possible
     to ensure that items in one tree are not
     <emphasis>accidentally</emphasis> modified to depend on items in
     a tree that is supposed to be unrelated.  When you want items in
     one tree to be able to use items in another tree, you declare a
     <firstterm>tree dependency</firstterm> of one tree on another.
     This creates a one-way relationship between the two trees such
     that items in the <emphasis>dependent</emphasis> tree (the one
     that declares the dependency) can see items in the tree on which
     it depends, but no visibility is possible in the other direction.
     To declare a tree dependency, you list the name of the tree
     dependency in the <property>tree-deps</property> key of the
     dependent tree's <filename>Abuild.conf</filename> file.  As with
     item dependencies listed in <property>deps</property>, &abuild;
     requires that there are no cycles among tree dependencies.
    </para>
    <para>
     There is nothing special about a build tree that makes it able to
     be the target of a tree dependency: any tree can depend on any
     other tree as long as no dependency cycles are created.
    </para>
    <para>
     Once you set up another tree as a tree dependency of your tree,
     all build items defined in the tree named by the tree dependency
     are available to you (subject to normal scoping rules) as if they
     were in your local build tree.  Since any tree can potentially
     have a dependency relationship with any other, &abuild; enforces
     that none of the build items in any build tree may have the same
     name as any build item in any tree in the forest.  In order to
     avoid build item name clashes, it's a good idea to pick a naming
     convention for your build items that includes some kind of
     tree-based prefix, as we have done with names like
     <classname>common-lib1</classname>.
    </para>
   </sect1>
   <sect1 id="ref.top-level-conf">
    <title>Top-Level <filename>Abuild.conf</filename></title>
    <para>
     When you declare another tree as a tree dependency of your tree,
     you declare your dependency on the other tree by mentioning its
     name in the <property>tree-deps</property> of your tree's root
     <filename>Abuild.conf</filename>.  In order for this dependency
     to work, &abuild; must know where to find the tree.  &Abuild;
     finds items and trees in the same way: it traverses the build
     forest from the top down and creates a table mapping names to
     paths.  If the tree your tree depends on is
     <emphasis>inside</emphasis> of your tree, this poses no problem.
     But what if it is an external tree that is not inside your tree?
     In this instance, you must place the external tree somewhere
     within your overall build area, such as in another subdirectory
     of the parent of your own tree's root.  Then you must create an
     <filename>Abuild.conf</filename> file in that common parent
     directory that knows about the root directories of the two
     trees.  This is illustrated in <xref
     linkend="fig.top-level-conf"/>.
     <figure id="fig.top-level-conf">
      <title>Top-Level <filename>Abuild.conf</filename></title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="top-level-conf.png"/>
       </imageobject>
       <caption>
        <para>
         Tree <filename>A</filename> declares a tree dependency on
         tree <filename>B</filename>.  In order for
         <filename>A</filename> to find <filename>B</filename>, an
         <filename>Abuild.conf</filename> file that points to both
         trees' locations must be created in a common ancestor
         directory.  The ovals show the contents of each directory's
         <filename>Abuild.conf</filename> files.
        </para>
       </caption>
      </mediaobject>
     </figure>
     The tree named <filename>B</filename> has an
     <filename>Abuild.conf</filename> that that declares no tree
     dependencies.  It is a self-contained tree.  However,
     <filename>A</filename>'s <filename>Abuild.conf</filename> file
     mentions <filename>B</filename> <emphasis>by name</emphasis>.
     How does <filename>A</filename> find <filename>B</filename>?
     When you start &abuild;, it walks up the tree to find the
     highest-level <filename>Abuild.conf</filename> (or the highest
     level one not referenced as a child of the next higher
     <filename>Abuild.conf</filename>) and traverses downward from
     there.  In this case, the <filename>Abuild.conf</filename> in
     <filename>A</filename>'s parent directory knows the locations of
     both <filename>A</filename> and <filename>B</filename>.  In this
     way, &abuild; has figured out where to find
     <filename>B</filename> when <filename>A</filename> declares the
     tree dependency.  This is illustrated with a concrete example
     below.
    </para>
   </sect1>
   <sect1 id="ref.example.dependent-build-tree">
    <title>Tree Dependency Example</title>
    <para>
     In order for &abuild; to use multiple trees, it must be able to
     find the roots of all the trees when it traverses the file system
     looking for <filename>Abuild.conf</filename> files.  As described
     earlier, &abuild; locates the root of the forest by looking up
     toward the root of the file system for other
     <filename>Abuild.conf</filename> files that list previous
     <filename>Abuild.conf</filename> directories in their
     <property>child-dirs</property> key.  The parent directory of our
     previous example contains (see <xref
     linkend="ref.example.simple-build-tree"/>) the following
     <filename>Abuild.conf</filename> file:
     <?example general/reference/Abuild.conf?>
     This is an unnamed build item containing only a
     <property>child-dirs</property> key.  The
     <property>child-dirs</property> key lists not only the
     <filename>common</filename> directory, which is the root of the
     <filename>common</filename> tree, but also two other directories:
     <filename>project</filename> and <filename>derived</filename>,
     each of which we will discuss below.  These directories contain
     additional build tree root build items, thus making them known to
     any &abuild; invocation that builds <filename>common</filename>.
     It is also okay to create one build tree underneath another named
     tree.  As with build items, having one tree physically located
     beneath another doesn't have any implications about the dependency
     relationships among the trees.
    </para>
    <para>
     We will examine a new build tree that declares the build tree
     from our previous example as an dependency.  This new tree, which
     we will call the project build tree, can be found at
     <filename>doc/example/general/reference/project</filename>.  The
     first file we examine is the new build tree's root build item's
     <filename>Abuild.conf</filename>:
     <?example general/reference/project/Abuild.conf?>
     This build item configuration file, in addition to having the
     <property>tree-name</property> key (indicating that it is a root
     build item), also has a <property>tree-deps</property> key, whose
     value is the word <filename>common</filename>, which is the name
     of the tree whose items we want to use.  Note that, as with build
     items, &abuild; never requires you to know the location of a
     build tree.
    </para>
    <para>
     Inside the project build tree, the
     <classname>project-lib</classname> build item is defined inside
     the <filename>lib</filename> directory.  It is set up exactly the
     same way as <classname>common-lib1</classname> and the other
     libraries in the <filename>common</filename> tree.  Here is its
     <filename>Abuild.conf</filename>:
     <?example general/reference/project/lib/Abuild.conf?>
     Now look at <classname>project-lib.src</classname>'s
     <filename>Abuild.conf</filename>:
     <?example general/reference/project/lib/src/Abuild.conf?>
     Notice that it declares a dependency on
     <classname>common-lib1</classname>, which is defined in the
     <filename>common</filename> tree.  This works because &abuild;
     automatically makes available to you all the build items in any
     build trees your depends on.
    </para>
    <para>
     This build tree also includes a main program, but we will not go
     through the rest of the files in depth.  You are encouraged to
     study the files on your own.  There are also examples of traits in
     this build tree.  We will return to this build tree during our
     discussion of traits (see <xref linkend="ref.traits"/>).
    </para>
    <para>
     When you declare another build tree as a tree dependency, you
     automatically inherit any tree dependencies that
     <emphasis>that</emphasis> tree declared, so like item
     dependencies, tree dependencies are transitive.  If this were not
     the case, &abuild; would not be able to resolve dependencies
     declared in the other tree if those dependencies were resolved in
     one of <emphasis>its</emphasis> tree dependencies.  To illustrate
     this, we have a third build tree located in
     <filename>doc/example/general/reference/derived</filename>.  This
     build tree is for a second project that is derived from the first
     project.  This build tree declares <filename>project</filename>
     as an tree dependency as you can see in its root
     <filename>Abuild.conf</filename> file:
     <?example general/reference/derived/Abuild.conf?>
     For a diagram of the entire
     <filename>general/reference</filename> collection of build tress,
     see <xref linkend="fig.general-reference"/>.
     <figure id="fig.general-reference">
      <title>Build Trees in <filename>general/reference</filename></title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="general-reference.png"/>
       </imageobject>
       <caption>
        <para>
         The <filename>derived</filename> build tree declares a
         dependency on the <filename>project</filename> build tree.
         The <filename>project</filename> build tree declares a
         dependency on the <filename>common</filename> build tree.
        </para>
       </caption>
      </mediaobject>
     </figure>
     The <filename>derived</filename> build tree contains a
     <classname>derived-main</classname> build item structured
     identically to the C++ program build items we've seen earlier.
     Here at the main program's <filename>Abuild.conf</filename>:
     <?example general/reference/derived/main/src/Abuild.conf?>
     In this file, you can see that
     <classname>derived-main.src</classname> depends on
     <classname>project-lib</classname> from the
     <filename>project</filename> build tree and also
     <classname>common-lib2</classname> which is found in
     <filename>project</filename>'s dependency,
     <filename>common</filename>.  We will return to this build tree
     in the examples at the end of <xref
     linkend="ref.what-to-build"/>.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.help-system">
   <title>Help System</title>
   <para>
    &Abuild; has a built-in help system, introduced in version 1.1,
    that makes it easier for users to get help for &abuild; itself and
    also for available rules, both built-in and user-supplied.  All
    help text that is part of the &abuild; distribution can also be
    seen in <xref linkend="ref.help-files"/>.
   </para>
   <para>
    The starting point to &abuild;'s help system is the command
    <command>abuild --help</command>.  Help is available on a variety
    of general topics including the help system and command
    invocation.  You can also get help on rules.  You can see
    information about what kinds of help is available on rules by
    running <command>abuild --help rules</command>.
   </para>
   <para>
    The rules help facility offers three major capabilities.  By
    running <command>abuild --help rules list</command>, you can see
    the list of compiler toolchains and also the list of available
    rules that you can assign to <varname>RULES</varname> (make) or
    <varname>abuild.rules</varname> (Groovy).  In addition to telling
    you what's offered overall, this will tell you what target types
    the rules apply to, and whether the rules are available to you
    through your dependency chain.  That way, if you need to make use
    of a rule that is provided by some build item that you don't
    depend on, you can know which item you need to add a dependency on
    to gain access to the rule.  Once you know which toolchain or rule
    you want help on, you can use <command>abuild --help rules
    toolchain:<replaceable>toolchain-name</replaceable></command> or
    <command>abuild --help rules
    rule:<replaceable>rule-name</replaceable></command> to get
    available help for that toolchain or rule.
   </para>
   <para>
    Creating help files is very straightforward.  For any toolchain
    support file or rule file, in the same directory, create a text
    file called
    <filename><replaceable>toolchain-name</replaceable>-help.txt</filename>
    or
    <filename><replaceable>rule-name</replaceable>-help.txt</filename>
    as appropriate.  The contents of this help file will be displayed
    to the user when help is requested on that toolchain or rule.
    Lines within the help text that start with
    &ldquo;<literal>#</literal>&rdquo; are ignored, which makes it
    possible for you to include notes to people who might be
    maintaining the help file.  Also, &abuild; normalizes line
    terminators, displaying the help with whatever the platform's
    native line terminator is.
   </para>
   <para>
    We present examples of help files in this manual as we present
    information about adding rules and toolchain support files.  You
    can also run <command>abuild --help helpfiles</command> for a
    reminder about the help file format.  (This text is also available
    in <xref linkend="ref.help.topic.helpfiles"/>.)  To see an example
    of rule help, see <xref
    linkend="ref.example.code-generator.make"/>.  To see an example of
    toolchain help, see <xref
    linkend="ref.example.platforms-and-platform-type-plugins"/>.
   </para>
  </chapter>
  <chapter id="ref.what-to-build">
   <title>Telling &Abuild; What to Build</title>
   <para>
    Up to this point, we have seen only simple invocations of &abuild;
    to build a single item with all of its dependencies.  &Abuild;
    offers several ways of creating sets of build items to build or
    clean.  These are known as <firstterm>build sets</firstterm>.  In
    addition, &abuild;'s list of items to build can be expanded or
    restricted based on <firstterm>traits</firstterm> that are
    assigned to build items.
   </para>
   <sect1 id="ref.targets">
    <title>Build Targets</title>
    <para>
     As defined in <xref linkend="ref.basic-terminology"/>, the term
     <firstterm>target</firstterm> refers to a specific build product.
     In most cases, &abuild; passes any targets specified on the
     command line to the backend build system.  &Abuild; provides
     several standard targets (see <xref
     linkend="ref.command-line"/>).  We have already encountered
     <command>all</command> and <command>clean</command> in earlier
     examples.  It is also possible to add new targets through
     mechanisms that are covered later in the document.  For now, you
     really only need to know a few things about targets:
     <itemizedlist>
      <listitem>
       <para>
        Different targets tell &abuild; to build different things.
       </para>
      </listitem>
      <listitem>
       <para>
        The <command>all</command> target is &abuild;'s default
        target.  When &abuild; builds a build item in order to satisfy
        a dependency, building the <command>all</command> target is
        required to be sufficient to satisfy the needs of items that
        depend on it.  This means that the <command>all</command>
        target is responsible for building all parts of a build item
        that are potentially needed by any of its dependencies.  This
        may seem significant, but it's a detail that takes care of
        itself most of the time.
       </para>
      </listitem>
      <listitem>
       <para>
        With the exception of two <firstterm>special
        targets</firstterm>, &abuild; doesn't do anything itself with
        targets other than pass them onto the backend build tool.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <indexterm>
     <primary>clean</primary>
    </indexterm>
    <indexterm>
     <primary>no-op</primary>
    </indexterm>
    <indexterm>
     <primary>special targets</primary>
    </indexterm>
    <para>
     &Abuild; defines two <firstterm>special targets</firstterm>:
     <command>clean</command> and <command>no-op</command>.  These
     targets are special in two ways: &abuild; does not allow them to
     be combined with other targets, and &abuild; handles them itself
     without passing them to a backend.
    </para>
    <para>
     The <command>clean</command> target is used to remove the
     artifacts that are built by the other targets.  &Abuild;
     implements the <command>clean</command> target by simply removing
     all &abuild;-generated output directories (see <xref
     linkend="ref.output-directories"/>).  When &abuild; processes the
     <command>clean</command> target, it ignores any dependency
     relationships among build items.  Since it ignores dependencies
     and performs the cleanup itself without invoking a backend,
     running the <command>clean</command> target or cleaning multiple
     items using a clean set (described below) is very fast.
    </para>
    <para>
     Note
     that, starting with version 1.0.3, &abuild; cleans
     <emphasis>all</emphasis> build items, not just those with build
     files.  There are several reasons for this:
     <itemizedlist>
      <listitem>
       <para>
        In certain debugging modes, such as interface debugging mode,
        &abuild; may create output directories for items that don't
        build anything.
       </para>
      </listitem>
      <listitem>
       <para>
        You might change a build item from an item that builds
        something to an interface-only build item.  In this case, you
        will want a subsequent clean to remove the no-longer-needed
        output directories.
       </para>
      </listitem>
      <listitem>
       <para>
        Although it is not necessarily recommended, there are some use
        cases in which build items may &ldquo;push&rdquo; files into
        the output directory of an interface-only build item.  Some
        people may choose to implement installers that work this way.
        Having &abuild; clean interface-only build items makes it
        easier to clean up in those cases.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     The <command>no-op</command> target is used primarily for
     debugging build tree problems.  When &abuild; is invoked with the
     <command>no-op</command> target, it goes through all the motions
     of performing a build except that it does not read any
     <filename>Abuild.interface</filename> files or invoke any
     backends.  It does, however, perform full validation of
     <filename>Abuild.conf</filename> files including dependency and
     integrity checking.  This makes <command>abuild no-op</command>,
     especially with a build set (described below), very useful for
     taking a quick look at what items would be built on what
     platforms and in what order.  We make heavy use of the
     <command>no-op</command> target in the examples at the end of
     this chapter so that we can illustrate certain aspects of build
     ordering without being concerned about the actual compilation
     steps.
    </para>
   </sect1>
   <sect1 id="ref.build-sets">
    <title>Build Sets</title>
    <indexterm>
     <primary>build sets</primary>
    </indexterm>
    <para>
     We have already seen that, by default, &abuild; will build all of
     the build items on which the current item depends (directly or
     indirectly) in addition to building the current item.  Now we
     generalize on this concept by introducing <firstterm>build
     sets</firstterm>.  A build set is a collection of build items
     defined by certain criteria.  Build sets can be used both to tell
     &abuild; which items to build and also to tell it which items to
     clean.
     <footnote>
      <para>
       In retrospect, the term <firstterm>build item set</firstterm>
       would probably have been a better name for this.  Just keep in
       mind that build sets can be used for both building and
       cleaning, and that when we use build sets for cleaning, we
       sometimes call them <firstterm>clean sets</firstterm> instead.
      </para>
     </footnote>
     When &abuild; is invoked with no build set specified, its default
     behavior is to build all of the current item's dependencies as
     well as the current item.  Sometimes, you may wish to assume all
     the dependencies are up to date and just build the current build
     item <emphasis>without</emphasis> building any of its
     dependencies.  To do this, you may invoke &abuild; with the
     <option>--no-deps</option> option.  This will generally only work
     if all dependencies are up to date.  Using
     <option>--no-deps</option> is most convenient when you are in the
     midst of the edit/compile/test cycle on a single build item and
     you want to save the time of checking whether a potentially long
     chain of dependencies is already up to date.
     <footnote>
      <para>
       In &abuild; 1.0, this was the default behavior, and the
       <option>--with-deps</option> option was required in order to
       tell &abuild; to build the dependencies.
      </para>
     </footnote>
    </para>
    <para>
     To instruct &abuild; to build all the items in a specific build
     set, run <command>abuild
     --build=<replaceable>set-name</replaceable></command> (or
     <command>abuild -b
     <replaceable>set-name</replaceable></command>).  To instruct
     &abuild; to clean all the items in a specific build set, run
     <command>abuild
     --clean=<replaceable>set-name</replaceable></command> (or
     <command>abuild -c
     <replaceable>set-name</replaceable></command>).  When building a
     build set, &abuild; will also automatically build any items that
     are direct or indirect dependencies of any items in the build
     set.  However, if you specify any explicit targets on the command
     line, &abuild; will not, by default, apply those targets to items
     that it only added to the build set to satisfy dependencies; it
     will build those items with the <command>all</command> target
     instead.  This is important as it enables you to add custom
     targets to a build item without necessarily having those targets
     be defined for build items it depends on.  If you want &abuild;
     to build dependencies with explicitly named targets as well, use
     the <option>--apply-targets-to-deps</option> option.  When
     cleaning with a build set, &abuild; does not ordinarily also
     clean the dependencies of the items in the set.  To apply the
     <command>clean</command> target to all the dependencies as well,
     we also use the <option>--apply-targets-to-deps</option> option.
     This is a bit subtle, so we present several examples below.
    </para>
    <para>
     The following build sets are defined:
     <variablelist>
      <varlistentry>
       <term><option>current</option></term>
       <listitem>
        <para>
         the current build item (<emphasis>i.e.</emphasis>, the build
         item whose <filename>Abuild.conf</filename> is in the current
         directory); &abuild;'s default behavior is identical to
         <option>--build=current</option>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>deps</option></term>
       <listitem>
        <para>
         all direct and indirect dependencies of the current build item
         but not the item itself
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>desc</option></term>
       <listitem>
        <para>
         all build items located at or below the current directory
         (items that are <emphasis>desc</emphasis>endants of the
         current directory)
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>descending</option></term>
       <listitem>
        <para>
         alias for <option>desc</option>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>down</option></term>
       <listitem>
        <para>
         alias for <option>desc</option>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>local</option></term>
       <listitem>
        <para>
         all items in the build tree containing the item in the
         current directory; <emphasis>i.e.</emphasis>, the local build
         tree without any of its trees dependencies, noting that items
         in tree dependencies may, as always, still to be built to
         satisfy item dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>deptrees</option></term>
       <listitem>
        <para>
         all items in the build tree containing the item in the
         current directory as well as all items in any of its tree
         dependencies
         <footnote>
          <para>
           This is what the <optional>all</optional> build set did in
           &abuild; 1.0.  In &abuild; 1.1, <optional>all</optional>
           may be more expansive since &abuild; now actually knows
           about all trees in the forest, not just those referenced by
           the current tree.
          </para>
         </footnote>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>descdeptrees</option></term>
       <listitem>
        <para>
         all build items that are located at or below the current
         directory and are either in the current build tree or one of
         its dependencies&mdash;effectively the intersection between
         <option>desc</option> and <option>deptrees</option>
         <footnote>
          <para>
           This is what the <optional>desc</optional> build set did in
           &abuild; 1.0.  In &abuild; 1.1, <optional>desc</optional>
           includes <emphasis>all</emphasis> build items at or below
           the current directory, but in &abuild; 1.0, &abuild; didn't
           know about those not in the dependency chain of the current
           tree.  This build set is provided so there is an equivalent
           in &abuild; 1.1 to every build set from &abuild; 1.0.
           There are relatively few reasons to ever use it.
          </para>
         </footnote>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>all</option></term>
       <listitem>
        <para>
         all items in all known build trees, including those items in
         trees that are not related to the current build tree
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>name:<replaceable>item-name[,item-name,...]</replaceable></option></term>
       <listitem>
        <para>
         all build items whose names are listed
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>pattern:<replaceable>regular-expression</replaceable></option></term>
       <listitem>
        <para>
         all build items whose names match the given perl-compatible
         regular expression
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Ordinarily, when you invoke <command>abuild clean</command> or
     <command>abuild
     --clean=<replaceable>set-name</replaceable></command>, &abuild;
     will remove all output directories for any affected build items.
     You may also restrict &abuild; to remove only specified output
     directories.  There are two ways to do this.  One way is to run
     <command>abuild clean</command> from inside an output directory.
     In that case, &abuild; will remove all the files in the output
     directory.
     <footnote>
      <para>
       In &abuild; 1.0, &abuild; actually passed the
       <command>clean</command> target to the backend, but &abuild;
       version 1.1 handles this <command>clean</command> invocation
       internally as it does for other <command>clean</command>
       invocations.
      </para>
     </footnote>
     The other way is to use the <option>--clean-platforms</option>
     option, which may be followed by a shell-style regular expression
     that is matched against the platform portion of the output
     directory name.  Examples are shown below.
    </para>
    <sect2 id="ref.build-set.invocation-examples">
     <title>Example Build Set Invocations</title>
     <variablelist>
      <varlistentry>
       <term><command>abuild</command></term>
       <listitem>
        <para>
         builds the <command>all</command> target for all dependencies
         of the current directory's build item and for the current
         directory; equivalent to <command>abuild
         --build=current</command>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --no-deps</command></term>
       <listitem>
        <para>
         builds the current directory without building any of its
         dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <command>abuild check</command>
        (or <command>abuild --build=current check</command>)
       </term>
       <listitem>
        <para>
         builds the <command>check</command> target for the current
         build item and the <command>all</command> target for all of
         its direct and indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --apply-targets-to-deps check</command></term>
       <listitem>
        <para>
         builds the <command>check</command> target for the current
         build item and all of its direct and indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=local check</command></term>
       <listitem>
        <para>
         builds the <command>check</command> target for all build items
         in the local build tree and the <command>all</command> target
         for any dependencies of any local items that may be satisfied
         in other trees
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=deptrees check</command></term>
       <listitem>
        <para>
         builds the <command>check</command> target for all build items
         in the local build tree and all of its tree dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <command>abuild --clean=current</command> (or <command>abuild
        clean</command>)
       </term>
       <listitem>
        <para>
         removes all output directories for the current build item but
         not for any of its dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --clean=desc</command></term>
       <listitem>
        <para>
         removes all output directories for all build items at or below
         the current directory but not any of its dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --clean=all --clean-platforms java
       --clean-platforms '*.ix86.*'</command></term>
       <listitem>
        <para>
         for all build items, removes all
         <filename>abuild-java</filename> output directories and all
         output directories for platforms containing the string
         &ldquo;<filename>.ix86.</filename>&rdquo;
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --clean=current --apply-targets-to-deps</command></term>
       <listitem>
        <para>
         removes all output directories for the current build item and
         everything it depends on; useful when you want to try a
         completely clean build of a particular item
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --apply-targets-to-deps --clean=desc</command></term>
       <listitem>
        <para>
         removes all output directories for all build items at or
         below the current directory and all of their direct or
         indirect dependencies, including those that are not located
         at or below the current directory
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=name:lib1,lib2 xyz</command></term>
       <listitem>
        <para>
         builds the custom <command>xyz</command> target for the
         <classname>lib1</classname> and <classname>lib2</classname>
         build items and the <command>all</command> target for their
         direct or indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=pattern:'.*\.test'</command></term>
       <listitem>
        <para>
         builds the <command>all</command> target for any item whose
         name ends with <literal>.test</literal> and any of those
         items' direct or indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild -b all</command></term>
       <listitem>
        <para>
         builds the <command>all</command> target for all build items
         in all known trees in the forest
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild -c all</command></term>
       <listitem>
        <para>
         removes all output directories in all the build trees in the
         forest
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
   </sect1>
   <sect1 id="ref.build-also">
    <title>Using <property>build-also</property> for Top-level Builds</title>
    <para>
     Starting with &abuild; version 1.0.3, it is possible to list
     other build items in the <property>build-also</property> key of
     any named build item's <filename>Abuild.conf</filename> file.
     Starting with &abuild; version 1.1.4,
     <property>build-also</property> keys can list entire trees and
     also add options to include tree dependencies or other items at
     or below the item's directory.  When &abuild; adds any build item
     to the build set, if that build item has a
     <property>build-also</property> key, then any build items listed
     there are also added to the build set.  The operation of
     expanding initial build set membership using the
     <property>build-also</property> key is applied iteratively until
     no more build items are added.  The principal intended use of
     this feature is to aid with setting up virtual
     &ldquo;top-level&rdquo; build items.  For example, if your system
     consisted of multiple, independent subsystems and you wanted to
     build all of them, you could create a build item that lists the
     main items for each subsystem in a
     <property>build-also</property> key.
    </para>
    <para>
     Arguments to <property>build-also</property> may be as follows:
     <variablelist>
      <varlistentry>
       <term>
        [<literal>item:</literal>]<replaceable>item-name</replaceable> [<option>-desc</option>]
       </term>
       <listitem>
        <para>
         Add <replaceable>item-name</replaceable> to the build set.
         The literal <literal>item:</literal> prefix may be omitted
         for backward compatibility.
        </para>
        <para>
         If the <option>-desc</option> option is given, all items at
         or below the directory containing
         <replaceable>item-name</replaceable> are also added to the
         build set.  This is equivalent to running <command>abuild
         --build=desc</command> from
         <replaceable>item-name</replaceable>'s directory.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <literal>tree:</literal><replaceable>tree-name</replaceable>
        [<option>-desc</option>]
        [<option>-with-tree-deps</option>]
       </term>
       <listitem>
        <para>
         If
         <literal>tree:</literal><replaceable>tree-name</replaceable>
         is specified by itself, all items in the build tree named
         <replaceable>tree-name</replaceable> are added to the build
         set.  This is equivalent to running <command>abuild
         --build=local</command> somewhere in that tree.
        </para>
        <para>
         If <option>-desc</option> appears as an option by itself, all
         items at or below the directory containing the root of
         <replaceable>tree-name</replaceable> are added to the build
         set.  This is equivalent to running <command>abuild
         --build=desc</command> from the directory containing the root
         of the tree.
        </para>
        <para>
         If <option>-with-tree-deps</option> appears as an option by
         itself, all items in all trees that
         <replaceable>tree-name</replaceable> specifies as tree
         dependencies are added to the build set in addition to all
         items in <replaceable>tree-name</replaceable> itself.  This
         is equivalent to running <command>abuild
         --build=deptrees</command> somewhere in that tree.
        </para>
        <para>
         If <option>-with-tree-deps</option> and
         <option>-desc</option> are both specified, the result is to
         add the items that are in the
         <emphasis>intersection</emphasis> of the two options
         specified individually.  In other words, all items that are
         in any dependent tree <emphasis>and</emphasis> are at or
         below the directory containing the root of the tree are added
         to the build set.  This is equivalent to running
         <command>abuild --build=descdeptrees</command> at the root of
         the build tree.  Note that if you want the
         <emphasis>union</emphasis> of <option>-desc</option> and
         <option>-with-tree-deps</option> instead of the intersection,
         you simply have to specify both
         <literal>tree:</literal><replaceable>tree-name</replaceable>
         <option>-desc</option> and
         <literal>tree:</literal><replaceable>tree-name</replaceable>
         <option>-with-tree-deps</option> in the
         <property>build-also</property> key.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     In older versions of &abuild;, the only way to force building of
     one build item to build another item was to declare dependencies
     or tree dependencies.  This had several disadvantages, including
     the following:
     <itemizedlist>
      <listitem>
       <para>
        Adding unnecessary dependencies puts needless constraints on
        build ordering and parallelism.
       </para>
      </listitem>
      <listitem>
       <para>
        Using dependencies for this purpose is clumsy if there are
        multiple target types involved.  It would require you to use a
        platform-specific dependency, which in turn could interfere
        with proper use of platform selectors.
       </para>
      </listitem>
      <listitem>
       <para>
        Otherwise harmless interface variable name clashes or
        assignment issues could cause problems as a result of having
        two interfaces that were supposed to be independent being
        loaded together.
       </para>
      </listitem>
     </itemizedlist>
     Whenever you want building of one build item to result in
     building of another build item and the first item doesn't need to
     use anything from the items it causes to be built, it is
     appropriate to use <property>build-also</property> instead of a
     dependency.
    </para>
   </sect1>
   <sect1 id="ref.rdeps">
    <title>Building Reverse Dependencies</title>
    <indexterm>
     <primary>reverse dependencies</primary>
    </indexterm>
    <indexterm>
     <primary>dependencies</primary>
     <secondary>reverse</secondary>
    </indexterm>
    <para>
     Starting with &abuild; version 1.1, it is possible to use the
     <option>--with-rdeps</option> flag to instruct &abuild; to expand
     the build set by adding all <emphasis>reverse
     dependencies</emphasis> of any build item initially in the build
     set.  When combined with <option>--repeat-expansion</option>,
     this process is applied iteratively so that all forward and
     reverse dependencies of every item in the build set will also be
     in the build set.
     <footnote>
      <para>
       Stated formally, when &abuild; is invoked with both
       <option>--with-rdeps</option> and
       <option>--repeat-expansion</option>, the build set is closed
       with respect to forward and reverse dependencies.
      </para>
     </footnote>
     This can be especially useful if you are changing a widely used
     item and you want to make sure your change didn't break any build
     items that use your item.  For additional details on how the
     build set is constructed, see <xref
     linkend="ref.construction-of-build-sets"/>..
    </para>
   </sect1>
   <sect1 id="ref.traits">
    <title>Traits</title>
    <indexterm>
     <primary>traits</primary>
    </indexterm>
    <para>
     In &abuild;, it is possible to assign certain traits to a build
     item.  Traits are a very powerful feature of &abuild;.  This
     material is somewhat more complicated than anything introduced up
     to this point, so don't worry if you have to read this section
     more than once.
    </para>
    <para>
     Traits are used for two main purposes.  Throughout this material,
     we will refer back to the two purposes.  We will also provide
     clarifying examples later in the chapter.
    </para>
    <para>
     The first purpose of traits is creation of semantically defined
     groups of build items.  In this case, a trait corresponding to
     the grouping criteria would be applied to a build item directly.
     For example, all build items that can be deployed could be
     assigned the <property>deployable</property> trait.
    </para>
    <para>
     A second purpose of traits is to create specific relationships
     among build items.  These relationships may or may not correspond
     to dependencies among build items.  These traits may be applied
     to a build item by itself or in reference to other build items.
     For example, the <property>tester</property> trait may be applied
     to a general system test build item by itself and may be applied
     to every test suite build item with a reference to the specific
     item being tested.
    </para>
    <para>
     Traits are used to assist in the construction of build sets.  In
     particular, you can narrow a build set by removing all items that
     don't have all of a specified list of traits.  You can also
     expand a build set to add any build items that relate to any
     items already in the set by referring to them through all of a
     specified list of traits.  This makes it possible to say things
     like &ldquo;run the <command>deploy</command> target for every
     build item that has the <property>deployable</property>
     trait,&rdquo; or &ldquo;run the <command>test</command> target
     for every item that tests my local build item or anything it
     depends on.&rdquo;
    </para>
    <para>
     Since traits are visible in abuild's <option>--dump-data</option>
     output (see <xref linkend="ref.dump-data"/>), they are available
     to scripts or front ends to &abuild;.  They may also be used for
     purely informational purposes such as specifying the
     classification level of a build item or applying a uniform label
     to all build items that belong to some group.  Trait names are
     subject to the same constraints as build item names: they are
     case-sensitive and may consist of mixed case alphanumeric
     characters, numbers, underscores, dashes, and periods.  Unlike
     with build items, the period does not have any semantic meaning
     when used in a trait name.
    </para>
    <para>
     Starting with &abuild; 1.1.6, a build item that uses either the
     GNU Make backend or the Groovy backend (but not the deprecated
     xml-based ant backend) may also get access to the list of traits
     that are declared in its <filename>Abuild.conf</filename> file.
     For the GNU Make backend, the variable
     <varname>ABUILD_TRAITS</varname> contains a list of traits
     separated by spaces.  For the Groovy backend, the variable
     <varname>abuild.traits</varname> contains a groovy list of traits
     represented as strings.  In both cases, any information about
     referent build items is excluded; only the list of declared
     traits is provided.  Possible uses for this information would
     include having a custom rule check to make sure a given trait is
     specified before providing a particular target, having it give an
     error if a particular trait is not defined, or even having it
     change behavior on the basis of a trait.
    </para>
    <sect2 id="ref.declaring-traits">
     <title>Declaring Traits</title>
     <para>
      Any named build item may include a <property>traits</property>
      key that lists one or more of the traits that are supported in
      its build tree.  The list of traits supported in a build tree is
      given as the value of the <property>supported-traits</property>
      key in the root build item's <filename>Abuild.conf</filename>.
      The list of supported traits is inherited through tree
      dependencies, so any trait declared as valid in any trees your
      tree depends on are also available.  The set of traits that can
      be specified on the command line is the union of all traits
      allowed by all known trees.
     </para>
     <para>
      Traits listed in the <property>traits</property> key can be made
      referent to other build items by listing the other build items
      in an <option>-item</option> option.  For example, the following
      <filename>Abuild.conf</filename> fragment declares that the
      <classname>potato.test</classname> build item is deployable,
      unclassified, and a tester for the
      <classname>potato.lib</classname> and
      <classname>potato.bin</classname> build items:

      <programlisting>this: potato.test
traits: deployable tester -item=potato.lib -item=potato.bin unclassified
</programlisting>
     </para>
    </sect2>
    <sect2 id="ref.specifying-traits">
     <title>Specifying Traits at Build Time</title>
     <para>
      To modify the build set or clean set based on traits, use the
      <option>--only-with-traits</option> and
      <option>--related-by-traits</option> command-line options to
      &abuild;.  These options must be combined with the specification
      of a build set.  They correspond to the two purposes of traits
      discussed above.
     </para>
     <para>
      To build all build items that have all of a specified list of
      traits, run <command>abuild
      --build=<replaceable>set</replaceable> --only-with-traits
      <replaceable>trait</replaceable>[,<replaceable>trait</replaceable>,...]</command>.
      This is particularly useful when semantically grouped build
      items share a common custom target.  For example, if all the
      deployable build items had a special <command>deploy</command>
      target, you could run the <command>deploy</command> target for
      all deployable items in the local build tree with the command

      <programlisting>abuild --build=local --only-with-traits deployable deploy
</programlisting>
      If multiple traits are specified at once, only build items with
      all of the specified traits are included.
     </para>
     <para>
      Once a build set has been constructed, you may want to add
      additional items to the set based on traits.  Specifically, you
      may want to add all items related by a trait to items already in
      the build set.  To expand a build set in this way, run
      <command>abuild --build=<replaceable>set</replaceable>
      --related-by-traits
      <replaceable>trait</replaceable>[,<replaceable>trait</replaceable>,...]</command>
      For example, if you wanted to run the <command>test</command>
      target for all build items that are declared as testers (using
      the <property>tester</property> trait) of your build item or any
      of its dependencies, you could run the command

      <programlisting>abuild --build=current --related-by-traits=tester test
</programlisting>
      As above, if multiple traits are specified at once, only build
      items that are related by all of the specified traits are
      included.  Note that the same trait may be used referent to
      another build item or in isolation.  The
      <option>--related-by-traits</option> option only applies to
      traits used in reference to other build items.  For example, if
      a build item had the <property>tester</property> trait not
      referent to any build item, it would not be picked up by the
      above command.  The <option>--only-with-traits</option> option
      picks up all build items that have the named traits either in
      isolation or referent to other build items.
     </para>
     <para>
      It is also possible to combine these options.  In that case, the
      build set is first restricted using
      <option>--only-with-traits</option> and then expanded using the
      <option>--related-by-traits</option> as shown in examples below.
      The order of the arguments has no effect on this behavior.
     </para>
     <para>
      Ordinarily, when a specific target is specified as an argument
      to &abuild; (as in <command>abuild test</command> or
      <command>abuild deploy</command> rather than just
      <command>abuild</command>), &abuild; runs that target for every
      item initially in the build set (before dependency expansion).
      When the build set is expanded or restricted based on traits,
      any explicitly specified targets are run only for build items
      that have the specified traits.  This is important because it
      enables you to use traits to group build items that define
      specific custom targets.
     </para>
     <para>
      If <option>--related-by-traits</option> and
      <option>--only-with-traits</option> are both specified, any
      explicit targets are applied only to traits named in
      <option>--related-by-traits</option> as the effect of that
      option is applied last.  All other build items are built with
      the <command>all</command> target.  Note that the
      <option>--apply-targets-to-deps</option> option will cause any
      explicit targets to be applied to all build items, as always.
      Later in this chapter, we review the exact rules that &abuild;
      uses to decide which targets to apply to which build items.
     </para>
     <para>
      The <option>--list-traits</option> flag provides information
      about which traits can be used on the command line.  To see more
      detailed information about which traits were made available in
      which build trees, you can examine the output of <command>abuild
      --dump-data</command> (see <xref linkend="ref.dump-data"/>).
     </para>
     <para>
      For more detailed information about how build sets are
      constructed with respect to traits, please see <xref
      linkend="ref.construction-of-build-sets"/>.
     </para>
    </sect2>
    <sect2 id="ref.trait.invocation-examples">
     <title>Example Trait Invocations</title>
     <variablelist>
      <varlistentry>
       <term><command>abuild --build=desc --only-with-traits
       deployable deploy</command></term>
       <listitem>
        <para>
         Run the <command>deploy</command> target for all items at or
         below the current directory that have the
         <property>deployable</property> trait, and run the
         <command>all</command> target for all items that they depend
         on.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=current --related-by-traits
       tester test</command></term>
       <listitem>
        <para>
         Build the current build item and all of its dependencies with
         the <command>all</command> target, and run the
         <command>test</command> target for any build items that
         declared themselves as a tester for any of those items.  Any
         additional dependencies of the testers would also be built
         with the <command>all</command> target.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=local --only-with-traits
       deployable,tester deploy test</command></term>
       <listitem>
        <para>
         Run both the <command>deploy</command> and the
         <command>test</command> targets for any build items in the
         local build tree (the current build item's tree excluding its
         tree dependencies) that have both the
         <property>deployable</property> and the
         <property>tester</property> traits either specified alone or
         in reference to other build items.  Run the
         <command>all</command> target for their dependencies.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=all
       --only-with-traits requires-hw --related-by-traits tester
       hwtest</command></term>
       <listitem>
        <para>
         Run the <command>all</command> target for all items that have
         the <property>requires-hw</property> trait as well as any of
         their dependencies, and run the <command>hwtest</command>
         target for all items that test any of them.  Additional
         dependencies of the testers would also be built with the
         <command>all</command> target.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
   </sect1>
   <sect1 id="ref.target-selection">
    <title>Target Selection</title>
    <para>
     Although we have described how various options affect which
     build items are built with which targets, we summarize that
     information here so that it all appears in one place.  Put
     simply, the default behavior is that &abuild; applies any
     explicitly named targets to all build items that directly match
     the criteria for belonging to the named build set.  Any build
     items that &abuild; is building just to satisfy dependencies are
     built with the <command>all</command> target.  This behavior is
     overridden by specifying
     <option>--apply-targets-to-deps</option>, which causes &abuild;
     to build all build items with the explicit targets.  The exact
     rules are described in the list below.  These rules apply only
     when a build set is specified with <option>--build</option> or
     <option>-b</option>.  There are several mutually exclusive
     cases:
     <orderedlist>
      <listitem>
       <para>
        The <option>--apply-targets-to-deps</option> option was
        specified or the explicit target is <command>no-op</command>.
        In this case, any explicitly named targets are applied to all
        items in the build set.
       </para>
      </listitem>
      <listitem>
       <para>
        The <option>--apply-targets-to-deps</option> option was not
        specified, the target is not <option>no-op</option>, and no
        trait arguments were specified.  In this case, all items that
        were initially added to the build set, along with any build
        items specified by any of their
        <property>build-also</property> keys (with the
        <property>build-also</property> relationship applied
        recursively) are built with any explicitly specified targets.
        Any other build items added to the build set to satisfy
        dependencies are built with the <command>all</command> target.
       </para>
      </listitem>
      <listitem>
       <para>
        The <option>--apply-targets-to-deps</option> option was not
        specified, the target is not <option>no-op</option>,
        <option>--only-with-traits</option> <emphasis>was</emphasis>
        specified, and <option>--related-by-traits</option>
        <emphasis>was not</emphasis> specified.  In this case, all
        items belonging to the original build set (including
        <property>build-also</property> expansion) and having all of
        the named traits are built with the explicit targets.  Other
        items (dependencies of build items with the named traits but
        that do not have the named traits themselves) are built with
        the <command>all</command> target.
       </para>
      </listitem>
      <listitem>
       <para>
        The <option>--apply-targets-to-deps</option> option was not
        specified, the target is not <option>no-op</option>, and
        <option>--related-by-traits</option> <emphasis>was</emphasis>
        specified.  In this case, the build set is first constructed
        normally and then restricted to any items that have all the
        traits specified in the <option>--only-with-traits</option>
        option, if any.  Then it is expanded to include any build
        item related to one of the original build set members by all
        the traits named in <option>--related-by-traits</option>.
        These related items are built with the explicit targets.
        Other items, including additional dependencies of related
        items, are built with the <command>all</command> target.
       </para>
      </listitem>
     </orderedlist>
     For more detailed information on how the build set is
     constructed, please see <xref
     linkend="ref.construction-of-build-sets"/>.
    </para>
   </sect1>
   <sect1 id="ref.general-build-examples">
    <title>Build Set and Trait Examples</title>
    <para>
     Now that we've seen the topics of build sets and traits, we're
     ready to revisit our previous examples.  This time, we will talk
     about how traits are used in a build tree, and we will
     demonstrate the results of running &abuild; with different build
     sets.  We will also make use of the special target
     <command>no-op</command> which can be useful for debugging your
     build trees.
    </para>
    <sect2 id="ref.example.common-code-area">
     <title>Common Code Area</title>
     <para>
      Any arguments to &abuild; that are not command-line options are
      interpreted as targets.  By default, &abuild; uses the
      <command>all</command> target to build each build item in the
      build set.  If targets are named explicitly, for the build items
      to which they apply, they are passed directly to the backend.
      There are two exceptions to this rule: the special targets
      <command>clean</command> and <command>no-op</command> are
      trapped by &abuild; and handled separately without invocation of
      the backend.  We have already seen the <command>clean</command>
      target: it just removes any &abuild; output directories in the
      build item directory.  The special <command>no-op</command>
      target causes &abuild; to go through all the motions of building
      except for actually invoking the backend.  The
      <command>no-op</command> command is useful for seeing what build
      items would be built on what platforms in a particular
      invocation of &abuild;.  It does all the same validation on
      <filename>Abuild.conf</filename> files as a regular build, but
      it doesn't look at <filename>Abuild.interface</filename> files
      or build files (<filename>Abuild.mk</filename>, etc.).
     </para>
     <para>
      We return now to the <filename>reference/common</filename>
      directory to demonstrate both the <command>no-op</command>
      target and some build sets.  From the
      <filename>reference/common</filename> directory, we can run
      <command>abuild --build=local no-op</command> to tell &abuild;
      to run the special <command>no-op</command> target for every
      build item in the local build tree.  Since this tree has no tree
      dependencies, there is no chance that there are any dependencies
      that are satisfied outside of the local build tree.  Running
      this command produces the following results (with the native
      platform again replaced by the string
      <literal>&lt;native&gt;</literal>):
      <?qtest reference-common-no-op.out?>
      Of particular interest here is the order in which &abuild;
      visited the items.  &Abuild; makes no specific commitments about
      the order in which items will be built except that no item is
      ever built before its dependencies are built.
      <footnote>
       <para>
        In fact, when &abuild; creates a build order, it starts with a
        lexically sorted list of build trees and re-orders it as
        needed so that trees appear in dependency order.  Then, within
        each tree, it does the same with items.  The effect is that
        items build by tree with most referenced trees building
        earlier and, with each tree, most referenced items building
        earlier.  Ties are resolved by lexical ordering.  That said,
        the exact order of build items, other than that dependencies
        are built before items that depend on them, should be
        considered an implementation detail and not relied upon.
        Also, keep in mind that, in a multithreaded build, the order
        is not deterministic, other than that no item's build is
        started before all its dependencies' builds have completed.
       </para>
      </footnote>
      Since <classname>common-lib2.src</classname> depends on
      <classname>common-lib3.src</classname> (indirectly through its
      dependency on <classname>common-lib3</classname>), &abuild;
      automatically builds <classname>common-lib3.src</classname>
      before it builds <classname>common-lib2.src</classname>.  On the
      other hand, since <classname>common-lib2.test</classname> has no
      dependency on <classname>common-lib3.test</classname>, no
      specific ordering is necessary in that case.  If you were to run
      <command>abuild --clean=local</command> from this directory, you
      would not observe the same ordering of build items since
      &abuild; does not pay any attention to dependencies when it is
      running the clean target, as shown:
      <?qtest reference-common-clean-local.out?>
      Note also that only the build items that have
      <filename>Abuild.mk</filename> files are cleaned.  &Abuild;
      knows that there is nothing to build in items without
      <filename>Abuild.mk</filename> files and skips them when it is
      building or cleaning multiple items.
     </para>
     <para>
      If you are following along, then go to the
      <filename>reference/common</filename> directory and run
      <command>abuild --build=desc check</command>.  This will build
      and run the test suites for all build items at or below that
      directory, which in this case, is the same collection of build
      items as the <option>local</option> build set.
      <footnote>
       <para>
        The test suites in this example are implemented with <ulink
        url="http://qtest.qbilt.org">QTest</ulink>, which therefore
        must be installed for you to run them.  See <xref
        linkend="ref.test-integration"/>.
       </para>
      </footnote>
      This produces the following output, again with some
      system-specific strings replaced with generic values:
      <?qtest reference-common-check.out?>
      This example includes the output of
      <application>qtest</application> test suites.
      <application>QTest</application> is a simple and robust
      automated test framework that is integrated with &abuild; and
      used for &abuild;'s own test suite.  For information, see <xref
      linkend="ref.qtest"/>.
     </para>
     <para>
      By default, when &abuild; builds multiple build items using a
      build set, it will stop after the first build failure.
      Sometimes, particularly when building a large build tree, you
      may want &abuild; to try to build as many build items as it can,
      continuing on failure.  In this case, you may pass the
      <option>-k</option> option to &abuild;.  When run with the
      <option>-k</option> option, &abuild; will continue building
      other items after one item fails.  It will also exit with an
      abnormal exit status after it builds everything that it can, and
      it will provide a summary of what failed.  When run with
      <option>-k</option>, &abuild; also passes the corresponding
      flags to the backends so that they will try to build as much as
      they can without stopping on the first error.  Both the
      <application>make</application> and
      <application>Groovy</application> backends behave similarly to
      &abuild;: they will keep going on failure, skip any targets that
      depend on failed targets, and exit abnormally if any failures
      are detected.
     </para>
     <para>
      Ordinarily, if one build item fails, &abuild; will not attempt
      to build any other items that depend on the failed item even
      when run with <option>-k</option>.  If you specify the
      <option>--no-dep-failures</option> option along with
      <option>-k</option>, then &abuild; will not only continue after
      the first failure but will also attempt to build items even when
      one or more of their dependencies have failed.  Use of this
      option may result in cascading errors since the build of one
      item is likely to fail as a result of failures in its
      dependencies.  There are, however, several cases in which this
      option may still be useful.  For example, if building a large
      build tree with known problems in it, it may be useful to first
      tell &abuild; to build everything it possibly can.  Then you can
      go back and try to clean up the error conditions without having
      to wait for the compilation of files that would have been
      buildable before.  Another case in which this option may be
      useful is when running test suites: in many cases, we may wish
      to attempt to run test suites for items even if some of the test
      suites of their dependencies have failed.  Essentially, running
      <option>-k --no-dep-failures</option> allows &abuild; to attempt
      to build everything that the backends will allow it to build.
     </para>
    </sect2>
    <sect2 id="ref.example.project-code-area">
     <title>Tree Dependency Example: Project Code Area</title>
     <para>
      Returning to the project area, we demonstrate how item
      dependencies may be satisfied in trees named as tree
      dependencies and the effect this has on the build set.  Under
      <filename>reference/project</filename>, we have just two public
      build items called <classname>project-main</classname> and
      <classname>project-lib</classname>.  The
      <classname>project-lib</classname> build item is structured like
      the libraries in the common area.  The
      <classname>project-main</classname> build item has a
      <filename>src</filename> directory that builds an executable and
      has its own test suite.  We have already seen that
      <filename>reference/project/Abuild.conf</filename> has a
      <property>tree-deps</property> key that lists
      <filename>common</filename> and that items from the
      <filename>project</filename> tree depend on build items from
      <filename>common</filename>.  Specifically,
      <classname>project-lib</classname> depends on
      <classname>common-lib1</classname> and
      <classname>project-main</classname> depends on
      <classname>common-lib2</classname> which in turn depends on
      <classname>common-lib3</classname>.
     </para>
     <para>
      If we go to <filename>reference/project/main/src</filename> and
      run <command>abuild no-op</command>, we see the following
      output:
      <?qtest reference-project-main-no-op.out?>
      Notice here that &abuild; only built the build items whose names
      end with <classname>.src</classname>, that it built the items in
      dependency order, and that it built all the items from
      <filename>common</filename> before any of the items in
      <filename>project</filename>.  We can also run <command>abuild
      --apply-targets-to-deps check</command> to run the
      <command>check</command> target for each of these build items.
      This generates the following output:
      <?qtest reference-project-main-check.out?>
      The presence of the <option>--apply-target-to-deps</option> flag
      caused the <command>check</command> target will be run for our
      dependencies as well as the current build item.  In this case,
      there were no actions performed building the files in
      <filename>common</filename> because they were already built.  If
      individual files had been modified in any of these build items,
      the appropriate targets would have been rebuilt subject to the
      ordinary file-based dependency management performed by make or
      ant.
     </para>
    </sect2>
    <sect2 id="ref.example.trait">
     <title>Trait Example</title>
     <para>
      In our previous example, we saw the <command>check</command>
      target run for each item (that has a build file).  Since the
      items other than <classname>project-main</classname> don't
      contain their own test suites, we see the test suite only for
      <classname>project-main</classname>.  Sometimes we might like to
      run all the test suites of all the build items we depend on,
      even if we don't depend on their test suites directly.  We can
      do this using traits, assuming our build tree has been set up to
      use traits for this purpose.  Recall from earlier that our
      <filename>common</filename> build tree declared the
      <property>tester</property> trait in its root build item's
      <filename>Abuild.conf</filename>.  Here is that file again:
      <?example general/reference/common/Abuild.conf?>
      Also, recall that all the test suites declared themselves as
      testers of the items that they tested.  Here again is
      <classname>common-lib1.test</classname>'s
      <filename>Abuild.conf</filename>, which declares
      <classname>common-lib1.test</classname> to be a tester of
      <classname>common-lib1.src</classname>:
      <?example general/reference/common/lib1/test/Abuild.conf?>
      Given that all of our build items are set up in this way, we can
      instruct &abuild; to run the test suites for everything that we
      depend on.  We do this by running <command>abuild
      --related-by-traits tester check</command>.  This runs the
      <command>check</command> target for every item that declares
      itself as a tester of the current build item or any of its
      dependencies, and the <command>all</command> target for
      everything else, including any additional dependencies of any of
      those test suites.  That command generates the following output:
      <?qtest reference-project-main-trait-test.out?>
      Observe that the previously unbuilt
      <classname>project-lib.test</classname> build item was built
      using the <command>check</command> target by this command, and
      that all the test suites were run.  If your development area has
      good test suites, you are encouraged to use a trait to indicate
      which items they test as we have done here using the
      <property>tester</property> trait.  This enables you to run the
      test suites of items in your dependency chain.  This can give
      you significant assurance that everything you depend on is
      working the way it is supposed to be each time you start a
      development or debugging session.
     </para>
    </sect2>
    <sect2 id="ref.example.rdeps">
     <title>Building Reverse Dependencies</title>
     <para>
      Suppose you have made a modification to a particular build item,
      and you want to make sure the modification doesn't break anyone
      who depends on that build item, whether the dependent item is in
      the modified item's tree or not.  In order to do this, you can
      specify the <option>--with-rdeps</option> flag when building the
      modified item.  This will cause &abuild; to add all of that
      item's reverse dependencies to the build set.  For example, this
      is the output of running <command>abuild --with-rdeps</command>
      in the <filename>general/reference/common/lib2/src</filename>
      directory:
      <?qtest reference-common-lib2-rdeps.out?>
      This includes all direct and indirect reverse dependencies of
      <filename>common-lib2.src</filename>.  If you really want to be
      make sure that everything that is related to this build item by
      dependency in any way is rebuilt, you can use the
      <option>--repeat-expansion</option> option as well.  This will
      repeat the reverse dependency expansion after adding the other
      dependencies of your reverse dependencies, and will continue
      repeating the expansion until no more items are added.  If we
      run <command>abuild --with-rdeps --repeat-expansion
      no-op</command> from here, we get this output:
      <?qtest reference-common-lib2-rdeps-repeated.out?>
      Observe the addition of <filename>common-lib1.test</filename>
      and <filename>project-lib.test</filename>, which are reverse
      dependencies of libraries added to satisfy the dependencies of
      some of <filename>common-lib2</filename>'s dependencies!  If
      that seems confusing, then you probably don't need to worry
      about ever using <option>--repeat-expansion</option>!  Using
      <option>--repeat-expansion</option> with
      <option>--with-rdeps</option> will usually a lot of build items
      to the build set.  In this example, it actually adds every build
      item in the forest to the build set.  The only build items that
      would not be added would be completely independent sets of build
      items that happen to exist in the same forest.
     </para>
    </sect2>
    <sect2 id="ref.example.derived-project">
     <title>Derived Project Example</title>
     <para>
      Finally, we return to our derived project build tree in
      <filename>reference/derived</filename>.  This build tree
      declares <filename>project</filename> as a tree dependency.  As
      pointed out before, although <filename>derived</filename> does
      not declare <filename>common</filename> as a tree dependency, it
      can still use build items in <filename>common</filename> because
      tree dependencies are transitive.  If we run <command>abuild
      --build=desc check</command> from
      <filename>reference/derived</filename>, we will see all our
      dependencies in <filename>common</filename> and
      <filename>project</filename> being built (though all are up to
      date at this point) before our own test suite is run, and we
      will also see that all the items in <filename>common</filename>
      build first, followed by the items in
      <filename>project</filename>, finally followed by the items in
      <filename>derived</filename>.  This is the case even though they
      are not all descendants of the current directory.  This again
      illustrates how &abuild; adds additional items to the build set
      as required to satisfy dependencies:
      <?qtest reference-derived-check.out?>
      We can also observe that we do not see this behavior with the
      special <command>clean</command> target.  Both <command>abuild
      --clean=desc</command> and <command>abuild
      --clean=local</command> produce this output when run from
      <filename>reference/derived</filename>:
      <?qtest reference-derived-clean-local.out?>
     </para>
     <para>
      As another demonstration of the transitive nature of tree
      dependencies, run <command>abuild --clean=all</command> from the
      root of the <filename>derived</filename> build tree.  That
      generates this output:
      <?qtest reference-derived-clean.out?>
      Here are a few things to notice:
      <itemizedlist>
       <listitem>
        <para>
         We clean all build items in <filename>common</filename> and
         <filename>project</filename> as well as in
         <filename>derived</filename>.
        </para>
       </listitem>
       <listitem>
        <para>
         Even build items that don't contain build files are visited.
        </para>
       </listitem>
       <listitem>
        <para>
         Build items are cleaned in an order that completely
         disregards any dependencies that may exist among them.
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect2>
   </sect1>
  </chapter>
  <chapter id="ref.test-integration">
   <title>Integration with Automated Test Frameworks</title>
   <para>
    &Abuild; is integrated with two automated test frameworks: QTest,
    and JUnit.  Additional integrations can be performed with plugins
    or build item rules or hooks.
   </para>
   <sect1 id="ref.test-targets">
    <title>Test Targets</title>
    <para>
     &Abuild; defines three built-in targets for running test suites:
     <command>check</command>, <command>test</command>, and
     <command>test-only</command>.  The <command>check</command> and
     <command>test</command> targets are synonyms.  Both targets first
     ensure that a build item is built (by depending on the
     <command>all</command> target) and then run the build item's test
     suites, if any.  The <command>test-only</command> target also
     runs a build item's test suite, but it does not depend on
     <command>all</command>.  This means that it will almost certainly
     fail when run on a clean build tree.  The
     <command>test-only</command> target is useful for times when you
     <emphasis>know</emphasis> that a build item is already built and
     you want to run the test suite on what is there
     <emphasis>now</emphasis>.  One case in which you might want to do
     this would be if you had just started editing some source files
     and decided you wanted to rerun the test suite on the existing
     executables before rebuilding them.  Another case in which this
     could be useful is if you had just built a build tree and then
     wanted to immediately go back and run all the test suites without
     having to pay the time penalty of checking to make sure each
     build is up to date.  In this case, you could run <command>abuild
     --build=all test-only</command> immediately after the build was
     completed.  Such a usage style might be appropriate for
     autobuilders or other systems that build and test a build tree in
     a controlled environment.
    </para>
   </sect1>
   <sect1 id="ref.qtest">
    <title>Integration with QTest</title>
    <para>
     &Abuild; is integrated with the <ulink
     url="http://qtest.qbilt.org">QTest</ulink> test framework.  The
     QTest framework is a perl-based test framework intended to
     support a <emphasis>design for testability</emphasis> testing
     mentality.  &Abuild;'s own test suite is implemented using QTest.
     When using either the <application>make</application> or the
     <application>Groovy</application> backends, if a directory called
     <filename>qtest</filename> exists, then the
     <command>test</command> and <command>check</command> targets will
     invoke <command>qtest-driver</command> to run qtest-based test
     suites.  If a single file with the <filename>.testcov</filename>
     extension exists in the build item directory, &abuild; will
     invoke <command>qtest-driver</command> so that it can find the
     test coverage file and activate test coverage support.  Note that
     &abuild; runs <command>qtest-driver</command> from the output
     directory, so the coverage output files as well as
     <filename>qtest.log</filename> and
     <filename>qtest-results.xml</filename> will appear in that
     directory.  If you wish to have a qtest-based test suite be
     runnable on multiple platforms simultaneously, it's best to avoid
     creating temporary files in the <filename>qtest</filename>
     directory.  If you wish to use the &abuild; output directory for
     your temporary files, you can retrieve the full path to this
     directory by calling the <function>get_start_dir</function>
     method of the qtest <classname>TestDriver</classname> object.
    </para>
    <para>
     In order to use test coverage, you must add source files to the
     <varname>TC_SRCS</varname> variable in your
     <filename>Abuild.mk</filename> or
     <filename>Abuild.groovy</filename> file.  &Abuild; automatically
     exports this into the environment.  If you wish to specify a
     specific set of tests to run using the <envar>TESTS</envar>
     environment variable, you can pass it to &abuild; on the command
     line as a variable definition (as in <command>abuild check
     TESTS=some-test</command>), and &abuild; will automatically
     export it to the environment for qtest.
    </para>
   </sect1>
   <sect1 id="ref.junit">
    <title>Integration with JUnit</title>
    <para>
     When performing <application>ant</application>-based builds using
     the <application>Groovy</application> framework, if the
     <varname>java.junitTestsuite</varname> property is set to the
     name of a class, then the <command>test</command> and
     <command>check</command> targets will attempt to run a
     JUnit-based test suite.  You can also set
     <varname>java.junitBatchIncludes</varname> to a pattern that
     matches a list of class files, in which case JUnit tests will be
     run from all matching classes.  JUnit is not bundled with
     &abuild;, so it is the responsibility of the build tree
     maintainer to supply the required JUnit JARs to &abuild;.  The
     easiest way to do this is to create a plugin that adds the JUnit
     JARs to <varname>abuild.classpath.external</varname> in a
     <filename>plugin.interface</filename> file.  (For more details on
     plugins, please see <xref linkend="ref.plugins"/>.)  You can also
     copy the JAR file for a suitable version of JUnit into either
     ant's or abuild's <filename>lib</filename> directory, as any JAR
     files in those two locations are automatically added to the
     classpath.
    </para>
   </sect1>
   <sect1 id="ref.custom-test-framework">
    <title>Integration with Custom Test Frameworks</title>
    <para>
     Adding support for your additional test frameworks is
     straightforward and can be done by creating a plugin that adds
     the appropriate code to the appropriate targets.  For make-based
     items, you must make sure that your tests are run by the
     <command>check</command>, <command>test</command>, and
     <command>test-only</command> targets.  You also must ensure that
     your <command>check</command> and <command>test</command> targets
     depend on <command>all</command> and that your
     <command>test-only</command> target does not depend on
     <command>all</command>.  For Groovy-based items, you must make
     sure that your tests are run by the <command>test-only</command>
     target, and &abuild; will take care of making sure it is run by
     the <command>test</command> and <command>check</command> targets.
     For details on plugins, see <xref linkend="ref.plugins"/>.  For
     details on writing make rules, see <xref
     linkend="ref.guidelines-for-make-rule-authors"/>.  For details on
     writing rules for the Groovy backend, see <xref
     linkend="ref.guidelines-for-groovy-target-authors"/>.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.backing-areas">
   <!--  This chapter must precede the interface flags chapter     -->
   <!--  since the private interface flags examples are in a tree  -->
   <!--  with a backing area.                                      -->
   <title>Backing Areas</title>
   <para>
    <indexterm>
     <primary>backing area</primary>
    </indexterm>
    In a large development environment, it is very common for a
    developer to have a local work area that contains only the parts
    of the system that he or she is actually working on.  Any
    additional parts of the software that are required in order to
    satisfy dependencies would be resolved through some kind of
    outside, read-only reference area.  &Abuild; provides this
    functionality through the use of <firstterm>backing
    areas</firstterm>.
   </para>
   <sect1 id="ref.backing-areas.setup">
    <title>Setting Up Backing Areas</title>
    <para>
     Backing areas operate at the build forest level.  Any build
     forest can act as a backing area.  If &abuild; needs to reference
     a build item that is found in the local forest, it will use that
     copy of the build item.  If &abuild; can't find an item in the
     local forest, it will use the backing area to resolve that build
     item.  Since &abuild; never attempts to build or otherwise modify
     an item in a backing area, backing areas must always be fully
     built on all platforms for which they will be used as backing
     areas.  (For additional details on platforms, please see <xref
     linkend="ref.platforms"/>.)
    </para>
    <para>
     A build forest may declare multiple backing areas.  To specify
     the location of your backing areas, create a file called
     <filename>Abuild.backing</filename> in the root directory of your
     build forest.  As with the <filename>Abuild.conf</filename> file,
     the <filename>Abuild.backing</filename> file consists of
     colon-separated key/value pairs.  The
     <property>backing-areas</property> key is followed by a
     space-separated list of paths to your backing areas.  Backing
     area paths may be specified as either absolute or relative paths.
     The path you declare as a backing area may point anywhere into
     the forest that you wish to use as the backing area.  It doesn't
     have to point to the root of the forest, and it doesn't have to
     point to a place in the forest that corresponds to the root of
     your forest.
    </para>
    <para>
     When one forest declares another forest as a backing area, we say
     that the forest <firstterm>backs to</firstterm> its backing area.
     Creation and maintenance of backing areas is generally a function
     performed by the people who are in charge of maintaining the
     overall software baselines.  Most developers will just set up
     their backing areas according to whatever instructions they are
     given.  Having an external tool to create your
     <filename>Abuild.backing</filename> file is also reasonable.
     Note that <filename>Abuild.backing</filename> files should not
     generally be controlled in a version control system since they
     are a property of the developer's work area rather than of the
     software baseline.  If they are controlled, they should generally
     not be visible outside of the developer's work area.
    </para>
    <note>
     <para>
      Changing backing area configuration should generally be followed
      by a clean build.  This is also true when a build item is
      removed from a local build tree and therefore causes the build
      item with that name to resolve to the copy in backing area.  The
      reason is that changing the location of a build item changes the
      actual files on which the build target depends.  If those
      dependencies are older than the last build time, even if they
      were newer than the files they replaced,
      <application>make</application> and
      <application>ant</application> will not notice because they use
      modification time-based dependencies.  In other words, any
      operation that can replace one file with another file in such a
      way that the new file is not more recent than the last build
      should be followed by a clean build.
     </para>
    </note>
   </sect1>
   <sect1 id="ref.backing-areas.resolving-items">
    <title>Resolving Build Items to Backing Areas</title>
    <para>
     In this section, we will discuss backing areas from a
     functionality standpoint.  This section presents a somewhat
     simplified view of how backing areas actually work, but it is
     good enough to cover the normal cases.  To understand the exact
     mechanism that &abuild; uses to handle backing areas with enough
     detail to fully understand the subtleties of how they work,
     please see <xref linkend="ref.traversal-details"/>.
    </para>
    <para>
     The purpose of a backing area is to enable a developer to create
     a partially populated build tree and to fall back to a more
     complete area for build items that are omitted in the local build
     tree.  A build forest may have any number of backing areas, and
     backing areas may in turn have additional backing areas.  There
     are a few restrictions, however.  As with item and tree
     dependencies, there may be no cycles among backing area
     relationships.  Additionally, if two unrelated backing areas
     supply items or trees with the same name, this creates an
     ambiguity, which &abuild; will consider an error.
     <footnote>
      <para>
       What do we mean by &ldquo;unrelated&rdquo; backing areas?  If
       your build forest declares <filename>A</filename> and
       <filename>B</filename> to be backing areas and
       <filename>A</filename> backs to <filename>B</filename>,
       &abuild; will notice this relationship and will ignore your
       mention of <filename>B</filename> as a backing area.  You will
       still inherit items from <filename>B</filename>, but you will
       do so through <filename>A</filename> instead of getting them
       directly.  &Abuild; doesn't consider this to be an error or
       even a warning since, for all you know, <filename>A</filename>
       and <filename>B</filename> may be independent, and
       <filename>A</filename> may be using <filename>B</filename> on a
       temporary or experimental basis.  However, if you really want
       to know, &abuild; will tell you that it is ignoring
       <filename>B</filename> when you run it with the
       <option>--verbose</option> flag.
      </para>
     </footnote>
    </para>
    <para>
     When you have one or more backing areas, any reference to a build
     item or build tree that is not found locally can be resolved in
     the backing area.  What &abuild; essentially does is to maintain
     a list of available item and tree names, which it internally maps
     to locations in the file system.  When you using a backing area,
     &abuild; uses the backing areas' lookup tables in addition to
     that from your own forest to resolve items and trees.
     <footnote>
      <para>
       The actual implementation differs from this description, but
       the effect is the same.  For the real story, see <xref
       linkend="ref.traversal-details"/>.
      </para>
     </footnote>
     When a build item or tree is defined in a backing area and is
     also defined in your local forest, your local forest is said to
     <emphasis>shadow</emphasis> the item or tree.  This is not an
     error.  It is a normal case that happens when you are using
     backing areas.  In most cases, your build forest will contain
     items that either exist now in the backing area or will exist
     there at some future point.  This is because the backing area
     generally represents a more stable version of whatever project
     you are working on.
    </para>
    <para>
     Note that since &abuild; refers to build items and trees by name
     and not by path, there are no restrictions about the location of
     build items in the local forest relative to where they appear in
     the backing area.  This makes it possible for you to reorganize
     the build items or even the build trees in your local area
     without having to simultaneously change the backing area.  There
     is only way in which use of backing areas affects how &abuild;
     resolves paths: if a directory named in a
     <property>child-dirs</property> key in some
     <filename>Abuild.conf</filename> does not exist and the forest
     has a backing area, &abuild; will ignore the non-existence of the
     child directory.  (If you run with <option>--verbose</option>, it
     will mention that it is ignoring the directory, but otherwise,
     you won't be bothered with this detail.)  This enables you to
     create sparsely populated build items without having to edit
     <filename>Abuild.conf</filename> files of the parents of the
     directories you have chosen to omit.
    </para>
    <para>
     If this seems confusing, the best way to think about it is in
     terms of how this all interacts with a version control system.
     Typically, there is some master copy of the source code of a
     project in a version control system.  There may be some stable
     trunk or branch in the version control system that is expected to
     be self-contained and operational.  This is what would typically
     be checked out into a forest that would be fully built and used
     by others as a backing area.  Then, individual developers would
     just check out the pieces of the system that they are working on,
     and set their backing area to point to the stable area.  Since
     their checkouts would be sparse, there may be child directories
     that don't exist, but it wouldn't matter; once they check in
     their changes and the stable area from which the backing area is
     created gets updated, everything should be normal.
    </para>
    <para>
     One side effect of this is that if you remove the directory
     containing a build item or tree from your local forest while
     using a backing area that still contains that item or tree, the
     thing you removed doesn't really go away from &abuild;'s
     perspective.  Instead, it just &ldquo;moves&rdquo; from the local
     build tree to the backing area.  If it is actually your intention
     to <emphasis>remove</emphasis> the build item so that its name is
     not known to other build items in your build tree, you can do
     this by adding the name of the build item to the
     <property>deleted-items</property> key or the build tree to the
     <property>deleted-trees</property> key of your
     <filename>Abuild.backing</filename> file.  This effectively
     blocks &abuild; from resolving items or trees with those names
     from the backing area.  Most users will probably never use this
     feature and don't even need to know it exists, but it can be very
     useful under certain circumstances.  When you tell &abuild; to
     ignore a tree in this way, it actually blocks &abuild; from
     seeing any items defined in the deleted tree.  If you wanted to,
     you could create a new tree locally with the same name as the
     deleted tree, and the new tree and the old tree would be
     completely separate from each other.  We present an example that
     illustrates the use of the <property>deleted-item</property> key
     in <xref linkend="ref.example.deleted-item"/>.
    </para>
   </sect1>
   <sect1 id="ref.integrity-checks">
    <title>Integrity Checks</title>
    <para>
     In plain English, &abuild; guarantees that if
     <classname>A</classname> depends on <classname>B</classname> and
     <classname>B</classname> depends on <classname>C</classname>,
     <classname>A</classname> and <classname>B</classname> see the
     same copy of <classname>C</classname>.  To be more precise,
     &abuild; checks to make sure that no build item in a backing area
     references as a dependency or plugin an item that is shadowed in
     the local forest.  (Plugins are covered in <xref
     linkend="ref.plugins"/>.)
    </para>
    <para>
     We illustrate this in <xref linkend="fig.shadowed-dependency"/>.
     Suppose that build items <classname>A</classname>,
     <classname>B</classname>, and <classname>C</classname> are
     defined in build tree <filename>T2</filename> and that
     <classname>A</classname> depends on <classname>B</classname> and
     <classname>B</classname> depends on <classname>C</classname>.
     Now suppose you have a local build tree called
     <filename>T1</filename> that has <filename>T2</filename> as its
     backing area, and that you have build items
     <classname>A</classname> and <classname>C</classname> copied
     locally into <filename>T1</filename>, but that
     <classname>B</classname> is resolved in the backing area.
     <figure id="fig.shadowed-dependency">
      <title>Shadowed Dependency</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="shadowed-dependency.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>A</classname> in <filename>/T1</filename> sees
         <classname>B</classname> in <filename>/T2</filename> and
         <classname>C</classname> in <filename>/T1</filename>, but
         <classname>B</classname> in <filename>/T2</filename> sees
         <classname>C</classname> in <filename>/T2</filename>.  This
         means <classname>A</classname> in <filename>/T1</filename>
         builds with two different copies of <classname>C</classname>.
        </para>
       </caption>
      </mediaobject>
     </figure>
     If you were to attempt to build <classname>A</classname>,
     <classname>A</classname> would refer to files in
     <classname>B</classname>, which comes from a backing area.
     <classname>B</classname> would therefore already be built, and it
     would have been built with the copy of <classname>C</classname>
     from the backing area.  <classname>A</classname>, on the other
     hand, would see <classname>C</classname> in the local build tree.
     That means that <classname>A</classname> is indirectly using two
     different copies of <classname>C</classname>.  Depending on what
     changes were made to <classname>C</classname> in the local build
     tree, this would likely cause the build of
     <classname>A</classname> to be unreproducible at best and
     completely broken at worst.  The situation of
     <classname>B</classname> coming from a backing area and depending
     on <classname>C</classname>, which is shadowed locally, is what
     we mean when we say that <classname>B</classname> has shadowed
     dependencies.  If you attempt to build in this situation,
     &abuild; will provide a detailed error message telling you which
     build items are shadowed and which other build items depend on
     them.  One way to resolve this would be to copy the shadowed
     build items into your local build tree.  In this case, that would
     mean copying <classname>B</classname> into
     <filename>T1</filename>.  Another way to resolve it would be to
     remove <classname>C</classname> from your local area and allow
     that to be resolved in the backing area as well.  This solution
     would obviously only be suitable if you were not working on
     <classname>C</classname> anymore.
    </para>
   </sect1>
   <sect1 id="ref.example.task-branch">
    <title>Task Branch Example</title>
    <para>
     In this example, we'll demonstrate a task branch.  Suppose our
     task branch makes changes to <filename>project</filename> but not
     to <filename>common</filename> or <filename>derived</filename>.
     We can set up a new build forest in which to do our work.  We
     would populate this build forest with whatever parts of
     <filename>project</filename> we wanted to modify.  We have set up
     this forest in <filename>doc/example/general/task</filename>.
     Additionally, we have set this forest's backing area to
     <filename>../reference</filename> so that it would resolve any
     missing build items or trees to that location:
     <?example general/task/Abuild.backing?>
     Note that, although we used a relative path for our backing area
     in this example, we would ordinarily set our backing area to an
     absolute path.  We use a relative path here only so that the
     examples can remain independent of the location of
     <filename>doc/example</filename>.  Since we are not making
     modifications to any build items in <filename>common</filename>
     or <filename>derived</filename>, we don't have to include those
     build trees in our task branch.  Note that our forest root
     <filename>Abuild.conf</filename> still lists
     <filename>common</filename> and <filename>derived</filename> as
     children, since it is just a copy of the root
     <filename>Abuild.conf</filename> from reference:
     <?example general/task/Abuild.conf?>
     Since this forest has a backing area, &abuild; ignores the fact
     that the <filename>common</filename> and
     <filename>derived</filename> directories do not exist.  For a
     diagram of the task branch build trees, see <xref
     linkend="fig.general-task"/>.
     <figure id="fig.general-task">
      <title>Build Trees in <filename>general/task</filename></title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="general-task.png"/>
       </imageobject>
       <caption>
        <para>
         The <filename>derived</filename> build tree declares a tree
         dependency on the <filename>project</filename> build tree.
         The <filename>project</filename> build tree declares a tree
         dependency on the <filename>common</filename> build tree.
         Since the <filename>common</filename> and
         <filename>derived</filename> build trees are not shadowed in
         the <filename>task</filename> branch, those trees are
         resolved in the backing area, <filename>reference</filename>,
         instead.
        </para>
       </caption>
      </mediaobject>
     </figure>
     As always, for this example to work properly, our
     backing area must be fully built.  If you are following along, to
     make sure this is the case, you should run <command>abuild
     --build=all</command> in <filename>reference/derived</filename>.
     Next run <command>abuild --build=deptrees no-op</command> in
     <filename>task/project</filename>.  This generates the following
     output:
     <?qtest task-project-no-op.out?>
     This includes only items in our task branch.  No items in our
     backing area are included because &abuild; never attempts to
     build or modify build items in backing areas.
    </para>
    <para>
     If you study <filename>include/ProjectLib.hpp</filename> and
     <filename>src/ProjectLib.cpp</filename> in
     <filename>task/project/lib</filename> in comparison to their
     counterparts in <filename>reference/project/lib</filename>, you'll
     notice that the only change we made in this task branch is the
     addition of an optional parameter to
     <classname>ProjectLib</classname>'s constructor.  We also updated the
     test suite to pass a different argument to
     <classname>ProjectLib</classname>.  This new value comes from a new
     build item we added: <classname>project-lib.extra</classname>.  To
     add the new build item, we created
     <filename>task/project/lib/extra/Abuild.conf</filename>:
     and also added the <filename>extra</filename> directory in
     <filename>task/project/lib/Abuild.conf</filename>:
     <?example general/task/project/lib/extra/Abuild.conf?>
     <?example general/task/project/lib/Abuild.conf?>
     We didn't modify anything under
     <filename>task/project/main</filename> at all, but we included it
     in our task branch so we could run its test suite.  Remember that
     &abuild; won't try to build the copy of
     <classname>project-main</classname> there, and even if it did,
     that copy of <classname>project-main</classname> would not see
     our local copy of <classname>project-lib</classname>: it would
     see the copy in its own local build tree, which we have shadowed.
     This is an example of a shadowed dependency as described in <xref
     linkend="ref.integrity-checks"/>.  This is the output we see when
     running <command>abuild --build=deptrees check</command> from
     <filename>task/project</filename>:
     <?qtest task-project-check.out?>
     As with the <command>no-op</command> build, we only see output
     relating to local build items, not to build items in our backing
     areas as they are assumed to be already built.
    </para>
   </sect1>
   <sect1 id="ref.example.deleted-item">
    <title>Deleted Build Item</title>
    <para>
     Here we present a new forest located under
     <filename>doc/example/general/user</filename>.  This forest backs
     to the <filename>task</filename> forest from the previous
     example.  We will use this forest to illustrate the use of the
     <property>deleted-item</property> key in the
     <filename>Abuild.backing</filename>.
    </para>
    <para>
     Suppose we have a user who is working on changes that are related
     in some way to the task branch.  We want to create a user branch
     that backs to the task branch.  Our user branch contains all
     three trees: <filename>common</filename>,
     <filename>project</filename>, and <filename>derived</filename>.
     We will ignore <filename>derived</filename> for the moment and
     focus only <filename>common</filename> and
     <filename>project</filename>.  For a diagram of the user build
     trees, see <xref linkend="fig.general-user"/>.
     <figure id="fig.general-user">
      <title>Build Trees in <filename>general/user</filename></title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="general-user.png"/>
       </imageobject>
       <caption>
        <para>
         The <filename>user</filename> forest backs to the
         <filename>task</filename> forest.  All trees are present, so
         they all resolve locally.
        </para>
       </caption>
      </mediaobject>
     </figure>
    </para>
    <para>
     Observe that <filename>common</filename> contains only the
     <filename>lib1</filename> directory and that
     <filename>project</filename> contains only the
     <filename>lib</filename> directory.  We make a gratuitous change
     to a source file in <classname>common-lib1.src</classname> just
     as another example of shadowing a build item from our backing
     area.
    </para>
    <para>
     In <filename>project</filename>, we have made changes to
     <filename>project-lib</filename> to make use of private
     interfaces, which we discuss in <xref
     linkend="ref.interface-flags"/> and will ignore for the moment.
     We have also deleted the new build item
     <classname>project-lib.extra</classname> that we added in the
     task branch.  To delete the build item, we removed the
     <filename>extra</filename> directory from
     <filename>project/lib</filename> and from the
     <property>child-dirs</property> key in
     <filename>project/lib/Abuild.conf</filename>:
     <?example general/user/project/lib/Abuild.conf?>
     That in itself was not sufficient since, even though the
     <filename>extra</filename> directory is no longer present in the
     <property>child-dirs</property> key of
     <classname>project-lib</classname>'s
     <filename>Abuild.conf</filename>, we would just inherit
     <classname>project-lib.extra</classname> from our backing area.
     To really delete the build item, we also had to add a
     <property>deleted-item</property> key in
     <filename>user/Abuild.backing</filename>:
     <?example general/user/Abuild.backing?>
     This has effectively prevented &abuild; from looking for
     <classname>project-lib.extra</classname> in the backing area.  If
     any build item in the local tree references
     <classname>project-lib.extra</classname>, an error will be
     reported because &abuild; now considers that to be an unknown
     build item.
    </para>
    <para>
     Although we don't present any examples of using
     <property>deleted-tree</property>, it works in a very similar
     fashion.  Ordinarily, any build tree you do not have locally will
     be inherited from the backing area.  If your intention is to
     change the code so that it no longer uses a particular tree, and
     you want to make sure that that tree is not available at all in
     your local area, you can delete it using
     <property>deleted-tree</property>.  However, if you simply remove
     it from all your <property>tree-deps</property> directives, there
     is no risk of your using its items by accident.  As such, most
     people will probably never need to use the
     <property>deleted-tree</property> feature.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.read-only-paths">
   <title>Explicit Read-Only and Read/Write Paths</title>
   <para>
    One of the significant defining features of &abuild; is that it
    will automatically build items to satisfy dependencies.  Most of
    the time, this is useful and helpful behavior, but there are
    certain cases in which it can actually get in the way.  For
    example, you may have one build tree that provides common code,
    which you may want to build manually in advance of building
    everything else.  Then you may want to kick off parallel builds of
    separate dependent trees on multiple platforms simultaneously and
    be able to be sure that they won't step on each other by all
    trying to build the shared tree at the same time.  In cases like
    this, you might want to tell &abuild; to assume the shared tree is
    built and to treat it as read-only.
   </para>
   <para>
    To support this and similar scenarios, &abuild; allows you to
    explicitly designate specific paths as read-only on the command
    line.
    <footnote>
     <para>
      In &abuild; 1.0, we had a different mechanism for addressing
      this need: read-only externals.  There were several problems
      with read-only externals, though: they were ambiguous since
      whether a tree was read-only or not would depend on how &abuild;
      came to know about it through other trees, they were not
      granular as you could only control this at the tree level, and
      they were inflexible: you might set them up to address the needs
      of a particular build, and then have them get in the way of
      other builds.  When externals were replaced by named trees and
      tree dependencies, we dropped support for read-only externals
      and replaced them with read-only paths, which are much more
      flexible and which make the decision a function of the specific
      build rather than of the build trees, as it always should have
      been.
     </para>
    </footnote>
    Most of the time, specifying a read-only path is as simple as
    invoking &abuild; with the
    <option>--ro-path=<replaceable>directory</replaceable></option>
    option for the directory you want to treat as read-only.  There
    may cases, however, where you want a much more specific degree of
    control.  When you need it, it's there.  Here we describe the
    exact behavior of the <option>--ro-path</option> and
    <option>--rw-path</option> options.
    <itemizedlist>
     <listitem>
      <para>
       Both <option>--ro-path=<replaceable>dir</replaceable></option>
       and <option>--rw-path=<replaceable>dir</replaceable></option>
       may appear multiple times.
      </para>
     </listitem>
     <listitem>
      <para>
       If neither option appears, all build items are writable.
       (Except those in backing areas; backing areas are always
       read-only.)
      </para>
     </listitem>
     <listitem>
      <para>
       If only <option>--ro-path</option> appears, build items are
       writable by default, and only those located under any specified
       read-only path are read-only.
      </para>
     </listitem>
     <listitem>
      <para>
       If only <option>--rw-path</option> appears, build items are
       <emphasis>read-only</emphasis> by default, and only build items
       located under a directory specified with
       <option>--rw-path</option> are writable.
      </para>
     </listitem>
     <listitem>
      <para>
       If both <option>--ro-path</option> and
       <option>--rw-path</option> are specified:
       <itemizedlist>
        <listitem>
         <para>
          Either every <option>--ro-path</option> must be a path under
          some <option>--rw-path</option>, in which case build items
          are read-only by default,
         </para>
        </listitem>
        <listitem>
         <para>
          or every <option>--rw-path</option> must be path under some
          <option>--ro-path</option>, in which case build items are
          writable by default.
         </para>
        </listitem>
       </itemizedlist>
       In this case, the writability of items is determined by the
       lowest directory actually specified (start with the item's
       directory and walk up the file system until you find a
       directory explicitly mentioned), using the default of none is
       found.
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    This seems more complicated than it really is, so let's look at a
    simple example.  Suppose you have the directory structure
    <filename>a/b/c/d</filename>.  If you specified
    <option>--ro-path=a/b --rw-path=a/b/c</option>, all read/write
    paths are under some read only path, so build items are writable
    by default.  Everything under <filename>a/b/c</filename> is
    writable, and everything under <filename>a/b</filename> that is
    <emphasis>not</emphasis> under <filename>a/b/c</filename> is
    read-only.  Use of <option>--ro-path</option> and
    <option>--rw-path</option> together basically lets you make a
    particular area read only and then give exceptions.  Likewise, you
    can make everything read-only by default, and then make only a
    specific directory read-write, again make exceptions to that.
   </para>
   <para>
    These rules make it possible to unambiguously create any
    combination of read-only/writable build items without having the
    order of the arguments matter.  If you're sufficiently determined,
    you can use this mechanism to precisely control which items should
    be read-only and which should be writable.
   </para>
   <para>
    Paths specified may be absolute or relative.  Relative paths are
    resolved relative to the starting directory of abuild.  They are
    converted internally to absolute paths after any <option>-C
    <replaceable>start-directory</replaceable></option> option is
    evaluated.
   </para>
  </chapter>
  <chapter id="ref.command-line">
   <title>Command-Line Reference</title>
   <para>
    This chapter presents full detail about how to invoke &abuild;
    from the command line.  Some of functionality described here is
    explained in the chapters of <xref linkend="ref.part3"/>.
   </para>
   <sect1 id="ref.command-line-arguments">
    <title>Basic Invocation</title>
    <para>
     When running &abuild;, the basic invocation syntax is as follows:

     <programlisting><command>abuild [options] [definitions] [targets]</command>
</programlisting>
     Options, definitions, and targets may appear in any order.  Any
     argument that starts with a dash
     (&ldquo;<option>-</option>&rdquo;) is treated as an option.  Any
     option of the form <option>VAR=value</option> is considered to be
     a definition.  Anything else is considered to be a target.
    </para>
   </sect1>
   <sect1 id="ref.command-line.definitions">
    <title>Variable Definitions</title>
    <para>
     Arguments of the form <option>VAR=value</option> are variable or
     parameter definitions.  Variables defined in this way are made
     available to all backends.  These can be used to override the
     value of interface variables or variables set in backend build
     files.
    </para>
    <para>
     For the <application>make</application> backend, these variable
     definitions are just passed along to make.
    </para>
    <para>
     For the <application>Groovy</application> backend, these
     variables are stored in a manner such that
     <function>abuild.resolve</function> will give them precedence
     over normal parameters or interface variables.  They are also
     defined as properties in the ant project.
    </para>
    <para>
     For the deprecated xml-based ant framework, these definitions are
     made available as ant properties that are defined prior to
     reading any generated or user-provided files.
    </para>
   </sect1>
   <sect1 id="ref.command-line.informational">
    <title>Informational Options</title>
    <para>
     These options print information and exit without building
     anything.
    </para>
    <variablelist>
     <varlistentry>
      <term>--dump-build-graph</term>
      <listitem>
       <para>
        Dump to standard output the complete build graph consisting of
        items and platforms.  This is primarily useful for debugging
        &abuild; or diagnosing unusual problems relating to which
        items are built in which order.  The build graph output data
        conforms to a DTD which can be found in
        <filename>doc/build_graph.dtd</filename> in the &abuild;
        distribution.  The contents of the DTD can also be found in
        <xref linkend="ref.build-graph-dtd"/>.  Although nothing is
        built when this option is specified, &abuild; still performs
        complete validation including reading of all the interface
        files.  The build graph is discussed in <xref
        linkend="ref.construction-of-build-graph"/>.  For additional
        ways to use the build graph output, see also <xref
        linkend="ref.misc-xslt"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--dump-data</term>
      <listitem>
       <para>
        Dump to standard output all information computed by &abuild;.
        Useful for debugging or for tools that need in-depth
        information about what &abuild; knows.
        <option>--dump-data</option> is mutually exclusive with
        running any targets.  If you need to see
        <option>--dump-data</option> output and build targets at the
        same time, use <option>--monitored</option> instead (see <xref
        linkend="ref.monitored-mode"/>).  For details about the format
        generated by <option>--dump-data</option>, please see <xref
        linkend="ref.dump-data"/>.  For additional ways to use the
        build graph output, see also <xref linkend="ref.misc-xslt"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--find item-name</term>
      <listitem>
       <para>
        Print the name of the tree that contains item
        <replaceable>item-name</replaceable>, and also print its
        location.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--find=tree:tree-name</term>
      <listitem>
       <para>
        Print the location of the root build item of build tree
        <replaceable>tree-name</replaceable>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--help|-H</term>
      <listitem>
       <para>
        Print a brief introduction to &abuild;'s help system.  For
        additional details, see <xref linkend="ref.help-system"/>.
        For the text of all help files that are provided with
        &abuild;, see <xref linkend="ref.help-files"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--list-platforms</term>
      <listitem>
       <para>
        Print the names of all object-code platforms categorized by
        platform type and build tree, and indicate which ones would be
        built by default.  Note that &abuild; may build on additional
        platforms beyond those selected by default in order to satisfy
        dependencies from other items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--list-traits</term>
      <listitem>
       <para>
        Print the names of all traits known in the local build tree,
        its tree dependencies, and its backing areas.  This is the
        list of traits that are available for use on the command line
        with the <option>--only-with-traits</option> and
        <option>--related-by-traits</option> options.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--print-abuild-top</term>
      <listitem>
       <para>
        Print the path to the top of &abuild;'s installation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-V|--version</term>
      <listitem>
       <para>
        Print the version number of &abuild;.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.command-line.control">
    <title>Control Options</title>
    <para>
     These options change some aspect of how &abuild; starts or runs.
    </para>
    <variablelist>
     <varlistentry>
      <term>-C start-directory</term>
      <listitem>
       <para>
        Change directories to the given directory before building.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--clean-platforms=pattern</term>
      <listitem>
       <para>
        Specify a pattern that restricts which platform directories
        are removed by any &abuild; clean operation.  This argument
        may be repeated any number of times.  The
        <replaceable>pattern</replaceable> given can be any valid
        shell-style wild-card expression.  Any output directory
        belonging to any pattern that matches any of the given clean
        patterns will be removed.  All other output directories will
        be left alone.  This can be useful for removing only output
        directories for platforms we no longer care about or for other
        selective cleanup operations.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--compat-level=version</term>
      <listitem>
       <para>
        Set &abuild;'s compatibility level to the specified version,
        which may be either <literal>1.0</literal> or
        <literal>1.1</literal>.  You may also place the compatibility
        level version in the <envar>ABUILD_COMPAT_LEVEL</envar>
        environment variable.  By default, early pre-release versions
        of &abuild; attempt to detect deprecated constructs from older
        versions and issue warnings about their use, while final
        versions operate with deprecation support disabled by default.
        Setting the compatibility level to a given version causes
        &abuild; to not recognize constructs deprecated by that
        version at all.  For example, in compatibility level
        <literal>1.1</literal>, use of the <property>this</property>
        key in <filename>Abuild.conf</filename> would result in an
        error about an unknown key rather than being treated as if it
        were <property>name</property>, and the make variable
        <varname>BUILD_ITEM_RULES</varname> would be treated like any
        ordinary variable and would not influence the build in any
        way.  See also <option>--deprecation-is-error</option>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--deprecation-is-error</term>
      <listitem>
       <para>
        Ordinarily, &abuild; detects deprecated constructs, issues
        warnings about them, and continues operating by mapping
        deprecated constructs into their intended replacements.  When
        this option is specified, any use of deprecated constructs are
        detected and reported as errors instead of warnings.  Note
        that this is subtly different from specifying
        <option>--compat-level</option> with the current major and
        minor versions of &abuild;.  For example, if
        <option>--deprecation-is-error</option> is specified, use of
        the make variable <varname>BUILD_ITEM_RULES</varname> will
        result in an error message, while if
        <option>--compat-level=1.1</option> is specified, the variable
        will simply be ignored.  A good upgrade strategy is to use
        <option>--deprecation-is-error</option> to first test to make
        sure you've successfully eliminated all deprecated constructs,
        and then to use <option>--compat-level</option> (or to set the
        <envar>ABUILD_COMPAT_LEVEL</envar> environment variable) to
        turn off &abuild;'s backward compatibility support, if
        desired.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-e | --emacs</term>
      <listitem>
       <para>
        Tell ant to run in emacs mode by passing the
        <option>-e</option> flag to it and also setting the property
        <varname>abuild.private.emacs-mode</varname>.  Ant targets can
        use this information to pass to programs whose output may need
        to be dependent upon whether or not emacs mode is in effect.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--find-conf</term>
      <listitem>
       <para>
        Locates the first directory at or above the current directory
        that contains an <filename>Abuild.conf</filename> file, and
        changes directories to that location before building.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--full-integrity</term>
      <listitem>
       <para>
        Performs &abuild;'s integrity checks for all items in the
        local tree, tree dependencies, and backing areas.  Ordinarily,
        &abuild; performs its integrity check only for items that are
        being built in the current build.  The
        <option>--full-integrity</option> flag would generally be
        useful only for people who are maintaining backing areas that
        are used by other people.  For detailed information about
        &abuild;'s integrity checks, please see <xref
        linkend="ref.integrity-checks"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-jn| --jobs=n</term>
      <listitem>
       <para>
        Build up to <emphasis>n</emphasis> build items in parallel by
        invoking up to <emphasis>n</emphasis> simultaneous instances
        of the backend.  Does not cause the backend to run multiple
        jobs in parallel.  See also <option>--make-jobs</option>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--jvm-append-args ... --end-jvm-args</term>
      <listitem>
       <para>
        Appends any arguments between
        <option>--jvm-append-args</option> and
        <option>--end-jvm-args</option> to the list of extra arguments
        that &abuild; passes to the JVM when it invokes the java
        builder backend.  This option is intended for use in debugging
        &abuild;.  If you have to use it to make your build work,
        please report this as a bug.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--jvm-replace-args ... --end-jvm-args</term>
      <listitem>
       <para>
        Replaces &abuild;'s internal list of extra JVM arguments with
        any arguments between <option>--jvm-replace-args</option> and
        <option>--end-jvm-args</option>.  This option is intended for
        use in debugging &abuild;.  If you have to use it to make your
        build work, please report this as a bug.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-k | --keep-going</term>
      <listitem>
       <para>
        Don't stop the build after the first failed build item, but
        instead continue building additional build items that don't
        depend on any failed items.  Also tells backend to continue
        after its first failure.  Even with <option>-k</option>,
        &abuild; will never try to build an item if any of its
        dependencies failed.  This behavior may be changed by
        also specifying <option>--no-dep-failures</option>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--make</term>
      <listitem>
       <para>
        Terminate argument parsing and pass all remaining arguments to
        make.  Intended primarily for debugging.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--make-jobs[=n]</term>
      <listitem>
       <para>
        Allow make to run up to <emphasis>n</emphasis> jobs in parallel.
        Omit <emphasis>n</emphasis> to allow make to run as many jobs as
        it wants.  Be aware that if this option is used in combination
        with <option>--jobs</option>, the total number of threads
        could potentially be the product of the two numerical
        arguments.
       </para>
       <para>
        Note that certain types of make rules and certain may cause
        problems for parallel builds.  For example, if your build
        involves invoking a compiler or other tool that writes poorly
        named temporary files, it's possible that two simultaneous
        invocations of that tool may interfere with each other.
        Starting with &abuild; 1.1, it is possible to place
        <property>attributes: serial</property> in a make-based build
        item's <filename>Abuild.conf</filename> file to prevent
        <option>--make-jobs</option> from applying to that specific
        item.  This will force serial compilation of items that you
        know don't build properly in parallel.  This can be useful for
        build items that use the <filename>autoconf</filename> rules,
        which are known to sometimes cause trouble for parallel
        builds.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--monitored</term>
      <listitem>
       <para>
        Run in monitored mode.  For details, see <xref
        linkend="ref.monitored-mode"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-n</term>
      <listitem>
       <para>
        Have the backend print what it would do without actually doing
        it.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--no-dep-failures</term>
      <listitem>
       <para>
        Must be combined with <option>-k</option>.  By default,
        &abuild; does not attempt to build any items whose
        dependencies have failed even if <option>-k</option> is
        specified.  When the <option>--no-dep-failures</option> option
        is specified along with <option>-k</option>, &abuild; will
        attempt to build items even if one or more of their
        dependencies have failed.  Using <option>-k</option> and
        <option>--no-dep-failures</option> together enables &abuild;
        to attempt to build everything that the backends will allow.
        Note that cascading errors (<emphasis>i.e.</emphasis>, errors
        resulting from earlier errors) are likely when this option is
        used.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--platform-selector=selector | -p selector</term>
      <listitem>
       <para>
        Specify a platform selector.  This argument may be repeated
        any number of times.  Later instances supersede earlier ones
        when they specify selection criteria for the same platform
        type.  When two selectors refer to different platform types,
        both selectors are used.  Platform selectors may also be given
        in the <envar>ABUILD_PLATFORM_SELECTORS</envar> environment
        variable.  For details on platform selectors, see <xref
        linkend="ref.platform-selection"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--ro-path=path</term>
      <listitem>
       <para>
        Indicate that <replaceable>path</replaceable> is to be treated
        as read-only by &abuild; during build or clean operations.
        For details on using explicitly read-only and read/write
        paths, see <xref linkend="ref.read-only-paths"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--rw-path=path</term>
      <listitem>
       <para>
        Indicate that <replaceable>path</replaceable> is to be treated
        as read-write by &abuild; during build or clean operations.
        For details on using explicitly read-only and read/write
        paths, see <xref linkend="ref.read-only-paths"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.command-line.output">
    <title>Output Options</title>
    <para>
     These options change the type of output that &abuild; generates.
    </para>
    <variablelist>
     <varlistentry>
      <term>--buffered-output</term>
      <listitem>
       <para>
        Cause &abuild; to buffer the output produced by each
        individual item's build and display it contiguously after that
        build completes.  For additional details, see <xref
        linkend="ref.output-processing"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--error-prefix=prefix</term>
      <listitem>
       <para>
        Prepend the given prefix string to every error message
        generated by &abuild; and to every line written to standard
        error by any program &abuild; invokes.  See also
        <option>--output-prefix</option>.  For additional details, see
        <xref linkend="ref.output-processing"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--interleaved-output</term>
      <listitem>
       <para>
        In a multithreaded build, cause &abuild; to prepend each line
        of output (normal or error) with an indicator of the build
        item that was responsible for producing it.  Starting in
        &abuild; version 1.1.3, this is the default for multithreaded
        builds.  For additional details, see <xref
        linkend="ref.output-processing"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--output-prefix=prefix</term>
      <listitem>
       <para>
        Prepend the given prefix string to every line of non-error
        output generated by &abuild; and to every line written to
        standard output by any program &abuild; invokes.  See also
        <option>--error-prefix</option>.  For additional details, see
        <xref linkend="ref.output-processing"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--raw-output</term>
      <listitem>
       <para>
        Prevent &abuild; from doing any kind of capture or filtering
        of the output produced by any item's build.  This option also
        makes &abuild;'s standard input available to any program that
        &abuild; invokes.  This is the default for single-threaded
        builds and was the behavior for all builds prior to &abuild;
        version 1.1.3.  For additional details, see <xref
        linkend="ref.output-processing"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--silent</term>
      <listitem>
       <para>
        Suppress most non-error output.  Also tells the backend build
        tools to generate less output.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--verbose</term>
      <listitem>
       <para>
        Generate more verbose output.  Also tells the backend build
        tools to generate more output.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.command-line.build">
    <title>Build Options</title>
    <para>
     These options tell &abuild; what to build and what targets to
     apply to items being built.
    </para>
    <variablelist>
     <varlistentry>
      <term>--apply-targets-to-deps</term>
      <listitem>
       <para>
        Ordinarily, any explicitly specified targets are applied only
        to items that were directly selected for inclusion in the
        build set.  With this flag, they are applied to all items
        being built, including recursively expanded dependencies.
        When used with a clean set, this option causes the clean set
        to expanded to include dependencies, which is otherwise not
        done.  For detailed information about target selection, please
        see <xref linkend="ref.what-to-build"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--build=set | -b set</term>
      <listitem>
       <para>
        Specify which build items should be built.  The default is to
        use the build set <option>current</option>, which builds the
        current item and all of its dependencies.  For additional
        details including a list of valid values for
        <replaceable>set</replaceable>, see <xref
        linkend="ref.what-to-build"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--clean=set | -c set</term>
      <listitem>
       <para>
        Run <command>abuild clean</command> in all items in the build
        set.  The same build sets are defined as with the
        <option>--build</option> option.  Unlike build sets, clean
        sets are not expanded to include dependencies (unless
        <option>--apply-targets-to-deps</option> is specified), and
        build items are not cleaned in dependency order.  No targets
        may be specified in conjunction with this option.  For
        additional details including a list of valid values for
        <replaceable>set</replaceable>, see <xref
        linkend="ref.what-to-build"/>.  See also the description of
        the <option>--clean-platforms</option> (in <xref
        linkend="ref.command-line.control"/>) to learn about
        restricting which platform directories are removed.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--dump-interfaces</term>
      <listitem>
       <para>
        Cause &abuild; to create interface dump files in the output
        directories of every writable build item, including those that
        don't build anything.  This option can be useful for tracking
        down problems with interface variables.  For more
        information, see <xref linkend="ref.interface-debugging"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--no-deps</term>
      <listitem>
       <para>
        Prevent &abuild; from attempting to build any dependencies of
        the current build item before building the item itself.  The
        <option>--no-deps</option> option may not be combined with a
        build set.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--only-with-traits=trait[,trait,...]</term>
      <listitem>
       <para>
        Exclude from the initial build set any items that do not
        contain all of the named traits.  As always, all dependencies
        of any item in the reduced build set will remain in the build
        set regardless of what traits they have.  If not accompanied
        by the <option>--related-by-traits</option> option, any
        explicitly named targets will be applied only to items that
        have all of the named traits.  Other items (those they depend
        on) will be built with the default <command>all</command>
        target.  If accompanied by the
        <option>--related-by-traits</option> option, the
        <option>--related-by-traits</option> option's behavior with
        respect to explicit targets takes precedence.  For more
        information about traits, see <xref linkend="ref.traits"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--related-by-traits=trait[,trait,...]</term>
      <listitem>
       <para>
        Expand the build set with items that have all of the named
        traits relative to any item already in the build set.
        Specifying this option also causes any explicitly specified
        targets to be run only for those items.  The default target
        <command>all</command> is run for all other build items in the
        build set.  For more information about traits, see <xref
        linkend="ref.traits"/>.  When combined with
        <option>--repeat-expansion</option>, this process is repeated
        until no more items are added.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--repeat-expansion</term>
      <listitem>
       <para>
        Instruct &abuild; to apply build set expansion based on traits
        (<option>--related-by-traits</option>) or or reverse
        dependencies (<option>--with-rdeps</option>) repeatedly after
        adding dependencies of newly added items until no further
        expansion of the build set results.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--with-rdeps</term>
      <listitem>
       <para>
        Expand the build set by adding all reverse dependencies of any
        item already in the build set.  As always, any additional
        dependencies of newly added items are also added.  When
        specified with <option>--repeat-expansion</option>, addition
        of reverse dependencies is repeated (after adding additional
        dependencies) until no further expansion of the build set
        results.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.targets.general">
    <title>General Targets</title>
    <para>
     &Abuild;'s backends define several targets that are available for
     use from the command line, so you can rely on these targets being
     defined.
     <footnote>
      <para>
       When the <filename>Abuild-ant.xml</filename> build file is used
       with the deprecated xml-based ant backend, it is up to the
       author of the build file to provide these targets, and all bets
       are off.
      </para>
     </footnote>
    </para>
    <variablelist>
     <varlistentry>
      <term>all</term>
      <listitem>
       <para>
        This is the default target.  It is used to build all
        products that are intended for use by the end user or by
        other build items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>check</term>
      <listitem>
       <para>
        This target ensures that the local build item is built and
        then runs its automated test suite, if any.  For this to do
        anything, the build item must have a test suite implemented
        with a test framework that is integrated with &abuild; or that
        is made available with a plugin.  &Abuild; is integrated with
        QTest and, for Java-based build items, also with JUnit.  The
        <command>check</command> target is not automatically run by
        the default target; it must be requested specifically.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>clean</term>
      <listitem>
       <para>
        This target removes any output directories that &abuild;
        thinks it created.  (Output directories are discussed in <xref
        linkend="ref.output-directories"/>.)  Well-behaved &abuild;
        rules, including all the rules that are a standard part of
        &abuild;, won't create any files or directories outside of
        these locations.  See also the description of the
        <option>--clean-platforms</option> (in <xref
        linkend="ref.command-line.control"/>) to learn about
        restricting which platform directories are removed.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>doc</term>
      <listitem>
       <para>
        This target is provided for building documentation that is
        extracted from source code.  The <command>doc</command> target
        is not automatically run by the default target; it must be
        requested explicitly.  It depends on the
        <command>all</command> target.  There is no internal support
        for document generation in the <application>make</application>
        backend, so this capability must be provided by a plugin.  For
        <application>Groovy/ant</application> builds, there is
        built-in support for javadoc, but it is minimal and will
        likely have to be supplemented for any major documentation
        effort.  A contributed plugins to support doxygen is available
        in <filename>abuild-contrib</filename>, which is released
        separately from &abuild;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>no-op</term>
      <listitem>
       <para>
        This target does nothing other than printing the name and
        platform of each build item in the build set, but using it
        still causes &abuild; to perform all the same validations it
        would perform if it were going to build something.  The
        <command>no-op</command> target can be used to get a complete
        list of all the items and platforms that would be built if
        building a given build set and will also verify that there are
        no errors in any <filename>Abuild.conf</filename> files.  Note
        that <filename>Abuild.interface</filename> files are not read
        when invoking the <command>no-op</command> target.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>test</term>
      <listitem>
       <para>
        This target is a synonym for <command>check</command>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>test-only</term>
      <listitem>
       <para>
        This target runs any automated test suites but does not first
        try to build.  In other words, the
        <command>test-only</command> target does not depend on the
        <command>all</command> target like the
        <command>check</command> and <command>test</command> targets
        do.  This can be useful for running a test suite on a build
        item without first rebuilding it or for running all the test
        suites on a build tree that you know is up to date because you
        just built it.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
  </chapter>
  <chapter id="ref.additional-capabilities">
   <title>Survey of Additional Capabilities</title>
   <para>
    By now, you should have a pretty good feel for what &abuild; can
    do and how to use it in several situations.  The remaining
    chapters of this document cover advanced topics and present
    examples for solving a wide variety of problems.  Although later
    chapters sometimes build on information presented in earlier
    chapters, many of the remaining chapters and examples can probably
    be understood on their own.  It should therefore be safe to focus
    your attention on the material that is of interest or potential
    use to you.
   </para>
   <para>
    <xref linkend="ref.part3"/> opens with detailed descriptions of
    &abuild;'s configuration files and interface subsystem.  It then
    continues with explorations of several specific problems.  We
    present here a brief list of problems that are addressed in the
    remaining chapters:
    <variablelist>
     <varlistentry>
      <term>Controlling and Processing &Abuild;'s Output</term>
      <listitem>
       <para>
        &Abuild;'s output is primary intended to be useful to human
        readers, but there are a number of capabilities (introduced in
        version 1.1.3) that can make it easier to programmatically
        parse &abuild;'s output or to help make it easier to look at
        the output of a large build.  In <xref
        linkend="ref.output-processing"/>, we discuss ways to
        distinguish normal output from error messages and ways to
        clearly associate each line of &abuild;'s output with the
        build item whose build produced it.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Shared Libraries</term>
      <listitem>
       <para>
        &Abuild; includes support for creating shared libraries on
        UNIX platforms and DLLs on Windows platforms.  In <xref
        linkend="ref.shared-libraries"/>, we describe the process and
        explore some of the other concerns you have to consider when
        using shared libraries with &abuild;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Build Item Rules and Code Generators</term>
      <listitem>
       <para>
        &Abuild; allows build items to supply custom rules, most often
        for supporting automatic code generation.  In <xref
        linkend="ref.code-generators"/>, we discuss code generators
        for make-based and Groovy-based builds.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Private Interfaces</term>
      <listitem>
       <para>
        In general, &abuild; is designed such that all build item
        interfaces automatically inherit through the dependency
        chain.  There are some cases when it may be desirable for a
        build item to have an expanded interface that is available to
        certain build items upon request.  In <xref
        linkend="ref.interface-flags"/>, we introduce a feature of
        &abuild; designed to solve this problem and present an example
        of using it to implement private interfaces.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Cross-Platform Development</term>
      <listitem>
       <para>
        &Abuild;'s platform system is designed to make building on
        multiple platforms as easy as possible.  If a build item can
        be built on multiple platforms, &abuild; will generally sort
        out all the details of which build of one item another item
        should depend on.  There are times, however, when it is
        necessary to take control over this behavior.  We discuss this
        problem in <xref linkend="ref.cross-platform-support"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Mixed Classification Development</term>
      <listitem>
       <para>
        We all know that security is increasingly important in the
        software community.  In some cases, it may be necessary to
        create collections of software that are only allowed to run or
        even exist in secure environments.  In <xref
        linkend="ref.build-item-visibility"/>, we describe how to use
        &abuild;'s build item visibility feature along with tree
        dependencies to create a mixed classification development
        environment, and we present an example that illustrates one
        implementation strategy.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Whole Library Support</term>
      <listitem>
       <para>
        Ordinarily, when an application links with a library, only
        functions that are actually called are linked into the
        executable.  On platforms that support this, &abuild; allows
        you to specify that the entire contents of a library archive
        should be included in an executable.  In <xref
        linkend="ref.whole-library"/>, we describe why you might want
        to do this and how to do it.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Opaque Wrappers</term>
      <listitem>
       <para>
        Some development problems require one interface to be created
        that opaquely hides another interface.  Since &abuild;'s
        default behavior is to make all interfaces inherit through the
        dependency chain, special constructs are required to implement
        opaque wrappers.  In <xref linkend="ref.opaque-wrapper"/>, we
        present the mechanisms required to make this work.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Optional Dependencies</term>
      <listitem>
       <para>
        The goal of loose integration between software components can
        often be best served by allowing different components to make
        themselves known to the system at runtime.  However, there are
        instances in which a tighter, compile-time integration may be
        required with optional components.  In <xref
        linkend="ref.optional-dependencies"/>, will illustrate how
        &abuild; allows you to declare tree and item dependencies as
        optional and then create code that is conditional upon whether
        the optional dependency is satisfied.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Plugins</term>
      <listitem>
       <para>
        There are certain tasks that go beyond simply building targets
        and making them available.  Examples include adding support
        for new compilers and performing extra validations that go
        beyond what can be easily expressed using &abuild;'s built-in
        mechanisms.  In <xref linkend="ref.plugins"/>, we present a
        plugin framework that can be used to extend &abuild; in
        certain ways.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <para>
    In addition to the above topics, we explore some details of how
    &abuild; works behind the scenes and present guidelines for how to
    use &abuild; in the safest and most effective way.  The table of
    contents at the beginning of <xref linkend="ref.part3"/> includes
    a complete list of chapters, and each chapter starts with some
    introductory text that describes the material it covers.
   </para>
  </chapter>
 </part>
 <part id="ref.part3" label="III">
  <title>Advanced Functionality</title>
  <partintro id="ref.part3.intro">
   <para>
    In this part of the manual, we cover the remaining information
    about &abuild;'s features in detail.  This part contains complete
    reference guides to &abuild;'s configuration files, discussions of
    more advanced topics, and numerous examples to illustrate how to
    solve specific build problems with &abuild;.  By the end of this
    part, you should be able to use &abuild; for a wide range of build
    problems.
   </para>
  </partintro>
  <chapter id="ref.abuild.conf">
   <title>The <filename>Abuild.conf</filename> File</title>
   <para>
    <indexterm>
     <primary>Abuild.conf</primary>
    </indexterm>
    The <filename>Abuild.conf</filename> file is the fundamental
    configuration file that describes each build item and the
    relationships between build items.  It contains information about
    dependencies, file system locations, and platform support.  It
    explicitly does not contain any information about how to build a
    particular build item or what targets are built.
   </para>
   <sect1 id="ref.abuild.conf-syntax">
    <title><filename>Abuild.conf</filename> Syntax</title>
    <para>
     Every build item must contain <filename>Abuild.conf</filename>.
     The <filename>Abuild.conf</filename> file is a simple text file
     consisting of colon-separated key/value pairs.  Blank lines and
     lines that start with <literal>#</literal> are ignored.  Long
     lines may be continued to the next line by ending them with a
     backslash character (<literal>\</literal>).  Certain keys are
     permitted for some kinds of build items and not for others.  For a
     discussion of different types of build items, please see <xref
     linkend="ref.build-item-types"/>.
    </para>
    <indexterm>
     <primary>name</primary>
    </indexterm>
    <indexterm>
     <primary>description</primary>
    </indexterm>
    <indexterm>
     <primary>child-dirs</primary>
    </indexterm>
    <indexterm>
     <primary>platform-types</primary>
    </indexterm>
    <indexterm>
     <primary>deps</primary>
    </indexterm>
    <indexterm>
     <primary>visible-to</primary>
    </indexterm>
    <indexterm>
     <primary>supported-flags</primary>
    </indexterm>
    <indexterm>
     <primary>supported-traits</primary>
    </indexterm>
    <indexterm>
     <primary>traits</primary>
    </indexterm>
    <indexterm>
     <primary>build-also</primary>
    </indexterm>
    <indexterm>
     <primary>tree-deps</primary>
    </indexterm>
    <indexterm>
     <primary>tree-name</primary>
    </indexterm>
    <indexterm>
     <primary>attributes</primary>
    </indexterm>
    <para>
     The following keys are supported in
     <filename>Abuild.conf</filename>:
     <variablelist>
      <varlistentry>
       <term><property>attributes</property></term>
       <listitem>
        <para>
         This is a &ldquo;catch-all&rdquo; key whose value is a list
         of white-space separate keywords that assign certain specific
         attributes to a build item.  The following attributes are
         supported:
         <itemizedlist>
          <listitem>
           <para>
            <property>serial</property>: valid only for build items
            that are built using the <application>make</application>
            backend, where it prevents the
            <option>--make-jobs</option> option from applying to that
            build item, effectively forcing it to build serially
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>build-also</property></term>
       <listitem>
        <para>
         This key contains a list of whitespace-separated build items.
         Whenever &abuild; adds a given item to a build set, it also
         adds any items listed in its <property>build-also</property>
         key to the build set.  No dependency relationship or any
         other relationship is implied.  This is useful for creating
         pseudo-top-level build items that serve as starting points
         for multiple builds.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>child-dirs</property></term>
       <listitem>
        <para>
         This key is used to specify all subdirectories of this item
         that contain additional <filename>Abuild.conf</filename>
         files.  The value is a whitespace-separated list of relative
         paths, each of which must point down in the file system.
        </para>
        <para>
         A child directory may be followed by the
         <option>-optional</option> flag, in which case &abuild; will
         not complain if the directory doesn't exist.  This can be
         especially useful for high-level
         <filename>Abuild.conf</filename> files whose children may
         correspond to optional dependencies, optional build trees, or
         self-contained trees that may or may not be included in a
         particular configuration.
        </para>
        <para>
         If a child directory contains more than one path element, the
         intermediate directories may not contain their own
         <filename>Abuild.conf</filename> files.  (In other words, you
         can't skip over a directory that has an
         <filename>Abuild.conf</filename> file in it.)
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>deps</property></term>
       <listitem>
        <para>
         This key's value is a whitespace-separated list of the names
         of build items on which this build item depends.  This is the
         sole mechanism within &abuild; to specify inter-build-item
         dependencies.  Any dependency in this list may be optionally
         followed by one or more
         <option>-flag=<replaceable>interface-flag</replaceable></option>
         arguments.  This causes the
         <replaceable>interface-flag</replaceable> interface flag to
         be set when this build item reads the interface of the
         dependency (see <xref linkend="ref.interface-flags"/>).  It
         is also possible to specify a
         <option>-platform=<replaceable>selector</replaceable></option>
         option to a dependency to specify which of the dependency's
         platforms applies to this dependency (see <xref
         linkend="ref.cross-platform-dependencies"/>).  Dependencies
         may be specified as optional by following the dependency name
         with the <option>-optional</option> flag (see <xref
         linkend="ref.optional-dependencies"/>).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>description</property></term>
       <listitem>
        <para>
         This key can be used to add an information description to the
         build item.  Description information is intended to be human
         readable.  If present, it will be included in the output to
         <command>abuild --dump-data</command>.  Providing a
         description here rather than just by using a comment in the
         <filename>Abuild.conf</filename> file can be useful to other
         programs that provide additional visualization of build
         items.  For adding information that you may wish to
         categorize items for build purposes, use traits instead (see
         <xref linkend="ref.traits"/>).  The description field is only
         permitted for named build items, though comments may appear
         in any <filename>Abuild.conf</filename> file.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>name</property></term>
       <listitem>
        <para>
         This key is used to set the name of the build item.  Build
         item names consist of period-delimited segments.  Each
         segment consists of one or more alphanumeric characters,
         dashes, or underscores.  Some
         <filename>Abuild.conf</filename> files exist just to connect
         parent directories with child directories in the file system.
         In those cases, the <property>name</property> key may be
         omitted.  The <property>name</property> key is also optional
         for root build items that don't build anything themselves.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>platform-types</property></term>
       <listitem>
        <para>
         This key is used to specify which platform types a given
         build item is expected to work on.  It includes a
         whitespace-separated list of platform types.  For details
         about platform types, see <xref linkend="ref.platforms"/>.
         If a build item has a build file or an interface file, the
         <property>platform-types</property> key is mandatory.
         Otherwise, it must not be present.  Note that a build item
         may have multiple platform types, but all platform types for
         a given build item must belong to the same target type.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>plugins</property></term>
       <listitem>
        <para>
         This key is valid only in a root build item.  It is used to
         specify the list of build items that are treated plugins by
         this tree.  For information about plugins, see <xref
         linkend="ref.plugins"/>.  A plugin name may be followed by
         the option <option>-global</option> which makes it apply to
         all build trees in the forest.  Use this feature very
         sparingly.  For details, see <xref
         linkend="ref.global-plugins"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>supported-flags</property></term>
       <listitem>
        <para>
         This key contains a list of whitespace-separated flags that
         are supported by this build item.  When a flag is listed
         here, it becomes available to this item's
         <filename>Abuild.interface</filename> file for flag-specific
         variable assignments.  Other items can specify that this flag
         should be turned on when they depend on this item by using
         the
         <option>-flag=<replaceable>interface-flag</replaceable></option>
         option in their <property>deps</property> key.  For more
         information, see <xref linkend="ref.interface-flags"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>supported-traits</property></term>
       <listitem>
        <para>
         This key is allowed only in a root build item.  It contains a
         list of whitespace-separated traits that are supported by
         build items in the build tree.  For more information about
         traits, see <xref linkend="ref.traits"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>traits</property></term>
       <listitem>
        <para>
         This key contains a list of whitespace-separated traits that
         apply to this build item.  A trait may be referent to one or
         more additional build items.  To name a referent build item,
         follow the trait with the
         <option>-item=<replaceable>build-item</replaceable></option>
         option.  For more information about traits, see <xref
         linkend="ref.traits"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>tree-deps</property></term>
       <listitem>
        <para>
         This key is valid only in a root build item.  It contains a
         list of the names of trees on which this tree depends.  For
         information about tree dependencies, see <xref
         linkend="ref.multiple-trees"/>.  Tree dependencies may be
         declared optional by following the name of the dependency
         with <option>-optional</option> (see <xref
         linkend="ref.optional-dependencies"/>).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>tree-name</property></term>
       <listitem>
        <para>
         The presence of this key establish a build item as a root
         build item.  This key's value is the name of the build tree.
         Build trees must be named uniquely in a forest.  Build tree
         names may consist of alphanumeric characters, underscore,
         dash, and period.  Unlike with build item names, there is no
         hierarchical or scoping structure implied by any of the
         characters in the names of build trees.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>visible-to</property></term>
       <listitem>
        <para>
         This key's value is an indicator of the scope at which this
         build item is visible.  If present, it allows build items in
         the named scope to access this build item directly when they
         would ordinarily be prevented from doing so by normal scoping
         rules.  For information about build item name scopes and
         build item visibility, see <xref
         linkend="ref.build-item-name-scoping"/>.  For a discussion of
         the <property>visible-to</property> key in particular, see
         <xref linkend="ref.build-item-visibility"/>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     Note that the <property>child-dirs</property> keys is the only
     key that deals with paths rather than names.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.abuild.backing">
   <title>The <filename>Abuild.backing</filename> File</title>
   <para>
    <indexterm>
     <primary>Abuild.backing</primary>
    </indexterm>
    The <filename>Abuild.backing</filename> file may appear at the
    root of a build forest.  It specifies the locations of one or more
    backing areas and, optionally, provides a list of build items a
    trees that should not be inherited from the backing areas.  For
    details about backing areas, see <xref
    linkend="ref.backing-areas"/>.
   </para>
   <para>
    The syntax of the <filename>Abuild.backing</filename> file is
    identical to that of the <filename>Abuild.conf</filename> file: it
    contains a list of colon-separated key/value pairs.  Blank lines
    and lines beginning with the <literal>#</literal> character are
    ignored.
   </para>
   <para>
    <indexterm>
     <primary>backing-areas</primary>
    </indexterm>
    <indexterm>
     <primary>deleted-items</primary>
    </indexterm>
    <indexterm>
     <primary>deleted-trees</primary>
    </indexterm>
    The following keys are defined:
    <variablelist>
     <varlistentry>
      <term><property>backing-areas</property></term>
      <listitem>
       <para>
        This key's value is a space-separated list of relative or
        absolute paths to other build forests that are to be used as a
        backing area to the current forest.  It is the only required
        key in the <filename>Abuild.backing</filename> file.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><property>deleted-items</property></term>
      <listitem>
       <para>
        This key's value is a space-separated list of build items that
        should not be inherited from the backing area.  Any build item
        listed here is treated as an unknown build item in the local
        forest.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><property>deleted-trees</property></term>
      <listitem>
       <para>
        This key's value is a space-separated list of build trees that
        should be inherited from the backing area.  Any build item in
        any build tree listed here will not be made available from the
        backing area, and the build tree will not be considered a
        member of the local forest.  Note that, unlike with deleted
        items, it is permissible to create a new build tree locally
        with the same name as a deleted tree.  The new tree is not
        related to the old tree in any way, and the new tree will not
        inherit build items from an instance of the deleted tree in
        the backing areas.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </chapter>
  <chapter id="ref.abuild-interface-system">
   <title>The &Abuild; Interface System</title>
   <para>
    <indexterm>
     <primary>interface</primary>
    </indexterm>
    The &abuild; interface system is the mechanism through which
    &abuild; provides encapsulation.  Its purpose is to allow build
    items to provide information about the products they provide to
    other build items.  Build items provide their interfaces with the
    <filename>Abuild.interface</filename> file.  This chapter
    describes the interface system and provides details about the
    syntax and semantics of <filename>Abuild.interface</filename> and
    other &abuild; interface files.
   </para>
   <sect1 id="ref.abuild-interface-functionality-overview">
    <title>&Abuild; Interface Functionality Overview</title>
    <para>
     This section contains a prose description of the interface
     system's functionality and presents the basic syntax of
     <filename>Abuild.Interface</filename> without providing all of
     the details.  This material provides the basis for understanding
     how the interface functionality works.  In the next section, we
     go over the details.
    </para>
    <para>
     The <filename>Abuild.interface</filename> file has a fairly
     simple syntax that supports variable declarations, variable
     assignments, and conditionals.  Interface files are rigorously
     validated.  Any errors detected in an interface file are
     considered build failures which, as such, will prevent &abuild;
     from attempting to build the item with the incorrect interface
     and any items that depend on it.  Most
     <filename>Abuild.interface</filename> files will just set
     existing variables to provide specific information about that
     item's include and library information, classpath information, or
     whatever other standard information may be needed depending upon
     the type of item it is.  For casual users, a full understanding
     of this material is not essential, but for anyone trying to debug
     interface issues or create support within &abuild; for more
     complex cases, it will be important to understand how &abuild;
     reads <filename>Abuild.interface</filename> files.
    </para>
    <para>
     The basic purpose of <filename>Abuild.interface</filename> is to
     set variables that are ultimately used by a build item to access
     its dependencies.  The basic model is that an item effectively
     reads the <filename>Abuild.interface</filename> files of all its
     dependencies in dependency order.  (This is not exactly what
     happens.  For the full story, see <xref
     linkend="ref.interface-implementation"/>.)  As each file is read,
     it adds information to the lists of include paths, libraries,
     library directories, compiler flags, classpath, etc.  All
     variables referenced by <filename>Abuild.interface</filename> are
     global variables, even if they are declared inside the body of a
     conditional, much as is the case with shell scripts or makefiles.
     Although this is not literally what happens, the best way to
     think about how &abuild; reads interface files is to imagine
     that, for each build item, all of the interface files for its
     dependencies along with its own interface file are concatenated
     in dependency order and that the results of that concatenation
     are processed from top to bottom, skipping over any blocks inside
     of false conditional statements.
    </para>
    <para>
     Once &abuild; parses the <filename>Abuild.interface</filename>
     files of all of a build item's dependencies and that of the build
     item itself, the names and values of the resulting variables are
     passed to the backends by writing them to the &abuild;
     <firstterm>dynamic output file</firstterm>, which is called
     <filename>.ab-dynamic.mk</filename> for
     <application>make</application>-based builds and
     <filename>.ab-dynamic.groovy</filename> for
     <application>Groovy/ant</application>-based builds.  The dynamic
     output file is created in the output directory.  Although users
     running &abuild; don't even have to know this file exists,
     peeking at it is a useful way to see the results of parsing all
     the <filename>Abuild.interface</filename> files in a build item's
     dependency chain.
    </para>
    <para>
     The <filename>Abuild.interface</filename> file contains the
     following items:
     <itemizedlist>
      <listitem><para>Comments</para></listitem>
      <listitem><para>Variable declarations</para></listitem>
      <listitem><para>Variable assignments</para></listitem>
      <listitem><para>After-build file specifications</para></listitem>
      <listitem><para>Target type restrictions</para></listitem>
      <listitem><para>Conditionals</para></listitem>
     </itemizedlist>
     Similar to make or shell script syntax, each statement is
     terminated by the end of the line.  Whitespace characters (spaces
     or tabs) are used to separate words.  A backslash
     (<literal>\</literal>) as the last character of the line may be
     used to continue long statements onto the next line of the file,
     in which case the newline is treated as a word delimiter like any
     other whitespace.
     <footnote>
      <para>
       In this way, &abuild;'s handles line continuation like
       <application>GNU Make</application> and the C shell.  This is
       different from how the Bourne shell and the C programming
       language treat line continuation characters: in those
       environments, a quoted newline disappears entirely.  The only
       time this matters is if there are no spaces at the beginning of
       a line following a line continuation character.  For &abuild;,
       make, and the C shell it doesn't matter whether or not space is
       present at the beginning of a line following a line
       continuation character, but for C and the Bourne shell, it
       does.
      </para>
     </footnote>
     Any line that starts with a <literal>#</literal> character
     optionally preceded by whitespace is ignored entirely.  Comment
     lines have no effect on line continuation.  In other words, if
     line one ends with a continuation character and line two is a
     comment, line one is continued on line three.  This makes it
     possible to embed comments in multiline lists of values.  In this
     example, the value of <varname>ODDS</varname> would be
     <literal>one three</literal>:

     <programlisting>ODDS = \
  one \
# odd numbers only, please
  # two \
  three
</programlisting>
    </para>
    <para>
     Characters that have special meanings (space, comma,
     equal, etc.) may be quoted by preceding them by a backslash.  For
     consistency, a backslash followed by any character is treated as
     that character.  This way, the semantics of backslash quoting
     won't change if additional special characters are added in the
     future.
    </para>
    <para>
     All variables must be declared, though most
     <filename>Abuild.interface</filename> files will be assigning to
     variables that have already been declared in other interface
     files.  There are no variable scoping rules: all variables are
     global, even if declared inside a conditional block.  Variable
     names may contain alphanumeric characters, dash, underscore, and
     period.  By convention, make-based rules use all uppercase
     letters in variable names.  This convention also has the
     advantage of avoiding potential conflict with reserved
     statements.  Java-based rules typically use lower-case
     period-separated properties.  Ultimately &abuild; interface
     variables become <application>make</application> variables or
     <application>ant</application> properties and keys in parameter
     tables for <application>Groovy</application>, which is the basis
     for these conventions.  Note, however, that variables of both
     naming styles may be used by either backend, and some of
     &abuild;'s predefined interface variables that are available to
     both <application>make</application> and
     <application>Groovy/ant</application> are of the all upper-case
     variety.
    </para>
    <para>
     Once declared, a variable may be assigned to or referenced.  A
     variable is referenced by enclosing its name with parentheses and
     preceding it by a dollar sign (as in
     <varname>$(VARIABLE)</varname>), much like with standard make
     syntax, except that there is no special case for single-character
     variable names.  Other than using the backslash character to
     quote single characters, there is no quoting syntax: the single
     and double quote characters are treated as ordinary characters
     with no special meanings.
    </para>
    <para>
     Environment variables may be referenced using the syntax
     <varname>$(ENV:VARIABLE)</varname>.  Unlike many other systems
     which treat undefined environment variables as the empty string,
     &abuild; will trigger an error condition if the environment
     variable does not exist unless a default value is provided.  A
     default value can be provided using the syntax
     <varname>$(ENV:VARIABLE:default-value)</varname>.  The
     <replaceable>default-value</replaceable> portion of the string
     may not contain spaces, tabs, or parentheses.
     <footnote>
      <para>
       This syntax restriction is somewhat arbitrary, but it makes it
       less likely that syntax errors in specifying environment
       variable references will create hard-to-solve parsing errors in
       interface files.  If this restriction is in your way, you're
       probably abusing this feature and may need to rethink why
       you're accessing environment variables to begin with.
      </para>
     </footnote>
     Although it can sometimes be useful to have &abuild; interface
     files initialize interface variables from the environment, this
     feature should be used sparingly as it is possible to make a
     build become overly dependent on the environment in this way.
     (Even without this feature, there are other ways to fall into
     this trap that are even worse.)  Note that environment variables
     are not &abuild; variables.  They are expanded as strings and can
     be used in the interface file wherever ordinary strings can be
     used.
    </para>
    <para>
     In addition, starting in version 1.1.1, &abuild; can access
     command-line parameters of the form
     <replaceable>VAR=val</replaceable> from interface files.  This
     works identically to environment variables.  Parameter references
     are of the form <varname>$(PARAM:PARAMETER)</varname> or
     <varname>$(PARAM:PARMETER:default-value)</varname>.  As with
     environment variable references, accessing an unspecified
     parameter without a default is an error, and parameter expansions
     are treated as strings by the interface parser.  This feature
     should also be used sparingly as it can create plenty of
     opportunity for unpredictable builds.  The main valid use case
     for accessing parameters from an interface file would be to allow
     special debugging changes that allow modifying build behavior
     from the command-line for particular circumstances.  Keep in mind
     that changing parameters on the command line has no impact on
     dependencies, so gratuitous and careless use of this feature can
     lead to unreproducible builds.  That said, this feature does not
     make &abuild; inherently less safe since it has always been
     possible to access parameters and the environment directly from
     make code.
    </para>
    <para>
     Variables may contain single scalar values or they may contain
     lists of values of one of the three supported types:
     <function>boolean</function>, <function>string</function>, or
     <function>filename</function>.
    </para>
    <para>
     Boolean variables are simple true/false values.  The values
     <constant>1</constant> and <constant>true</constant> are
     interpreted interchangeably as true, and the values
     <constant>0</constant> and <constant>false</constant> are
     interpreted interchangeably as false.  Regardless of whether the
     word or numeric value is used to assign to boolean variables, the
     normalized values of <constant>0</constant> and
     <constant>1</constant> are passed to the backend build system.
     (For simplicity and consistency, this is true even for the Groovy
     backend, which could handle actual boolean values instead.)
     String variables just contain arbitrary text.  It is possible to
     embed spaces in string variables by quoting them with a
     backslash, but keep in mind that not all backends handle spaces
     in single-word variable values cleanly.  For example, dealing
     with embedded spaces in variable names in GNU Make is impractical
     since it uses space as a word delimiter and offers no specific
     quoting mechanisms.  The values of filename variables are
     interpreted to be path names.  Path names may be specified with
     either forward slashes or backslashes on any platform.  Relative
     paths (those that do not start with a path separator character
     or, on Windows, also a drive letter) are interpreted as
     <emphasis>relative to the file in which they are
     assigned</emphasis>, not the file in which they are referenced as
     is the case with <application>make</application>.  This means
     that build items can export information about their local files
     using relative paths without having to use any special variables
     that point to their own local directories.  Although this is
     different from how make works, it is the only sensible semantic
     for files that are referenced from multiple locations, and it is
     one of the most important and useful features of the &abuild;
     interface system.
    </para>
    <para>
     List variables may contain multiple space-separated words.
     Assignments to list variables may span multiple lines by using a
     trailing backslash to indicate continuation to the next line.
     Each element of a list must be the same type.  Lists can be made
     of any of the supported scalar types.  (Lists of boolean values
     are supported, though they are essentially useless.)  List
     variables must be declared as either <function>append</function> or
     <function>prepend</function>, depending upon whether successive
     assignments are appended or prepended to the value of the list.
     This is described in more depth when we discuss variable
     assignment below.
    </para>
    <para>
     Scalar variables may be assigned to in one of three ways:
     <firstterm>normal</firstterm>, <firstterm>override</firstterm>,
     and <firstterm>fallback</firstterm>.  A normal assignment to a
     scalar variable fails if the variable already has a value.  An
     override assignment initializes a previously uninitialized
     variable and replaces any previously assigned value.  A fallback
     assignment sets the value of the variable only if it has not
     previously been initialized.  Uninitialized variables are passed
     to the backend as empty strings.  It is legal to initialize a
     string variable to the empty string, and doing this is distinct
     from not initializing it.
    </para>
    <para>
     List variables work differently from anything you're likely to
     have encountered in other environments, but they offer
     functionality that is particularly useful when building software.
     List variables may be assigned to multiple times.  The value in
     each individual assignment may contain zero or more words.
     Depending on whether the variable was declared as
     <function>append</function> or <function>prepend</function>, the
     values are appended to or prepended to the list in the order in
     which they appear in the specific assignment.  An example is
     provided below.
    </para>
    <para>
     Scalar and list variables can both be reset using the
     <function>reset</function> statement.  This resets the variable back
     to its initial state, which is uninitialized for scalars and
     empty for lists.
    </para>
    <para>
     Any variable assignment statement can be made conditional upon
     the presence of a given interface flag.  Interface flags are
     introduced in <xref linkend="ref.interface-flags"/>, and the
     details of how to use them in interface files are discussed later
     in this chapter.
    </para>
    <para>
     &Abuild; supports nested conditionals, each of which may contain
     an <function>if</function> clause, zero or more
     <function>elseif</function> clauses, and an optional
     <function>else</function> clause.  The &abuild; interface syntax
     supports no relational operators: all conditionals are expressed
     in terms of function calls, the details of which are provided
     below.
    </para>
    <para>
     In addition to supporting variables and conditionals, it is
     possible to specify that certain variables are relevant only to
     build items of a specific target type.  A target type restriction
     applies until the next <function>target-type</function> directive
     or until the end of the current file and all the files it loads
     as <function>after-build</function> files.  By default,
     declarations in an <filename>Abuild.interface</filename> file
     apply to all target types.  The vast majority of interface files
     will not have to include any target type restrictions.
    </para>
    <para>
     It is possible for a build item to contain interface information
     that is intended for items that depend on it but not intended for
     the item itself.  Typical uses cases would include when some of
     this information is a product of the build or when a build item
     needs to modify interface information provided by a dependency
     after it has finished using the information itself.  To support
     this, an <filename>Abuild.interface</filename> file may specify
     additional interface files that are not to be read until after
     the item is built.  The values in any such files are not
     available to the build item itself, but they are available to any
     items that depend on the build item that exports this interface.
     Such files may be dynamically generated (such as with
     <application>autoconf</application>; see <xref
     linkend="ref.example.autoconf"/>), or they may be hand-generated
     files that are just intended not to apply to the build of the
     current build item (see <xref
     linkend="ref.example.opaque-wrapper"/>).
    </para>
    <para>
     By default, once a variable is declared and assigned to in a
     build item's <filename>Abuild.interface</filename>, the
     declaration and assignments are automatically visible to all
     build items that depend on the item that made the declaration or
     assignment.  In this sense, &abuild; variables are said to be
     <firstterm>recursive</firstterm>.  It is also possible to declare
     a variable as <firstterm>non-recursive</firstterm>, in which case
     assignments to the variable are only visible in the item itself
     and in items that depend <emphasis>directly</emphasis> on the
     item that makes the assignment.  Declarations inherit normally.
     <footnote>
      <para>
       The rationale behind using the terms
       <emphasis>recursive</emphasis> and
       <emphasis>non-recursive</emphasis> have to do with how these
       variables are used.  Conceptually, when you reference an
       interface variable, you see all assignments made to it by any
       of your <emphasis>recursively expanded</emphasis> list of
       dependencies, <emphasis>i.e.,</emphasis> your direct and
       indirect dependencies.  When a variable is declared to be
       non-recursive, you only assignments made by your direct
       dependencies.  Other terms, such as
       <emphasis>indirect</emphasis> or
       <emphasis>non-inheriting</emphasis> would be technically
       incorrect or slightly misleading.  Although there's nothing
       specifically recursive or non-recursive about how interface
       variables are used, we feel that this choice of terminology is
       a reasonable reflection of the semantics achieved.
      </para>
     </footnote>
    </para>
    <para>
     It is also possible to declare an interface variable as
     <firstterm>local</firstterm>.  When a variable is declared as
     local, the declaration and assignment are not visible to any
     other build items.  This can be useful for providing values only
     to the current build item or for using variables to hold
     temporary values within the <filename>Abuild.interface</filename>
     file and any after-build files that it may explicitly reference.
    </para>
   </sect1>
   <sect1 id="ref.abuild.interface-syntactic-details">
    <title>Abuild.interface Syntactic Details</title>
    <para>
     In this section, we provide the syntactic details for each of the
     capabilities described in the previous section.  There are some
     aspects of how <filename>Abuild.interface</filename> files are
     interpreted that are different from other systems you have likely
     encountered.  If you are already familiar with the basics of how
     these files work, this section can serve as a quick reference.
    </para>
    <note>
     <para>
      If you only read one thing, read about list assignment.
      Assignment to list variables is probably different for
      <filename>Abuild.interface</filename> files than for any other
      variable assignment system you're likely to have encountered.
      It is specifically designed to support building up lists
      gradually by interpreting multiple files in a specific order.
     </para>
    </note>
    <variablelist>
     <varlistentry>
      <term>comment</term>
      <listitem>
       <para>
        Any line beginning with a <literal>#</literal> optionally
        preceded by whitespace is treated as a comment.  Comments are
        completely ignored and, as such, have no effect on line
        continuation.  Note that the <literal>#</literal> does not
        have any special meaning when it appears in another context.
        There is no syntax for including comments within a line that
        contains other content.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>variable declaration</term>
      <listitem>
       <para>
        A scalar variable declaration takes the form

        <programlisting>declare <replaceable>variable</replaceable> [ <replaceable>scope</replaceable> ] <replaceable>type</replaceable> [ = <replaceable>value</replaceable> ]
</programlisting>
        where <replaceable>variable</replaceable> is the name of the
        variable and <replaceable>type</replaceable> is one of
        <type>boolean</type>, <type>string</type>, or
        <type>filename</type>.  If specified,
        <replaceable>scope</replaceable> may be one of
        <type>non-recursive</type> or <type>local</type>.  The
        declaration may also be followed optionally be an
        initialization, which takes the same form as assignment,
        described below.

Example scalar variable declarations:

        <programlisting>declare CODEGEN filename
declare HAS_CLASS boolean
declare _dist local filename = $(ABUILD_OUTPUT_DIR)/dist
</programlisting>
       </para>
       <para>
        A list variable declaration takes the form

        <programlisting>declare <replaceable>variable</replaceable> [ <replaceable>scope</replaceable> ] list <replaceable>type</replaceable> <replaceable>append-type</replaceable> [ = <replaceable>value</replaceable> ]
</programlisting>
        where <replaceable>variable</replaceable> is the name of the
        variable, <replaceable>type</replaceable> is one of
        <type>boolean</type>, <type>string</type>, or
        <type>filename</type>, and
        <replaceable>append-type</replaceable> is one of
        <type>append</type> or <type>prepend</type>.  The optional
        <replaceable>scope</replaceable> specification is the same as
        for scalar variables (<type>non-recursive</type> or
        <type>local</type>), and as with scalar variables, an optional
        initialization may be provided.  Example list variable
        declarations:

        <programlisting>declare QFLAGS list string append
declare QPATHS list filename prepend = qfiles private-qfiles
declare DEPWORDS non-recursive list string append
</programlisting>
       </para>
       <para>
        Scalar variables start off uninitialized.  List variables
        start off containing zero items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>scalar variable assignment</term>
      <listitem>
       <para>
        Scalar variables may be assigned in one of three ways: normal,
        override, or default.  A normal assignment looks like this:

        <programlisting><replaceable>variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
        where <replaceable>variable</replaceable> is the variable name
        and <replaceable>value</replaceable> is a single word (leading
        and trailing space ignored).  Extra whitespace is permitted
        around the <literal>=</literal> sign.
       </para>
       <para>
        Override assignments look like this:

        <programlisting>override <replaceable>variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
       </para>
       <para>
        Fallback assignments look like this:

        <programlisting>fallback <replaceable>variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
        Example scalar variable assignments:

        <programlisting>fallback CODEGEN = gen_code.pl
HAS_CLASS = 0
override HAS_CLASS = 1
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>list variable assignment</term>
      <listitem>
       <para>
        List variables are assigned using a simple
        <literal>=</literal> operator:

        <programlisting><replaceable>list-variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
        where <replaceable>value</replaceable> consists of zero or
        more words, and the semantics of the assignment depend on how
        the list was declared.  For <type>append</type> lists, the
        assignment operator appends the words to the existing list in
        the order in which they appear.  For <type>prepend</type>
        lists, the assignment operator <emphasis>prepends</emphasis>
        the words to the existing value of list in the order in which
        they appear.  For example, if the variables
        <varname>LIBS</varname> is declared as a <type>prepend</type>
        list of <type>string</type>s, these two statements would
        result in <varname>LIBS</varname> containing the value
        <literal>lib3 lib4 lib1 lib2</literal>:

        <programlisting>LIBS = lib1 lib2
LIBS = lib3 lib4
</programlisting>
        The distinction of whether a list is declared as
        <type>append</type> or <type>prepend</type> generally doesn't
        matter to the user, but there are cases in a build environment
        in which it is important to prepend to a list.  One notable
        example is the list of libraries that are linked into an
        application: if one library calls functions from another
        library, the dependent library must come
        <emphasis>before</emphasis> the library on which it depends in
        the link command.  Since &abuild; reads the dependency's
        interface file first, the depending library must
        <emphasis>prepend</emphasis> itself to the list of libraries.
        Note that multiple assignments to a single list variable would
        ordinarily not occur in the same
        <filename>Abuild.interface</filename> file, but would instead
        occur over successive files.  It is perfectly valid to assign
        multiple times in the same file, however.  One instance in
        which this would typically occur would be with private
        interfaces, as illustrated in <xref
        linkend="ref.example.private-interface"/>.  Another common
        case would be with conditional assignments.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>variable reset</term>
      <listitem>
       <para>
        List and scalar variables can both be reset.  After a variable
        is reset, its value becomes uninitialized (for scalars) or
        empty (for lists) just as if it had just been declared.  The
        syntax for resetting a variable is

        <programlisting>reset <replaceable>variable</replaceable>
</programlisting>
        It is also possible to reset all variables with

        <programlisting>reset-all
</programlisting>
        A reset of a specific variable, either by an explicit
        <function>reset</function> or a
        <function>reset-all</function>, can be blocked within the
        scope of a single <filename>Abuild.interface</filename> file
        or any files it loads with <function>after-build</function>.
        To block a variable from being reset, use

        <programlisting>no-reset <replaceable>variable</replaceable>
</programlisting>
        Any <function>no-reset</function> commands will apply to the
        next <function>reset</function> or
        <function>reset-all</function> that appears in the current
        file or files it explicitly loads.  (Although there would be
        no real reason to use <function>no-reset</function> before a
        specific <function>reset</function> of a specific variable,
        &abuild; does support this construct.)
       </para>
       <para>
        Variable reset operations are used fairly infrequently, but
        there are use cases that justify all of the various reset
        operations.  For examples of using them, please see <xref
        linkend="ref.cross-platform-dependencies"/> and <xref
        linkend="ref.opaque-wrapper"/>.
       </para>
       <para>
        There are some subtleties about the effect of a variable reset
        when interface files are loaded.  For details, see <xref
        linkend="ref.interface-implementation"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>flag-based variable assignment</term>
      <listitem>
       <para>
        An <filename>Abuild.interface</filename> file may prefix any
        variable assignment (<function>normal</function>,
        <function>override</function>, <function>fallback</function>,
        scalar, or list) with a <function>flag</function> statement.
        This indicates that that particular assignment will be ignored
        by build items that don't request the particular flag through
        the
        <option>-flag=<replaceable>interface-flag</replaceable></option>
        syntax in their <filename>Abuild.conf</filename> files.  A
        flag-based assignment looks like this:

        <programlisting>flag <replaceable>interface-flag</replaceable> <replaceable>assignment-statement</replaceable>
</programlisting>
       </para>
       <para>
        &Abuild; enforces that a build item's
        <filename>Abuild.interface</filename> and any
        <function>after-build</function> files that it reads may only
        use the <function>flag</function> statement for a flag
        declared in the build item's
        <property>supported-flags</property> key in its own
        <filename>Abuild.conf</filename>.  For an example of using
        flag-based assignment, see <xref
        linkend="ref.example.private-interface"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>after-build file specification</term>
      <listitem>
       <para>
        &Abuild; allows you to specify the name of an additional
        interface file with the same syntax as
        <filename>Abuild.interface</filename> that is loaded
        immediately after the current item has been built, before any
        items that depend on this item are built.  Because the file is
        loaded after the build has been completed, any directives in
        this file will be visible to items that depend on this item
        but not by this item itself.  To specify the name of such a
        file, use

        <programlisting>after-build <replaceable>filename</replaceable>
</programlisting>
        where <replaceable>filename</replaceable> is the path to the
        file to be loaded.  A relative path is interpreted as relative
        to the original <filename>Abuild.interface</filename> file.
        Note that files loaded by <function>after-build</function> may
        themselves not include <function>after-build</function>
        directives.  It is also not permitted to have
        <function>after-build</function> statements in interface files
        belonging to plugins or build items that have no build files.
        (Having them would be meaningless since such build items are
        not built.)
       </para>
       <para>
        Since interface statements in <function>after-build</function>
        files are visible to items that depend on this build item but
        not to the item itself, this mechanism is useful for changing
        interface variables for the item's reverse dependencies
        without changing what the build item itself sees.  The Opaque
        Wrapper example (<xref linkend="ref.example.opaque-wrapper"/>)
        does this.  It also makes this construct useful for
        automatically generated interface data.  For an example of
        that use, see <xref linkend="ref.example.autoconf"/>.
       </para>
       <para>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>target type restriction</term>
      <listitem>
       <para>
        To specify the target type to which subsequent variable
        declarations belong, use

        <programlisting>target-type <replaceable>type</replaceable>
</programlisting>
        where <replaceable>type</replaceable> is the name of the
        target type.  For information about target types, see <xref
        linkend="ref.platforms"/>.  In addition to the built-in target
        types, the special type <type>all</type> may be used to
        indicate that variables should be made available to all target
        types.  In practice, there is little reason to ever restrict a
        variable to a particular target type, though many of the
        &abuild; predefined variables are restricted.  Restricting the
        target type of a variable only determines whether that
        variable is passed to the backend, so the only reason to
        restrict a variable to a specific target type would be to
        reduce the number of unneeded variables that were passed to
        the backend.  It has no impact on variable scope, visibility,
        or even availability for use in other
        <filename>Abuild.interface</filename> files.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>conditional</term>
      <listitem>
       <para>
        Conditionals in <filename>Abuild.interface</filename> take the
        following form:

        <programlisting>if (<replaceable>condition</replaceable>)
   ...<replaceable>valid code</replaceable>...
elseif (<replaceable>condition</replaceable>)
   ...<replaceable>valid code</replaceable>...
elseif (<replaceable>condition</replaceable>)
   ...<replaceable>valid code</replaceable>...
else
   ...<replaceable>valid code</replaceable>...
endif
</programlisting>
        An <function>if</function> block may contain zero or more
        <function>elseif</function> clauses and an optional
        <function>else</function> clause.  Any valid
        <filename>Abuild.interface</filename> code, including nested
        conditionals, is permitted inside a conditional block.  Recall
        that all variables have global scope including variables
        declared inside of conditional blocks.  Code inside of
        conditions that are not satisfied is ignored but must be
        syntactically valid.
       </para>
       <para>
        The <replaceable>condition</replaceable>s specified above may
        be of one of the following forms:

        <programlisting>$(<replaceable>variable</replaceable>)
</programlisting>
        where <replaceable>variable</replaceable> is a
        <type>boolean</type> variable, or

        <programlisting><replaceable>function</replaceable>(<replaceable>arg</replaceable>, <replaceable>arg</replaceable>, ...)
</programlisting>
        where <replaceable>function</replaceable> is a valid
        <filename>Abuild.interface</filename> conditional function and
        each <replaceable>arg</replaceable> consists of one or more
        words.  Only variables declared as <type>boolean</type> and
        specific conditional functions, described in the next section,
        are permitted in conditionals.  There are no relational
        operators, and variables of other types whose values happen to
        be valid boolean values are not allowed in conditionals.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.abuild.interface-conditional-functions">
    <title>&Abuild; Interface Conditional Functions</title>
    <para>
     A single <filename>Abuild.interface</filename> conditional must
     appear in parentheses after an <function>if</function> or
     <function>elseif</function> statement.  The conditional may be a
     simple boolean variable reference, or it may be a call to any of
     the provided conditional functions, each of which returns a
     boolean value.  Conditional functions may be nested as needed.
     Any boolean argument described below may a be function call or a
     simple boolean variable reference, thus allowing function calls
     to nest.  The following functions are defined:
    </para>
    <variablelist>
     <varlistentry>
      <term><function>and</function>(<replaceable>bool1</replaceable>, <replaceable>bool2</replaceable>)</term>
      <listitem>
       <para>
        Returns true if both expressions are true and false otherwise.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>or</function>(<replaceable>bool1</replaceable>, <replaceable>bool2</replaceable>)</term>
      <listitem>
       <para>
        Returns true if either value is true.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>not</function>(<replaceable>bool</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the given value is false, or false otherwise.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>equals</function>(<replaceable>scalar1</replaceable>, <replaceable>scalar2</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the two scalars contain the same contents.
        The two values must be the same type.  The
        <function>equals</function> function may not be used to
        compare lists.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>matches</function>(<replaceable>string</replaceable>, <replaceable>regex</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the string value matches the given
        Perl-compatible regular expression.  Regular expression
        matches may be applied only to strings.  Note that
        <function>matches</function> returns true if the regular
        expression matches the <emphasis>whole</emphasis> string.  If
        you need to do a partial match, you must add
        <literal>.*</literal> at the beginning and/or end of the
        expression.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>contains</function>(<replaceable>list</replaceable>, <replaceable>scalar</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the given list contains the given scalar
        value.  The scalar must have the same type as the list.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>containsmatch</function>(<replaceable>string-list</replaceable>, <replaceable>regex</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the given list contains any elements that
        match the given Perl-compatible regular expression.  The list
        must be a list of strings.  As with
        <function>matches</function>, the regular expression must match
        the entirety of some member of the list.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.abuild.interface-and-target-types">
    <title><filename>Abuild.interface</filename> and Target Types</title>
    <para>
     &Abuild; maintains a single variable symbol table.  All variables
     are global, and all variables are visible to interface code of
     any item regardless of target type.  Variables may be declared to
     apply to a specific target type.  By default, they apply to all
     target types.  When interface variables are passed to the
     backend, only variables declared in either the special target
     type <type>all</type> or in the item's own target type are
     made available.
    </para>
    <para>
     In general, end users will not have to be concerned about which
     target types a variable applies to.  A build item could, in
     principle, assign to both <varname>INCLUDES</varname> and
     <varname>abuild.classpath</varname> without having to care that
     only <type>object-code</type> items will see
     <varname>INCLUDES</varname> and only <type>java</type> items will
     see <varname>abuild.classpath</varname>.
    </para>
   </sect1>
   <sect1 id="ref.predefined-abuild.interface-variables">
    <title>Predefined <filename>Abuild.interface</filename> Variables</title>
    <para>
     Before &abuild; reads any <filename>Abuild.interface</filename>
     files, it provides certain predefined variables.  We divide them
     into categories based on target type.
    </para>
    <para>
     The variables mentioned here, along with any additional variables
     that are declared in <filename>Abuild.interface</filename> files,
     are made available to the backends in the form of identically
     named make variables or Groovy framework definitions and ant
     properties.
    </para>
    <sect2 id="ref.interface.all">
     <title>Interface Variables Available to All Items</title>
     <!-- Should have an index term for each variable -->
     <indexterm>
      <primary>ABUILD_STDOUT_IS_TTY</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_ITEM_NAME</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_THIS</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_TREE_NAME</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_TARGET_TYPE</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_PLATFORM_TYPE</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_PLATFORM</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_OUTPUT_DIR</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_PLATFORM</primary>
     </indexterm>
     <para>
      The following interface variables are available to build items
      of all target types:
      <variablelist>
       <varlistentry>
        <term>ABUILD_ITEM_NAME</term>
        <listitem>
         <para>
          The name of the current build item
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_OUTPUT_DIR</term>
        <listitem>
         <para>
          The output directory in which this item's products are
          generated for this platform.  This is the most often
          referenced &abuild; interface variable as it is normal
          practice to expand this variable when setting the names of
          library directories, classpaths, or anything else that
          references generated targets.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM</term>
        <listitem>
         <para>
          The name of the platform on behalf of which this interface
          is being read.  This variable is not used very often.  When
          referring to the output directory, always use
          <varname>$(ABUILD_OUTPUT_DIR)</varname> instead of writing
          something in terms of this variable.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_TYPE</term>
        <listitem>
         <para>
          The platform type of the platform on behalf of which this
          interface is being read
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_STDOUT_IS_TTY</term>
        <listitem>
         <para>
          A Boolean variable indicate whether &abuild;'s standard output
          is a terminal.  It can be useful to know this so that this
          information can be passed to other programs invoked by
          backends, particularly those (like ant) which redirect output
          through a pipe that ultimately goes to &abuild;'s standard
          output.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_TARGET_TYPE</term>
        <listitem>
         <para>
          The target type of the current build item
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_THIS</term>
        <listitem>
         <para>
          The obsolete variable <varname>ABUILD_THIS</varname>
          contains the name of the current build item.  It would have
          been deprecated in &abuild; version 1.1, but there is no
          reliable way to deprecate an interface variable since
          &abuild; can't detect its use in backend build files.  New
          code should not use <varname>ABUILD_THIS</varname>, but
          should use <varname>ABUILD_ITEM_NAME</varname> instead.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_TREE_NAME</term>
        <listitem>
         <para>
          The name of the current build item's tree
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </sect2>
    <sect2 id="ref.interface.object-code">
     <title>Interface Variables for Object-Code Items</title>
     <indexterm>
      <primary>ABUILD_PLATFORM_OS</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_PLATFORM_CPU</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_PLATFORM_TOOLSET</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_PLATFORM_COMPILER</primary>
     </indexterm>
     <indexterm>
      <primary>ABUILD_PLATFORM_OPTION</primary>
     </indexterm>
     <indexterm>
      <primary>INCLUDES</primary>
     </indexterm>
     <indexterm>
      <primary>LIBS</primary>
     </indexterm>
     <indexterm>
      <primary>LIBDIRS</primary>
     </indexterm>
     <indexterm>
      <primary>XCPPFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>XCFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>XCXXFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>XLINKFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>SYSTEM_INCLUDES</primary>
     </indexterm>
     <para>
      The following interface variables are available for object-code
      build items:
      <variablelist>
       <varlistentry>
        <term>ABUILD_PLATFORM_COMPILER</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>COMPILER</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_CPU</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>CPU</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_OPTION</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>OPTION</varname> field of the platform if present or
          the empty string otherwise (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_OS</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>OS</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_TOOLSET</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>TOOLSET</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>INCLUDES</term>
        <listitem>
         <para>
          This variable is to contain directories that users of this
          build item should add to their include paths.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>LIBDIRS</term>
        <listitem>
         <para>
          This variable is to contain directories that users linking
          with this build item's libraries should add to their library
          search paths.  Typically, this is just set to
          <varname>$(ABUILD_OUTPUT_DIR)</varname> since this is where
          &abuild; creates library files.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>LIBS</term>
        <listitem>
         <para>
          This variable is to contain the names of libraries (without
          any prefixes, suffixes, or command-line flags) that this
          build item provides.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCFLAGS</term>
        <listitem>
         <para>
          This variable is to contain additional flags, beyond those
          in <varname>$(XCPPFLAGS)</varname> to be passed to the
          compiler when compiling C code.  This variable will be used
          very infrequently.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCPPFLAGS</term>
        <listitem>
         <para>
          This variable is to contain additional preprocessor flags
          that must be added when using this item.  This flag should
          be used very sparingly as changing the value of this
          variable does not cause things to automatically recompile.
          It is here primarily to support third-party libraries that
          only work if a certain flag is defined.  If you are using
          this to change the configuration of a build item, please
          consider using another method instead, such as defining
          symbols in a header file or using runtime configuration.
          For an example of how to do this based on the value of a
          variable, see <xref
          linkend="ref.example.auto-from-variable"/>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCXXFLAGS</term>
        <listitem>
         <para>
          This variable is to contain additional flags, beyond those
          in <varname>$(XCFLAGS)</varname> and
          <varname>$(XCPPFLAGS)</varname> to be passed to the compiler
          when compiling C++ code.  This variable will be used very
          infrequently.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XLINKFLAGS</term>
        <listitem>
         <para>
          This variable is to contain additional flags to be added to
          the command-line when linking.  The most common use for this
          would be to pass flags to the linker that are other than
          libraries or library paths.  For linking with libraries,
          whether they are your own libraries or third-party
          libraries, you are better off using
          <varname>$(LIBDIRS)</varname> and <varname>$(LIBS)</varname>
          instead.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>SYSTEM_INCLUDES</term>
        <listitem>
         <para>
          This variable, introduced in &abuild; 1.1.6, may contain a
          list of directories that contain system include files.  For
          compilers that support this, any directory mentioned in the
          <varname>INCLUDES</varname> directory that starts with any
          of the paths mentioned in the
          <varname>SYSTEM_INCLUDES</varname> directory will be
          specified to the compiler using a flag that indicates that
          it's a system include directory.  Some compilers treat
          system include directories differently, such as suppressing
          most compiler warnings.  For gcc, this causes
          <option>-isystem</option> to be used rather than
          <option>-I</option> when specifying the include directory.
          Note that directories must still be added to
          <varname>INCLUDES</varname> to be searched.  A typical use
          of this would be for build items that are providing
          interfaces to third-party libraries.  Those build items'
          <filename>Abuild.interface</filename> files may add the
          directory to both <varname>INCLUDES</varname> and
          <varname>SYSTEM_INCLUDES</varname> to prevent users from
          having to look at warning messages generated by incorrect
          code in the third-party library.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <warning>
      <para>
       Although &abuild; allows you to do so, it is strongly
       recommended that you avoid using these variables to configure
       your build items by passing preprocessor symbol definitions on
       the command line.  There are some times when passing
       preprocessor symbols on the command line is okay, such as when
       you're passing a parameter required by a third-party library or
       passing in some truly static value such as the name of the
       operating system, but passing dynamic configuration information
       this way is dangerous.  A significant reason for this is that
       <application>make</application>'s entire dependency system is
       based on file modification times.  If you change a preprocessor
       symbol in an <filename>Abuild.mk</filename> or
       <filename>Abuild.interface</filename> file, there is nothing
       that triggers anything to get rebuilt.  The result is that you
       can end up with items that build inconsistently with respect to
       that symbol.  Furthermore, &abuild; has no way to perform its
       integrity checks relative to the values of compiler flags in
       build and interface files.  If you need to have
       preprocessor-based static configuration of your code, a better
       way to handle it is by creating a header file and putting your
       <literal>#define</literal>s there.  That way, when you modify
       the header file, anything that depends upon that file will
       rebuild automatically.
      </para>
     </warning>
     <para>
      Note that the various <varname>FLAGS</varname> variables above
      can also be set (or, more likely, appended to) in
      <filename>Abuild.mk</filename> files, as can additional
      variables to control flags on a per-file basis.  Please run
      <command>abuild rules-help</command> in a C/C++ build item or
      see <xref linkend="ref.ccxx"/> for details.
     </para>
    </sect2>
    <sect2 id="ref.interface.java">
     <title>Interface Variables for Java Items</title>
     <indexterm>
      <primary>abuild.classpath</primary>
     </indexterm>
     <indexterm>
      <primary>abuild.classpath.external</primary>
     </indexterm>
     <indexterm>
      <primary>abuild.classpath.manifest</primary>
     </indexterm>
     <para>
      The following variables are used by <type>java</type> build
      items, described here from the context of the item assigning to
      them:
      <variablelist>
       <varlistentry>
        <term>abuild.classpath</term>
        <listitem>
         <para>
          This variable is to contain generated JAR files to add to
          the compile-time classpath and to include by default in
          higher level archives.  Most ordinary Java build items that
          create JAR files will assign to this variable.  Its value
          will typically be
          <filename>$(ABUILD_DIR_OUTPUT)/dist/<replaceable>JarFile.jar</replaceable></filename>,
          where <replaceable>JarFile.jar</replaceable> is the name of
          the JAR file you placed in the
          <varname>java.jarName</varname> property in your
          <filename>Abuild.groovy</filename> file.  See also
          <varname>abuild.classpath.manifest</varname> below.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>abuild.classpath.manifest</term>
        <listitem>
         <para>
          This variable is to contain JAR files whose names should be
          listed in the <property>Class-Path</property> key of the
          manifest of JAR files that depend on it directly.  In most
          cases, anything that is assigned to
          <varname>abuild.classpath</varname> must also be assigned to
          <varname>abuild.classpath.manifest</varname>.  The
          <varname>abuild.classpath.manifest</varname> variable is
          declared as <type>non-recursive</type>, so assignments made
          to it are visible only to items that depend directly on the
          item making the assignment.  This is appropriate because
          Java handles indirect dependencies on its own.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>abuild.classpath.external</term>
        <listitem>
         <para>
          This variable is to contain externally supplied JAR files to
          add to the compile-time classpath.  Unlike JARs added to
          <varname>abuild.classpath</varname>, JAR files placed here
          will not be included in higher level archives by default.
          Whether you assign a JAR to
          <varname>abuild.classpath</varname> or
          <varname>abuild.classpath.external</varname> depends on the
          nature of your runtime environment.  Java SE applications
          probably don't need to use this variable at all.  Java EE
          applications should use this primarily for JAR files that
          are required at compile time by are provided by default by
          the application server or runtime environment.  As with
          <varname>abuild.classpath</varname>, Values assigned to
          <varname>abuild.classpath.external</varname> will usually
          also have to be assigned to
          <varname>abuild.classpath.manifest</varname>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      For additional discussion of how these are used by the Groovy
      backend, please see <xref
      linkend="ref.groovy.java-classpaths"/>.  In that section, we
      discuss the variables from the context of the item that is using
      them rather than the item that is assigning to them.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.interface-debugging">
    <title>Debugging Interface Issues</title>
    <para>
     Although most <filename>Abuild.interface</filename> files are
     reasonably simple and have easily understandable consequences,
     there will inevitably be situations in which some interface
     variable has a value that you don't understand.  For example, you
     might see an assignment in one
     <filename>Abuild.interface</filename> file that appears to have
     no effect, or you may wonder which of a very long list of
     dependencies was responsible for a particular variable assignment
     or declaration.
    </para>
    <para>
     Starting with &abuild; version 1.0.3, you can have &abuild; dump
     everything it knows about a build item's interface variables into
     an XML file.  Do this by passing the
     <option>--dump-interfaces</option> flag to any &abuild; command
     that builds something.  Doing so will cause &abuild; to create
     interface dump files for every build item including those that
     don't build anything and even those that have no
     <filename>Abuild.interface</filename> files themselves.
    </para>
    <para>
     For build items that do not have build files, &abuild; creates a
     file called <filename>.ab-interface-dump.xml</filename> in the
     output directory for every platform on which that build item
     exists.  This file contains information about all interface
     variables that are known to that item.  For build items that have
     build files, &abuild; creates two files:
     <filename>.ab-interface-dump.before-build.xml</filename> and
     <filename>.ab-interface-dump.after-build.xml</filename>.  If a
     build has no <filename>Abuild.interface</filename> or the item's
     <filename>Abuild.interface</filename> has no after-build files,
     the two files are identical and are analogous to
     <filename>.ab-interface-dump.xml</filename> files of build items
     that don't have build files.  Otherwise, the
     <filename>.ab-interface-dump.before-build.xml</filename> file
     reflects the interface as seen by the build item itself (before
     any after-build files are loaded), and the
     <filename>.ab-interface-dump.after-build.xml</filename> shows
     what interface this build item provides to items that depend on
     it.
    </para>
    <para>
     Note that the interface dump files contain not just a list of
     variables with their values but a complete list of everything
     &abuild; knows about each variable.  This includes its type,
     where it was declared, every assignment that was made to it,
     every reset of every variable, etc.  When you reference an
     interface variable, &abuild; computes the value on the fly,
     sometimes influenced by interface flags that may be in effect.
     To get maximum benefit from the information in the interface dump
     files, you must understand how this works.  For those details,
     please refer to <xref linkend="ref.interface-implementation"/>.
     The format of the interface dump file is described in <xref
     linkend="ref.interface-dump"/>.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.abuild.mk">
   <title>The <application>GNU Make</application> backend</title>
   <para>
    <indexterm>
     <primary>Abuild.mk</primary>
    </indexterm>
    The <application>GNU Make</application> backend is used to build
    items that contain an <filename>Abuild.mk</filename> file.  In
    this chapter, we describe how to set up your
    <filename>Abuild.mk</filename> file and provide details specific
    to the rule sets provided by the &abuild; <application>GNU
    Make</application> backend.
   </para>
   <sect1 id="ref.abuild.mk.general">
    <title>General <filename>Abuild.mk</filename> Syntax</title>
    <para>
     The <filename>Abuild.mk</filename> file is read by GNU Make and is
     a GNU Make fragment.  It therefore has GNU Make syntax.  The
     <filename>Abuild.mk</filename> file is intended to contain only
     variable settings.  It contains no make rules or include
     directives.  &Abuild; automatically includes your
     <filename>Abuild.mk</filename> file at the appropriate time and in
     the appropriate context.
    </para>
    <para>
     The most important line in <filename>Abuild.mk</filename> is the
     setting of the <varname>RULES</varname> variable.  Its purpose is
     to tell &abuild; which rule set should be used to generate
     targets from sources.  Most of the remaining variables that are
     set are dependent upon which rules are being used.  It is always
     possible to use &abuild;'s help system to get detailed
     rule-specific help about what variables you are expected to
     define in your <filename>Abuild.mk</filename> for a specific set
     of rules.  Run <command>abuild --help help</command> for
     additional information.  &Abuild; provides some built-in rules.
     Additional rules may provided my plugins or items that you depend
     on.  You can always run <command>abuild --help rules
     list</command> to get a list of rules that are available to your
     build item.
    </para>
    <para>
     In rare instances, it may be necessary to create local rules for
     a specific build item.  Examples may include one-off,
     special-purpose code generators that are specific to a particular
     build item.  To use local rules, place a list of files that
     contain definitions of your rules in the
     <varname>LOCAL_RULES</varname> variable.  Files listed there are
     resolved relative to the <filename>Abuild.mk</filename>.  They
     may contain any valid <application>GNU Make</application> code.
     If you have written the same local rule in more than one or two
     places, you are probably doing something wrong and should be
     using build-item-specific rules (<xref
     linkend="ref.code-generators"/>) or plugins (<xref
     linkend="ref.plugins"/>) instead.
    </para>
    <para>
     Please note that local rules are run from the context of the
     output directory&mdash;you must keep this in mind when using
     relative paths from your local rules.  The make variable
     <varname>SRCDIR</varname> is always set to a relative path to the
     directory that contains the <filename>Abuild.mk</filename> file.
     Also, local rules should avoid creating files outside of the
     output directory since these files will not be removed by the
     <command>clean</command> target.
    </para>
   </sect1>
   <sect1 id="ref.make-rule-specific-targets">
    <title>Make Rules</title>
    <para>
     The following sections describe the make-based rule sets provided
     by &abuild;.
    </para>
    <sect2 id="ref.ccxx">
     <title>C and C++: <filename>ccxx</filename> Rules</title>
     <indexterm>
      <primary>C code</primary>
     </indexterm>
     <indexterm>
      <primary>C++ code</primary>
     </indexterm>
     <indexterm>
      <primary>ccxx</primary>
     </indexterm>
     <para>
      Rules for compiling C and C++ code are provided by the
      <filename>ccxx</filename> rules.  These rules also include
      support for flex, bison, and Sun RPC.  It is possible for a
      single build item to build multiple targets including any
      mixture of static library, shared library, and executable
      targets.
     </para>
     <para>
      A note about flex and bison before we get to the main event: the
      flex and bison rules can take advantage of &abuild;'s
      <command>codegen-wrapper</command> utility.  If you set the
      variable <varname>FLEX_CACHE</varname>, &abuild; will cache
      generated flex output files and input file checksums making it
      possible for your flex code to be used on systems that don't
      have flex.  The variable <varname>BISON_CACHE</varname> serves
      the same function for code generated with bison.  &Abuild;'s own
      build uses this functionality.  To use this facility, set
      <varname>FLEX_CACHE</varname> and/or
      <varname>BISON_CACHE</varname> to directories relative to our
      source directory.  &Abuild; will copy files to or from this
      directory during its build.  These directories are relative to
      your source directory, not your output directory.  As such, the
      resulting files are likely to be controlled in your version
      control system.  This is an exception to the ordinary rule of
      &abuild; not creating files outside of the output directory, but
      it's an appropriate exception as the intention is to control
      these automatically generated files so that they could be
      available for users who didn't have flex or bison.  For
      information about using the <command>codegen-wrapper</command>
      utility with your own builds, see <xref
      linkend="ref.codegen-wrapper"/>.
     </para>
     <para>
      When building C and C++ code, you must define at least one of
      <varname>TARGETS_lib</varname> or
      <varname>TARGETS_bin</varname>.  These variables contain a list
      of library and executable targets respectively.  Targets should
      be specified without any operating system-specific prefixes or
      suffixes.  For example, the library target
      <filename>moo</filename> might generate
      <filename>libmoo.a</filename> on a UNIX system or
      <filename>moo.lib</filename> on a Windows system.  Likewise, the
      executable target <filename>quack</filename> might generate
      <filename>quack</filename> on a UNIX system and
      <filename>quack.exe</filename> on a Windows system.
     </para>
     <para>
      For each target <replaceable>target</replaceable> listed in
      <varname>TARGETS_lib</varname>, you must define the variable
      <varname>SRCS_lib_<replaceable>target</replaceable></varname>
      to contain a list of source files used to build the library.
      Likewise, for each binary target in
      <varname>TARGETS_bin</varname>, you must define
      <varname>SRCS_bin_<replaceable>target</replaceable></varname>.
      These variables can contain any mixture of C and C++ files.  The
      source files listed in these variables are typically located in
      the same directory as the <filename>Abuild.mk</filename>, but
      they may also refer to automatically source files that will
      actually appear in the output directory.
      <footnote>
       <para>
        For example, if you have a local rule that generates
        <filename>autogen.cc</filename> in the output directory, you
        can simply list <filename>autogen.cc</filename> in one of your
        <varname>SRCS</varname> variables, and &abuild; will find it
        anyway.  This is because &abuild;'s make code uses
        <application>GNU Make</application>'s
        <function>vpath</function> feature.  We provide an example of
        this construct in <xref
        linkend="ref.example.code-generator.make"/>.
       </para>
      </footnote>
      There are variables that can be used to control the creation of
      shared libraries.  For details, see <xref
      linkend="ref.building-shared-libraries"/>.  Files whose names
      end with <filename>.c</filename> are treated as C code.  Files
      whose names end with either <filename>.cc</filename> or
      <filename>.cpp</filename> are considered to be C++ code.
      Although you can have any mixture of binary and library targets
      in a build item, no single source file should be listed in more
      than one target.  Additionally, &abuild; will automatically
      include any library targets at the beginning of the library list
      when linking any binary targets in the build item.  All targets
      are created directly in the &abuild; output directory.
     </para>
     <para>
      In addition to the standard targets, the
      <filename>ccxx</filename> rules provide a special target
      <command>ccxx_debug</command>.  This target prints the current
      include and library path as well as the list of libraries that
      we are linking against.  This can be a useful debugging tool for
      solving dependency declaration problems.
     </para>
     <indexterm>
      <primary>XCPPFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>XCFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>XCXXFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>XLINKFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>DFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>OFLAGS</primary>
     </indexterm>
     <indexterm>
      <primary>WFLAGS</primary>
     </indexterm>
     <para>
      It is also possible to add additional preprocessor, compiler, or
      linker flags globally or on a per-file basis and to specifically
      override debug, optimization, or warning flags globally or on a
      per-file basis.  This is done by setting the values of certain
      make variables, some of which may also be set in
      <filename>Abuild.interface</filename>.  Details about these
      variables may be obtained by running <command>abuild
      rules-help</command> from any C/C++ build item.  The following
      variables are available:
      <variablelist>
       <varlistentry>
        <term>XCPPFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the preprocessor, C compiler, and
          C++ compiler (but not the linker)
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the C compiler, C++ compiler, and
          linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCXXFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the C++ compiler and linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XLINKFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the linker&mdash;usually not used
          for libraries
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>DFLAGS</term>
        <listitem>
         <para>
          debug flags passed to the processor, compilers, and linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>OFLAGS</term>
        <listitem>
         <para>
          optimization flags passed to the processor, compilers, and
          linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>WFLAGS</term>
        <listitem>
         <para>
          warning flags passed to the processor, compilers, and linker
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      Note that the <varname>XCPPFLAGS</varname>,
      <varname>XCFLAGS</varname>, <varname>XCXXFLAGS</varname>, and
      <varname>XLINKFLAGS</varname> variables may be set in
      <filename>Abuild.interface</filename> as well.  Therefore,
      although you assign to them normally with <literal>=</literal>
      in <filename>Abuild.interface</filename>, when assigning to them
      in <filename>Abuild.mk</filename>, it is generally better to
      append to these variables (using <literal>+=</literal>) rather
      than to set them outright.  Also, keep in mind that flags are
      often compiler-specific.  It may often make sense to set certain
      flags conditionally upon the value of the
      <varname>$(ABUILD_PLATFORM_COMPILER)</varname> variable or other
      platform field variables.  This can be done using regular
      <application>GNU Make</application> conditional syntax.
     </para>
     <para>
      Each of the above variables also has a file-specific version.
      For the <varname>X*FLAGS</varname> variables, the file-specific
      values are added to the general values.  For example, setting
      <varname>XCPPFLAGS_File.cc</varname> will cause the value of
      that variable to be added to the preprocessor, C compiler and
      C++ compiler invocations for <filename>File.cc</filename>.
      File-specific versions of <varname>XCPPFLAGS</varname>,
      <varname>XCFLAGS</varname>, and <varname>XCXXFLAGS</varname> are
      used only for compilation and, if appropriate, preprocessing of
      those specific files.  They are not used at link time.
     </para>
     <para>
      The file-specific versions of <varname>DFLAGS</varname>,
      <varname>OFLAGS</varname>, and <varname>WFLAGS</varname>
      <emphasis>override</emphasis> the default values rather than
      supplementing them.  This makes it possible to completely change
      debugging flags, optimization flags, or warning flags for
      specific source files.  For example, if
      <filename>Hardware.cc</filename> absolutely cannot be compiled
      with any optimization, you could set
      <varname>OFLAGS_Hardware.cc</varname> to the empty string to
      suppress optimization on that file regardless of the value of
      OFLAGS.  Similarly, if <filename>autogen.c</filename> were an
      automatically generated file with lots of warnings, you could
      explicitly set <varname>WFLAGS_autogen.c</varname> to the empty
      string or to a flag that suppresses warnings.  This would
      suppress warnings for that file without affecting other files.
      If you wish to append to the default flags instead of replacing
      them, include the regular variable name in the value, as in
      <literal>WFLAGS_File.cc := $(WFLAGS) -Wextra</literal> or even
      <literal>WFLAGS_File.cc := $(filter-out
      -Wall,$(WFLAGS))</literal>.
     </para>
     <para>
      The <filename>ccxx</filename> rules provide a mechanism for you
      to generate preprocessed output for any C or C++ file.  For
      <filename><replaceable>file</replaceable>.c</filename>,
      <filename><replaceable>file</replaceable>.cc</filename>, or
      <filename><replaceable>file</replaceable>.cpp</filename>, run
      <command>abuild <replaceable>file</replaceable>.i</command>.
      This will generate
      <filename><replaceable>file</replaceable>.i</filename> in the
      output directory.  Its contents will be the output of running
      the preprocessor over the specified source file with all the
      same flags that would be used during actual compilation.
      <footnote>
       <para>
        The <filename>.i</filename> suffix is a traditional UNIX
        suffix for preprocessed C code and was created as an
        intermediate file by some compilers.  GCC recognizes this as
        preprocessed C code and also recognizes
        <filename>.ii</filename> as a suffix for preprocessed C++
        code.  When &abuild; is given a <filename>.i</filename> file
        as a suffix, its make rules use a pattern-based rule to run
        the preprocessor over the file, it never uses the resulting
        files as input to the compiler.  &Abuild; uses the original
        suffix of the file (<filename>.c</filename>,
        <filename>.cc</filename>, or <filename>.cpp</filename>) to
        determine whether the file is a C or C++ source file and does
        not therefore need to distinguish between
        <filename>.i</filename> and <filename>.ii</filename>.
       </para>
      </footnote>
     </para>
     <para>
      When invoking &abuild; to build C or C++ executables or shared
      libraries, it is possible to set the make variable
      <varname>LINKWRAPPER</varname> to the name of a program that
      should wrap the link command.  This makes it possible to use
      programs such as <application>Purify</application> or
      <application>Quantify</application> that wrap the link step in
      this fashion.
     </para>
     <para>
      Ordinarily, &abuild; uses a C++ compiler or linker to link all
      executables and shared libraries.  If you are writing straight C
      code that doesn't make any calls to C++ functions including
      those in external libraries and you want to link your program as
      a C program to avoid runtime dependencies on the C++ standard
      libraries, set the variable <varname>LINK_AS_C</varname> to some
      non-empty value in your <filename>Abuild.mk</filename>.  This
      applies to all shared libraries and executables in the build
      item.
     </para>
     <para>
      Most of the time, &abuild; manages all the dependencies of the
      source and object files (as opposed to inter-build-item
      dependencies) automatically, but there are some rare instances
      in which you may have to create such dependencies on your own,
      such as when an object file depends on an automatically generate
      header file that is generated in the same build item.  For an
      example of this, see <xref
      linkend="ref.example.auto-from-variable"/>.  To make it possible
      to express such dependencies in a portable fashion, the
      <filename>ccxx</filename> rules provide the variables
      <varname>LOBJ</varname> and <varname>OBJ</varname> which are set
      to the object file suffixes for library object files and
      non-library object files respectively.  For example, if you have
      a source file called <filename>File.cc</filename> that is part
      of a library, the name of the object file will be
      <filename>File.<varname>$(LOBJ)</varname></filename>, and the
      file will be created inside the &abuild; output directory.  If
      <filename>File.cc</filename> were part of an executable instead,
      the object file would be
      <filename>File.<varname>$(OBJ)</varname></filename> instead.
      <footnote>
       <para>
        <varname>LOBJ</varname> and <varname>OBJ</varname> usually
        have the same value as each other, and the value is usually
        &ldquo;<literal>o</literal>&rdquo; on UNIX systems and
        &ldquo;<literal>obj</literal>&rdquo; on Windows systems.
        However, there are some circumstances under which either of
        these conditions may not be true, so it is best to use
        <varname>LOBJ</varname> or <varname>OBJ</varname> explicitly
        as required.
       </para>
      </footnote>
     </para>
     <para>
      As is the case for any rule set, you can run <command>abuild
      --help rules rule:ccxx</command> for additional information.
      This help text is also included in <xref
      linkend="ref.help.rule.ccxx"/>.
     </para>
     <para>
      There is a lot more to &abuild;'s C and C++ generation than is
      discussed here.  For a complete understanding of how it works,
      you are encouraged to read
      <filename>rules/object-code/ccxx.mk</filename> in the &abuild;
      distribution (<xref linkend="ref.ccxx.mk"/>).  There you will
      find copious comments and a lot of pretty hairy <application>GNU
      Make</application> code.
     </para>
    </sect2>
    <sect2 id="ref.msvc">
     <title>Options for the <filename>msvc</filename> Compiler</title>
     <para>
      &Abuild; includes built-in support for Microsoft's Visual C++
      compiler on Windows.  There are three MSVC-specific variables
      that can be set:
      <itemizedlist>
       <listitem>
        <para>
         <varname>MSVC_RUNTIME_FLAGS</varname>: set to
         <option>/MD</option> by default, which causes the
         executable to dependent on Microsoft runtime DLLs.  By
         setting this to <option>/MT</option>, it is possible to
         create executables that statically link with the runtime
         environment.  A trailing
         &ldquo;<option>d</option>&rdquo; is automatically
         appended when building debugging executables or
         libraries.
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>MSVC_MANAGEMENT_FLAGS</varname>: set to
         <option>/EHsc</option> by default, which enables
         synchronous exception handling and assumes
         &ldquo;C&rdquo; functions do not throw exceptions.  By
         setting this to <option>/clr</option>, it is possible to
         build programs that work with the .NET framework.
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>MSVC_GLOBAL_FLAGS</varname>: contains flags
         that are passed globally to all compilation commands.
         Users will seldom have to modify this.  For details, see
         comments in
         <filename>make/toolchains/msvc.mk</filename>.
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect2>
    <sect2 id="ref.autoconf">
     <title>Autoconf: <filename>autoconf</filename> Rules</title>
     <indexterm>
      <primary>Autoconf</primary>
     </indexterm>
     <para>
      The <filename>autoconf</filename> rules provide rules for
      including autoconf fragments for a build item.
      <footnote>
       <para>
        <ulink
        url="http://www.gnu.org/software/autoconf">Autoconf</ulink> is
        a package used to help software developers create portable
        code.  This section assumes some familiarity with autoconf.
       </para>
      </footnote>
      Rather than having a monolithic autoconf-based component in a
      source tree, it is recommended that individual build items use
      autoconf for only those things they need.  This reduces the
      likelihood that something may fail to build due to lack of
      support for something it doesn't need (but that is checked for
      by a monolithic autoconf component).  The only caveat to doing
      this is that, if you use autoconf-generated header files, you
      may find that the same symbols are defined in more than one
      place.  You will have to experiment and come up with appropriate
      standards for your project.
     </para>
     <para>
      The <filename>autoconf</filename> rules don't supply any special
      targets.  A reasonably complete example of using autoconf
      follows in <xref linkend="ref.example.autoconf"/>.  You may also
      run <command>abuild --help rules rule:autoconf</command> for
      full information on using these rules.  This help text is also
      included in <xref linkend="ref.help.rule.autoconf"/>.
     </para>
     <para>
      Some of the tools run by <filename>autoconf</filename> create
      temporary files that may cause problems when running parallel
      builds.  It is therefore recommended that you place
      <property>attributes: serial</property> in the
      <filename>Abuild.conf</filename> file of build items that use
      autoconf rules.
     </para>
     <para>
      Autoconf properly honors your C/C++ toolchain and runs
      <filename>configure</filename> with the proper C/C++ compilation
      environment defined.  The usual approach for autoconf-based
      build items is that, if make variables need to be defined based
      on the results of running <filename>configure</filename>,
      <filename>configure.ac</filename> generates a file called
      <filename>autoconf.interface</filename> which is specified as an
      <function>after-build</function> file in
      <filename>Abuild.interface</filename>.  This means that the
      autoconf-based build item itself may not include code that is
      conditional upon the results of running autoconf.  It is okay,
      however, for build items that depend on an autoconf-based build
      item to include conditional code in their
      <filename>Abuild.interface</filename> and
      <filename>Abuild.mk</filename> files based on variables defined
      in its <filename>autoconf.interface</filename> should this be
      required.
     </para>
    </sect2>
    <sect2 id="ref.empty">
     <title>Do Nothing: <filename>empty</filename> Rules</title>
     <para>
      In some rare cases, it may be desirable to create an
      <filename>Abuild.mk</filename> file that does nothing.  One
      reason for doing this would be if you had a library that
      contained some code that should only exist on certain platforms.
      You might want to create an <filename>Abuild.mk</filename> file
      that was conditional upon some value of the
      <varname>ABUILD_PLATFORM_OS</varname> variable, for example.
      Since &abuild; requires that you set at least one of
      <varname>RULES</varname> or <varname>LOCAL_RULES</varname>, you
      can set the <varname>RULES</varname> variable to the value
      <filename>empty</filename>.  &Abuild; will still attempt to
      build the item in this case, but the build will not do anything.
      The <filename>empty</filename> rule set is available for build
      items of any target type.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.example.autoconf">
    <title>Autoconf Example</title>
    <para>
     This example demonstrates how to use autoconf and also shows one
     use of the <function>after-build</function> statement within
     <filename>Abuild.interface</filename>.  In this example, we
     create a stub library that replaces functionality from an
     external library if that library is not available.  Our example
     is somewhat contrived, but it demonstrates the core functionality
     and patterns required to do this.  Our example resides in
     <filename>doc/example/general/user/derived/world-peace</filename>.
    </para>
    <para>
     Notice that the <filename>Abuild.conf</filename> in the
     <filename>world-peace</filename> directory itself defines a
     <firstterm>pass-through build item</firstterm> (see <xref
     linkend="ref.build-item-types"/>) that depends on the
     <classname>world-peace.stub</classname> build item:
     <?example general/user/derived/world-peace/Abuild.conf?>
     The <classname>world-peace.stub</classname> build
     item, in turn, depends on the
     <classname>world-peace.autoconf</classname> build item:
     <?example general/user/derived/world-peace/stub/Abuild.conf?>
    </para>
    <para>
     The <classname>world-peace.autoconf</classname> build item's
     <filename>Abuild.interface</filename> file adds its output
     directory to the <varname>INCLUDES</varname> variable since this
     where the autoconf-generated header file will go.  Then it
     declares <filename>autoconf.interface</filename> in its output
     directory as an after-build file using the
     <function>after-build</function> statement:
     <?example general/user/derived/world-peace/autoconf/Abuild.interface?>
     This means that the <filename>autoconf.interface</filename> file
     won't be included when this build item is built but will be
     included when other build items that depend on this one are
     built.  This is important since the file won't actually exist yet
     when this build item is being built from a clean state.
    </para>
    <para>
     Next, look at the <filename>autoconf/Abuild.mk</filename> file:
     <?example general/user/derived/world-peace/autoconf/Abuild.mk?>
     Here, we set the variables that the <varname>autoconf</varname>
     rules require.  The <varname>AUTOFILES</varname> variable is set
     to the value <filename>autoconf.interface</filename>, which is
     the same as the file name used as the
     <function>after-build</function> file in the
     <filename>Abuild.interface</filename> file.  Additionally, we set
     the variable <varname>AUTOCONFIGH</varname> to the name of the
     header file that we will be generating.
    </para>
    <para>
     Here is the <filename>autoconf/configure.ac</filename> file:
     <?example general/user/derived/world-peace/autoconf/configure.ac?>
     This contains normal autoconf macros.  There are two important
     things to notice here.  The first is the
     <function>AC_CONFIG_FILES</function> macro, which tells autoconf
     to generate the <filename>autoconf.interface</filename> file from
     <filename>autoconf.interface.in</filename>.  The second is the
     <function>AC_CONFIG_HEADERS</function> call, which takes name of
     the file set as the value of the <varname>AUTOCONFIGH</varname>
     variable in <filename>Abuild.mk</filename>.  The header file
     template is generated automatically using
     <command>autoheader</command>.  The need to duplicate this
     information is unfortunate, and this may be improved in a future
     version of &abuild;.  Note that the autoconf macros don't have
     any knowledge of the &abuild; output directory.  This works
     because we actually run autoconf inside the output directory with
     copies of the input files.
    </para>
    <para>
     Use of <function>AC_CONFIG_HEADERS</function> and
     <varname>AUTOCONFIGH</varname> are optional.  If you omit one,
     you should omit both.  If you decide to use an autoconf-generated
     header, you should be aware of the possibility that you may have
     duplicated preprocessor symbols defined by different
     autoconf-based build items.  There are several ways to avoid
     this.  One way would be to create your own header file template
     and generate it using <function>AC_CONFIG_FILES</function> rather
     than <function>AC_CONFIG_HEADER</function>.  Another way would be
     to structure your build so that you combine functionality that
     requires use of preprocessor symbols into a single build item,
     using separate build items only for cases that can be handled
     through interface variables.  It may also be possible to set
     <varname>XCPPFLAGS</varname> in an after-build file based on
     interface variables initialized by a file generated with
     autoconf.  The most important thing is that you pick a way to do
     it and use it consistently.
    </para>
    <para>
     Next, we examine the <filename>autoconf.interface.in</filename>
     file:
     <?example general/user/derived/world-peace/autoconf/autoconf.interface.in?>
     This is just like any other file generated by autoconf: it
     contains substitution tokens surrounded by @ signs.  Since it is
     an &abuild; interface file, it has &abuild; interface syntax.
    </para>
    <para>
     In our example, our <filename>configure.ac</filename> file checks
     to see whether we have two functions: <function>printf</function>
     and <function>create_world_peace</function>.  Unfortunately, only
     the first of these two functions is defined on most systems.  Our
     <filename>autoconf.interface.in</filename> file will set &abuild;
     boolean variables to the values determined by autoconf.  Then, if
     the <function>create_world_peace</function> function is
     available, we will add its library (which, in a real case, you
     would know or test for explicitly in
     <filename>configure.ac</filename>) to the library path.  If the
     library were not installed in the default library and include
     paths, it probably would also have add something to the
     <varname>LIBDIRS</varname> and <varname>INCLUDES</varname>
     variables.
    </para>
    <para>
     Now we turn our attention to the <filename>stub</filename>
     directory.  This directory contains our stub implementation of
     <function>create_world_peace</function>.  It is a poor substitute
     for the real thing, but it will at least allow our software to
     compile.  The implementation protects the definition of the
     function with the <constant>HAVE_CREATE_WORLD_PEACE</constant>
     preprocessor symbol as generated by autoconf.  It also makes use
     of <function>printf</function> and checks to make sure it's
     there, just to demonstrate how you might do such a thing:
     <?example general/user/derived/world-peace/stub/stub.cc?>
     The stub implementation provides a header file called
     <filename>world_peace.hh</filename>, which is presumably the same
     as the name of the header provided by the real implementation and
     which would have been made available by the
     <filename>world-peace.autoconf</filename> build item if the
     library were found:
     <?example general/user/derived/world-peace/stub/world_peace.hh?>
     The <filename>Abuild.interface</filename> file in the
     <filename>stub</filename> directory actually adds
     <filename>world-peace</filename> to the list of libraries only if
     the <varname>HAVE_CREATE_WORLD_PEACE</varname> variable, as
     provided by <classname>world-peace.autoconf</classname>'s
     <filename>autoconf.interface</filename> file, is false.  That
     way, if we had a real <function>create_world_peace</function>
     function (whose library would have presumably also been made
     available to us in <classname>world-piece.autoconf</classname>'s
     <filename>autoconf.interface</filename> file), we wouldn't
     provide information about our stub library:
     <?example general/user/derived/world-peace/stub/Abuild.interface?>
    </para>
    <para>
     Note that users of the <filename>world-peace</filename> build
     item actually don't even have to know whether they are using the
     stub library or the real library&mdash;those details are all
     completely hidden inside of its private build items.  Declaring a
     dependency on <classname>world-peace</classname> will make sure
     that you have the appropriate interfaces available.  You can see
     an example of this by looking at <filename>main.cpp</filename> in
     <filename>user/derived/main/src</filename>:
     <?example general/user/derived/main/src/main.cpp?>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.abuild.groovy">
   <title>The <application>Groovy</application> Backend</title>
   <note>
    <para>
     This part of the manual is not as narrative and thorough as it
     ideally should be.  However, between this chapter and the
     material in &abuild;'s help system, all the basic information is
     presented, even if in an overly terse format.  As a supplement to
     this chapter, please refer to the help text for the
     <filename>java</filename> rules in <xref
     linkend="ref.help.rule.java"/>.  You can also refer to the
     complete code for the <filename>java</filename> rules in <xref
     linkend="ref.rules.java.groovy"/>.
    </para>
   </note>
   <para>
    A Groovy-based backend, primarily intended for building Java-based
    software, was introduced in &abuild; version 1.1.  This framework
    replaces the older, now deprecated, xml-based ant framework that
    was present in &abuild; version 1.0.
    <footnote>
     <para>
      For limited documentation on the old framework, see <xref
      linkend="ref.deprecated-ant"/>.
     </para>
    </footnote>
    The old ant framework was extremely limited in capability in
    comparison to &abuild;'s make backend, and it was always
    considered tentative.  &Abuild;'s groovy backend is at least as
    powerful as its make backend offers comparable functionality
    across the board.  As of &abuild; 1.1, the specific rules provided
    for building Java code lack the maturity of the C/C++ rules
    provided as part of &abuild;'s make backend, but they still
    represent a significant improvement over what was available in
    &abuild; 1.0.
   </para>
   <para>
    You might wonder why you should consider using &abuild;'s Groovy
    backend when other Groovy/ant-based build systems, such as <ulink
    url="http://gant.codehaus.org">Gant</ulink> and <ulink
    url="http://www.gradle.org">Gradle</ulink> are available.  You may
    wonder why you should use &abuild; for Java at all when you could
    get transitive dependency management with <ulink
    url="http://ant.apache.org/ivy/">Ivy</ulink> or <ulink
    url="http://maven.apache.org/">Maven</ulink>.  Surely those tools
    may be the right tools in some environments, particularly for
    Java-only projects, but, at least at their current stage of
    development, they lack the same cross-platform/cross-language
    interoperability support offered by &abuild;, even as they offer
    more mature rules for building Java code and better integration
    with other &ldquo;standard&rdquo; Java build environments.  But
    this is the &abuild; manual, not a comparison of various Java
    build options, so, without further delay, we'll continue with our
    description of &abuild;'s Groovy backend.
   </para>
   <sect1 id="ref.groovy.crash-course">
    <title>A Crash Course in Groovy</title>
    <para>
     Although you don't really have to understand Groovy to use the
     above-described features of the Groovy backend, if you want to
     get the most out of &abuild;'s Groovy backend, it helps to have a
     decent understanding of the <ulink
     url="http://groovy.codehaus.org">Groovy language</ulink>, and you
     will certainly need to understand at least some basic Groovy to
     take advantage of more advanced customization or to write your
     own rules.  If you are already comfortable with Groovy, feel free
     to skip this section.
    </para>
    <para>
     Providing a tutorial on Groovy would be out of scope for this
     manual.  However, there are a few Groovy idioms that &abuild; (as
     well as many other Groovy-based systems) make heavy use of, and
     understanding at least that much, particularly if you are already
     a Java programmer, will certainly help you to make sense of what
     is going on here.
    </para>
    <variablelist>
     <varlistentry>
      <term>
       Closures
      </term>
      <listitem>
       <para>
        A <firstterm>closure</firstterm> is an anonymous block of code
        that is treated as an object.  When a closure is run,
        variables and functions that it uses are generally resolved in
        the context in which the closure was
        <emphasis>defined</emphasis> rather than in the context in
        which it is run.  You can't get very far in Groovy without
        having a basic understanding of closures.  You don't have to
        understand closures to <emphasis>use</emphasis> &abuild;'s
        Groovy backend, but you certainly have to understand them, at
        least at some level, when you get to the point of writing
        custom rules.
       </para>
       <para>
        Although a closure is often written as a literal block of code
        enclosed in curly braces, Groovy allows you to treat any
        function as a closure.  In particular, Groovy allows you take
        a particular method call of a <emphasis>specific
        instance</emphasis> of an object and treat that method call as
        a closure.  This feature is sometimes known as
        <firstterm>bound methods</firstterm> and is present in many
        modern programming languages.  The syntax for creating a
        closure from a method in Groovy is
        <literal>object.&amp;methodName</literal>.  &Abuild;'s Groovy
        backend uses this construct heavily in its rule code.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Automatic Bean Formation
      </term>
      <listitem>
       <para>
        In Groovy, calling <literal>object.field</literal> is just
        &ldquo;syntactic sugar&rdquo; for
        <literal>object.getField()</literal>.  In other words, if an
        object has a method called <function>getField</function>, then
        accessing <literal>object.field</literal> is exactly the same
        as calling <literal>object.getField()</literal>.  It is
        important to understand this when looking at Groovy code that
        is interfacing with the Java standard library.  For example,
        <literal>object.class.name</literal> is the same as
        <literal>object.getClass().getName()</literal>, which may not
        be obvious to a Java programmer with no prior Groovy
        experience.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       List and Map Literals
      </term>
      <listitem>
       <para>
        Groovy supports lists and maps that are similar to those in
        Java.  However, Groovy has a syntax for list and map
        <emphasis>literals</emphasis> that can appear directly in
        code.  We make heavy use of these in the &abuild; Groovy
        backend, and in fact, you will find heavy use of these in just
        about any Groovy code.
       </para>
       <para>
        The syntax for a list literal is <literal>[val1, val2, val3,
        ...]</literal>.  The syntax for a map literal is
        <literal>['key1': value1, 'key2': value2, ...]</literal>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       The <literal>&lt;&lt;</literal> Operator
      </term>
      <listitem>
       <para>
        Groovy overloads the left-shift operator
        (<literal>&lt;&lt;</literal>) for appending to lists.  For
        example, this code:

        <programlisting>def var = []
var &lt;&lt; 1
var &lt;&lt; 2
</programlisting>
        would result in a list whose value is <literal>[1,
        2]</literal>.  The <literal>&lt;&lt;</literal> operator, like
        all operators in Groovy, is just a shortcut for calling a
        specific corresponding method.  This method returns the object
        being appended.  So the above code could also have been
        written as

        <programlisting>def var = []
var &lt;&lt; 1 &lt;&lt; 2
</programlisting>
        We use this syntax sometimes to append maps to lists of maps
        as it's a little cleaner (in the author's opinion) than
        explicitly coding lists of maps.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Named Parameters
      </term>
      <listitem>
       <para>
        Under the covers, Groovy runs on top of the Java virtual
        machine.  As such, Groovy function calls are really just like
        Java function calls: a function may take a specific number of
        arguments that appear in a specific order.  The Java language
        doesn't support named parameters, so there is no encoding of
        them in Java byte code.  Yet Groovy appears to support named
        parameters, so how does this work?
       </para>
       <para>
        With Groovy, you often see function calls that look like they
        have named parameters.  For example, the following would be a
        valid function call in Groovy:

        <programlisting>f('param1': value1, other, 'param2': value2)
</programlisting>
        You can even mix what look like named parameters with regular
        parameters as in the above example.  What Groovy does when it
        sees named parameters is that it gathers them all up in a
        single map and then passes that map to the function as the
        first argument.  As such, the above call is <emphasis>exactly
        equivalent</emphasis> to the following:

        <programlisting>f(['param1': value1, 'param2': value2], other)
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Trailing Closures
      </term>
      <listitem>
       <para>
        In Groovy, it is common to see something that looks like a
        function call, or even bare function name, followed by a block
        of code in curly braces.  In fact, this construct is used in
        virtually every <filename>Abuild.groovy</filename> file.  This
        points to another special bit of Groovy syntax surrounding
        function calls.  Specifically, if a function call is
        immediately followed by one or more closures, those closures
        are passed to the function at the end of its parameter list.
        Additionally, if a function is being called with no arguments
        prior to the trailing closure, the parentheses can be
        omitted.  So the following blocks of code are
        <emphasis>exactly equivalent</emphasis>:

        <programlisting>f({println 'hello'})
f() {
    println 'hello'
}
f {
    println 'hello'
}
</programlisting>
        In all three cases, the function <function>f</function> is
        being called with a single argument, and that argument is a
        closure that, when run, prints the string
        <literal>hello</literal> followed by a newline.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Closure-based Iteration
      </term>
      <listitem>
       <para>
        Iteration over lists and maps is so common that Groovy
        provides convenience methods for calling a closure on each
        element of a list or map.  In Groovy, a closure with one
        parameter can access the single parameter anonymously with
        through the variable <varname>it</varname>.  If there are
        multiple parameters (or zero parameters), they have to be
        named and followed by <literal>-&gt;</literal> to separate
        them from the body of the closure.
       </para>
       <para>
        If you have a list in a variable called
        <varname>items</varname>, the following code:

        <programlisting>items.each { f(it) }
</programlisting>
        would call the function <function>f</function> for each
        argument of the list.  If have a map in a variable called
        <varname>table</varname>, this code:

        <programlisting>table.each { k, v -> f(k, v) }
</programlisting>
        would call the function <function>f</function> on each key and
        value in the map.  All that's happening here is that Groovy is
        calling the <function>each</function> method of the list and
        map objects with a closure passed to it as the last argument,
        which should hopefully be clear now that you've seen the
        trailing closure feature.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Safe Dereference
      </term>
      <listitem>
       <para>
        How often have you found yourself writing code where you first
        check whether a variable is null and, only if it isn't null,
        access it?  Groovy offers a shortcut for this.  This code:

        <programlisting>obj?.method()
</programlisting>
        is the same as

        <programlisting>if (obj != null)
{
    obj.method()
}
</programlisting>
        but it's a lot easier to write!
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     These features are often combined.  In fact, this is extremely
     common when using Groovy's <classname>AntBuilder</classname>,
     which &abuild; uses very heavily.  So if you see something like
     this:

     <programlisting>ant.javac('destdir': classesDir, 'classpath': classPath) {
    srcdirs.each { dir -> src('path' : dir) }
    compilerargs?.each { arg -> compilerarg('value' : arg) }
    includes?.each { include('name' : it) }
    excludes?.each { exclude('name' : it) }
}
</programlisting>
     you may be able to a little bit better of an idea of what's going
     on!
    </para>
    <para>
     There's a lot more to Groovy than in this tiny crash course.  You
     are encouraged to seek out Groovy documentation or get a good
     book on the language.  But hopefully this should be enough to get
     you through the examples in this documentation.
    </para>
   </sect1>
   <sect1 id="ref.Abuild.groovy">
    <title>The <filename>Abuild.groovy</filename> File</title>
    <para>
     To use &abuild;'s Groovy backend, you must create a build file
     called <filename>Abuild.groovy</filename>.  We've already seen a
     few examples of <filename>Abuild.groovy</filename> files in <xref
     linkend="ref.example.basic.java-library"/> and <xref
     linkend="ref.example.basic.java-program"/>.
    </para>
    <sect2 id="ref.groovy.parameter-blocks">
     <title>Parameter Blocks</title>
     <para>
      &Abuild;'s Groovy backend loads each build item's
      <filename>Abuild.groovy</filename> file in a private context such
      that no two build items' build files can interfere with each
      other.  Although the <filename>Abuild.groovy</filename> file is a
      full-fledged Groovy script which could, in principle, run
      arbitrary Groovy code, the intent is that your
      <filename>Abuild.groovy</filename> file do nothing other than set
      &abuild; parameters.  &Abuild; parameters are similar to make
      variables or ant properties.  Unlike make variables or ant
      parameters, they are a construct implemented by &abuild;'s Groovy
      backend itself rather than being something more fundamental to
      Groovy.
      <footnote>
       <para>
        In fact, &abuild; parameters are nothing more than keys in a
        map of parameter values.
       </para>
      </footnote>
      Parameters look like ant or Java properties, but unlike ant
      properties, their values can be modified.  Parameter names are
      typically divided into period-separated components, like
      <varname>abuild.rules</varname> or
      <varname>java.dir.dist</varname>.
     </para>
     <para>
      The most common way to set &abuild; parameters is by assigning to
      them inside of a <firstterm>parameters block</firstterm>.  A
      parameters block in <filename>Abuild.groovy</filename> looks
      something like this:

      <programlisting>parameters {
    java.jarName = 'example.jar'
    abuild.rules = ['java', 'groovy']
}
</programlisting>
      Within a parameters block, things that look like variables are
      treated as &abuild; parameters instead.  (For a discussion of
      how this works, see <xref
      linkend="ref.parameter-blocks-implementation"/>.)  On the left
      hand side of an assignment, &abuild; automatically treats the
      assignment as an assignment to a parameter.  On the right hand
      side, you have to wrap the parameter name in a call to
      <function>resolve</function>.  You can also pass the names of
      interface variables to <function>resolve</function>.  For
      example, the following would give the parameter
      <varname>item.name</varname> the value of the interface variable
      <varname>ABUILD_ITEM_NAME</varname>:

      <programlisting>parameters {
    item.name = resolve(ABUILD_ITEM_NAME)
}
</programlisting>
      If the interface variable contains characters that make it
      invalid as a Groovy identifier, you can quote it, as in the
      following:

      <programlisting>parameters {
    item.parameter = resolve('some-build-item.archive-name')
}
</programlisting>
      In addition to assigning to parameters, you can append to them
      by using the <literal>&lt;&lt;</literal> operator, which is the
      same operator Groovy uses to append to lists.  The following
      three parameter blocks are equivalent:

      <programlisting>parameters {
    abuild.rules = ['java', 'groovy']
}
parameters {
    abuild.rules &lt;&lt; 'java' &lt;&lt; 'groovy'
}
parameters {
    abuild.rules &lt;&lt; 'java'
    abuild.rules &lt;&lt; 'groovy'
}
</programlisting>
      It is even possible to delete parameters like this:

      <programlisting>parameters {
    delete some.parameter
}
</programlisting>
      though there should seldom if ever be a need to do this.
     </para>
     <para>
      Most of the time, working with parameters and parameter blocks
      is straightforward, but there are some subtleties that may pop
      up in rare instances.  For a full discussion, refer to <xref
      linkend="ref.groovy.variables"/>.
     </para>
    </sect2>
    <sect2 id="ref.groovy.selecting-rules">
     <title>Selecting Rules</title>
     <para>
      In a typical <filename>Abuild.groovy</filename> file, you will
      be assigning to some rule-specific parameters and to at least
      one the two parameters provided directly by &abuild;.  The two
      &abuild; parameters are <varname>abuild.rules</varname> and
      <varname>abuild.localRules</varname>.  The parameter
      <varname>abuild.rules</varname> contains a list of rule sets
      that will be providing code to generate targets from sources.
      The vast majority of Groovy-based build items will set the
      <varname>abuild.rules</varname> parameter.  In rare instances, a
      build item may need to provide additional rules for some one-off
      purpose.  In this case, the parameter
      <varname>abuild.localRules</varname> may be set to a list of
      files, relative to the directory containing the
      <filename>Abuild.groovy</filename> file, that implement the
      local rules.  Note that <varname>abuild.rules</varname> contains
      the <emphasis>names</emphasis> of rule set implementations while
      <varname>abuild.localRules</varname> contains the names of
      <emphasis>files</emphasis> that contain rule implements.  (This
      makes these parameters consistent with the variables
      <varname>RULES</varname> and <varname>LOCAL_RULES</varname> used
      by the make backend.)  &Abuild; requires that at least one of
      <varname>abuild.rules</varname> and
      <varname>abuild.localRules</varname> be set in every
      <filename>Abuild.groovy</filename> file.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.groovy.directory-structure">
    <title>Directory Structure for Java Builds</title>
    <para>
     &Abuild;'s Groovy backend provides a default directory structure
     that it uses by convention when performing Java builds.  It is
     possible to override all of these paths by setting specific
     parameters as described in <xref
     linkend="ref.groovy.advanced-java"/>.  In this section, we just
     provide a quick overview of the default paths.
    </para>
    <para>
     All paths are relative to the build item directory.  Note that
     <filename>abuild-java</filename> is the &abuild; output directory
     for Java builds.  All directories under
     <filename>abuild-java</filename> are created automatically if
     needed.  All other directories are optional: &abuild; will use
     them if they exist but will not complain if they are missing.
     Note that the <command>clean</command> target removes the entire
     &abuild; output directory.
    </para>
    <table id="table.java-directories" frame="all">
     <title>Default Java Directory Structure</title>
     <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <thead>
       <row>
        <entry>Directory</entry>
        <entry>Purpose</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><filename>src</filename></entry>
        <entry/>
       </row>
       <row>
        <entry><filename>&indent;java</filename></entry>
        <entry>
         hand-coded Java sources
        </entry>
       </row>
       <row>
        <entry><filename>&indent;resources</filename></entry>
        <entry>
         hand-created additional files to be packaged into the root of
         the item's JAR or EAR files or into the
         <filename>WEB-INF/classes</filename> directories of the
         item's WAR files
        </entry>
       </row>
       <row>
        <entry><filename>&indent;conf</filename></entry>
        <entry>
         not used directly by &abuild;; a good place to put other
         configuration files such as
         <filename>application.xml</filename>, that are referenced by
         specific parameters
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;META-INF</filename></entry>
        <entry>
         hand-created files to go into the item's archives'
         <filename>META-INF</filename> directories
        </entry>
       </row>
       <row>
        <entry><filename>&indent;web</filename></entry>
        <entry/>
       </row>
       <row>
        <entry><filename>&indent;&indent;content</filename></entry>
        <entry>
         hand-created content to go into the root of the item's WAR
         files
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;WEB-INF</filename></entry>
        <entry>
         hand-created content to go into the item's WAR files'
         <filename>WEB-INF</filename> directories
        </entry>
       </row>
       <row>
        <entry><filename>abuild-java</filename></entry>
        <entry>
         the &abuild; output directory; all contents below here are
         generated
        </entry>
       </row>
       <row>
        <entry><filename>&indent;src</filename></entry>
        <entry/>
       </row>
       <row>
        <entry><filename>&indent;&indent;java</filename></entry>
        <entry>
         generated Java sources; treated identically to
         <filename>src/java</filename>
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;resources</filename></entry>
        <entry>
         generated additional files; treated identically to
         <filename>src/resources</filename>
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;conf</filename></entry>
        <entry>
         not used directly by &abuild;; a good place to put generated
         versions of whatever you would put in
         <filename>src/conf</filename>
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;&indent;META-INF</filename></entry>
        <entry>
         generated META-INF files; treated identically to
         <filename>src/conf/META-INF</filename>
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;web</filename></entry>
        <entry/>
       </row>
       <row>
        <entry><filename>&indent;&indent;&indent;content</filename></entry>
        <entry>
         generated web content; treated identically to
         <filename>src/web/content</filename>
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;&indent;WEB-INF</filename></entry>
        <entry>
         generated WEB-INF; treated identically to
         <filename>src/web/WEB-INF</filename>
        </entry>
       </row>
       <row>
        <entry><filename>&indent;dist</filename></entry>
        <entry>
         the location where &abuild; places generated archives
        </entry>
       </row>
       <row>
        <entry><filename>&indent;doc</filename></entry>
        <entry>
         the location where &abuild; places Javadoc documentation
        </entry>
       </row>
       <row>
        <entry><filename>&indent;junit</filename></entry>
        <entry>
         the location where &abuild; writes JUnit test results
        </entry>
       </row>
       <row>
        <entry><filename>&indent;&indent;html</filename></entry>
        <entry>
         the location where &abuild; writes HTML reports generated
         from JUnit test results
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect1>
   <sect1 id="ref.groovy.java-classpaths">
    <title>Class Paths and Class Path Variables</title>
    <para>
     In <xref linkend="ref.interface.java"/>, we discuss the three
     classpath interface variables.  These are as follows, described
     here from the perspective of the item that is using them:
     <itemizedlist>
      <listitem>
       <para>
        <varname>abuild.classpath</varname>: archives your item
        compiles with and probably packages in higher-level archives
       </para>
      </listitem>
      <listitem>
       <para>
        <varname>abuild.classpath.external</varname>: archives your
        item compiles with but probably doesn't package in
        higher-level archives
       </para>
      </listitem>
      <listitem>
       <para>
        <varname>abuild.classpath.manifest</varname>: archives that
        should go in the your the manifest classpath of archives you
        generate
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Within the context of a Java build, there are four different
     types of classpath-like entities.  We describe them here and show
     how they are related to the three classpath interface variables:
     <itemizedlist>
      <listitem>
       <para>
        Compile-time classpath: used as the
        <property>classpath</property> attribute to the
        <command>javac</command> task.  Its default value is the
        combination of the values of
        <varname>abuild.classpath</varname> and
        <varname>abuild.classpath.external</varname>.
       </para>
      </listitem>
      <listitem>
       <para>
        Manifest classpath: used as
        <property>Manifest-Classpath</property> attribute in the
        manifest of any JAR files that you create.  Its default value
        is the value of <varname>abuild.classpath.manifest</varname>.
       </para>
      </listitem>
      <listitem>
       <para>
        Archive to package: the list of archives that get included in
        higher-level archives such as EAR files.  Its default value is
        the value of <varname>abuild.classpath</varname>.
       </para>
      </listitem>
      <listitem>
       <para>
        Runtime class path: the classpath used by wrapper scripts and
        test drivers.  Its default value is the values of
        <varname>abuild.classpath</varname> and
        <varname>abuild.classpath.external</varname> plus any JAR
        files created by the current build item.
       </para>
      </listitem>
     </itemizedlist>
     Each of the above classpaths is computed inside &abuild;'s
     <filename>java</filename> rules.  In each case, the computed
     value is used as a default value for attributes to the various
     targets that use them.
    </para>
    <para>
     To override the value of one of these classpaths for a specific
     build item, there are two approaches.  One is to effectively
     replace the interface variable with a parameter.  Since &abuild;
     uses <function>resolve</function> internally to retrieve these
     values, constructs such as this:

     <programlisting>parameters {
    abuild.classpath.manifest &lt;&lt; 'something-else.jar'
}
</programlisting>
     or

     <programlisting>parameters {
    abuild.classpath.manifest =
        resolve(abuild.classpath.manifest).grep {
            it != 'something-else.jar'
        }
}
</programlisting>
     can be used to change the underlying variables used to construct
     the various class paths.  To understand why this works, please
     refer to <xref linkend="ref.groovy.variables"/>.
    </para>
    <para>
     The other way these can be overridden is to specifically override
     the classpath that is used by each target.  This can be done by
     using control parameters, as discussed in <xref
     linkend="ref.groovy.advanced-java"/>.  Each target's
     attributes map contains a key that can be set to supply a new
     value for whichever classpaths need to be changed.
    </para>
   </sect1>
   <sect1 id="ref.groovy.basic-java">
    <title>Basic Java Rules Functionality</title>
    <para>
     Virtually all Java-based build items will set the
     <varname>abuild.rules</varname> parameter to the value
     <literal>'java'</literal> or to a list that includes that value.
     The <filename>java</filename> rules are quite flexible and give
     you considerable leeway on how things should work.  In this
     section, we will describe only the most basic use of the
     <filename>java</filename> rules.  When using the rules in this
     way, you control everything that you are going to build by
     setting a few simple parameters, and you set up your build item's
     directory structure according to &abuild;'s conventions.  In
     later sections, we will discuss other more general ways to
     customize or override &abuild;'s default behavior.
    </para>
    <para>
     The <filename>java</filename> rules perform a variety of
     functions, most of which must be enabled by setting one or more
     parameters.  With appropriate parameters, the
     <filename>java</filename> rules can perform the following tasks:
     <itemizedlist>
      <listitem>
       <para>
        Compiling Java source code into class files
       </para>
      </listitem>
      <listitem>
       <para>
        Generating Javadoc documentation
       </para>
      </listitem>
      <listitem>
       <para>
        Creating JAR files populated by class files and other
        arbitrary contents
       </para>
      </listitem>
      <listitem>
       <para>
        Creating simple wrapper scripts that run executable JAR files
        in the context of the source tree; these wrapper scripts are
        useful for testing within the source tree, but not for
        installation or deployment
       </para>
      </listitem>
      <listitem>
       <para>
        Creating WAR files that contain locally produced files as well
        as signed JAR files or other content
       </para>
      </listitem>
      <listitem>
       <para>
        Producing higher-level JAR-like archives, such as RAR files,
        that may contain other JAR files
       </para>
      </listitem>
      <listitem>
       <para>
        Creating EAR files that may contain locally produced files
        including other archives as well as other content
       </para>
      </listitem>
     </itemizedlist>
     We will discuss each of these briefly in turn.  In the
     discussions below, we describe the default behavior of each of
     these capabilities.  Keep in mind that virtually every aspect of
     them, including all the default paths and file locations, can be
     customized.  We will be describing how to customize and override
     the default behavior in later sections.
    </para>
    <para>
     The sections below include prose descriptions of the default
     locations of files.  To see all this presented in one place,
     please refer to <xref linkend="ref.groovy.directory-structure"/>.
    </para>
    <note>
     <para>
      At this time, this manual does not include any examples of
      creating high-level archives or signed JAR files.  To see
      examples, you may refer to &abuild;'s test suite, which fully
      exercises all available functionality.  The most comprehensive
      example that uses the Groovy framework is the code generator
      example (<xref linkend="ref.example.code-generator.groovy"/>),
      which also illustrates a few other aspects of the Groovy
      framework.
     </para>
    </note>
    <sect2 id="ref.java.compile">
     <title>Compiling Java Source Code</title>
     <para>
      By default, Java compilation involves compiling with
      <command>javac</command> every <filename>.java</filename> file
      found in <filename>src/java</filename> and writing the output
      files into <filename>abuild-java/classes</filename>.  In
      addition to <filename>src/java</filename>, &abuild; also looks
      for Java sources in <filename>abuild-java/src/java</filename>,
      which is where automatic code generators are expected to put
      generated Java sources.  You may add additional directories in
      which &abuild; will search for <filename>.java</filename> files
      to compile by adding the names of the directories to the
      <varname>java.dir.extraSrc</varname> parameter.
     </para>
     <para>
      By default, &abuild; invokes <command>javac</command> with
      <option>debug</option> and <option>deprecation</option> turned
      on and with the additional arguments <option>-Xlint</option> and
      <option>-Xlint:-path</option>.
     </para>
     <para>
      You may customize Java compilation in several ways including
      changing the locations in which &abuild; finds source files or
      writes output files, changing the compile-time classpath, or
      changing the attributes passed to the ant
      <command>javac</command> task.  For details, see <xref
      linkend="ref.groovy.advanced-java"/>.
     </para>
    </sect2>
    <sect2 id="ref.java.jar">
     <title>Building Basic Jar Files</title>
     <para>
      If the <varname>java.jarName</varname> parameter is set,
      &abuild; will create a JAR file with the indicated name.  For an
      example of this, see <xref
      linkend="ref.example.basic.java-library"/>.  By default, you are
      expected to put any hand-created files other than class files in
      <filename>src/resources</filename>.  Build items that
      automatically generate additional files to include in the JAR
      file should place those files in
      <filename>abuild-java/src/resources</filename>.  All files in
      <filename>src/resources</filename>,
      <filename>abuild-java/classes</filename>, and
      <filename>abuild-java/src/resources</filename>, subject to the
      usual ant exclusions (version control directories, editor backup
      files, etc.), will be included in the JAR file.  You may specify
      additional directories whose contents should be included by
      appending the names of the directories to the parameter
      <varname>java.dir.extraResources</varname>.  Additionally, any
      files in the <filename>src/conf/META-INF</filename> and
      <filename>abuild-java/src/conf/META-INF</filename> directories
      will be included in the <filename>META-INF</filename> directory
      of the JAR file.  You can specify additional META-INF
      directories by setting the parameter
      <varname>java.dir.extraMetainf</varname>.
     </para>
     <para>
      As always, all default path names may be overridden.  It is also
      possible to provide additional arguments to the
      <command>jar</command> task, to set additional keys in the
      <filename>manifest</filename>, and to create multiple JAR
      targets.  For details, see <xref
      linkend="ref.groovy.advanced-java"/>.
     </para>
    </sect2>
    <sect2 id="ref.java.wrapper-scripts">
     <title>Wrapper Scripts</title>
     <para>
      If the <varname>java.wrapperName</varname> and
      <varname>java.mainClass</varname> parameters are set in addition
      to the <varname>java.jarName</varname> parameter, &abuild; will
      generate a simple wrapper script that will invoke
      <command>java</command> on the JAR file using the specified main
      class and with the calculated or specified runtime class path.
      For an example of this, see <xref
      linkend="ref.example.basic.java-program"/>. The wrapper script
      is placed directly in the &abuild; output directory.
     </para>
     <para>
      It is possible to have &abuild; generate multiple wrapper
      scripts that invoke the application using different
      <function>main</function> classes.  For details, see <xref
      linkend="ref.groovy.advanced-java"/>.  For an example, see
      (<xref linkend="ref.example.multiple-wrapper-scripts"/>).
     </para>
    </sect2>
    <sect2 id="ref.java.junit">
     <title>Testing with JUnit</title>
     <para>
      If you have implemented JUnit tests suites, you can run them
      using either the <command>test</command> or
      <command>batchtest</command> nested tasks of the
      <command>junit</command> ant task.  If you have a single test
      suite that you want to run, you can set the
      <varname>java.junitTestsuite</varname> parameter to the name of
      the class that implements the test suite.  If you want to run
      multiple test suites using the <command>batchtest</command>
      task, you can set the parameter
      <varname>java.junitBatchIncludes</varname> and optionally also
      <varname>java.junitBatchExcludes</varname> to patterns that will
      be matched against the classes in
      <filename>abuild-java/classes</filename>.  You may provide
      values for all of these if you wish, in which case &abuild; will
      run all test specified.  &Abuild; will write XML test output to
      the <filename>abuild-java/junit</filename> directory and,
      whether the tests pass or fail, will also generate an HTML
      report in <filename>abuild-java/junit/html</filename>.  By
      default, if the test fails, the &ldquo;build&rdquo; of the
      <command>test</command> target for the item will fail.  This and
      other behavior can be overridden; see <xref
      linkend="ref.groovy.advanced-java"/>.
     </para>
    </sect2>
    <sect2 id="ref.java.jar-signing">
     <title>JAR Signing</title>
     <para>
      When creating WAR files, EAR files, or other high-level archives
      that may contain other JAR files, JAR signing is available by
      default.  In order for &abuild; to sign any JAR files, you must
      set the <varname>java.sign.alias</varname> and
      <varname>java.sign.storepass</varname> parameters, which
      correspond to the mandatory <option>alias</option> and
      <option>storepass</option> attributes of the
      <command>signjar</command> ant task.  You will usually also want
      to set the <varname>java.sign.keystore</varname> and
      <varname>java.sign.keypass</varname> parameters, corresponding
      to the <option>keystore</option> and <option>keypass</option>
      attributes to the <command>signjar</command> task.  In most
      cases, you will set these parameters in one place.  This place
      can be either a plugin or a single build item that all build
      items that sign JARs will depend on.  It's okay to put these in
      a plugin if all JARs in your project will be signed in the same
      way.
     </para>
     <para>
      Setting the above parameters is necessary in order to have any
      JARs be signed, but it is not sufficient; you must also indicate
      which JARs are to be signed, which you will generally do in the
      higher-level archive build item that actually does the signing.
      The usual way to do this is to set the
      <varname>java.jarsToSign</varname> parameter to a list of paths
      to JAR files that should be signed.  Although these JARs are
      typically created by other build items, you should never have
      your build item's <filename>Abuild.groovy</filename> file refer
      to JARs created by other build items directly by path even using
      a relative path.  Instead, you should always have the build item
      that creates the JAR file provide the path to the JAR file with
      an &abuild; interface variable, and you should add that to the
      <varname>java.jarsToSign</varname> parameter by calling
      <function>abuild.resolve</function> on the interface variable.
      This way, your build item will continue to work even if the one
      that provides the JAR file moves or is resolved in a backing
      area.
     </para>
     <para>
      It is also possible to arrange for JARs to be signed by having
      them appear in the <filename>abuild-java/signed-jars</filename>
      directory.  This case can be useful if the same build item that
      is signing the JAR files is also creating them, either because
      it is actually compiling Java code itself or because it is
      repackaging other JAR files.  However, if you find yourself
      writing code that just copies other JAR files into
      <filename>abuild-java/signed-jars</filename>, then you should
      probably be assigning the paths to the those JAR files to the
      <varname>java.jarsToSign</varname> parameter instead.
     </para>
     <para>
      Whichever method you use, or even if you use both methods
      together, the signed JARs will be placed in the
      <filename>abuild-java/signed-jars</filename> directory.  Since
      &abuild; will sign unsigned JARs in that directory, &abuild;
      invokes the <command>signjar</command> task with lazy JAR
      signing by default.  If it didn't, then every time you invoked
      &abuild;, it would re-sign all JAR files in that directory even
      if they were already signed.  Lazy JAR signing allows &abuild;
      to avoid repeatedly signing the same JARs, which makes it
      possible to have &abuild; do nothing if invoked on an area that
      is fully built.  (In other words, this allows builds to be
      <emphasis>idempotent</emphasis>.)  If you have a reason not to
      use lazy JAR signing, it is possible to disable it and override
      the JAR signing behavior to avoid re-signing the JARs, but this
      should seldom if ever be required.  For details on the full
      range of customization opportunities available, please see <xref
      linkend="ref.groovy.advanced-java"/>.
     </para>
    </sect2>
    <sect2 id="ref.java.war">
     <title>WAR Files</title>
     <para>
      If you wish to build a WAR file, you must set the
      <varname>java.warname</varname> parameter to the name of the WAR
      file and the <varname>java.webxml</varname> parameter to the
      path to the <filename>web.xml</filename> file for that WAR.  The
      <varname>java.webxml</varname> parameter may be set to a
      relative path, in which case it is resolved relative to the
      build item's top-level directory (the directory containing
      <filename>Abuild.groovy</filename>).  By default, &abuild; will
      package into <filename>WEB-INF/classes</filename> the contents
      of <filename>src/resources</filename>,
      <filename>abuild-java/classes</filename>,
      <filename>abuild-java/src/resources</filename> and any
      additional directories named in
      <varname>java.dir.extraResources</varname>.  It will also
      package at the root of the WAR file any files in
      <filename>src/web/content</filename>,
      <filename>abuild-java/src/web/content</filename>, and any
      directories named in
      <varname>java.dir.extraWebContent</varname>.  It will populate
      <filename>META-INF</filename> exactly as it does for JAR files.
      The <filename>WEB-INF</filename> directory will be populated
      from <filename>src/web/WEB-INF</filename>,
      <filename>abuild-java/src/web/WEB-INF</filename>, and any
      directories named in <varname>java.dir.extraWebinf</varname>.
      For additional information about creating WAR files, please see
      <xref linkend="ref.groovy.advanced-java"/>.
     </para>
    </sect2>
    <sect2 id="ref.java.high-level-archives">
     <title>High Level Archives</title>
     <para>
      &Abuild; includes default rules for creation of high-level
      archives, in addition to WAR and EAR files, that may contain
      other JAR files, including signed JARs.  To create a JAR-like
      high-level archive, set the parameter
      <varname>java.highLevelArchiveName</varname> to the name of the
      archive to be created.  By default, the archive is populated
      exactly as a regular JAR file is, including pulling files from
      all the same places.  In addition, by default, high-level
      archives contain all archives in the package class path at the
      root of the archive.  The list of additional files to package in
      the high-level archive can be customized along with all the
      things that can be customized for regular JAR files.  For
      details, see <xref linkend="ref.groovy.advanced-java"/>.
     </para>
    </sect2>
    <sect2 id="ref.java.ear">
     <title>EAR Files</title>
     <para>
      To create an EAR file, you must set the
      <varname>java.earName</varname> and
      <varname>java.appxml</varname> parameters.  EAR files are
      populated with the same files from the same places as high-level
      JAR-like archives, including packaging all items from the
      package class path at the root of the EAR file,
      <emphasis>except</emphasis> that they to not contain files from
      <filename>abuild-java/classes</filename>.  For additional
      information about customizing creation of EAR files, see <xref
      linkend="ref.groovy.advanced-java"/>.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.groovy.advanced-java">
    <title>Advanced Customization of Java Rules</title>
    <para>
     &Abuild;'s Java rules can be customized using a layered approach.
     At the most basic level, you can set specific parameters that
     tell &abuild; how to run its normal rules.  As you need more
     advanced functionality, you can override the locations that
     &abuild; uses for various types of files, pass additional
     arguments to various underlying ant tasks, cause targets to be
     run multiple times, or even supply your own Groovy closures to be
     run for specific tasks.  This is also described in &abuild;'s
     built-in help for the Java rules.  The help text is included in
     this document as well; see <xref linkend="ref.help.rule.java"/>.
    </para>
   </sect1>
   <sect1 id="ref.groovy.environment">
    <title>The &Abuild; Groovy Environment</title>
    <para>
     The <filename>Abuild.groovy</filename> file along with all rules
     implementation files are loaded as scripts by the Groovy backend.
     We have already discussed the <function>parameters</function>
     closure that is available within the
     <filename>Abuild.groovy</filename> file.  This closure is
     provided by being included in the <firstterm>binding</firstterm>,
     which is a mechanism used by Groovy to communicate with embedded
     scripts.  Here we discuss the remainder of the Groovy environment
     used by &abuild;
    </para>
    <sect2 id="ref.groovy.binding">
     <title>The Binding</title>
     <para>
      There are three variables provided through the binding to any
      Groovy script that &abuild; loads:
      <variablelist>
       <varlistentry>
        <term>
         <varname>abuild</varname>
        </term>
        <listitem>
         <para>
          An instance of the
          <classname>org.abuild.groovy.BuildState</classname> object,
          which holds onto all information about the state of the
          current build.  This includes information about parameters,
          targets, and other things as well.  We discuss the interface
          of this object in <xref
          linkend="ref.java.abuild-object-interface"/>, though most
          build items that don't implement any of their own rules will
          find their interaction with it limited to calling
          <function>abuild.resolve</function> if they have any
          interaction with it at all.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <varname>ant</varname>
        </term>
        <listitem>
         <para>
          An instance of a Groovy <classname>AntBuilder</classname>
          object set up with an ant <classname>Project</classname>
          specific for &abuild;.  We discuss the ant project in more
          detail in <xref linkend="ref.groovy.ant-project"/>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <varname>parameters</varname>
        </term>
        <listitem>
         <para>
          A closure that provides an environment for convenient
          setting of parameters.  We discussed this above in <xref
          linkend="ref.groovy.parameter-blocks"/>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </sect2>
    <sect2 id="ref.groovy.ant-project">
     <title>The Ant Project</title>
     <para>
      &Abuild; creates a fresh ant project for each build item that it
      builds.  No information is passed between build items through
      the ant project.  The only mechanism for passing information
      between &abuild; build items is the interface system.  This
      barrier is critical to &abuild;'s scalability.  It also results
      in using the same mechanism to pass information between build
      items regardless of whether the build items use the same
      backend, which is important for support true cross-language
      development.
     </para>
     <para>
      The primary mechanism for passing information between a build
      item and the rules used to build it is through setting and
      resolving parameters, but &abuild; also provides some
      information through ant properties.  Specifically, when you
      define a variable on &abuild;'s command line, that variable
      becomes available as an ant property in addition to being
      visible to <function>resolve</function> in &abuild;'s parameter
      blocks (or to <function>abuild.resolve</function> from anywhere
      in the &abuild; Groovy environment).
      <footnote>
       <para>
        Truth be told, the primary reason for this is that the same
        ant project is passed to the Groovy backend as to the
        deprecated xml-based ant backend, for which properties are the
        only useful way of sending in information.  However, setting
        these properties certainly doesn't hurt, and it might even
        help, so we will continue to do it.
       </para>
      </footnote>
     </para>
     <para>
      Additionally, &abuild; will set the project's logger and log
      level based on how it was invoked, and &abuild; will also set
      the <varname>basedir</varname> property to the output directory
      of the current build item.  Note that since all Java builds are
      running in one JVM, &abuild; cannot change the current
      directory.  All well-behaved ant tasks are supposed to resolve
      relative paths to <varname>basedir</varname> anyway though, so
      this should generally not matter.  If you find builds failing
      with odd messages about missing files or directories below where
      you happened to start &abuild;, it may be because of relative
      paths being passed to incorrectly implemented ant tasks.  In
      this case, you can usually just prepend
      <literal>${basedir}/</literal> to the relative path you are
      providing as an attribute.
     </para>
     <para>
      Note that, although &abuild; makes full use of ant tasks through
      the ant project and the ant builder, &abuild; does not use ant's
      target facility.  Instead, it defines its own with target bodies
      being provided by Groovy closures.  This provides much greater
      flexibility and ease of implementation.
     </para>
    </sect2>
    <sect2 id="ref.groovy.variables">
     <title>Parameters, Interface Variables, and Definitions</title>
     <para>
      We have discussed how to set and resolve parameters within an
      <filename>Abuild.groovy</filename> file, but we have only just
      glossed over interface variables and variable definitions passed
      on &abuild;'s command line.  Most of the time, you don't have to
      be concerned about the distinction, but sometimes it might be
      important.  If the explanation in this section doesn't make
      sense to you, just skip it for now.  You may never need to
      understand the distinctions made here, but if something isn't
      working the way you expect, you can always refer back to this
      section.
     </para>
     <para>
      &Abuild;'s groovy backend actually maintains three separate
      namespaces of variables: parameters, interface variables, and
      definitions.  Of these, the only ones you can actually modify
      from an <filename>Abuild.groovy</filename> file are parameters,
      so any assignment made in a parameter block affects a parameter.
      However, calls to <function>resolve</function> have access to
      interface variables and definitions.  As a reminder, parameters
      are set explicitly in parameters blocks.  Interface variables
      come from &abuild;'s interface system and are set in
      <filename>Abuild.interface</filename> files.  Definitions are
      passed on &abuild;'s command line through arguments of the form
      <option>VAR=value</option>.  When you resolve a variable with
      <function>resolve</function>, here is exactly what happens:
      <itemizedlist>
       <listitem>
        <para>
         If there is a <emphasis>definition</emphasis> of that
         variable that was passed on &abuild;'s command line, return
         that value.
        </para>
       </listitem>
       <listitem>
        <para>
         Otherwise, if there is a <emphasis>parameter</emphasis> by
         the name, return the value of the parameter.
        </para>
       </listitem>
       <listitem>
        <para>
         Otherwise, if there is an <emphasis>interface
         variable</emphasis> by that name, return that value
        </para>
       </listitem>
       <listitem>
        <para>
         Otherwise, return null
        </para>
       </listitem>
      </itemizedlist>
      When you append to a parameter in a parameter block (or by
      calling <function>abuild.appendParameter</function>), if there
      is no parameter with the name of the variable that you are
      appending to, &abuild; will first try to initialize the
      parameter by calling <function>resolve</function>.  This means
      that if you initialize something as an interface variable and
      then append to it in a parameter block,
      <function>resolve</function> will return a value that is the
      interface variable's value appended with the changes made in
      your parameter block.  However, since definitions take
      precedence over both interface variables and parameters, if you
      specify the value of a variable on the command line, the affect
      of modifying a parameter by the same name will be ignored by
      future calls to <function>resolve</function>.  What this all
      means is that variables defined on the command line effectively
      override any values specified in the interface or build files.
      This is equivalent to the behavior you would see with make or
      ant.
      <footnote>
       <para>
        It is possible to get at the interface, definitions, and
        parameters directly through the <varname>abuild</varname>
        object, but you shouldn't do it.  If you are in a situation
        where you are depending on that behavior, you're probably
        doing something wrong.
       </para>
      </footnote>
      If the above explanation didn't make a lot of sense, don't worry
      about it.  It's set up so that the Right Thing happens most of
      the time without your having to worry about it.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.groovy.qtest">
    <title>Using QTest With the Groovy Backend</title>
    <para>
     For simple QTest-based test suites, nothing unusual is required:
     just create your <filename>.test</filename> files in the
     <filename>qtest</filename> directory as always.  If you are using
     QTest's coverage system, you can assign the names of the source
     files containing coverage calls to the <varname>TC_SRCS</varname>
     parameter, which &abuild; will automatically export to the
     environment.  &Abuild; also automatically exports
     <varname>TESTS</varname>, so you can pass it on the
     <command>abuild</command> command line (e.g. <command>abuild
     TESTS="one two"</command> to run <filename>one.test</filename>
     and <filename>two.test</filename>) if you want to run a subset of
     your tests.
    </para>
    <para>
     The easiest way to pass information from your build into your
     test suite is through environment variables.  For example, you
     may need to pass in the path of a configuration file or JAR file
     so that your test suite can find it.  To do this, you can create
     parameters containing those values and then append the names of
     the parameters to the <varname>qtest.export</varname> parameter.
     For each value in <varname>qtest.export</varname>, an upper-case
     version of the variable name is exported to the environment with
     the value returned by calling <varname>resolveAsString</varname>
     on that parameter.  For example, if you had the following
     parameter block in your <filename>Abuild.conf</filename>:

     <programlisting>parameters {
    TEST_CONFIG = 'test_config.xml'
    qtest.export &lt;&lt; 'TEST_CONFIG'
    // other standard parameters ...
}
</programlisting>
     your test suites would be able to reference
     <literal>$ENV{'TEST_CONFIG'}</literal> to retrieve the value
     <literal>test-config.xml</literal>.
    </para>
   </sect1>
   <sect1 id="ref.java.groovy">
    <title>Groovy Rules</title>
    <para>
     The <filename>groovy</filename> rule set, available by setting
     <varname>abuild.rules</varname> to <literal>['java',
     'groovy']</literal>, adds the ability to build Groovy code to the
     functionality of the <filename>java</filename> rules.  The basic
     functionality is that all <filename>.groovy</filename> files in
     the <filename>src/groovy</filename> and
     <filename>abuild-java/src/groovy</filename> directories are
     compiled to <filename>.class</filename> files and written to the
     <filename>abuild-java/classes</filename> directory.  The order in
     which Java and Groovy sources are compiled is determined by the
     order in which <filename>java</filename> and
     <filename>groovy</filename> are added to
     <varname>abuild.rules</varname>, but you must include
     <filename>java</filename> if you include
     <filename>groovy</filename>.  If you have a build item that
     builds both Java and Groovy code, you should avoid having
     circular dependencies between your Java and Groovy code.  If your
     Groovy classes make calls into your Java code, list
     <filename>java</filename> in your <varname>abuild.rules</varname>
     parameter first.  If your Java code makes calls to your Groovy
     code, then include <varname>groovy</varname> first.  For
     additional information on how to customize compilation of Groovy
     code, refer to &abuild;'s online help for the
     <filename>groovy</filename> rules.  This help text is included in
     <xref linkend="ref.help.rule.groovy"/>.
    </para>
   </sect1>
   <sect1 id="ref.java.for-rule-authors">
    <title>Additional Information for Rule Authors</title>
    <para>
     The following sections describe Groovy interfaces of objects that
     are available to rule programmers.
    </para>
    <sect2 id="ref.java.abuild-object-interface">
     <title>Interface to the <classname>abuild</classname> Object</title>
     <para>
      The <varname>abuild</varname> variable, provided in the Groovy
      binding to all scripts run in &abuild;, is the primary object
      that you will interact with.  Here we describe its intended
      public interface.
      <footnote>
       <para>
        Groovy 1.x does not enforce access control on method or field
        invocations.
       </para>
      </footnote>
     </para>
     <!--  NOTE: Use <function>f(args)</function> and              -->
     <!--  <varname>field</varname> rather than messing around     -->
     <!--  with <replaceable/>, etc. since it makes the text look  -->
     <!--  more uniform.                                           -->
     <sect3 id="ref.abuild-object.accessing-parameters">
      <title>Accessing Parameters</title>
      <para>
       These methods are used to access the values of definitions,
       parameters, and interface variables.  They can be used either
       in <filename>Abuild.groovy</filename> files or in custom rule
       code.
      </para>
      <variablelist>
       <varlistentry>
        <term>
         <function>resolve('name',defaultValue)</function>
        </term>
        <listitem>
         <para>
          If <replaceable>name</replaceable> represents a definition
          (specified with <option>VAR=val</option> on the command
          line), return the definition value.  Otherwise, if a
          parameter named <replaceable>name</replaceable> is a
          parameter, return the parameter value.  Otherwise, if
          <replaceable>name</replaceable> is an interface variable,
          return the value of the interface value.  Otherwise, return
          <varname>defaultValue</varname>.
         </para>
         <para>
          The implementation of this method is what is responsible
          for implementing the effect of command-line definitions
          overriding parameter settings and interface variables,
          which gives the Groovy backend the same behavior as make
          and ant.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>resolve('name')</function>
        </term>
        <listitem>
         <para>
          calls
          <function>resolve('name', null)</function>
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>resolveAsString('name', defaultValue)</function>
        </term>
        <listitem>
         <para>
          If <function>resolve('name', defaultValue)</function>
          returns other than null or a string, fail.  Otherwise,
          return value as type String.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>resolveAsString('name')</function>
        </term>
        <listitem>
         <para>
          calls <function>resolveAsString('name', null)</function>
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>resolveAsList('name', defaultValue)</function>
        </term>
        <listitem>
         <para>
          If <function>resolve('name', defaultValue)</function>
          returns a list, return that value.  Otherwise, return a
          list containing that value.  This makes it convenient to
          deal with parameters whose values may contain a single
          value or a list of values without having to handle the
          special case in the target.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </sect3>
     <sect3 id="ref.abuild-object.modifying-parameters">
      <title>Modifying Parameters</title>
      <para>
       Most of the time, you will set and modify parameters inside a
       parameter block (<xref
       linkend="ref.groovy.parameter-blocks"/>).  Setting and
       modifying parameters inside a parameter block is essentially
       just &ldquo;syntactic sugar&rdquo; for the underlying
       interface, which is described here.  This interface is
       available if you need to modify parameters from somewhere other
       than a parameter block.
      </para>
      <variablelist>
       <varlistentry>
        <term>
         <function>setParameter('name', value)</function>
        </term>
        <listitem>
         <para>
          Sets parameter <replaceable>name</replaceable> to
          <varname>value</varname>, replacing any previous value that
          may have been set.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>appendParameter('name', value)</function>
        </term>
        <listitem>
         <para>
          If parameter <replaceable>name</replaceable> has been
          previously set with <function>setParameter</function> (and
          not subsequently deleted), this is an error.  Otherwise,
          makes the value of the parameter a list and appends
          <varname>value</varname> to it.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>deleteParameter('name')</function>
        </term>
        <listitem>
         <para>
          Removes any previous value for parameter
          <replaceable>name</replaceable>.  Note that if an interface
          variable by the same name exists, deleting the parameter
          will re-expose the value of the interface variable to calls
          to <function>resolve</function>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </sect3>
     <sect3 id="ref.abuild-object.build-environment">
      <title>Build Environment</title>
      <para>
       The following methods supply information about the build
       environment.  These are most often used from within rule code,
       but they can also be useful in
       <filename>Abuild.groovy</filename> for setting parameter
       values.
      </para>
      <variablelist>
       <varlistentry>
        <term>
         <varname>buildDirectory</varname>
        </term>
        <listitem>
         <para>
          A <classname>File</classname> object containing the build
          directory (the &abuild; output directory)
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <varname>sourceDirectory</varname>
        </term>
        <listitem>
         <para>
          A <classname>File</classname> object containing the source
          directory (the build item directory)
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <varname>itemPaths[item]</varname>
        </term>
        <listitem>
         <para>
          Contains The full path to the given build item.  This is
          intended primarily for rule code to get the location of the
          build item providing the rule code
          (<emphasis>i.e.</emphasis>, for build items to get
          <emphasis>their own</emphasis> paths) or, in some cases,
          paths of items they directly control or contain.  Paths are
          only available for items in the dependency chain of the
          current build item.
          <warning>
           <para>
            You should not use <varname>itemPaths</varname> to find
            the location of arbitrary build items.  If you need
            information about where something is in a build item, the
            build item in question should provide that information
            through an interface variable.
           </para>
          </warning>
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </sect3>
     <sect3 id="ref.abuild-object.target-configuration">
      <title>Target Configuration</title>
      <para>
       These methods are used to create or modify targets.  You would
       call these methods from custom rule code.  They would not be
       called from <filename>Abuild.groovy</filename>.
      </para>
      <variablelist>
       <varlistentry>
        <term>
         <function>configureTarget('name', named parameters) { closure }</function>
        </term>
        <listitem>
         <para>
          Registers target <replaceable>name</replaceable>;
          <emphasis>i.e.</emphasis>, causes it to exist if it does not
          already exist.
         </para>
         <para>
          If a closure is provided, adds it to the list of closures
          for target <replaceable>name</replaceable>.
         </para>
         <para>
          If the <option>deps</option> named parameter is specified,
          its value must be a string or a list of strings representing
          dependencies.  Each dependency is added as a dependency of
          target <replaceable>name</replaceable>.
         </para>
         <para>
          If the <option>replaceClosures</option> named parameter is
          specified, its value must be a boolean.  If
          <literal>true</literal>, any previous closures associated
          with <replaceable>name</replaceable> are removed before
          adding any newly specified closure.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>configureTarget('name')</function>
        </term>
        <listitem>
         <para>
          Calls the three-argument
          <function>configureTarget</function> with no named
          parameters or closure body; <emphasis>i.e.</emphasis>, just
          causes the target to exist.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>addTarget('name')</function>
        </term>
        <listitem>
         <para>
          Synonym for <function>configureTarget('name')</function>
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>configureTarget('name', named parameters)</function>
        </term>
        <listitem>
         <para>
          Calls the three-argument
          <function>configureTarget</function> with no closure body
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>addTargetDependencies('name', ['dep1', 'dep2'])</function>
        </term>
        <listitem>
         <para>
          Calls <function>configureTarget('name', 'deps': ['dep1',
          'dep2'])</function>; <emphasis>i.e.</emphasis>, creates the
          target and adds to its dependency list
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>configureTarget('name') { closure }</function>
        </term>
        <listitem>
         <para>
          Calls three-argument <function>configureTarget</function>
          with no named parameters
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>addTargetClosure('name') { closure }</function>
        </term>
        <listitem>
         <para>
          Synonym for <function>configureTarget('name') { closure }</function>
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </sect3>
     <sect3 id="ref.abuild-object.build-support">
      <title>Build Support</title>
      <para>
       The following methods are provided for use in custom rules.
      </para>
      <variablelist>
       <varlistentry>
        <term>
         <function>runActions(String targetParameter, Closure defaultAction, Map defaultAttributes)</function>
        </term>
        <listitem>
         <para>
          <varname>targetParameter</varname> is the name of a
          parameter that, if defined, resolves to a list whose
          elements are either maps or closures.  If not defined, it is
          treated as if its value were a list containing an empty map.
         </para>
         <para>
          For each element in the resulting list, if it is a closure,
          call it.  If it is a map, then expand the map by copying
          entries from defaultAttributes for keys that are not present
          in the map.  Then call
          <function>defaultAttributes</function> on the resulting map.
         </para>
         <para>
          For an example of <function>runActions</function>, see <xref
          linkend="ref.example.code-generator.groovy"/>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>fail(String message)</function>
        </term>
        <listitem>
         <para>
          Causes the build to fail immediately by throwing an instance
          of <classname>AbuildBuildFailure</classname>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>error(String message)</function>
        </term>
        <listitem>
         <para>
          Issues an error message and continues to the end of the
          closure.  After the closure finishes, the build is
          considered to have failed, so unless <option>-k</option> has
          been specified, no additional closures will be called.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>runTarget(target)</function>
        </term>
        <listitem>
         <para>
          If <replaceable>target</replaceable> has not yet been run,
          runs <replaceable>target</replaceable> preceded by its full
          dependency chain.  No target is ever run more than once.
         </para>
         <para>
          It is seldom necessary to call
          <function>runTarget</function>.  It is generally better to
          let targets get run automatically through the dependency
          chain, though there are some instances in which it might
          make sense to use this method.  For example, &abuild; uses
          it internally to have the <command>check</command> and
          <command>test</command> targets depend on
          <command>all</command> and call
          <command>test-only</command>, making it possible for
          <command>test-only</command> to provide test functionality
          without have any of its own dependencies.  Without this
          facility, it would be necessary to implement the test
          functionality multiple times as is the case with the make
          backend.  The <function>runTarget</function> method gives
          this Groovy-based build framework capability beyond what can
          be done with make's target framework.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <function>runTargets([target, ...])</function>
        </term>
        <listitem>
         <para>
          Runs each target specified in the order given subject to the
          constraints that no target is run more than once and that no
          target is run before all of its dependencies have been run.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </sect3>
    </sect2>
    <sect2 id="ref.java.abuild-util">
     <title>Using <classname>org.abuild.groovy.Util</classname></title>
     <para>
      The <classname>org.abuild.groovy.Util</classname> class provides
      a small number of static methods and fields that may be useful
      to rule authors.  You can gain access to this class by importing
      it in your Groovy code.
      <itemizedlist>
       <listitem>
        <para>
         <function>absToRel(path, basedir)</function>: convert
         <varname>path</varname> into a path relative to
         <varname>basedir</varname>.  Most of the time, you need
         absolute paths, which you can easily get from the
         <classname>File</classname> object, but sometimes you
         explicitly need a relative path, such as when generating
         relative links.  This method can help you with that task.
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>inWindows</varname>: a field whose value is true if
         you are in a Windows environment.  You should use this very
         sparingly as it is possible to create platform-dependent
         output files in what is supposed to be a platform-independent
         directory.  (See <xref linkend="ref.best-practices"/> for a
         discussion.)  However, sometimes when you are executing
         external programs, it becomes necessary to do it different on
         a Windows system from a UNIX system.  This field can help you
         in those cases.
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect2>
   </sect1>
  </chapter>
  <chapter id="ref.output-processing">
   <title>Controlling and Processing &Abuild;'s Output</title>
   <para>
    When examining the output of a large build, it is desirable to be
    able to scan the output of the build to look for errors and
    warnings, and even to be able to associate specific lines of
    output with the build items that produced them.  In versions of
    &abuild; prior to 1.1.3, the output of a multithreaded build would
    consist of outputs from the builds of multiple build items all
    interleaved with each other in arbitrary ways.  This would make
    the output virtually impossible to parse programmatically and even
    tricky for a human reader to fully understand.  This chapter
    introduces features that help to improve the usability of
    &abuild;'s output.  They are most useful for multithreaded builds,
    but in some cases, they can help with single-threaded builds as
    well.
   </para>
   <sect1 id="ref.output-processing.introduction">
    <title>Introduction and Terminology</title>
    <para>
     When &abuild; is used to perform a build, the overall build
     process consists of several <firstterm>phases</firstterm>: a
     check phase, a build phase, and a summary phase.  In the check
     phase, &abuild; reads and validates
     <filename>Abuild.conf</filename> files, performs integrity
     checks, and so forth.  In the build phase, &abuild; walks through
     the dependency graph and invokes backend processes to perform the
     actual build steps.  After the build phase is complete, the
     summary phase includes a summary of any failures as well as an
     indication of elapsed time.
    </para>
    <para>
     During the build phase, &abuild; invokes various backend programs
     to individually build each item on each of its platforms.  For
     purposes of discussion, we refer to those individual builds as
     <firstterm>jobs</firstterm>.  A job always corresponds to a
     specific build item being built on a specific platform.
    </para>
    <para>
     When &abuild; invokes backend processes to do the actual build
     steps, it may either capture the output of the backend processes
     or it may let the backend processes inherit standard input,
     standard output, and standard error from &abuild; itself.  We
     refer to the way in which &abuild; handles the output of its
     backend programs as its <firstterm>output mode</firstterm>.
    </para>
   </sect1>
   <sect1 id="ref.output-processing.output-modes">
    <title>Output Modes</title>
    <para>
     <indexterm>
      <primary>output modes</primary>
     </indexterm>
     Each line of &abuild;'s output can come from one of two sources:
     either &abuild; can generate the output itself, or the output can
     come from one of the backends invoked on behalf of the individual
     job.  The backend output would include output from programs like
     make or ant or from anything they may invoke, such as compilers.
     &Abuild; can either capture and process output from its backends,
     or it can just let the backends use the same standard input,
     output, and error as &abuild; itself.  We refer to what &abuild;
     does with its output as its <firstterm>output mode</firstterm>.
    </para>
    <para>
     &Abuild; has three output modes: <firstterm>raw mode</firstterm>,
     <firstterm>interleaved mode</firstterm>, and <firstterm>buffered
     mode</firstterm>.  In interleaved and buffered modes, each job is
     run with standard input connected to the null device
     (<filename>/dev/null</filename> in UNIX environments and
     <filename>NUL</filename> in Windows environments) and with
     standard output and standard error redirected to two separate
     pipes.  &Abuild; reads from each job's output and error pipes and
     process the results with its own logging facility.
    </para>
    <para>
     In raw mode, &abuild; invokes backend processes without capturing
     their output.  The backend processes just write to the same
     standard output and standard error as &abuild; itself uses.
     Additionally, each backend has access to &abuild;'s standard
     input, which makes it possible for builds to prompt the user for
     input.  For single-threaded builds, &abuild;'s default behavior
     is to run in the raw mode.  This was the only output mode
     available in versions of &abuild; prior to 1.1.3.  To explicitly
     tell &abuild; to use raw output mode, specify the
     <option>--raw-output</option> flag when invoking &abuild;.
    </para>
    <para>
     In interleaved mode, every job is assigned a specific
     <firstterm>job prefix</firstterm>, which is a fixed-length
     (possibly zero-filled) number enclosed in square brackets.  Every
     line of output generated by &abuild; itself, as well as every
     complete line generated by the backend, is prefixed with the job
     prefix and then written to &abuild;'s standard output or standard
     error as appropriate.  Messages generated by &abuild; are written
     immediately, and lines generated by the jobs' backends are
     written as soon as they are received through the pipes.  By using
     the job prefix, it is possible to unambiguously associate each
     line of &abuild;'s output with the job (build item/platform) that
     generated it while still having each line of output written as
     soon as it is generated.
    </para>
    <para>
     For multithreaded builds, &abuild; runs in interleaved mode by
     default.  Interleaved mode may be specifically requested by
     passing the <option>--interleaved-output</option> flag to
     &abuild;.  If <option>--interleaved-output</option> is specified
     for a single-threaded build, &abuild; still runs the backend
     through pipes and disconnected from standard input, but it does
     not prepend each line with a job prefix.
    </para>
    <para>
     In buffered mode, rather than prefixing lines with a job prefix
     and outputting them as soon as they are available, &abuild; saves
     up (buffers) all the output from a particular job and outputs it
     all at once when the job completes.  This ensures that, even for
     a multithreaded build, there is no interleaving of output from
     the builds of different build items.  To enable buffered output,
     invoke &abuild; with the <option>--buffered-output</option> flag.
    </para>
   </sect1>
   <sect1 id="ref.output-processing.output-prefixes">
    <title>Output Prefixes</title>
    <para>
     When &abuild; invokes a backend, anything that the backend writes
     to its standard error will ultimately be written to &abuild;'s
     standard error, and likewise, anything the backend writes to
     standard output will end up on &abuild;'s standard output.  This
     makes it possible to use shell redirection for standard output
     and standard error even when using interleaved or buffered output
     modes.  However, separation of standard output from standard
     error removes needed context from error messages, so it's very
     useful to be able to distinguish output lines from error lines
     when looking at the complete output of a build.
    </para>
    <para>
     This can be achieved by setting a specific prefix to be prepended
     to all normal output lines and/or all error output lines.  To
     specify a prefix to be prepended to non-error output lines, use
     the
     <option>--output-prefix=<replaceable>prefix</replaceable></option>
     option.  To specify a prefix to be prefix to error lines, use
     <option>--error-prefix=<replaceable>prefix</replaceable></option>.
     If either of these options is specified and no output mode has
     been explicitly selected, &abuild; will use interleaved output
     mode, even for single-threaded builds.  If raw output mode is
     explicitly selected, then any output or error prefix
     specifications will be ignored.
    </para>
    <para>
     To make programmatic distinction of output lines from error lines
     in &abuild;'s output, it is recommended that you specify output
     and error prefixes of the same length.  To make error messages
     stand out, you could run &abuild; with
     <option>--error-prefix=<literal>'E&nbsp;&nbsp;&nbsp;'</literal>
     --output-prefix=<literal>'&nbsp;&nbsp;&nbsp;&nbsp;'</literal></option>
     (setting the output prefix to a number of spaces equal in length
     to the size of the error prefix).  This way, you could be sure
     that all lines as originally created by &abuild; or its backends
     would start in the same column of the prefixed output, and that
     the first column of the prefixed output would contain
     <literal>E</literal> for any error or warning.  Another way to
     make error messages stand out would be to omit the error prefix
     entirely and to specify an output prefix consisting of several
     space characters.  This would cause all output lines to be
     indented, making it easy to visually scan the build output for
     error messages.  Note that this approach is not unambiguous
     because you can't tell output lines from error lines that happen
     to start with several spaces.  But for a human reader, it may be
     more to your preference.
    </para>
   </sect1>
   <sect1 id="ref.output-processing.output-parsing">
    <title>Parsing Output</title>
    <para>
     A principal goal of adding output capture modes, output prefixes,
     and error prefixes to &abuild; was to make it easier to
     programmatically parse &abuild;'s output.  By combining these
     features, it is possible to run &abuild; in batch mode and to
     then unambiguously associate each line of &abuild;'s output with
     the specific platform build of the specific build item that was
     responsible for producing that line of output.
    </para>
    <para>
     This section describes how such a parser could be implemented.
     You can also find an example parser implementation in
     <filename>misc/parse-build-output</filename> relative to the top
     of your &abuild; distribution.  (You can always find the top of
     the &abuild; distribution by running <command>abuild
     --print-abuild-top</command>.)  Since a Perl script is worth a
     thousand words (as they say), and since the
     <command>parse-build-output</command> script is actually tested
     in &abuild;'s test suite, it can serve as a tool for helping you
     understand the details of &abuild;'s output as well as being a
     great starting point for writing your own parser.
    </para>
    <para>
     When &abuild; performs a build, the overall build consists of a
     check phase, a build phase, and a summary phase.  In the check
     phase, &abuild; reads and validates
     <filename>Abuild.conf</filename> files, performs integrity
     checks, and so forth.  Under normal conditions, the check phase
     doesn't produce any output.  If everything is in order at the end
     of the check phase, the build phase begins.  Immediately before
     beginning the build phase, &abuild; always outputs the line

     <programlisting>abuild: build starting
</programlisting>
     Immediately following the build phase, &abuild; outputs the line

     <programlisting>abuild: build complete
</programlisting>
     After the build phase is complete, &abuild; will output a summary
     of any failures that may have occurred as well as a report of the
     total duration of the build.  Parsers may use the <literal>build
     starting</literal> and <literal>build complete</literal> lines as
     shown above to demarcate the build phase.
    </para>
    <para>
     Within the build phase, output can be associated with a build
     item/platform pair (referred to here as a
     <firstterm>job</firstterm>) in the following way:
     <itemizedlist>
      <listitem>
       <para>
        If output/error prefixes are specified, they always precede
        any job prefixes generated in interleaved mode.  Strip them
        from the beginning of each line.  For this to work
        unambiguously, it is easiest if you use output and error
        prefixes of the same length.
       </para>
      </listitem>
      <listitem>
       <para>
        In interleaved mode, all lines of output that are part of a
        build start with a number enclosed in square brackets and
        followed by a single space.  It is possible for some lines not
        to start this way, but such cases indicate an unusual error or
        failure condition and are discussed later in this section.
       </para>
      </listitem>
      <listitem>
       <para>
        The first line of output from a build of a given item on a
        given platform will always start with

        <programlisting>abuild: <replaceable>item-name</replaceable> (<replaceable>abuild-output-directory</replaceable>)
</programlisting>
        possibly followed by other text or punctuation.  This will
        always be at the beginning of the line, after removing any
        output, error, or job prefixes.
       </para>
       <para>
        In interleaved mode, the above can be parsed the first time a
        line appears with a given job prefix to associate the job
        prefix with the job.
       </para>
       <para>
        In buffered mode, if a line that matches the above pattern is
        the first line to mention a specific item/platform pair, it
        marks the beginning of output for that job, and all subsequent
        lines until a line that indicates the start of a different job
        or the end of the build phase belong to that job.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     There are a few exceptions to the above rules, but they only
     happen in cases of serious errors, and most parsers can safely
     ignore them, as long as they treat unexpected input as general
     error conditions.  (The sample parser actually does take these
     cases into consideration.)  Specifically, in both buffered and
     interleaved mode, certain major errors from the java builder
     process, such as abnormal termination or &ldquo;rogue
     output&rdquo; from the java backend, can result in asynchronous
     output from the java builder.
     <footnote>
      <para>
       The java builder process may run multiple ant jobs in separate
       threads.  It separates the output of different projects by
       creating each ant thread in a separate thread group and
       associating a job identifier with the thread group.  There are
       two ways the java builder process could create rogue output:
       one is for an ant task to create a thread in a separate thread
       group and to have that thread write something to standard
       output or standard error, and the other is for the java builder
       process itself to generate output.  The former case is very
       unlikely, and the latter case would indicate a bug in the java
       builder process, or a severe error such as failure of the JVM.
       Additionally, if the java builder process crashes, &abuild;
       will generate a message that indicates this, and that message
       would not be associated with any build.
      </para>
     </footnote>
     In interleaved builds with multiple threads, this output is
     prefixed with the string
     &ldquo;<literal>[JavaBuilder]&nbsp;</literal>&rdquo;.  In
     buffered builds, it is not marked in any way, but will always
     appear between the uninterrupted outputs from individual jobs.
     Most parsers would probably end up associating such output with
     the job that had most recently completed, which would probably be
     wrong, but again, this is a very rare case.  In a single-threaded
     build, any rogue output from the java builder process would have
     to be related to the job that is in progress, so the fact that it
     is unmarked doesn't pose any problems.
    </para>
    <para>
     In any case, any line of output that doesn't conform to the
     output that the parser expects should just be treated as a
     general error from &abuild;.  Such a line either indicates a
     serious problem with &abuild; itself (such as an assertion
     failure or abnormal termination, probably indicating a bug in
     &abuild; or a system error) or a bug in the parser.  Either way,
     the output should be preserved.
    </para>
   </sect1>
   <sect1 id="ref.output-processing.caveats">
    <title>Caveats and Subtleties of Output Capture</title>
    <para>
     When &abuild; is running in one of the output capture modes
     (interleaved or buffered), it sends the outputs of any backend
     build commands through a pair of pipes (one for standard output
     and one for standard error), reads from those pipes, and sends
     the results through its own logging facility.  This is usually
     harmless, but there are several minor issues that can result:
     <itemizedlist>
      <listitem>
       <para>
        By default, standard output is usually block-buffered when
        output is written to a pipe, while standard error is usually
        unbuffered.  This means that, unless a program takes explicit
        action to flush (or unbuffer) its output, error messages could
        appear in the output earlier than they otherwise would.
       </para>
       <para>
        In practice, this is not expected to be a real problem.  The
        reason is that it is extremely common to run builds with
        output redirected to pipes or files&mdash;virtually all
        continuous integration packages or automated build scripts do
        this.  As such, virtually every commonly used build program
        already unbuffers its output.  If you have been previously
        running &abuild; with its output going to a pipe or into a
        file and haven't noticed any re-ordering of output and error,
        then this issue is not likely to affect you.
       </para>
      </listitem>
      <listitem>
       <para>
        Even if the program that &abuild; invokes unbuffers its
        output, there's still a possibility that an individual error
        line may appear earlier or later by a small distance than it
        would under ordinary conditions.  The reason for this is that
        &abuild; runs with standard output and standard error
        redirected through two separate pipes, which opens up the
        possibility of a race condition.  If, as &abuild; reads data
        from the two pipes, both pipes have data ready to be readb at
        the same time, it is possible that &abuild; may read them in a
        different order from the order in which the pipes were
        written.  There is no solution to this problem as the
        information about when the pipes were written is simply not
        available.  This is a necessary cost of being able to
        distinguish standard output from standard error.  In practice,
        it doesn't usually pose any real problems&mdash;the misplaced
        error line will still be unambiguously associated with a
        specific job.
       </para>
      </listitem>
     </itemizedlist>
     <itemizedlist>
      <listitem>
       <para>
        As &abuild; reads the output and error pipes of the programs
        it invokes, it sends them to &abuild;'s output or error
        streams a line at a time.  Although it is rare for a program
        to interleave standard output and standard error within a
        single line, if it does, &abuild; will end up separating the
        text onto separate lines.  This is an inevitable consequence
        of the fact that &abuild; uses separate pipes for standard
        output and standard error, and it may actually be desirable in
        some instances.
       </para>
      </listitem>
      <listitem>
       <para>
        If the last line of output (or error) from a program that
        &abuild; invokes does not end with a newline, &abuild; will
        append the string <literal>[no newline]</literal> followed by
        a newline to the line.  This way all lines output by &abuild;
        end with a newline.  This ensures that &abuild;'s own output
        is always anchored to the beginning of a line.
       </para>
      </listitem>
      <listitem>
       <para>
        If you interrupt &abuild; abnormally, for example, by hitting
        CTRL-C, &abuild; will let the operating system terminate it in
        the usual way.  This means that any partially read output from
        a pipe will be lost.  In interleaved mode, any lost output
        would generally be less than one line of output, though it
        could be more in the (unlikely )case of unbuffered pipes.  In
        buffered mode, all the output from any partially completed job
        will be lost.  Note that no output is ever lost if &abuild; is
        allowed to terminate on its own, unless it terminates as a
        result of an internal error or assertion failure, which would
        never occur during routine operation.  (An error in a specific
        build would never cause that to happen.)
       </para>
      </listitem>
      <listitem>
       <para>
        In buffered mode, since &abuild; doesn't output anything for a
        given item's build until that item's build is completed, it is
        possible that &abuild; could sit for a long time without
        generating any output.  &Abuild; gives no indication of
        in-progress builds in buffered mode.  If you need continuous
        feedback, use interleaved mode instead.  (This is the main
        reason that interleaved mode is the default for multithreaded
        builds even though buffered output is a little easier to
        read.)  Note that monitored mode (<xref
        linkend="ref.monitored-mode"/>) can be combined with
        interleaved or buffered mode, and that any output generated by
        monitored mode will be interleaved between item builds when
        &abuild; is running in buffered mode.  The sample parser makes
        no provisions for handling monitored mode output.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.shared-libraries">
   <title>Shared Libraries</title>
   <para>
    In most cases, development efforts consisting of large amounts of
    dynamic and evolving code will be best served by sticking with
    static libraries.  Sometimes, however, it may be desirable or
    necessary to create shared library object files.  &Abuild;
    provides support for creating shared libraries on UNIX-based
    systems and DLLs on Windows systems.  Note that there are many
    ancillary concerns one must keep in mind when using shared
    libraries such as binary interface compatibility.  We touch
    lightly on these topics here, but a full discussion is out of
    scope for this document.
   </para>
   <sect1 id="ref.building-shared-libraries">
    <title>Building Shared Libraries</title>
    <para>
     Building shared libraries with &abuild; is essentially identical
     to building static libraries.  You still set up your shared
     library targets using <varname>TARGETS_lib</varname> in
     <filename>Abuild.mk</filename> just as you would for static
     libraries.  In order to tell &abuild; that a library should be
     created as a shared library, you must set the additional variable
     <varname>SHLIB_<replaceable>libname</replaceable></varname> where
     <replaceable>libname</replaceable> is the name of the library
     target.  The value of this variable consists of up to three
     numbers: <varname>major version</varname>, <varname>minor
     version</varname>, and <varname>revision</varname>.  These values
     tell potential users of your library when the library has
     changed.  In general, you should only modify these values when
     you are releasing versions of your library.  During development,
     it's best to just leave them alone or else your version numbers
     will get very large and you will lose all the advantages of using
     shared libraries because of the need to relink everything all the
     time.  Before a release, the major version number should be
     incremented if the shared library has had interfaces removed or
     modified since the last release as those operations would make
     old binaries that linked with the shared library fail to work
     with the new version.  The minor version should be incremented if
     no interfaces were changed or removed but new interfaces were
     added.  This indicates that old binaries would work with new
     libraries but new binaries may not work with old libraries.  The
     revision number should be incremented if any changes were made to
     the shared library code that did not affect the interfaces.  This
     just tells the user that the library has changed relative to
     another version that may be installed.  &Abuild; will build
     executables that link against shared libraries in such a way that
     they will fail to locate shared libraries whose major version
     numbers do not match what they linked against.  On UNIX
     platforms, the unversioned <filename>.so</filename> file and the
     <filename>.so</filename> file with only the major version will be
     symbolic links to the fully versioned file name.  (For example,
     if the actual shared library file were
     <filename>libmoo.so.1.2.3</filename>, both
     <filename>libmoo.so</filename> and
     <filename>libmoo.so.1</filename> would be symbolic links to it.)
     On Windows, the DLL will contain the major version in its name
     (e.g., <filename>moo1.dll</filename>) while the companion static
     library remains unversioned.
    </para>
    <para>
     Note that all the version number parameters are optional.
     Although they should always be used when creating actual shared
     libraries that you intend to link programs against, they may be
     omitted in some other cases.  For example, if you are building a
     shared library object file that will be loaded at runtime or used
     as a plugin (such as with Java native code), then it may be
     appropriate to omit the version numbers altogether.  Even if the
     <varname>SHLIB_<replaceable>libname</replaceable></varname>
     variable is set to an empty string, &abuild; will still make a
     shared library instead of a static library.  There is no way to
     create both a shared and a static version of the same library at
     the same time, but it is possible to create a shared library that
     links against a static library, which can be used to achieve the
     same effect in many circumstances.
    </para>
    <para>
     When &abuild; builds shared libraries, it links them with any
     libraries in the <varname>LIBS</varname> variable.  Although this
     is generally the correct behavior for systems that support
     linking of shared libraries, it can cause unpleasant side effects
     if you mix shared libraries with static libraries.  When mixing
     shared libraries and static libraries, you should make sure that
     you don't include two copies of the same symbols in more than one
     place (two shared libraries or a shared library and an
     executable).  Some systems handle this case acceptably, and
     others don't.  Even in the best case, doing this is wasteful and
     potentially confusing.  If you need to prevent &abuild; from
     linking certain static libraries into shared libraries, you may
     manually manipulate the contents of the <varname>LIBS</varname>
     variable in your <filename>Abuild.mk</filename> file.  However,
     if you find that you need to do this, you should probably rethink
     how you have your build configured.  If you have static libraries
     that are intended to be linked into shared libraries and then not
     used again for other purposes, you should reset the value of
     <varname>LIBS</varname> in an after-build file that is included
     by your shared library build item's
     <filename>Abuild.interface</filename> file.  This is discussed in
     <xref linkend="ref.example.shared-library"/>.
     <footnote>
      <para>
       Versions of &abuild; prior to 1.0.3 behaved somewhat
       differently with respect to linking of shared libraries.  See
       the changes for version 1.0.3 in the release notes for details.
      </para>
     </footnote>
    </para>
    <para>
     &Abuild; allows you to mix executables, shared libraries, and
     static libraries in the same build item.  If you do this, all
     executable targets will link with all shared and all static
     library targets, and all shared library targets will link with
     all static library targets.  The shared library targets will not
     link with each other.  There are few, if any, good reasons to mix
     shared and static library targets in the same build item, as
     doing so can only lead to confusion.  When they are mixed, it is
     probably appropriate to avoid adding the static libraries to
     <varname>LIBS</varname> in the
     <filename>Abuild.interface</filename> file.
    </para>
    <para>
     In order to allow static libraries to be linked into shared
     libraries, &abuild; compiles all library object files as
     position-independent code.  In some extremely rare cases, you may
     wish to avoid doing this as there is a very minor performance
     cost to do it.  If you wish to prevent a specific source file
     from being compiled as position-independent code, set the
     variable
     <varname>NOPIC_<replaceable>filename</replaceable></varname> to
     <literal>1</literal> where <replaceable>filename</replaceable> is
     the name of the source file.  For example, the code
     <literal>NOPIC_File.cc := 1</literal> in your
     <filename>Abuild.mk</filename> file would prevent
     <filename>File.cc</filename> from being compiled as
     position-independent code.  Note that &abuild; does not check to
     make sure that code compiled in this way is not eventually linked
     into a shared library.  If you try to link
     non-position-independent code into a shared library, it may not
     link at all, or it may cause undefined and hard-to-trace
     behavior.  Use of this feature is not recommended unless
     absolutely needed to fix some specific problem.
    </para>
    <para>
     In order to run a program that is linked with shared libraries,
     the operating system will have to know where to find the shared
     library.  &Abuild; does not include library run path information
     in the executables as doing so is inherently dangerous and
     non-portable.  Even if &abuild; were to ignore this danger and
     include run path information, doing so would potentially preclude
     the ability to swap out shared libraries at runtime, which is
     often the main reason for wanting to use them in the first place.
     <footnote>
      <para>
       The way the runtime loader behaves when shared library location
       information is compiled into an executable (as run path data)
       varies from system to system.  In most systems, if the shared
       library doesn't exist at the compiled-in location, the system
       will fall back to its standard rules for locating shared
       libraries.  In some systems, if the shared library does exist
       in the compiled-in location, that copy of the shared library
       will be used with no way to override it.  This may have
       undesired implications.  For example, suppose you were to
       create an executable that linked with a shared library and
       included run path information to the development version of the
       shared library.  If you installed that executable and shared
       library in standard locations on a system without a copy of the
       development environment, everything would work fine.  Then
       suppose you put a development environment on that system and
       built a newer version of the same shared library.  Your
       installed executable would actually use the new development
       copy of the library because it still has that path compiled
       into it!  This is almost certainly not what would be intended.
       &Abuild; avoids this issue entirely but not including support
       for specifying run path data.
      </para>
      <para>
       For another approach to using shared libraries, look at <ulink
       url="http://www.gnu.org/software/libtool"><application>libtool</application></ulink>.
       The <application>libtool</application> program gets around this
       problem by creating wrappers around executables and shared
       libraries in the development tree.  Although &abuild; is not
       integrated with <application>libtool</application>, such an
       integration would be possible.  The possibility of including
       support for <application>libtool</application> is actually one
       of the motivations behind allowing library object files and
       non-library object files to have different extensions.
      </para>
     </footnote>
     Instead, you will need to make sure that, one way or another, the
     shared libraries you need are located in a directory that is in
     your shared library path.  On most UNIX systems, you can set the
     <envar>LD_LIBRARY_PATH</envar> environment variable or install
     the shared libraries into certain system-defined locations.  On
     some systems (like Linux), you can also add directories to
     <filename>/etc/ld.so.conf</filename>.  On Windows, you can
     colocate the DLL files with the executables, or you can add the
     directories containing the DLL files to your path.  When building
     DLLs and executables with MSVC versions greater than or equal to
     .NET 2005, &abuild; automatically embeds the manifest file in the
     DLL or executable with the <command>mt</command> command.
    </para>
   </sect1>
   <sect1 id="ref.example.shared-library">
    <title>Shared Library Example</title>
    <para>
     In <filename>doc/example/shared-library</filename>, you will find
     an example of using shared libraries.  This example contains an
     executable program and two implementations of the same interface,
     both provided in shared libraries.  In the
     <filename>shared-library/prog</filename> directory, you will find
     a simple program.  Here is its <filename>Abuild.conf</filename>
     file:
     <?example shared-library/prog/Abuild.conf?>
     All it does is depend on the build item
     <classname>shared</classname>.  This program doesn't have to do
     anything special in order to link against the shared library.
     Here is the <classname>shared</classname> build item's
     <filename>Abuild.conf</filename>:
     <?example shared-library/shared/Abuild.conf?>
     This is a pass-through build item that depends upon
     <classname>shared.impl1</classname>.  Here is that build item's
     <filename>Abuild.conf</filename>:
     <?example shared-library/shared/impl1/Abuild.conf?>
     This build item depends on an item called
     <classname>shared.include</classname>.  Although, in general,
     putting your header files in a separate build item is risky (see
     <xref linkend="ref.best-practices"/> for a discussion), in this
     case, we want to do this so that we can have two separate
     implementations of this interface that reside in two different
     shared libraries.  By making this build item private to the
     <classname>shared</classname> build item name scope (see <xref
     linkend="ref.build-item-name-scoping"/>), we effectively
     prevent outside build items from depending on it directly.
    </para>
    <para>
     Here is the first implementation's <filename>Abuild.mk</filename>
     file:
     <?example shared-library/shared/impl1/Abuild.mk?>
     What we have here is a normal library
     <filename>Abuild.mk</filename> file except that we have set the
     variable <varname>SHLIB_shared</varname> to the value <literal>1
     2 3</literal>.  This tells &abuild; to build the
     <filename>shared</filename> library target as a shared library
     instead of a static library using the version information
     provided.  On Windows, &abuild; will create
     <filename>shared1.dll</filename> along with
     <filename>shared1.exp</filename> and
     <filename>shared.lib</filename>.  On UNIX, it will create
     <filename>libshared.so.1.2.3</filename> and will make
     <filename>libshared.so</filename> and
     <filename>libshared.so.1</filename> symbolic links to it.  UNIX
     executables that link with <filename>-lshared</filename> will
     need to find <filename>libshared.so.1</filename> in their library
     paths at runtime.  Windows executables that link with
     <filename>-lshared</filename> will need to find
     <filename>shared1.dll</filename> in their executable paths at
     runtime.
    </para>
    <para>
     This shared library consists of a single file called
     <filename>Shared.cc</filename>.  Here is the header file
     <filename>Shared.hh</filename>:
     <?example shared-library/shared/include/Shared.hh?>
     This is the implementation of the interface:
     <?example shared-library/shared/impl1/Shared.cc?>
     Notice the <literal>__declspec(dllexport)</literal> line that is
     there for Windows only.  This is necessary to make Windows export
     the function to a DLL.  No such mechanism is required in a UNIX
     environment.  Our <filename>Abuild.interface</filename> file
     looks like a normal <filename>Abuild.interface</filename> file
     for libraries except that it omits an <varname>INCLUDES</varname>
     variable and declares a special <firstterm>mutex</firstterm>
     variable:
     <?example shared-library/shared/impl1/Abuild.interface?>
     The <varname>INCLUDES</varname> variable is set in the
     <classname>shared.include</classname> build item's
     <filename>Abuild.interface</filename> instead:
     <?example shared-library/shared/include/Abuild.interface?>
     The mutex variable is a normal interface variable.  We declare
     the same variable in the <filename>Abuild.interface</filename>
     file for <classname>shared.impl2</classname>.  Since &abuild;
     won't allow any interface variable to declared in more than one
     place, this effectively prevents any one build item from
     simultaneously depending on both
     <classname>shared.impl1</classname> and
     <classname>shared.impl2</classname>.  Please note that we have
     included the name of the public item,
     &ldquo;<classname>shared</classname>&rdquo; in the name of the
     mutex variable &ldquo;<varname>shared_MUTEX</varname>&ldquo; to
     avoid namespace collisions with other unrelated build items.
    </para>
    <para>
     Our second implementation is not in the dependency chain of our
     program.  It resides in the <filename>impl2</filename> directory.
     Here are its <filename>Abuild.conf</filename> and
     <filename>Abuild.mk</filename>:
     <?example shared-library/shared/impl2/Abuild.conf?>
     <?example shared-library/shared/impl2/Abuild.mk?>
     You will notice in this case that this build item depends on a
     static library that its private to its own build item name scope.
     This static library provides additional functions that are used
     <emphasis>within</emphasis> the shared library.  Since the static
     library is linked into the shared library and is not intended to
     provide any public interfaces, we want to avoid having the static
     library appear on the link statement for executables that link
     with this shared library.  To do that, we have to do some extra
     work in our <filename>Abuild.interface</filename> file.  Here are
     that file and the <function>after-build</function> file that it
     loads:
     <?example shared-library/shared/impl2/Abuild.interface?>
     <?example shared-library/shared/impl2/after.interface?>
     Notice that we reset the <varname>LIBS</varname> variable and add
     our own library to it after the build has completed.  This
     effectively replaces everything that was previously in the
     <varname>LIBS</varname> variable with our library for items that
     depend on us.  In this case, the
     <classname>shared.impl2.static</classname> build item had added
     <filename>static</filename> to <varname>LIBS</varname> in its
     <filename>Abuild.interface</filename> file:
     <?example shared-library/shared/impl2/static/Abuild.interface?>
     The effect of our reset that the <filename>static</filename>
     library added to <varname>LIBS</varname> there is available to
     <classname>shared.impl2</classname> during its linking but not
     available to those who depend on
     <classname>shared.impl2</classname>.
     <footnote>
      <para>
       What is going on here is a bit subtle.  At first, resetting
       <varname>LIBS</varname> may seem quite drastic, but it really
       isn't.  The reset statement only resets the state of
       <varname>LIBS</varname> as it was at the time that this
       <filename>Abuild.interface</filename> file was processed.  Any
       build item that depends on this item will still have all the
       other items that were added to <filename>LIBS</filename> by
       other build items.  To really understand how this works, please
       see <xref linkend="ref.interface-implementation"/>.
      </para>
     </footnote>
    </para>
    <para>
     Finally, we can run our program.  Remember that in order to run
     the program, you must explicitly add the directory containing the
     shared library whose implementation you want to use to your
     <envar>LD_LIBRARY_PATH</envar> on UNIX or your
     <envar>PATH</envar> on Windows.  If you set this variable to
     include the output directory for
     <classname>shared.impl1</classname>, you will see this output:
     <?qtest shared-library-prog-impl1.out?>
     If you set it to the <classname>shared.impl2</classname> build
     item's directory, you will see this instead:
     <?qtest shared-library-prog-impl2.out?>
     Note that we could have made <classname>shared</classname> depend
     on <classname>shared.impl2</classname> instead of
     <classname>shared.impl1</classname> and gotten the same results.
     Hiding the actual shared library implementation behind a
     pass-through build item provides a useful device for allowing you
     to reconfigure the system later on, including replacing
     place-holder shared library-based stub implementations with
     static library implementations later in the development process.
     With careful planning, this type of technique could be used to
     provide a shared-library based stub system that could be swapped
     out later with very little effect on the overall build system.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.code-generators">
   <title>Build Item Rules and Automatically Generated Code </title>
   <para>
    In this chapter, we show how to use &abuild; with custom rules
    provided by build items.  The most common application of build
    item-supplied rules is to support automatic code generation.
    Examples are presented for both the <application>GNU
    Make</application> backend and the
    <application>Groovy/ant</application> as the mechanisms are very
    similar.
   </para>
   <sect1 id="ref.build-item-rules">
    <title>Build Item Rules</title>
    <indexterm>
     <primary>rules</primary>
     <secondary>build item</secondary>
    </indexterm>
    <para>
     The most important thing to realize about code generators in
     &abuild; is that code generation can be viewed as a just another
     service that a build item can offer, just like libraries or
     header files.  In many build systems, code generators are
     problematic because you need to take special steps to make sure
     generated code appears before compilation or dependency
     generation begin.  With &abuild;, code generators get run at the
     correct stage by virtue of appearing in the correct place in the
     dependency tree.
    </para>
    <para>
     Any build item may provide custom rules.
     <footnote>
      <para>
       Actually, there is no way for build items using the deprecated
       xml-based ant backend to provide custom rules.  They are
       limited to providing code for specific hooks in the set rule
       structure.  It is possible for plugins to provide custom
       targets using <filename>preplugin-ant.xml</filename>.
      </para>
     </footnote>
     To provide custom rules, a build item creates a
     <filename>rules</filename> directory.  The rules themselves go in
     a subdirectory of <filename>rules</filename> either named
     <filename>all</filename>, for rules that can be used by any build
     item, or named after the target type (one of
     <filename>object-code</filename>, <filename>java</filename>, or
     <filename>platform-independent</filename>) for rules that are
     available only to build items of the specified target type.  When
     searching for rules, &abuild; always looks the directory under
     <filename>rules</filename> corresponding to the build item's
     target type first, and then it searches the
     <filename>all</filename> directory.  The basic procedure for
     providing build item rules is essentially the same for both
     backends.  The differences are mainly syntactic.  We describe the
     mechanisms in turn for each backend.
    </para>
    <para>
     In order for a <application>make</application>-based build item
     to provide code generation, it must supply additional make rules.
     The rules are in the form of a make fragment.  The name of the
     rules file is
     <filename><replaceable>rulename</replaceable>.mk</filename>,
     where <replaceable>rulename</replaceable> is whatever you are
     calling the rules.  This is what people who use the rules will
     place in their <varname>RULES</varname> variable in their
     <filename>Abuild.mk</filename> file.  Any rules provided by a
     build item are run from the &abuild; output directory of the
     build item that is using the rules, just as is the case with
     built-in rules.  That means that if the rules need to refer to
     files inside the build item that <emphasis>provides</emphasis>
     the rules, they must do so by either accessing interface
     variables defined in that build item's
     <filename>Abuild.interface</filename> or by prefixing the files
     with a variable that &abuild; provides.  Specifically, for a
     build item named
     <classname><replaceable>build-item</replaceable></classname>,
     &abuild; provides variable called
     <varname>abDIR_<replaceable>build-item</replaceable></varname>
     that can be accessed from the rules implementation file.  Note
     that &abuild; only provides these variables for build items in
     your dependency chain.  Also, use of these variables from
     <filename>Abuild.mk</filename> files is strongly discouraged as
     it can cause your build tree to contain path-based dependencies
     instead of name-based dependencies, which would defeat one of the
     most compelling advantages of &abuild;.  The best practice is to
     refer to files in your own build item from your own files by
     using the abuild-provided variable name to find your own path,
     and to define interface variables for files that you intend for
     other build items to access.  Either way, there are certain
     things that it are important to keep in mind when writing
     <application>GNU Make</application> rules for use inside of
     &abuild;.  For a discussion of this topic, please see <xref
     linkend="ref.guidelines-for-make-rule-authors"/>.
    </para>
    <para>
     In order for a <application>Groovy</application>-based build item
     to provide rules, it must supply additional groovy code in a file
     called
     <filename><replaceable>rulename</replaceable>.groovy</filename>.
     Build items can use the rule by adding
     <filename><replaceable>rulename</replaceable></filename> to the
     <varname>abuild.rules</varname> parameter in their
     <filename>Abuild.groovy</filename> files.  Within the context of
     the build item-supplied, the variables
     <varname>abuild.sourceDirectory</varname> and
     <varname>abuild.buildDirectory</varname> are
     <classname>File</classname> objects that represent the build item
     directory and output directory of the item on behalf of which the
     rules are being invoked.  If the rules need to reference a file
     inside of the build item that is <emphasis>providing</emphasis>
     the rules, it should either set an interface variable or access
     its location by name using
     <varname>abuild.itemPaths[<replaceable>item-name</replaceable>]</varname>,
     where <replaceable>item-name</replaceable> is the name of the
     build item providing the rules.  &Abuild; only provides locations
     for build items that are plugins or that are in the dependency
     chain of the item being built.
    </para>
    <para>
     A build item may actually provide rules for both backends at the
     same time as <filename>.mk</filename> and
     <filename>.groovy</filename> files can co-mingle in the
     <filename>rules</filename> directory.  Whichever type of rules
     are being provided, rule authors are encouraged to create a help
     file that gives the user information needed to use the rules.
     The help file is called
     <filename><replaceable>rulename</replaceable>-help.txt</filename>
     and resides in the same directory as the rules.
    </para>
   </sect1>
   <sect1 id="ref.example.code-generator.make">
    <title>Code Generator Example for Make</title>
    <para>
     The <classname>derived-code-generator</classname> build item in
     <filename>doc/example/general/user/derived/code-generator</filename>
     contains a trivial code generator.  All it does is generate a
     source and header file that define a function that returns a
     constant, which is read from a file.  We have modified
     <classname>derived-main</classname> to use the code generator.
     The code generator itself is implemented in the
     <classname>derived-codegen</classname> build item, which provides
     a rule set called <filename>code-generator</filename>.  The build
     item is making these rules available for build items of type
     <type>object-code</type>.  The file that implements the rules is
     therefore called
     <filename>rules/object-code/code-generator.mk</filename>.
    </para>
    <para>
     First, we'll look at the code generator itself.  Notice that the
     only &abuild; file contained in the
     <classname>derived-code-generator</classname> build item
     directory at <filename>user/derived/code-generator</filename> is
     <filename>Abuild.conf</filename>.  There is no
     <filename>Abuild.interface</filename> or
     <filename>Abuild.mk</filename>, though these files could exist if
     the build item itself had something that it needed to build.
    </para>
    <para>
     Before we get to the rules themselves, observe that there is
     another file in <filename>rules/object-code</filename>: the help
     file,
     <filename>rules/object-code/code-generator-help.txt</filename>,
     the contents of which are presented here:
     <?example general/user/derived/code-generator/rules/object-code/code-generator-help.txt?>
     Whenever you provide a rule implementation for rule
     <replaceable>rulename</replaceable>, you should create a
     <filename><replaceable>rulename</replaceable>-help.txt</filename>
     file in the same directory.  This is the file that will be
     displayed when the user types <command>abuild --help rules
     rule:<replaceable>rulename</replaceable></command>.
    </para>
    <para>
     The most important part of this example is the rule
     implementation file, so we'll study it carefully.  Here is the
     <filename>rules/object-code/code-generator.mk</filename> file:
     <?example general/user/derived/code-generator/rules/object-code/code-generator.mk?>
     The first thing that happens is that we have some code that checks
     for undefined variables.  This isn't strictly necessary, but it
     can save your users a lot of trouble if you detect when variables
     they are supposed to provide are not there.  We use the function
     <function>undefined_vars</function> to do this check.  This
     function is provided by &abuild; and appears in the file
     <filename>make/global.mk</filename> relative to the top of the
     &abuild; installation.  If you expect to write a lot of make
     rules, it will be in your best interest to familiarize yourself
     with the functions offered by this file.  Even if we hadn't done
     this, &abuild; invokes GNU Make in a manner that causes it to
     warn about any undefined variables.  This is useful because
     undefined variables are a common cause of makefile errors.
    </para>
    <para>
     Then we add our source file to the <command>all::</command>
     target to make sure it gets built.  Note that we use
     <command>all::</command>, not <command>all:</command>, since
     there are multiple <command>all::</command> targets throughout
     various rules files.  Adding our source files to the
     <command>all::</command> target is not strictly necessary in this
     case since, by listing the source file as a source file for one
     of our targets (in the build item that uses this code generator),
     it will be built in the proper sequence.  It's still good
     practice to do this though, but remember that in a parallel
     build, dependencies of the <command>all::</command> target may
     not necessarily be built in the order in which they are listed.
    </para>
    <para>
     Next, we have the actual <application>make</application> rules
     that create the automatically generated files.  In this case, we
     make the output files depend on both the input file and the
     code generator.  Although &abuild; is running the rules from the
     depending build item's output directory, we don't need to put any
     prefix in front of the name of the input file: &abuild; sets
     <application>make</application>'s <varname>VPATH</varname>
     variable so that the file can be found.  By creating a dependency
     on the code generator as well, we can be sure that if the code
     generator itself is modified, any code that it generates will
     also be updated.
    </para>
    <para>
     In the commands for generating our files, notice that we don't
     need an <literal>@</literal> sign before the generation command
     to prevent it from echoing since &abuild; doesn't echo its output
     by default.  Not putting an <literal>@</literal> sign there means
     that the user will see the command if he/she runs &abuild; with
     the <option>--verbose</option> option.  So that the user knows
     something is happening, we generate a useful output message using
     <varname>@$(PRINT)</varname>.  The use of
     <varname>@$(PRINT)</varname> ensures that we don't see the actual
     echo command even when running with <option>--verbose</option>
     (since otherwise, we'd see the <command>echo</command> command
     immediately followed by the output of the <command>echo</command>
     command), and that we don't see the output at all when we're
     running with <option>--silent</option>.  All informational
     messages should be generated this way.  Note also that we invoke
     the code generator with <command>perl</command> rather than
     assuming that it is executable (since some version control
     systems or file systems make it hard to preserve execute
     permissions) and that we specify the path to the code generator
     in terms of <varname>$(abDIR_derived-code-generator)</varname>.
     Also notice that we have to prefix the name of the input file
     with <varname>$(SRCDIR)</varname> when we pass it to the code
     generator since we are running from the &abuild; output
     directory.  The <varname>VPATH</varname> variable tells
     <application>make</application> where to look, but it doesn't
     tell our code generator anything!  However, the special GNU Make
     variables like <varname>$&lt;</varname> and <varname>$^</varname>
     will contain the full paths to prerequisites and can often be
     used instead.
    </para>
    <para>
     To use this code generator from
     <classname>derived-main.src</classname>, all we have to do is
     define the required variables in <filename>Abuild.mk</filename>,
     add <classname>derived-code-generator</classname> as a dependency
     in <filename>Abuild.conf</filename>, and add
     <filename>code-generator</filename> to the
     <varname>RULES</varname> variable in
     <filename>Abuild.mk</filename>.  Note that we have modified
     <filename>main.cpp</filename> to include
     <filename>auto.h</filename> and to call
     <varname>getNumber()</varname>, thus testing the use of the code
     generator.  Since this application effectively contains the only
     test suite for the code generator, we declare it as a tester of
     the code generator in <filename>Abuild.conf</filename> using
     traits.  Here are the relevant files from
     <classname>derived-main.src</classname>:
     <?example general/user/derived/main/src/Abuild.conf?>
     <?example general/user/derived/main/src/Abuild.mk?>
     Here is the modified <filename>main.cpp</filename> file:
     <?example general/user/derived/main/src/main.cpp?>
    </para>
   </sect1>
   <sect1 id="ref.example.code-generator.groovy">
    <title>Code Generator Example for Groovy</title>
    <!--  Search for xrefs to this section.  The general Groovy    -->
    <!--  documentation mentions that this is where a more         -->
    <!--  comprehensive example can be found.  If better Groovy    -->
    <!--  examples are eventually added, that disclaimer can       -->
    <!--  probably be removed.                                     -->
    <para>
     The build tree containing the Java code generator example, built
     using the Groovy framework, can be found in the tree located at
     <filename>java</filename>.  The code generator itself is at
     <filename>java/code-generator</filename>.  This example discusses
     the code generator, and it also serves as a general example for
     several aspects of the Groovy framework.
    </para>
    <para>
     In any situation in which code generators are used, there will
     always be one build item that provides the code generator and one
     or more build items that use the code generator.  In some cases,
     the provider and user will be the same build item, but in the
     most general case, the code generator will usually be provided by
     a build item whose sole purpose is to provide the code generator.
     In the Java world, a useful and common way to perform code
     generation is through providing a custom ant task, which is what
     we do here.
    </para>
    <para>
     We'll start our examination by looking at the build item that
     provides the code generator.  We provide a simple build item
     whose name is just <filename>code-generator</filename>.  (In a
     real implementation, you would obviously want to give this a more
     specific name.)  Its <filename>Abuild.conf</filename> and
     <filename>Abuild.groovy</filename> files reveal a very ordinary
     build item:
     <?example java/code-generator/Abuild.conf?>
     <?example java/code-generator/Abuild.groovy?>
     The only thing unusual about this
     <filename>Abuild.groovy</filename> file is that it sets the
     parameter <varname>java.includeAntRuntime</varname> to
     <option>true</option>.  This is necessary for any build item that
     uses ant's API, such as when adding a new ant task.  This build
     item generates a JAR file, but unlike most Java build items, this
     JAR file is not intended to be added to the compile-time,
     run-time, or package-time class paths.  Instead, we just assign
     it to a specific interface variable so that it can be used in the
     <command>taskdef</command> statement of the rules implementation.
     Here is the <filename>Abuild.interface</filename> file:
     <?example java/code-generator/Abuild.interface?>
    </para>
    <para>
     Next, let's look at the example task itself.  This is just a
     regular Java implementation of an ant task.  There's nothing
     &abuild;-specific about it, but we'll show it here for
     completeness.  This task just creates a class with a public
     <function>negate</function> method that returns the opposite of
     the number passed in.  The task takes the fully qualified class
     name and the source directory into which the class should be
     written as arguments.  Here is the implementation:
     <?example java/code-generator/src/java/com/example/codeGenerator/ExampleTask.java?>
    </para>
    <para>
     To make this task available for use by other Java build items, we
     have to provide an implementation of the appropriate rules.  The
     implementation of the rules can be found in the file
     <filename>rules/java/codegenerator.groovy</filename>.  This means
     that people can use these rules by ensuring that
     <filename>codegenerator</filename> appears in
     <varname>abuild.Rules</varname>, almost certainly along with
     <filename>java</filename>.  As is always advisable, we also
     provide a rules help file, which is
     <filename>rules/java/codegenerator-help.txt</filename>, is shown
     here:
     <?example java/code-generator/rules/java/codegenerator-help.txt?>
    </para>
    <para>
     The implementation of the rules is heavily commented, but we'll
     also provide some additional discussion following the text.  You
     may wish to follow the implementation as you read the text in the
     rest of this section.  Here is the code generator implementation:
     <?example java/code-generator/rules/java/codegenerator.groovy?>
    </para>
    <para>
     In the Groovy programming language, a
     <firstterm>script</firstterm> is a special type of class that has
     access to read and modify variables in the
     <firstterm>binding</firstterm>.  This is a powerful facility that
     makes it easy to communicate between the script and the caller of
     the script.  &Abuild; makes use of the binding to provide the ant
     project and other state to rules implementations.  However, one
     downside is that any undeclared variable becomes part of the
     binding, which may not be what you intended.  To minimize
     unintended consequences of using undeclared variables, we
     recommend the practice of doing most of the work inside a class.
     For any script that contains any code other than a single class
     implementation, Groovy automatically creates a class named after
     the file.  Since our rules implementation defines a class and
     then also contains other code, we set the name of the class
     explicitly to something other than the name of the file.  This
     this case, the base part of the file name is
     <filename>codegenerator</filename>, but we name the class inside
     of it <classname>CodeGenerator</classname>.  Our class's
     constructor takes as arguments a reference to the
     <classname>abuild</classname> object (see <xref
     linkend="ref.java.abuild-object-interface"/>) and to the ant
     project (see <xref linkend="ref.groovy.ant-project"/>).  This is
     a common pattern suitable for use for just about any rule
     implementation.  The constructor performs global setup.  In this
     case, we just call <function>ant.taskdef</function>, as would be
     done by virtually any task-providing custom rules.  Other things
     that would be appropriate to do in your constructor would be
     initializing additional fields of your object or doing any other
     types of operations that would be common in class constructors.
     The main things you should <emphasis>not</emphasis> do are to
     perform operations that depend on users' parameter settings or on
     state of an in-progress build since, at the this is loaded, not
     all initialization is necessarily in place.
    </para>
    <para>
     Right after the constructor, we have the implementation of
     <function>codegenTarget</function>.  This method will be used as
     the closure for the target provided by these rules.  This target
     follows the pattern expected to be used for all but the most
     trivial rules: it sets up a default attributes list whose fields
     are initialized from parameters intended to be set in users'
     <filename>Abuild.groovy</filename> files.  Here, we initialize
     the <option>classname</option> field from the
     <varname>codeGenerator.classname</varname> parameter.  This is
     what makes it possible for the user to specify the name of the
     class to be generated by setting that parameter or,
     alternatively, by providing lists of maps containing the
     <option>classname</option> key.  Once we provide our default
     attributes, we can just call
     <function>abuild.runActions</function>.  The
     <function>abuild.runActions</function> method takes three
     arguments: the name of the control parameter, a closure that
     implements the required actions, and the default attributes.  The
     closure, which here uses the Groovy method closure syntax of
     <literal><replaceable>object</replaceable>.&amp;<replaceable>method</replaceable></literal>
     syntax, will be invoked with a map.  This map will always have
     any keys in it that are defined in the
     <varname>defaultAttrs</varname> argument.
    </para>
    <para>
     The next significant chunk of code here is the
     <function>codegen</function> method.  This is the method that
     actually does the work.  Everything up to this point has just
     been scaffolding.  The <function>codegen</function> method takes
     a single parameter: a map of attributes.  Any key provided in the
     default attributes is known to be defined.  Any other keys can be
     used at the discretion of the code.  A common convention, which
     is used by most of &abuild;'s built-in targets, is to take extra
     attributes and just pass them along to whichever underlying ant
     task is doing the real work.  In this case, we simply ignore
     extra attributes since the work is being done by a custom task,
     and we have already handled all available options.  In this code,
     we set the <varname>className</varname> variable to a field of
     the <varname>attributes</varname> element.  Other common idioms
     would be to set something conditionally upon whether a key is
     present or to set something and also to delete the attribute.
     For examples of these, please refer to the implementation of the
     built-in <filename>java</filename> rules (<xref
     linkend="ref.rules.java.groovy"/>).  The actual implementation of
     our code generator target just does a few sanity checks and then
     invokes the task using the task we've provided.  Notice that we
     use <varname>java.dir.generatedSrc</varname> as the directory in
     which to write the generated class.  This is what all code
     generators should do.  By using
     <function>abuild.resolve</function> to get the value at this
     point, we ensure that any changes the user may have made to the
     value of that parameter will be properly accounted for.
     Resolving the parameter as needed is a better implementation
     choice than reading the parameter value in the constructor and
     stashing it in a field as it prevents rules from ignoring late
     changes to the value of the parameter.
    </para>
    <para>
     Finally, we come to the code that resides outside the
     <classname>CodeGenerator</classname> class.  This code just
     creates an instance of the class, passing to it the
     <varname>abuild</varname> and <varname>ant</varname> objects from
     the binding, and then adds the <function>codegenTarget</function>
     method as a closure for the <command>generate</command> target,
     again using Groovy's method closure syntax.  Sometimes you might
     want to do other checks here, such as making sure other required
     rules have been loaded.  &Abuild;'s built-in
     <filename>groovy</filename> rules do this.  The implementation of
     those rules is included in <xref
     linkend="ref.rules.java.groovy"/>.
    </para>
    <para>
     Now that we've seen how the rules are implemented, we can see how
     the rules are used.  The good news is that using the rules is
     much simpler than implementing them.  This is as it should be:
     creation of rules is a much more advanced operation that needs to
     be performed by people with more in-depth knowledge of &abuild;.
     Using rules should be very simple.  Our
     <filename>library</filename> build item in
     <filename>java/library</filename> makes use of the code
     generator.  To do this, it must declare a dependency on the
     <filename>code-generator</filename> build item, as you can see in
     the <filename>Abuild.conf</filename> file:
     <?example java/library/Abuild.conf?>
     and it must set the required parameter to generate the class.  In
     this case, we use
     <classname>com.example.library.Negator</classname> as the fully
     qualified class name, as you can see by looking at the
     <filename>Abuild.groovy</filename> file:
     <?example java/library/Abuild.groovy?>
     We also include one statically coded Java source file which,
     along with the generated class, will be packaged into
     <filename>example-library.jar</filename>.  Here, for
     completeness, is the text of the additional source file, which
     just wraps around the generated class:
     <?example java/library/src/java/com/example/library/Library.java?>
     Finally, as for any well-behaved Java build item that exports a
     JAR file, we add the JAR file to the regular compile-time class
     path as well as to the manifest class path.  We do this here by
     following
     <varname>archiveName</varname>/<varname>archivePath</varname>
     convention first discussed in <xref
     linkend="ref.example.basic.java-library"/> and by adding the
     archive file to both <varname>abuild.classpath</varname> and
     <varname>abuild.classpath.manifest</varname>.  Here is the
     <filename>Abuild.interface</filename> file:
     <?example java/library/Abuild.interface?>
     The example in <xref
     linkend="ref.example.multiple-wrapper-scripts"/> creates an
     executable that tests this library.
    </para>
   </sect1>
   <sect1 id="ref.example.multiple-wrapper-scripts">
    <title>Multiple Wrapper Scripts</title>
    <para>
     This example illustrates use of a target's control parameter to
     cause that target to be run multiple times.  In this case, we set
     the <varname>java.wrapper</varname> parameter to a list of maps
     so that we can generate two wrapper scripts.  One of them is used
     to test the library and code generator discussed in <xref
     linkend="ref.example.code-generator.groovy"/>, and also
     illustrates reading a file that was placed in the JAR by placing
     it in <filename>src/resources</filename>.  The other
     <function>main</function> just prints a message.
     Here is the very ordinary <filename>Abuild.conf</filename>:
     <?example java/executable/Abuild.conf?>
     Here is the first main class:
     <?example java/executable/src/java/com/example/executable/Executable.java?>
     Here is the file it reads from resources:
     <?example java/executable/src/resources/com/example/file.txt?>
     Here is the second main class:
     <?example java/executable/src/java/com/example/executable/Other.java?>
     Finally, here is the <filename>Abuild.groovy</filename> file.
     Observe here how we set the <varname>java.wrapper</varname>
     parameter to a list of maps by appending one map at a time.  This
     is one of many syntaxes that could be used, but it uses less
     extraneous punctuation than many of the other choices:
     <?example java/executable/Abuild.groovy?>
    </para>
   </sect1>
   <sect1 id="ref.example.auto-from-variable">
    <title>Dependency on a Make Variable</title>
    <para>
     In the previous example, we showed how to create a code generator
     that generates code from a file.  This works nicely because
     <application>make</application>'s dependency system is based on
     file modification times.  Sometimes, you may want to generate
     code based on the value of a <application>make</application>
     variable whose origin may be either
     <filename>Abuild.mk</filename> or, more likely,
     <filename>Abuild.interface</filename>.  Doing this is more
     difficult because it requires some obscure make coding, but it is
     common enough to warrant an example.
    </para>
    <para>
     The &ldquo;obvious&rdquo; way to pass information from a
     <application>make</application> variable into your code would be
     to use a preprocessor symbol based on the variable and to pass
     this symbol to the code with <varname>XCPPFLAGS</varname> or
     <varname>XCPPFLAGS_<replaceable>Filename</replaceable></varname>.
     The problem with this is that there is no dependency tracking on
     variable values, so if you change the variable value, there is
     nothing that will trigger recompilation of the files that use the
     preprocessor symbol.  To get around this problem, we use local
     rules to generate a file with the value of the variable.  This
     example can be found in
     <filename>doc/example/auto-from-variable</filename>.
    </para>
    <para>
     First, look at the <classname>file-provider</classname> build
     item in <filename>library</filename>.  This build item
     automatically generates a header file based on the value of a
     make variable.  The variable itself is defined in the
     <filename>Abuild.interface</filename> file:
     <?example auto-from-variable/library/Abuild.interface?>
     We define the variable <varname>file-provider-filename</varname>
     to point to a local file.  By making this a <type>filename</type>
     variable, we tell &abuild; to translate its location to the path
     to this file as resolved relative to the
     <filename>Abuild.interface</filename> file's directory.  Note
     that we use the build item name in the variable name to reduce
     the likelihood of clashing with other interface variables.  In
     the <filename>Abuild.mk</filename> file we use the
     <varname>LOCAL_RULES</varname> variable to declare the local
     rules file <filename>generate.mk</filename>.  This is where we
     will actually generate the header file.  Otherwise, this is an
     ordinary <filename>Abuild.mk</filename>:
     <?example auto-from-variable/library/Abuild.mk?>
    </para>
    <para>
     Here is <filename>generate.mk</filename>:
     <?example auto-from-variable/library/generate.mk?>
     There is a lot going on here, so we'll go through line by line.
     <application>GNU Make</application> is essentially a functional
     programming environment.  Makefiles are not executed
     sequentially; they are evaluated based on dependencies instead.
     Sometimes you need to force <application>make</application> to
     run steps sequentially.  You can trick
     <application>make</application> into doing this by making the
     operations side effects of a variable assignment using the
     <literal>:=</literal> operator since these are evaluated when
     they are read.  Our goal here is to translate a variable value,
     which can't be tracked by the dependency system, into a file
     modification time, which can.  To do this, we create a file whose
     value and modification time get updated whenever the variable
     value changes.  We do this in two steps: first, we write the
     value of the variable to a temporary file (the first
     <varname>DUMMY</varname> assignment), and then we overwrite
     another file with the temporary file if the other file either
     doesn't exist or has a different value (the second assignment).
     In this way, whenever the variable changes, the file called
     <filename>variable-value</filename> gets updated.  Although the
     <filename>variable-value.tmp</filename> file gets updated every
     time when run &abuild;, we don't care since that file is not used
     as a dependency.  Next, we provide the rules to actually generate
     the header file.  The header file depends on the file
     <filename>variable-value</filename> so it will get regenerated
     whenever the variable changes.  Here we just use
     <command>echo</command> to write the header file.  Note that we
     have to call <application>make</application>'s
     <function>abspath</function> function to translate the value of
     <varname>file-provider-filename</varname> to an absolute path.
     This is because &abuild; writes <type>filename</type> variables
     as relative paths when it passes them to
     <application>make</application>.  Note also that didn't actually
     have to use the value of the <filename>variable-value</filename>
     file.  We know that its contents are identical to the value of
     the variable, so we can just use the variable's value directly.
     Finally, we want to make sure that
     <filename>FileProvider_file.hh</filename> exists before we start
     compiling any of the files that reference it.  We have a little
     bit of a bootstrapping problem here: although &abuild; ordinarily
     generates dependency information of object files on header files
     automatically, this generation step is performed during the
     compilation itself.  In order to force the header file to be
     generated before the compile starts, we have to create an
     explicit dependency.  We do this by creating an explicit
     dependency from the object file to the header file.  Notice that
     we use the make variable <varname>LOBJ</varname> to get the
     object file suffix rather than hard-coding it.  All compiler
     support files are required to set the variable
     <varname>LOBJ</varname> to the suffix of object files that are
     going into libraries and <varname>OBJ</varname> for object files
     that are not going into libraries.  Although they are often the
     same, they don't have to be.
     <footnote>
      <para>
       It would be nice to be able to avoid this issue entirely.  One
       way to avoid it would be generate a source file instead of a
       header file.  In that case, <application>make</application>
       would definitely try to generate the source file before
       building, so no explicit dependency would be required.  This
       approach would certainly work for this example.  One option
       that would definitely <emphasis>not</emphasis> work would be to
       create a <command>generate</command> target, analogous to the
       <command>generate</command> target in &abuild;'s
       <application>Groovy/ant</application> support, and making it a
       prerequisite for the <command>all</command> target.  Although
       this would work for strictly serial builds, it wouldn't
       necessarily work for parallel builds as
       <application>make</application> is free to build all the
       prerequisites for a given target in any order as long as they
       don't have dependencies on each other.  In fact, the reason
       this trick works in <application>Groovy</application> is that
       the <application>Groovy</application> framework never runs
       targets in parallel, and <application>ant</application> only
       runs tasks within a target in parallel when you explicitly tell
       it that it can.  So the bottom line is that whatever we are
       automatically generating, at the file level, must appear as a
       dependency somewhere.  Source files automatically appear as
       dependencies of their object files, but header files don't
       appear as dependencies anywhere until the compile has already
       been run at least one time.  Therefore, a solution that works
       for parallel builds and generates header files has to create an
       explicit dependency such as in this example.
      </para>
     </footnote>
    </para>
    <para>
     We have two files that use the header file.  The first one is the
     library implementation itself:
     <?example auto-from-variable/library/FileProvider.cc?>
     The other is the main program from the other build item:
     <?example auto-from-variable/program/main.cc?>
    </para>
    <para>
     There are a few additional points to be made about this example.
     We have taken an approach here that can be tailored for a wide
     variety of situations.  In this example, the interface variable
     is accessible to other build items.  If we didn't want this to be
     the case, we could have used an <filename>Abuild.mk</filename>
     variable instead or we could have made this variable visible
     conditionally upon an interface flag.  We have also made the
     header file available to other build items by adding the output
     directory to <varname>INCLUDES</varname> in
     <filename>Abuild.interface</filename>.  If you didn't want these
     to have such high visibility, you could protect them just as you
     would protect any private interfaces.  In other words, this
     example is a little bit of an overkill for the exact case that it
     implements, but it shows a pattern that can be used when this
     type of functionality is required.  The main thing to take away
     here is the use of a <application>make</application> trick to
     translate a variable value into a file modification time, thus
     making it trackable with <application>make</application>'s
     ordinarily dependency tracking mechanism.
    </para>
   </sect1>
   <sect1 id="ref.codegen-wrapper">
    <title>Caching Generated Files</title>
    <para>
     As a general rule, it's a good idea to avoid controlling
     automatically generated files.  Instead, it's often best to have
     the generation of those files be part of the build process.
     Sometimes, however, you might find yourself in a situation where
     the tool used to create the generated file may not always be
     available.  Perhaps it's a specialized tool that requires
     separate installation or licensing but whose output is generally
     usable.  In cases such as this, it would be helpful if the build
     system would cache the generated files and use the cached files
     if all the input files are up to date.  This is the functionality
     provided by <command>codegen-wrapper</command>, located in
     &abuild;'s <filename>util</filename> directory, and accessible
     through use of the <varname>$(CODEGEN_WRAPPER)</varname> variable
     within user-supplied make rules.
    </para>
    <para>
     The <command>codegen-wrapper</command> command can handle the
     situation described above for relatively simple cases, but it is
     likely to be good enough for many situations.  For details on its
     syntax, please run it with no options to get a summary.  It works
     as follows:
     <itemizedlist>
      <listitem>
       <para>
        The <command>codegen-wrapper</command> command the following
        inputs:
        <itemizedlist>
         <listitem>
          <para>
           a cache directory, which must exist in advance
          </para>
         </listitem>
         <listitem>
          <para>
           a list of input files
          </para>
         </listitem>
         <listitem>
          <para>
           a list of output files
          </para>
         </listitem>
         <listitem>
          <para>
           a command to generate the output files from the input files
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
      <listitem>
       <para>
        The <command>codegen-wrapper</command> checks the following
        prerequisites:
        <itemizedlist>
         <listitem>
          <para>
           For each input file <filename>infile</filename>, see if the
           file <filename>infile.md5</filename> exists in the cache
           directory and contains the md5 checksum of
           <filename>infile</filename>.  You may pass the
           <option>--normalize-line-endings</option> flag to
           <command>codegen-wrapper</command> to have it disregard
           differences in line endings (carriage return + newline
           vs. newline) when computing checksums.
          </para>
         </listitem>
         <listitem>
          <para>
           For each output file <filename>outfile</filename>, see if
           a file called <filename>outfile</filename> exists in the
           cache directory.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
     If all of the above prerequisites are satisfied,
     <command>codegen-wrapper</command> copies the output files from
     the cache directory into the output directory.  Otherwise,
     <command>codegen-wrapper</command> runs the specified command.
     If the command succeeded and generated all the expected output
     files, <command>codegen-wrapper</command> updates the checksums
     of the input files and copies all the generated files into the
     cache directory.  Note that the cache directory is expected to be
     a controlled directory that is part of your source tree.  As
     such, it is likely that <command>codegen-wrapper</command> will
     actually update files in the cache directory which you will
     subsequently have to check into your version control system.
    </para>
    <sect2 id="ref.example.codegen-wrapper">
     <title>Caching Generated Files Example</title>
     <para>
      Let's now look at an example.  We have an example that provides a
      simple code generator.  This generator reads an input file and,
      based on annotations in the file, repeats some input lines into
      an output file.  However, its exact functionality is not
      important; for purposes of this example, all we need to care
      about is that it generates some output file from an input file.
     </para>
     <para>
      To use this code generator, we'll adopt a convention that any
      input file passed to the code generator will generate a file by
      the same name appended with the <filename>.rpt</filename>
      suffix.  The code generator build item will require that any
      input files be named in the variable <varname>INPUT</varname>.
      For each file named in <varname>$(INPUT)</varname>, it will
      the corresponding <filename>.rpt</filename> file using the code
      generator.  If the variable <varname>REPEATER_CACHE</varname> is
      defined, the build item will use that as the cache directory.  We
      implement that with the following rule fragment:
      <?example codegen-wrapper/repeater/rules/all/repeater.mk?>
     </para>
     <para>
      There's a lot here, so let's go through it line by line.  At the
      beginning, we see the normal check for undefined variables.  We
      want to make sure that the <varname>INPUT</varname> variable is
      defined.  (Obviously, a real build item would have to come up
      with a better, less generic name than this.)  Next, we add all
      the <filename>.rpt</filename> lines to the <command>all</command>
      target, as usual, by adding them as dependencies of
      <command>all</command> specified with two colons, indicating that
      there are multiple <command>all</command> targets.  So far,
      there's nothing different from any other code generator.
     </para>
     <para>
      Next, we define a macro <function>rpt_command</function> which
      actually runs the command to generate the files.  Note that, in
      this case, the code generator lives right in the build item, so
      there's really not much reason to use
      <command>codegen-wrapper</command> with it.  But our purpose here
      is to demonstrate <command>codegen-wrapper</command>, so we'll
      use it!  When defining this macro, we make use of the variables
      <varname>$&lt;</varname> and <varname>$@</varname>.  These are
      predefined make variables that, when evaluated in the context of
      a rule, refer to the first prerequisite and the target
      respectively.  They aren't valid at the point where the macro is
      defined, but they are valid at the point where it is expanded,
      which is what's relevant.  We don't really have to define a macro
      for this, but doing so helps us to avoid having to repeat the
      invocation of the code generator, which might be involved in some
      cases.
     </para>
     <para>
      Finally, there's the rule itself.  This is a typically GNU Make
      pattern rule that generates a <filename>.rpt</filename> file from
      an input file without the suffix.  The complete rule is prefixed
      with the list of output files, thus restricting it to only apply
      on this files.  Within the rule definition itself, we make the
      generation step conditional upon whether the
      <varname>REPEATER_CACHE</varname> variable is defined.  The
      effect of the <command>ifdef</command> is applied at the time the
      file is read, no at the time the rule is run, but this is okay
      because the rule implementation file is always loaded after
      <filename>Abuild.mk</filename>.  When
      <varname>REPEATER_CACHE</varname> is not defined, we just run the
      repeater command normally.  When it is defined, we run it with
      <varname>$(CODEGEN_WRAPPER)</varname>, specifying the cache
      directory, the inptu files, the output files, and the commands
      using arguments to the <command>codegen-wrapper</command> command
      as invoked through the <varname>$(CODEGEN_WRAPPER)</varname>
      variable.
     </para>
     <para>
      Let's look at two build items that use these rules.  They both
      set their <varname>RULES</varname> variable to include
      <filename>repeater</filename>.  Both build items set the
      <varname>INPUT</varname> variable.  Only the second one sets the
      <varname>REPEATER_CACHE</varname> variable.  Here are the
      <filename>Abuild.mk</filename> file:
      <?example codegen-wrapper/user1/Abuild.mk?>
      <?example codegen-wrapper/user2/Abuild.mk?>
      Assuming that we start off with an empty cache directory, here is
      what the first build from scratch with <command>abuild -b
      all</command> would generate:
      <?qtest repeater-pass1.out?>
      Note that, for the build item <filename>user1</filename>, we just
      saw the messages that the output files were generated from the
      input files.  For <filename>user2</filename>, you can see
      messages from <command>codegen-wrapper</command> indicating that
      generation succeeded and that it has updated the cache.
     </para>
     <para>
      If we built again right away, the output files would already
      exist and be newer than the input files, so the rule wouldn't
      even trigger.  Therefore we have to first clean everything with
      <command>abuild -c all</command> to demonstrate the cache
      functionality.  If you're following along, you'll notice that the
      directory <filename>codegen-wrapper/user2/cache</filename> now
      contains four files: <filename>file1.md5</filename>,
      <filename>file1.rpt</filename>, <filename>file2.md5</filename>,
      and <filename>file2.rpt</filename>.  Here's the output of a
      second build from clean with <command>abuild -b all</command>:
      <?qtest repeater-pass2.out?>
      This time, the build of <filename>user1</filename> looks the
      same, but the build of <filename>user2</filename> is different.
      Instead of actually running the command to generate the output,
      we see <command>codegen-wrapper</command> telling us that files
      are up to date and that it is using the cached files.
     </para>
     <para>
      The best part about this is that if we modify one of the input
      files, the cache will get automatically updated.  Without doing a
      clean, we can add some line to the end of
      <filename>codegen-wrapper/user2/file2</filename> and run another
      build with <command>abuild -b all</command>.  That generates the
      following output:
      <?qtest repeater-mod-pass1.out?>
      Nothing happened in build item <filename>user1</filename> at all
      since everything was up to date.  Likewise, we see no mention of
      <filename>file1</filename> in <filename>user2</filename>.
      However, for <filename>file2</filename> in
      <filename>user2</filename>, we once again see the output from
      <command>codegen-wrapper</command> indicating that generation
      succeeded and that it has updated the cache.  Doing another clean
      build <command>abuild -c all</command> followed by
      <command>abuild -b all</command>, we once again see that files
      from the cache are used:
      <?qtest repeater-pass2.out?>
     </para>
     <para>
      There's a lot to swallow here, but you will hopefully recognize
      the power and usefulness of such an approach.  Hopefully, the
      <command>codegen-wrapper</command> tool will meet some of your
      needs.  Even if it doesn't, it may provide a starting point.
      Here are a few things to take away from this example:
      <itemizedlist>
       <listitem>
        <para>
         Writing code generators is always going to require some
         advanced make coding.  The incremental complexity added by
         <command>codegen-wrapper</command> is relatively low, so for
         simple code generators, enhancing them to use this utility
         should be reasonably straightforward.
        </para>
       </listitem>
       <listitem>
        <para>
         The <command>codegen-wrapper</command> tool doesn't do
         anything fancy with respect to knowing how to generate output
         file names from input file names.  Instead, we just pass the
         actual names to it on the command line.  Using the make
         variables <varname>$&lt;</varname> and <varname>$@</varname>
         makes this easy.  Sometimes there may be multiple input files
         and/or multiple output files.  Handling multiple input files
         is fairly easy.  The make variable <varname>$^</varname>
         contains all the prerequisites for a given target while
         <varname>$&lt;</varname> contains the first prerequisite.
         Using <varname>$&lt;</varname> or <varname>$^</varname> for
         your input files and <varname>$@</varname> for your output
         files is nice when you can get away with it because all the
         handling of finding input files in <filename>..</filename>
         (through make's <varname>VPATH</varname> feature) is handled
         for you automatically.
        </para>
        <para>
         Handling multiple output files may be a bit trickier, but it
         can still be done.  You may need to experiment a little.
         Often you will find that make will pick whichever target it
         tries to create first as <command>$@</command> and that the
         rule will be invoked only one time.  In this case, you may
         have to generate your output file names yourself.  Sometimes
         you can do this by defining them relative to
         <command>$@</command>, which you should do if at all
         possible.  For an example of this, you can look at
         <filename>make/standard-code-generators.mk</filename> in your
         &abuild; distribution.  This code uses
         <command>codegen-wrapper</command> for flex and bison.  The
         bison rules generate multiple output files from a single input
         file and generate the multiple output names from
         <varname>$@</varname> in this way.
        </para>
       </listitem>
       <listitem>
        <para>
         In our little example, the code generator was always
         available, so when we modified the input file, everything
         worked.  If the code generator were not available or if it
         failed, <command>codegen-wrapper</command> would fail with the
         same exit status and would not updated the cache.
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect2>
   </sect1>
  </chapter>  <chapter id="ref.interface-flags">
   <!--  This chapter must follow the backing areas chapter since  -->
   <!--  the private interface flags examples are in a tree with   -->
   <!--  a backing area.                                           -->
   <title>Interface Flags</title>
   <para>
    In this chapter, we will examine interface flags.  Both interface
    flags and standard &abuild; interface conditionals allow us to
    cause a particular interface variable assignment to be evaluated
    only under a specific condition.  When such assignments are
    implemented inside normal &abuild; interface conditional blocks,
    all depending build items will see the results of such assignments
    in the same way (as would be typical of any variable assignment
    system).  With interface flags, it is possible to have different
    build items see the effects of different assignments to certain
    variables, a concept we describe in greater depth below.  This is
    an unusual capability, but it is very useful for implementing
    private interfaces.  In this chapter, we will explore interface
    flags in enough detail to see how to use them to implement private
    interfaces, which is their primary use.
   </para>
   <sect1 id="ref.flags-overview">
    <title>Interface Flags Conceptual Overview</title>
    <para>
     If there were a contest to select the most unusual feature of
     &abuild;, interface flags would probably be the strongest
     contender for the prize.  This section presents a conceptual
     overview that should be good enough to enable you to make use of
     interface flags to implement private interfaces.  We provide a
     private interface example at the end of this chapter.  In order
     to provide a conceptual overview of how interface flags work, we
     will present a partial but accurate explanation of how they work,
     and we will focus our attention on list variables only.  To
     understand interface flags in full detail, see <xref
     linkend="ref.interface-implementation"/>.
    </para>
    <para>
     Every build item in &abuild;, whether it has an
     <filename>Abuild.interface</filename> file or not, has an
     &abuild; interface.  The &abuild; interface for a build item is
     the union of all the interfaces of all its dependencies, taken in
     dependency order, along with its own
     <filename>Abuild.interface</filename>, if any.  To understand
     what we mean by the &ldquo;union&rdquo; of &abuild; interfaces,
     you have to know a little bit about how &abuild; stores
     interfaces.
    </para>
    <para>
     Recall that &abuild; interface files contain a series of variable
     declarations and assignments, and that variables may be declared
     in one file and assigned to in other files.  In particular, it is
     standard operating procedure for numerous
     <filename>Abuild.interface</filename> files to all assign to the
     same list variables (<varname>INCLUDES</varname>,
     <varname>LIBDIRS</varname>, <varname>LIBS</varname>,
     <varname>abuild.classpath</varname>, etc.).  As &abuild; reads
     interface files and encounters multiple assignments to the same
     list variable, it doesn't actually update some internal notion of
     that variable's value as you might suspect.  Rather than storing
     the values of variables in a build item's interface, &abuild;
     actually retains a list of all the assignments to a given
     variable throughout all the relevant
     <filename>Abuild.interface</filename> files.  This enables
     &abuild; to compute the values of variables when they are needed.
     When we say that an &abuild; interface is the union of the
     interfaces of its dependencies, what we really mean is that the
     value of each interface variable comes from the union of all
     assignments to those variables across all the dependencies'
     interface files.
    </para>
    <para>
     There are two different times when &abuild; computes the value of
     an interface variable.  The first is when that variable is
     expanded in an <filename>Abuild.interface</filename> file using
     the <varname>$(VARIABLE)</varname> syntax.  The second is when
     &abuild; generates the dynamic output file as introduced in <xref
     linkend="ref.abuild-interface-functionality-overview"/>.  In each
     case, &abuild; computes the value of a variable by looking at all
     the assignments it knows about at that time and combining them
     together based on whether the list variable is an
     <type>append</type> list or a <type>prepend</type> list.  Either
     way, since &abuild; has a history of all assignments to the
     variable, it has everything it needs to compute the value of the
     variable.
    </para>
    <para>
     Now this is where flags come in.  As we saw in <xref
     linkend="ref.abuild.interface-syntactic-details"/>, it is
     possible to associate a given variable assignment with an
     interface flag.  When a variable assignment is associated with an
     interface flag, &abuild; simply stores this fact in the list of
     assignments to the variable.  When it is time to compute a value
     for the variable, &abuild; filters out all assignments that are
     associated with a flag that isn't set.  Consider the following
     example.  Suppose the variable <varname>VAR1</varname> is
     declared as an <type>append</type> list of <type>string</type>s,
     and that you have the following assignments to
     <varname>VAR1</varname>:

     <programlisting>VAR1 = one
flag flag1 VAR1 = two
VAR1 = three
</programlisting>
     If you evaluate this sequence of assignments with the
     <property>flag1</property> flag set, the value of
     <varname>VAR1</varname> would be <literal>one two
     three</literal>.  If you evaluate this list of assignments
     <emphasis>without</emphasis> the <property>flag1</property> flag
     set, the value of <varname>VAR1</varname> would just be
     <literal>one three</literal>.
    </para>
    <para>
     Here is a subtle but important point.  You don't really have to
     understand it to make use of private interfaces, but if you can
     understand it, you will be well on your way to grasping how
     interface flags really work.  This handling of interface flags
     means that the value of a variable is based on the collection of
     flags that are set <emphasis>when its value is
     computed</emphasis>.  As we already noted, there are two
     instances in which &abuild; computes the values of variables:
     when it encounters a variable expansion while reading
     <filename>Abuild.interface</filename> files, and when it creates
     dynamic output files.  Interface flags are only set when creating
     dynamic output files.  At the time that
     <filename>Abuild.interfaces</filename> are being read, flags
     haven't been set yet.  If this worked any other way, it would not
     be possible for multiple build items to see different values for
     certain variables, and that is the whole reason for being of
     interface flags.  We defer further discussion of this point to
     <xref linkend="ref.interface-implementation"/>.
    </para>
    <para>
    </para>
   </sect1>
   <sect1 id="ref.using-flags">
    <title>Using Interface Flags</title>
    <para>
     In order to associate a particular variable assignment with a
     flag, the assignment in an <filename>Abuild.interface</filename>
     file must be prefixed with <literal>flag
     <replaceable>flagname</replaceable></literal>, as we have seen
     above.  Before <property>flagname</property> can be associated
     with an assignment, it must be declared as one of the build
     item's <firstterm>supported flags</firstterm>.  This is achieved
     by including the flag in the <property>supported-flags</property>
     keyword in <filename>Abuild.conf</filename>.  For example:

     <programlisting>supported-flags: flagname
</programlisting>
    </para>
    <para>
     As we have already seen, the effect of an assignment that is
     associated with a flag is visible only if the value of the
     variable is requested when the specified flag is set.  The only
     time this ever happens is when &abuild; is creating the dynamic
     output file for a build item.  We mentioned above that &abuild;
     maintains a list of assignments for each variable and retains a
     record of any flag that may have been associated with each
     assignment.  &Abuild; also stores the name of the build item that
     is responsible for each assignment in a variable's assignment
     history.  When one build item depends on another, it may request
     the evaluation of any assignments made by the dependency item
     that were associated with a specific flag.  This is done by
     including the
     <option>-flag=<replaceable>flagname</replaceable></option> option
     when declaring the dependency in the
     <filename>Abuild.conf</filename> file.  For example, if build
     item <classname>A</classname> wanted to see all assignments that
     <classname>B</classname> made associated with the
     <property>private</property> flag, then
     <classname>A</classname>'s <filename>Abuild.conf</filename> would
     contain the following line:

     <programlisting>deps: B -flag=private
</programlisting>
     When a flag is specified as part of a dependency in this fashion,
     &abuild; requires that the dependency list the given flag as one
     of its supported flags.  For example, in this case, it would be
     an error if <classname>B</classname>'s
     <filename>Abuild.conf</filename> did not list
     <property>private</property> in its
     <property>supported-flags</property> key.
    </para>
    <para>
     As mentioned above, the effect of any flag-based assignment is
     visible only when actually exporting a build item's interface to
     the dynamic output.  When &abuild; exports a build item's own
     interface for its own use, it does so with all of the flags
     supported by that build item in effect.  For example, in <xref
     linkend="fig.private-flag"/>, <classname>B</classname> has an
     <filename>include</filename> directory and a
     <filename>private-include</filename> directory.  It wants the
     <filename>include</filename> directory to be visible to all build
     items that depend on it, but the
     <filename>private-include</filename> directory should be visible
     only to other build items that specifically ask for it.
     <classname>B</classname> would indicate that it supports the
     <property>private</property> flag by adding this line to its
     <filename>Abuild.conf</filename>:

     <programlisting>supported-flags: private
</programlisting>
     If it wanted the header files in <filename>include</filename>
     directory to be visible to all items that depend on it, but it
     wanted the header files in the
     <filename>private-include</filename> directory to be visible only
     to those build items that specifically requested by depending on
     it with the <property>private</property> flag, it would include
     the following lines in its <filename>Abuild.interface</filename>
     file:

     <programlisting>INCLUDES = include
flag private INCLUDES = private-include
</programlisting>
     If <classname>A</classname> wanted to see the
     <filename>private-include</filename> directory, it could indicate
     that it wants the <property>private</property> flag set when it
     reads <classname>B</classname>'s
     <filename>Abuild.interface</filename>.  It would do this by
     including the following in its <filename>Abuild.conf</filename>:

     <programlisting>deps: B -flag=private
</programlisting>
     Then, when <classname>A</classname> reads
     <classname>B</classname>'s <filename>Abuild.interface</filename>
     file, it will see the <filename>private-include</filename>
     assignment.  <classname>B</classname> will also see it because
     build items always see all of their own flag-based assignments.
     If a third build item <classname>X</classname> depended on
     <classname>A</classname> without specifying the
     <property>private</property> flag, it would not see
     <classname>B</classname>'s <filename>private-include</filename>
     directory as that assignment would not be inherited through
     <classname>A</classname>'s interface.
     <figure id="fig.private-flag">
      <title>Private Interface Flag</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="private-flag.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>A</classname> and <classname>B</classname> see
         <filename>private-include</filename>, but
         <classname>X</classname> does not.
        </para>
       </caption>
      </mediaobject>
     </figure>
     This is a bit tricky to understand.  For additional
     clarification, see the example below, <xref
     linkend="ref.example.private-interface"/>.
    </para>
    <para>
     Although we have used a single and generically named
     <property>private</property> flag for this example, there is
     nothing special about the name
     &ldquo;<property>private</property>&rdquo;.  There's no reason
     that other special-purpose flags couldn't be introduced to
     provide fine-grained control over which parts of a build item are
     to be visible to other build items.  In most cases, use of a
     simple flag like <property>private</property> should suffice.  To
     reduce confusion among developers in a project, it is recommended
     that a project adopt its own conventions about how interface
     flags will be used.
    </para>
   </sect1>
   <sect1 id="ref.example.private-interface">
    <title>Private Interface Example</title>
    <indexterm>
     <primary>private interfaces</primary>
    </indexterm>
    <para>
     Here we return to our <filename>user</filename> trees in
     <filename>doc/example/general/user</filename>.  In our user
     branch, we have modified the <classname>project-lib</classname>
     library to make use of private interfaces.  If you look at the
     <filename>Abuild.conf</filename> in the <filename>src</filename>
     directory, you will see that it lists
     <property>private</property> in its
     <property>supported-flags</property> key:
     <?example general/user/project/lib/src/Abuild.conf?>
     In its <filename>Abuild.interface</filename> file, it adds
     <filename>../private-include</filename> to
     <varname>INCLUDES</varname> only when the
     <property>private</property> flag is set:
     <?example general/user/project/lib/src/Abuild.interface?>
     This makes the headers in the
     <filename>private-include</filename> directory visible to it and
     any build item that depends on it with
     <option>-flag=private</option>.
     <footnote>
      <para>
       Note that when the <property>private</property> flag is set,
       <emphasis>both</emphasis> assignments to
       <varname>INCLUDES</varname> take effect.  To understand why
       this is, please see <xref
       linkend="ref.interface-implementation"/>.
      </para>
     </footnote>
     Note that the
     <classname>project-lib.src</classname> build item didn't have to
     do anything special to see its own private interfaces.  This is
     because a build item automatically operates with all of its own
     interface flags set for itself.  Another thing we've done in this
     build item is to put the new source file
     <filename>ProjectLib_private.cpp</filename> in a
     <filename>private</filename> subdirectory:
     <?example general/user/project/lib/src/Abuild.mk?>
     The only reason we did this was to demonstrate that &abuild;
     allows multi-element paths (<emphasis>i.e.</emphasis>, paths
     with subdirectories in them) in your source variables.  Just
     avoid putting &ldquo;<filename>..</filename>&rdquo; anywhere in
     the path.
     <footnote>
      <para>
       Such constructs, if permitted, would potentially cause &abuild;
       to write files outside the output directory.  For example, if
       you had <filename>../A.cc</filename> as a source file, &abuild;
       would construct
       <filename>abuild-<replaceable>platform</replaceable>/../A.o</filename>
       as the object file name.  Fortunately, &abuild; actually
       detects this case and reports an error.
      </para>
     </footnote>
    </para>
    <para>
     If you study <filename>ProjectLib.cpp</filename> in
     <filename>user/project/lib/src</filename>, you will notice that
     we have included the file
     <filename>ProjectLib_private.hpp</filename>, which is located in
     the <filename>private-include</filename> directory, and that we
     have called a function that is declared in that file to get the
     value with which we initialize <varname>cl1</varname>:
     <?example general/user/project/lib/private-include/ProjectLib_private.hpp?>
     <?example general/user/project/lib/src/ProjectLib.cpp?>
     Private interfaces can be particularly useful in any
     implementation that hides implementation details from outside
     users because it can prevent accidentally accessing restricted
     header files.  This type of construct is most useful in straight
     C code rather than C++ code since C doesn't provide any
     encapsulation capability other than use of opaque types defined
     in private header files.  This is somewhat akin to using the
     <function>friend</function> keyword in C++, except that access to
     private interfaces is requested by the accessor rather than the
     accessee.
     <footnote>
      <para>
       Since the build item that supports the
       <property>private</property> flag is also protected by the
       scope of its name, this gives us an added layer of protection.
      </para>
     </footnote>
    </para>
    <para>
     The test code in <filename>main.cpp</filename> in
     <filename>user/project/lib/test</filename> also calls a function
     defined in the private header file.  Note that the
     <filename>Abuild.conf</filename> file in the
     <filename>test</filename> directory mentions
     <classname>project-lib.src</classname> explicitly in its
     dependency list, and that it is followed by
     <option>-flag=private</option>:
     <?example general/user/project/lib/test/Abuild.conf?>
     This means that when <classname>project-lib.test</classname>
     reads <classname>project-lib.src</classname>'s
     <filename>Abuild.interface</filename> file, any assignments that
     are flagged with the <property>private</property> flag will be
     processed.
    </para>
    <para>
     The alert reader may notice that we have also assigned the trait
     <property>interesting</property> to this build item.  Although
     the build item is somewhat interesting, the primary purpose of
     doing this is to illustrate the use of a trait without a referent
     build item and to show how a trait can be added in a specific
     tree to supplement traits that are available because of our tree
     dependencies.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.cross-platform-support">
   <title>Cross-Platform Support</title>
   <sect1 id="ref.platform-selection">
    <title>Platform Selection</title>
    <indexterm>
     <primary>platform selectors</primary>
    </indexterm>
    <para>
     When &abuild; starts up, it determines a list of object-code
     platform types and, within each platform type, a list of
     platforms.  Platforms are given initial priorities based on the
     order in which they are declared with later declarations having
     higher priority than earlier ones.  (In this way, platforms added
     by plugins are preferred over internally defined ones.)  By
     default, &abuild; builds each object-code build item on the
     highest priority platform in each of its platform types.
     &Abuild; may also choose to build an item on additional platforms
     to satisfy dependencies.
    </para>
    <para>
     The list of platforms on which &abuild; will attempt to build an
     item may be overridden using platform selectors.  Platform
     selectors may be specified in the
     <varname>ABUILD_PLATFORM_SELECTORS</varname> environment variable
     or on the command line using the
     <option>--platform-selector</option> or <option>-p</option>
     command-line flag.  Each platform selector may refer to a
     specific platform type or may be a general selector for all
     platform types.  There may be at most one selector for each
     platform type and at most one general selector.  If multiple
     selectors for the sample platform type or multiple general
     selectors are specified, &abuild; chooses the last one.
     Selectors given on the command line always take precedence over
     those in the environment variable.  This makes it possible for
     later options to override earlier ones or for the command line to
     override the environment.  To specify multiple selectors in the
     environment, set the variable to contain multiple space-separated
     words.  To specify multiple selectors on the command line,
     provide the command-line option more than once.  For example:

     <programlisting>--platform-selector <replaceable>selector</replaceable> [ --platform-selector <replaceable>selector</replaceable> ... ]
</programlisting>
     or

     <programlisting>ABUILD_PLATFORM_SELECTORS="<replaceable>selector</replaceable>[ <replaceable>selector</replaceable> ... ]"
</programlisting>
    </para>
    <para>
     Each selector is of the form

     <programlisting>[<replaceable>platform-type</replaceable>:]<replaceable>criteria</replaceable>
</programlisting>
    </para>
    <para>
     If no <replaceable>platform-type</replaceable> is specified, then
     the selector applies to all object-code platform types.  When
     applying selectors, &abuild; will always first try a selector for
     the specific platform type first.  Only if there isn't one will
     &abuild; attempt to use the general selector.
    </para>
    <para>
     The <replaceable>criteria</replaceable> field above may have one
     of the following forms:
     <itemizedlist>
      <listitem>
       <para>
        <type>option=<replaceable>option</replaceable></type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>compiler=<replaceable>compiler</replaceable>[.<replaceable>option</replaceable>]</type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>platform=<replaceable>os</replaceable>.<replaceable>cpu</replaceable>.<replaceable>toolset</replaceable>.<replaceable>compiler</replaceable>[.<replaceable>option</replaceable>]</type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>all</type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>default</type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>skip</type>
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     The special <type>skip</type> selector prevents automatic
     selection of any platforms from the type.  When it is used, no
     platforms from that platform type are selected by default, so no
     builds will be done in that platform type except when needed to
     satisfy a dependency.  This could be useful if you only wanted to
     do embedded builds, for example.  This is the only selector that
     can be used with the <type>indep</type> or <type>java</type>
     platform types.  Starting with &abuild; 1.1.4, it is valid to
     specify <type>skip</type> without a platform type qualifier,
     which will suppress any default platform selection for any object
     code platform type.  This could be used to build only
     <type>indep</type> and <type>java</type>, or it could be used to
     suppress all but a specific platform type by also providing a
     type-specific selector for the type you do want to build.
    </para>
    <para>
     The <type>default</type> selector means to select whichever
     platform would be selected if no platform specifier were given.
     It must be used with a platform type qualifier.  This is useful
     to direct &abuild; to use the default for a given platform type
     when a general specifier was used.
    </para>
    <para>
     The other selectors are translated into an (<type>os</type>,
     <type>cpu</type>, <type>toolset</type>, <type>compiler</type>,
     <type>option</type>) tuple.  Each field may be
     <literal>*</literal> or a platform field.  The selector
     <type>all</type> is equivalent to <literal>*.*.*.*.*</literal>.
     The empty string may not be explicitly specified, but omitted
     fields are mapped to the empty string.  For example,
     <type>compiler=x</type> is equivalent to (<type>""</type>,
     <type>""</type>, <type>""</type>, <type>"x"</type>,
     <type>""</type>).  Any empty string field except for
     <type>option</type> matches the corresponding field of the
     highest priority platform (the last one declared) in the list of
     platforms for the given type.  This is the always the first
     platform listed for the platform type by <command>abuild
     --list-platforms</command>.  An empty <type>option</type> field
     means that the <type>option</type> field of the platform must be
     empty.
    </para>
    <para>
     When picking platforms on which to build by default, &abuild;
     will always pick the first platform that matches the criteria.
     If there are no matches, it will pick the first platform of the
     platform type.  If any of the fields of the selector are equal to
     <literal>*</literal>, then &abuild; will select
     <emphasis>all</emphasis> platforms that match the criteria, again
     falling back to only the first platform in the type if there are
     no matches.
    </para>
    <para>
     Here are several examples.  For purposes of discussion, assume
     that we have the following platforms, shown here by type:
     <variablelist>
      <varlistentry>
       <term><type>vxworks</type></term>
       <listitem>
        <simplelist>
         <member><type>vxworks.ppc.6_3.vxgcc</type></member>
         <member><type>vxworks.x86.6_3.vxgcc</type></member>
         <member><type>vxworks.x86.6_3.vxgcc.debug</type></member>
        </simplelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>native</type></term>
       <listitem>
        <simplelist>
         <member><type>linux.x86.rhel4.xlc</type></member>
         <member><type>linux.x86.rhel4.xlc.debug</type></member>
         <member><type>linux.x86.rhel4.xlc.release</type></member>
         <member><type>linux.x86.rhel4.gcc</type></member>
         <member><type>linux.x86.rhel4.gcc.debug</type></member>
         <member><type>linux.x86.rhel4.gcc.release</type></member>
        </simplelist>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     If no platform selectors were provided, we would build native
     build items with <type>linux.x86.rhel4.xlc</type> and
     <type>vxworks</type> build items with
     <type>vxworks.ppc.6_3.vxgcc</type>.  Here are several platform
     selectors along with a description of what they mean:
     <variablelist>
      <varlistentry>
       <term><type>native:option=debug</type></term>
       <listitem>
        <para>
         On the native platform type, build with the first platform
         that has the <type>debug</type> option.  If none, build with
         the first platform regardless of its options.  (This is
         always the behavior when there are no platforms that fit the
         criteria, so this will not repeated for each example.)  In
         this case, we would build <type>native</type> items on
         <type>linux.x86.rhel4.xlc.debug</type>.  Build the default
         platform for <type>vxworks</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>native:compiler=gcc.release</type></term>
       <listitem>
        <para>
         On the native platform type, build with compiler
         <type>gcc</type> with the <type>release</type> option.  In
         this case, that would be
         <type>linux.x86.rhel4.gcc.release</type>.  Build the default
         platform for vxworks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>compiler=gcc vxworks:default</type></term>
       <listitem>
        <para>
         On all <type>object-code</type> platform types except
         <type>vxworks</type>, build with <type>gcc</type> with no
         options.  For <type>native</type>, this is
         <type>linux.x86.rhel4.gcc</type>.  Explicitly build the
         default platform for <type>vxworks</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>native:compiler=gcc.*</type></term>
       <listitem>
        <para>
         On the native platform type, build all <type>gcc</type>
         platforms with all options, including the <type>gcc</type>
         platform without any options.  That would include
         <type>linux.x86.rhel4.gcc</type>,
         <type>linux.x86.rhel4.gcc.debug</type>, and
         <type>linux.x86.rhel4.gcc.release</type>.  Build the default
         platform for vxworks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>native:compiler=*.debug</type></term>
       <listitem>
        <para>
         On the native platform type, build all platforms that have
         the <type>debug</type> option:
         <type>linux.x86.rhel4.xlc.debug</type> and
         <type>linux.x86.rhel4.gcc.debug</type>.  Build the default
         platform for vxworks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>native:compiler=*.*</type></term>
       <listitem>
        <para>
         On the native platform type, build all platforms:
         <type>linux.x86.rhel4.xlc</type>,
         <type>linux.x86.rhel4.xlc.debug</type>,
         <type>linux.x86.rhel4.xlc.release</type>,
         <type>linux.x86.rhel4.gcc</type>,
         <type>linux.x86.rhel4.gcc.debug</type>, and
         <type>linux.x86.rhel4.gcc.release</type>.  Build the default
         for vxworks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>vxworks:platform=*.*.*.*.debug</type></term>
       <listitem>
        <para>
         On vxworks, build for all platforms that have the
         <type>debug</type> option:
         <type>vxworks.x86.6_3.vxgcc.debug</type>.  Build the default
         platform for native.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>vxworks:platform=*.x86.*.*.*</type></term>
       <listitem>
        <para>
         On vxworks, build all platforms that have <type>x86</type> as
         the <type>cpu</type> field:
         <type>vxworks.x86.6_3.vxgcc</type> and
         <type>vxworks.x86.6_3.vxgcc.debug</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>skip indep:skip java:skip vxworks:default</type></term>
       <listitem>
        <para>
         Skip all platform types except vxworks, and build with the
         default platform for vxworks.  Note that specifying
         <type>skip</type> by itself only skips object-code platform
         types, so we have to explicitly skip <type>indep</type> and
         <type>java</type> as well.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>vxworks:skip</type></term>
       <listitem>
        <para>
         Skip the vxworks platform type; no vxworks builds will be
         done except as needed to satisfy dependencies.  Native builds
         are done normally.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>platform=*.*.*.*</type></term>
       <listitem>
        <para>
         For all otherwise unspecified platform types, build for all
         platforms that have an empty <type>option</type> field:
         <type>vxworks.ppc.6_3.vxgcc</type>,
         <type>vxworks.x86.6_3.vxgcc</type>,
         <type>linux.x86.rhel4.xlc</type>, and
         <type>linux.x86.rhel4.gcc</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>platform=*.*.*.*.*</type></term>
       <listitem>
        <para>
         For all otherwise unspecified platform types, build for all
         platforms.  This is the same specifying the platform selector
         <type>all</type>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect1>
   <sect1 id="ref.dependency-platform-compatibility">
    <title>Dependencies and Platform Compatibility</title>
    <indexterm>
     <primary>dependency</primary>
     <secondary>platform compatibility</secondary>
    </indexterm>
    <indexterm>
     <primary>platforms</primary>
     <secondary>compatibility for dependency</secondary>
    </indexterm>
    <para>
     As you can see, any given build item may build on one more
     platforms.  When build item <classname>A</classname> depends on
     build item <classname>B</classname>, that dependency must be
     satisfied separately for each platform on which
     <classname>A</classname> builds.  So if <classname>A</classname>
     and <classname>B</classname> both build on platforms
     <type>p1</type> and <type>p2</type>, then the actual situation is
     that <classname>A</classname> on <type>p1</type> depends on
     <classname>B</classname> on <type>p1</type>, and
     <classname>A</classname> on <type>p2</type> depends on
     <classname>B</classname> on <type>p2</type>.  This case of
     <classname>A</classname> and <classname>B</classname> building on
     the same platforms is simple and common, but there are cases in
     which things don't work out so easily.  For this, &abuild; has
     two concepts: <firstterm>platform compatibility</firstterm> and
     <firstterm>explicit cross-platform dependencies</firstterm>.  We
     discuss platform compatibility here and explicit cross-platform
     dependencies in the next section.  These sections describe these
     concepts in basic terms.  For the complete story with all the
     details, please refer to <xref
     linkend="ref.construction-of-build-graph"/>.
    </para>
    <para>
     The rules for platform compatibility are fairly straightforward.
     Specifically, a platform <type>p</type> in a platform type
     <type>pt</type> is compatible with all other platforms in
     <type>pt</type> and also with all platforms in <type>pt</type>'s
     <emphasis>parent</emphasis> platform type, and by extension, all
     the way up the hierarchy of platform types.  Starting with
     &abuild; 1.1.4, when a platform type is declared, it can
     optionally be declared to have a parent platform type.  In all
     versions of &abuild;, any platform type declared without a parent
     has the platform type <type>indep</type> as an implicit parent.
     This means that all platforms are compatible with
     <type>indep</type>, which is how any build item of any platform
     type can depend on a build item of type <type>indep</type>.
    </para>
    <para>
     For example, suppose you are creating a plugin to define platform
     types for the VxWorks embedded operating system, and you are
     creating separate platform types for different embedded boards
     that have different vendor-supplied board support packages.
     Suppose you also have a body of code that will work for all
     VxWorks boards and don't contain anything that depends on a
     specific board support package.  To implement this, you could
     create a common platform type for the specific version of VxWorks
     and then also create child platform types for each specific
     board.  For example, you could have a base type called
     <type>vxworks-6_8-base</type> and child types
     <type>vxworks-6_8-bsp1</type> and <type>vxworks-6_8-bsp2</type>.
     Now if you had a build item <classname>Q</classname> of type
     <type>vxworks-6_8-bsp1</type> and a build item
     <classname>R</classname> of type <type>vxworks-6_8-bsp2</type>,
     both build items could depend on item <classname>S</classname> of
     type <type>vxworks-6_8-base</type> since all platforms in the two
     board-specific platform types are compatible with the platforms
     in the base type.  Additionally, if there were a build item
     <classname>T</classname> of type <type>indep</type>, all three of
     the other build items could depend on <classname>T</classname>
     because <type>indep</type> is compatible with all other platform
     types.  For further discussion of creating platform types, see
     <xref linkend="ref.adding-platform-types"/>.
    </para>
   </sect1>
   <sect1 id="ref.cross-platform-dependencies">
    <!-- The title of this section is included in an error message in
         Interface.cc. -->
    <title>Explicit Cross-Platform Dependencies</title>
    <indexterm>
     <primary>dependency</primary>
     <secondary>cross-platform</secondary>
    </indexterm>
    <para>
     Ordinarily, when <classname>A</classname> depends on
     <classname>B</classname>, &abuild; requires that
     <classname>B</classname> be buildable on platforms that are
     compatible with all the platforms <classname>A</classname> is
     being built on.  In this case, the instance of
     <classname>A</classname> being built on platform <type>p</type>
     depends specifically on the instance of <classname>B</classname>
     being built on platform <type>p</type> or some other platform
     that is compatible with <type>p</type>.  Under these rules, it
     would be impossible for <classname>A</classname> to depend on
     <classname>B</classname> if <classname>B</classname> couldn't be
     built on at least one platform that was compatible with each of
     <classname>A</classname>'s platforms.  This would make it
     impossible for a platform-independent item to depend on any
     object-code or Java build items, object-code and Java build items
     to depend on each other, or for non-compatible object-code
     platform types to depend on each other.  (Recall from the
     previous section that any item can depend on a
     platform-independent build item since the platform type
     <type>indep</type> is compatible with all other platform types.)
     To make these other cases possible, &abuild; allows a dependency
     to declare that the dependency should be on a specific platform
     by using the <option>-platform</option> flag to the dependency
     declaration.  Rather than declaring a platform by name, the
     argument to the <option>-platform</option> argument is either a
     platform type or a platform-type-qualified platform selector.  In
     this case, the instance of <classname>A</classname> on each of
     its platforms depends on the specifically selected instance of
     <classname>B</classname>.
     <footnote>
      <para>
       Note that a platform-specific dependency overrides the
       dependency platform choice for all platforms on which the
       depending is being built.  It is not presently possible to make
       the platform-specific dependency behave differently for
       different platform types of the depending item.  This behavior
       could be simulated by making use of separate intermediate build
       items, but if you find yourself doing that, you may need to
       rethink how you're using the various platform types.
      </para>
     </footnote>
    </para>
    <para>
     To choose which of <classname>B</classname>'s platforms will be
     used, &abuild; picks the first platform in the given type that
     matches the platform selector.  Matches are performed using the
     same technique as when platform selectors are specified on the
     command line with two exceptions: the <type>criteria</type> field
     may be omitted, and the selector only ever matches a single
     platform even if <literal>*</literal> appears as one of the
     fields.  &Abuild; versions prior to 1.1 ignored any platform
     specifiers given on the command line or in the environment when
     resolving cross-platform dependencies, but the current &abuild;
     does take them into consideration.  If you want to specify a
     platform-specific dependency on the default platform for a given
     platform type <emphasis>regardless of any platform
     selectors</emphasis>, you can specify
     <type><replaceable>platform-type</replaceable>:default</type> as
     the <option>-platform</option> option to your dependency.
    </para>
    <sect2 id="ref.cross-platform-interface-errors">
     <!-- The title of this section is included in an error message in
          Interface.cc. -->
     <title>Interface Errors</title>
     <para>
      Under a very specific set of circumstances, it is possible to
      have a subtle and hard-to-understand error condition involving
      interface variables with cross-platform dependencies.  You
      should feel free to skip this section unless you are either
      determined to understand the deepest subtleties of how &abuild;
      works or you have been directed here by an error message issued
      by &abuild;.  To understand the material in this section, it
      will help to understand <xref
      linkend="ref.construction-of-build-graph"/> and <xref
      linkend="ref.interface-implementation"/>.
     </para>
     <para>
      Internally, when &abuild; builds a build item, it loads the
      interfaces of all the other build items that the item depends
      on.  If item <classname>A</classname> depends on item
      <classname>B</classname> in two different ways (say directly and
      indirectly or indirectly through two different dependency
      paths), &abuild; will effectively still load
      <classname>B</classname>'s interface file only one time because
      of the way the interface system keeps track of things.  At least
      this is what happens under normal circumstances.  If, however,
      the two different instances of <classname>B</classname> in
      <classname>A</classname>'s dependency chain are from different
      platforms, problems can arise.
     </para>
     <para>
      We should note that this can happen only under the following
      conditions:
      <itemizedlist>
       <listitem>
        <para>
         Build item <classname>A</classname> depends (directly or
         indirectly) on two items, which we'll call
         <classname>X1</classname> and <classname>X2</classname>.
        </para>
       </listitem>
       <listitem>
        <para>
         Both <classname>X1</classname> and <classname>X2</classname>
         depend on <classname>B</classname>.
        </para>
       </listitem>
       <listitem>
        <para>
         At least one of <classname>X1</classname> and
         <classname>X2</classname> depends on <classname>B</classname>
         with a platform-specific dependency.  If both do, they do so
         with different platform specifications.
        </para>
       </listitem>
      </itemizedlist>
      When all of the above conditions have been met,
      <classname>A</classname> will have two different instances of
      <classname>B</classname> in its dependency chain.
     </para>
     <para>
      Once this situation has occurred, it becomes possible for there
      two be conflicting assignments to a variable, both of which
      originate from the same line of the same interface file.  For
      example, if <classname>B</classname>'s
      <filename>Abuild.interface</filename> file assigns the value of
      <varname>$(ABUILD_OUTPUT_DIR)</varname> to a scalar interface
      variable, the effect of that assignment will differ across the
      two different instances of <classname>B</classname>.  &Abuild;
      will detect this case and issue an error message.  (That error
      message will direct you here to this section of the manual!)  If
      <classname>B</classname> assigns this to a list variable,
      there's no problem&mdash;&abuild; will honor both assignments.
      It's also no problem if the assignment doesn't have different
      meanings on the different platforms.  It's only when the same
      assignment causes a conflict that &abuild; will complain.
     </para>
     <para>
      If you should run into this situation, there are several
      possible remedies you should consider.
      <itemizedlist>
       <listitem>
        <para>
         Rethink why you are using cross-platform dependencies in this
         way.  If you're just trying to make sure that some other
         build item gets built, consider whether you can use
         <property>build-also</property> instead of platform-specific
         dependencies to meet your needs.
        </para>
       </listitem>
       <listitem>
        <para>
         If you want both values and doing this won't hurt other build
         items, use a list variable instead of a non-list variable.
         In this case, abuild will give you both (all) values.
        </para>
       </listitem>
       <listitem>
        <para>
         If you don't care which value you get, and doing so doesn't
         cause other problems for other build items, use a fallback or
         override assignment instead of a regular assignment.  Then
         you'll get the first (in the case of fallback) or last (in
         the case of override) assignment that is processed.
        </para>
       </listitem>
       <listitem>
        <para>
         If you can't change <classname>B</classname>'s interface and
         <classname>A</classname> doesn't care about the value of the
         value, you can do a reset on the offending variable from the
         one or more of the items that <classname>A</classname>
         depends on and that depend on different instances of
         <classname>B</classname>.  For example,
         <classname>X1</classname> could have an after-build file that
         resets the offending variable.  Then when
         <classname>A</classname> imports <classname>X1</classname>'s
         interface, it will no longer include the conflicting
         assignment from <classname>B</classname>'s interface.
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.pass-through-dependencies">
    <title>Dependencies and Pass-through Build Items</title>
    <indexterm>
     <primary>pass-through build item</primary>
     <secondary>dependencies</secondary>
    </indexterm>
    <para>
     When a build item does not declare any platform types and has
     dependencies on items of multiple platform types, that item
     because a <firstterm>pass-through</firstterm> build item and is
     handled slightly differently with respect to dependencies.
     Specifically, a pass-through build item is implicitly buildable
     on every platform, so any build item may depend on a pass-through
     build item.  Also if a specific instance of pass-through build
     item on a specific platform depends on another item for which
     there are no compatible platform types, that dependency is
     ignored.  This makes it possible to use pass-through build items
     to provide wrappers around families of alternative build items
     that provide related but separate functionality for consumers of
     different platform types.
    </para>
    <para>
     For example, suppose build items <classname>A1</classname> and
     <classname>B1</classname> build on platform <type>X</type> and
     build items <classname>A2</classname> and
     <classname>B2</classname> build on platform <type>Y</type>.  If
     <classname>A1</classname> and <classname>A2</classname> depend on
     pass-through item <classname>P</classname> which in turn depends
     on <classname>B1</classname> and <classname>B2</classname>,
     &abuild; will create effective dependencies between the
     <classname>A1</classname> and <classname>A2</classname> and also
     between <classname>B1</classname> and <classname>B2</classname>
     based on platform type (see <xref linkend="fig.pass-through"/>).
     <figure id="fig.pass-through">
      <title>Multiplatform Pass-through Build Item</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="pass-through.png"/>
       </imageobject>
       <caption>
        <para>
         Pass-through item <classname>P</classname> effectively
         connects <classname>A1</classname> to
         <classname>B1</classname> and <classname>A2</classname> to
         <classname>B2</classname> based on their platform types.
        </para>
       </caption>
      </mediaobject>
     </figure>
     What's really happening here is that the instance of
     <classname>P</classname> for <type>X</type> depends on
     <classname>B1</classname> and ignores <classname>B2</classname>
     while the instance of <classname>P</classname> on <type>Y</type>
     depends on <classname>B2</classname> and ignores
     <classname>B1</classname>.  If <classname>P</classname> also had
     a dependency on some third build item of type <type>indep</type>,
     both instances of <classname>P</classname>, and therefore
     effectively both <classname>A1</classname> and
     <classname>B1</classname> would also depend on the third item of
     type <type>indep</type>.
    </para>
    <para>
     The documentation doesn't provide a specific example that
     illustrates that case because this type of usage would be fairly
     unusual.
     <footnote>
      <para>
       Okay, we don't provide an example because it's tricky to make
       one that would be more illustrative than confusing without an
       actual embedded platform to work with.  If we did create an
       example, we'd have to make up some kind of simulated embedded
       platform with a plugin, and that would probably create more
       confusion than it would be worth.
      </para>
     </footnote>
     Instead, we will provide a description of how it would work.
     Suppose you had a plugin to support VxWorks, an embedded
     operating system, that added a platform type
     <type>vxworks</type>, and you wanted to provide a custom
     threading library that worked for your native platform and for
     VxWorks.  Suppose also that your native library implementation
     used boost threads but that you wanted to create a VxWorks
     implementation that used VxWorks native threads.  You could
     create a pass-through build item called
     <classname>threads</classname> that depends on
     <classname>threads.native</classname> and
     <classname>threads.vxworks</classname>, and you could set up
     <classname>threads.native</classname> to have
     <property>platform-types</property> <type>native</type> and
     <classname>threads.vxworks</classname> to have
     <property>platform-types</property> <type>vxworks</type>.  The
     <classname>threads</classname> build item would not declare any
     platform types.  It would just depend on
     <classname>threads.vxworks</classname> and
     <classname>threads.native</classname>.  If you now had a program
     that supported both <type>native</type> and <type>vxworks</type>
     that depended on <classname>threads</classname>, your application
     would use the <classname>threads.native</classname>
     implementation when it built on the <type>native</type> platforms
     and the <classname>threads.vxworks</classname> implementation
     when it built on <type>vxworks</type> platforms.  This would
     happen transparently because of the pass-through build item.  If
     you wanted to allow <emphasis>any</emphasis> build item to depend
     on <classname>threads</classname> even if there is no support for
     that item's platform type, you could also create
     <classname>threads.indep</classname> and make
     <classname>threads</classname> depend on that as well.  Just keep
     in mind that all instances of <classname>threads</classname> will
     depend on the <type>indep</type> version even if they also depend
     on one of the platform-specific versions.
    </para>
    <para>
     To fully understand why this works, please see <xref
     linkend="ref.construction-of-build-graph"/>.  Note that you could
     also put conditionals in your
     <filename>Abuild.interface</filename> and/or
     <filename>Abuild.mk</filename> to avoid having to split this into
     multiple build items, so this is not the only solution.  The same
     trick would work if you wanted to create a facade for a library
     that was implemented in multiple languages, though it's unlikely
     that there would be any reason to do that: although you can have
     one build item that builds for multiple platform types, you can't
     have a single build item that builds for target types.
    </para>
   </sect1>
   <sect1 id="ref.example.cross-platform-dependency">
    <title>Cross-Platform Dependency Example</title>
    <para>
     In the <filename>doc/example/cross-platform</filename> directory,
     there is a build tree that illustrates &abuild;'s ability to
     enhance dependency declaration with platform type or platform
     information.  In this example, we show a platform-independent
     code generator that calls a C++ program to do some of its work.
     We also show a program that uses this code generator.  We'll
     examine these build items from the bottom up in the dependency
     chain.  Our first several items are quite straightforward and are
     no different in how they work from what we've seen before.
    </para>
    <para>
     First, look at <filename>lib</filename>:
     <?example cross-platform/lib/Abuild.conf?>
     <?example cross-platform/lib/Abuild.mk?>
     <?example cross-platform/lib/Abuild.interface?>
     This build item defines a function <varname>f</varname> that
     returns the square of its integer argument.  Here is
     <filename>lib.cc</filename>:
     <?example cross-platform/lib/lib.cc?>
    </para>
    <para>
     Next, look at <filename>calculate</filename>:
     <?example cross-platform/calculate/Abuild.conf?>
     <?example cross-platform/calculate/Abuild.mk?>
     <?example cross-platform/calculate/calculate.cc?>
     This is a simple program that takes a number of arguments on the
     command line and prints tab-delimited output with the number in
     column 1 and the square of the number in column 2.  It uses the
     <function>f</function> function in <classname>lib</classname> to
     do the square calculation, and therefore depends on the
     <classname>lib</classname> build item.
    </para>
    <para>
     So far, we haven't seen anything particularly unusual in this
     example, but this is where it starts to get interesting.  The
     material here is tricky.  To follow this, you need to remember
     that variables set in <filename>Abuild.interface</filename> files
     of build items you depend on are available to you as
     <application>make</application> variables.  We can use
     <application>make</application>'s <function>export</function>
     command to make those variables available in the environment.
    </para>
    <para>
     The <classname>calculate</classname> build item exports the name
     of its program in an interface variable in its
     <filename>Abuild.interface</filename> file by creating a variable
     called <varname>CALCULATE</varname>:
     <?example cross-platform/calculate/Abuild.interface?>
     As with all interface variables, this will be available as a make
     variable within <filename>Abuild.mk</filename>.  It also includes
     the <function>after-build</function> file
     <filename>after.interface</filename>:
     <?example cross-platform/calculate/after.interface?>
     This file protects the <varname>CALCULATE</varname> variable from
     being reset, and then calls <function>reset-all</function>.  In
     this way, items that depend on <classname>calculate</classname>
     will not automatically inherit the interface from
     <classname>lib</classname> or any of its dependencies.  This
     represents the intention that a dependency on the
     <classname>calculate</classname> build item would be set up if
     you wanted to <emphasis>run</emphasis> the
     <filename>calculate</filename> program rather than to link with
     or include header files from the libraries used to build
     <classname>calculate</classname>.  In other words, we treat
     <classname>calculate</classname> as a black box and don't care
     how it was built.  This works because the
     <varname>CALCULATE</varname> variable, which contains the name of
     the <filename>calculate</filename> program, was protected from
     reset, but the <varname>LIBS</varname>,
     <varname>LIBDIRS</varname>, and <varname>INCLUDES</varname>
     variables have been cleared.  In that way, a user of the
     <classname>calculate</classname> build item won't link against
     the <filename>lib</filename> library or be able to include the
     <filename>lib.hh</filename> header file unless they had also
     declared a dependency on <classname>lib</classname>.  If we
     hadn't cleared these variables, any code that depended on the
     <classname>calculate</classname> build item may well still have
     worked, but it would have had some excess libraries, include
     files, and library directories added to its compilation commands.
     In some cases, this could create unanticipated code dependencies,
     expose you to namespace collisions, or cause unwanted static
     initializers to be run.
    </para>
    <para>
     Next, look at the <classname>codegen</classname> build item.
     This build item runs a code generator,
     <filename>gen_code.pl</filename>, which in turn runs the
     <filename>calculate</filename> program.  We provide the name of
     our code generator in the <filename>Abuild.interface</filename>
     file:
     <?example cross-platform/codegen/Abuild.interface?>
     This build item provides a rules implementation file in
     <filename>rules/object-code/codegen.mk</filename> (and a help
     file in <filename>rules/object-code/codegen-help.txt</filename>)
     for creating a file called <filename>generate.cc</filename>.  It
     calls the <filename>gen_code.pl</filename> program, which it
     finds using the <varname>CODEGEN</varname> interface variable, to
     do its job.  The <filename>gen_code.pl</filename> program uses
     the <envar>CALCULATE</envar> environment variable to find the
     actual calculate program.  Although we have the
     <varname>CALCULATE</varname> variable as a make variable
     (initialized from <classname>calculate</classname>'s
     <filename>Abuild.interface</filename> file), we need to export it
     so that it will become available in the environment.  We also
     pass the file named in the <varname>NUMBERS</varname> variable to
     the code generator.  Here are the
     <filename>codegen-help.txt</filename> file, the
     <filename>codegen.mk</filename> file, and the code generator:
     <?example cross-platform/codegen/rules/object-code/codegen.mk?>
     <?example cross-platform/codegen/rules/object-code/codegen-help.txt?>
     <?example cross-platform/codegen/gen_code.pl?>
     In order for this to work, the <classname>codegen</classname>
     build item must depend on the <classname>calculate</classname>
     build item.  Ordinarily, &abuild; will not allow this since the
     <classname>calculate</classname> build item would not be able to
     be built on the <type>indep</type> platform, which is the only
     platform on which <classname>codegen</classname> is built.  To
     get around this, <classname>codegen</classname>'s
     <filename>Abuild.conf</filename> specifies a
     <option>-platform</option> argument to its declaration of its
     dependency on <classname>calculate</classname>:
     <?example cross-platform/codegen/Abuild.conf?>
     The argument <option>-platform=native:option=release</option>
     tells &abuild; to make <classname>codegen</classname> depend on
     the instance of <classname>calculate</classname> built on the
     first <type>native</type> platform that has the
     <type>release</type> option, if any; otherwise, it depends on the
     highest priority <type>native</type> platform.  Note that this
     will cause the <type>release</type> option of the appropriate
     platform to be built for <classname>calculate</classname> and its
     dependencies even if they would not have otherwise been built.
     This is an example of &abuild;'s ability to build on additional
     platforms on an as-needed basis.  For details on exactly how
     &abuild; resolves such dependencies, see <xref
     linkend="ref.construction-of-build-graph"/>.
    </para>
    <para>
     Notice that this code generator uses an interface variable, in
     this case <varname>$(CALCULATE)</varname>, to refer to a file in
     the <classname>calculate</classname> build item.  Not only is
     this a best practice since it avoids having us have to know the
     location of a file in another build item, but it is actually the
     only way we can find the <filename>calculate</filename> program:
     &abuild; doesn't provide any way for us to know the name of the
     output directory from the <classname>calculate</classname> build
     item we are using except through the interface system.  (The
     value of the <varname>ABUILD_OUTPUT_DIR</varname> variable would
     be the output directory for the item currently being built, not
     the output directory that we want from the
     <classname>calculate</classname> build item.)  We also use an
     interface variable to refer to the code generator within our own
     build item, though in this case, it would not be harmful to use
     <varname>$(abDIR_codegen)/gen_code.pl</varname> instead.
     <footnote>
      <para>
       Actually, there is something a bit more subtle going on here.
       If we didn't have an <filename>Abuild.interface</filename> file
       or an <filename>Abuild.mk</filename> file, &abuild; would not
       allow this build item to declare a platform type, and it would
       automatically inherit its platform type from its dependency or
       become a special build item of platform type <type>all</type>,
       as discussed in <xref
       linkend="ref.construction-of-build-graph"/>.  In that case,
       &abuild; would not allow us to declare a platform-specific
       dependency, and although the code generator would still work
       just fine, this wouldn't be much of an example!  The construct
       illustrated here is still useful though as this is exactly how
       it would have to work if there were other values to be exported
       through <filename>Abuild.interface</filename> or any products
       that needed to be built by this build item itself.  For
       example, if the code generator example had been written in Java
       instead of perl, this pattern would have been the only way to
       achieve the goal.
      </para>
     </footnote>
    </para>
    <para>
     Finally, look at the <classname>prog</classname> build item.
     This build item depends on the <classname>codegen</classname>
     build item.  Its <filename>Abuild.mk</filename> defines the
     <varname>NUMBERS</varname> variable as required by
     <filename>codegen</filename>, which it lists in its
     <varname>RULES</varname> variable.  This build item doesn't know
     or care about the interface of the <classname>lib</classname>
     build item, which has been hidden from it by the
     <function>reset-all</function> in
     <classname>calculate</classname>'s
     <filename>after.interface</filename>.  (If it wanted to, it could
     certainly also depend on <classname>lib</classname>, in which
     case it would get <classname>lib</classname>'s interface.)  In
     fact, running <command>abuild ccxx_debug</command> will show that
     <classname>prog</classname>'s <varname>INCLUDES</varname>,
     <varname>LIBS</varname>, and <varname>LIBDIRS</varname> variables
     are all empty:
     <?qtest cross-platform-ccxx_debug.out?>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.build-item-visibility">
   <title>Build Item Visibility</title>
   <para>
    By default, build items are allowed to refer to other build items
    directly in their <filename>Abuild.conf</filename> files subject
    to certain scoping rules as described in <xref
    linkend="ref.build-item-name-scoping"/>.  In some rare instances,
    in order to resolve a conflict between what a given build item is
    supposed to be able to see and which items a given item is
    supposed to be seen by, it is necessary to increase the visibility
    of a build item.  In this chapter, we describe a mechanism for
    doing this and present a real-world example in which it would be
    required.
   </para>
   <sect1 id="ref.overriding-visibility">
    <title>Increasing a Build Item's Visibility</title>
    <para>
     The <filename>Abuild.conf</filename> file supports an optional
     <property>visible-to</property> key has a value consisting of a
     single scope identifier.  It may have one of the following two
     forms:
     <itemizedlist>
      <listitem>
       <para>
        <classname>ancestor-scope.*</classname>: the current build
        item is visible to all build items under the named
        ancestor-scope.  The ancestor-scope must be at or above the
        &ldquo;grandparent&rdquo; of the current build item since
        build items belong by default to the scope named by the parent
        build item.
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>*</classname>: this build item may be seen by any build
        item.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     For example, if the item <classname>A.B.C</classname> declared
     itself as visible to <classname>A.*</classname>, then the items
     <classname>A.P</classname>, <classname>A.Q.R</classname>, or
     anything else under <classname>A</classname> would be allowed to
     access it directly.  Even though it is hidden beneath
     <classname>A.B</classname>, access to it would be checked as if
     it were directly under <classname>A</classname>.  The
     <classname>A.B.C</classname> build item would increase its
     visibility by adding this line to its
     <filename>Abuild.conf</filename>:

     <programlisting>visible-to: A.*
</programlisting>
    </para>
    <indexterm>
     <primary>dependency</primary>
     <secondary>one-way gates</secondary>
    </indexterm>
    <para>
     Here we describe a more concrete example.  The next section
     demonstrates an actual implementation of the pattern described
     here.  Suppose you needed to implement a project that contained
     build items at different levels of classification, which we'll
     call <emphasis>public</emphasis> and
     <emphasis>sensitive</emphasis>.  We want the sensitive build
     items to be able to see the public ones, but the public ones
     should never be allowed to see the sensitive ones.  To achieve
     this, we create an public build tree and a sensitive build tree,
     and then we have the sensitive build tree list the public build
     tree as a tree dependency.  The explanation that follows refers
     to <xref linkend="fig.build-item-visibility"/>.
     <figure id="fig.build-item-visibility">
      <title>Build Item Visibility</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="build-item-visibility.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>B.sensitive</classname> can see
         <classname>B.W</classname> and <classname>B.X</classname>
         because of its scope.  <classname>B.sensitive</classname> can
         be seen by <classname>A.sensitive</classname> because of its
         visibility.
        </para>
       </caption>
      </mediaobject>
     </figure>
     Suppose you have software components <classname>A</classname> and
     <classname>B</classname> and that <classname>A</classname>
     depends on <classname>B</classname>.  Let's say that
     <classname>B</classname> has two public subcomponents called
     <classname>B.Q</classname> and <classname>B.R</classname> and
     that <classname>B</classname>'s <filename>Abuild.conf</filename>
     declares those as dependencies, making it a facade build item for
     its subcomponents.  When <classname>A</classname> depends on
     <classname>B</classname>, it will automatically get
     <classname>B.Q</classname>'s and <classname>B.R</classname>'s
     interfaces through <classname>B</classname>'s dependency on them.
     Now suppose that both <classname>A</classname> and
     <classname>B</classname> have some additional subcomponents that
     are sensitive.  In order to avoid having the public items even
     know that the sensitive items exist and to prevent them from ever
     accidentally depending on them even when they are being modified
     in a sensitive environment, we add sensitive subcomponents to
     <classname>A</classname> and <classname>B</classname> in a
     completely separate build tree.  Suppose <classname>B</classname>
     has sensitive subcomponents <classname>B.W</classname> and
     <classname>B.X</classname>.  Those need to be under the scope
     <classname>B</classname> so that they can see
     <classname>B.Q</classname> and <classname>B.R</classname>.  Now
     we can create a facade build item called
     <classname>B.sensitive</classname> that depends on
     <classname>B</classname> and also on <classname>B.W</classname>
     and <classname>B.X</classname>.  Then anyone who depends on
     <classname>B.sensitive</classname> can see all four subcomponents
     of <classname>B</classname>.  Suppose we have a sensitive version
     of <classname>A</classname> called
     <classname>A.sensitive</classname>.  Unfortunately, by our normal
     scoping rules, <classname>A.sensitive</classname> would not be
     allowed to depend on <classname>B.sensitive</classname> because
     <classname>B.sensitive</classname> would be hidden beneath
     <classname>B</classname>.  We can't move
     <classname>B.sensitive</classname> out of
     <classname>B</classname> (by calling it something like
     <classname>B_sensitive</classname>, for example) since then it
     would not be able to depend on <classname>B.W</classname> and
     <classname>B.X</classname>.  Instead, we have to have
     <classname>B.sensitive</classname> make itself globally visible
     by adding <literal>visible-to: *</literal> to its
     <filename>Abuild.conf</filename>.  Now any build item that can
     resolve its name, which by design means only build items in the
     sensitive build tree, can declare a dependency directly on
     <classname>B.sensitive</classname>.  That way, the public
     <classname>A</classname> build item depends on the public
     <classname>B</classname> build item, and the sensitive
     <classname>A.sensitive</classname> build item depends on the
     sensitive <classname>B.sensitive</classname> build item, and all
     constraints are satisfied.  This pattern can be useful whenever
     separate build trees are used to add new private subcomponents to
     something defined in a different build tree.  In this case, the
     use of a separate tree and a tree dependency creates what is
     effectively a <firstterm>one-way dependency gate</firstterm>:
     items in the sensitive tree can see items in the public tree, but
     items in the public tree can't see items in the sensitive tree.
     The next section demonstrates an actual implementation of this
     pattern.
    </para>
   </sect1>
   <sect1 id="ref.example.mixed-classification">
    <title>Mixed Classification Example</title>
    <para>
     This example shows a sample implementation of how one might solve
     certain development problems in a mixed classification
     development environment.  To avoid any potential confusion, we'll
     call our two classification levels &ldquo;public&rdquo; and
     &ldquo;sensitive.&rdquo;.  These could correspond to different
     levels of protection of information and could apply to any
     environment in which people have to be granted special access in
     order to use parts of a system.  The code is divided into two
     separate build trees: <filename>public</filename> and
     <filename>sensitive</filename>.  The <filename>public</filename>
     tree's root <filename>Abuild.conf</filename> file is here:
     <?example mixed-classification/public/Abuild.conf?>
     The <filename>sensitive</filename> tree's root
     <filename>Abuild.conf</filename> is here:
     <?example mixed-classification/sensitive/Abuild.conf?>
     If you were in an environment where the
     <filename>sensitive</filename> tree were not present, the root of
     the <filename>public</filename> tree could be the root of the
     forest.  In an environment where both trees are available, they
     can be both be made known to &abuild; by supplying a common
     parent <filename>Abuild.conf</filename> that lists them both as
     children.  Here is the common parent:
     <?example mixed-classification/Abuild.conf?>
     Note that connecting these two trees together is achieved without
     modifying either tree and without having either tree know the
     location of the other.
    </para>
    <para>
     In this example, we'll demonstrate a very simple message
     processing system.  When a message is received, it is processed
     by a <firstterm>message processor</firstterm> and then dispatched
     to a series of <firstterm>message consumers</firstterm>.  Our
     system allows message consumers to be registered with a special
     message consumer table.  Each message consumer is passed a
     reference to a message processor.  Then, for each message, each
     consumer processes the message with the message processor and
     then does whatever it needs to do with the results.
    </para>
    <para>
     In the public version of the system, we have some message
     consumers and a message processor.  In the sensitive version of
     the system, we want access to the public consumers, but we also
     want to register some additional consumers that are only allowed
     to work in the sensitive environment.  In addition, we want to be
     able to replace the message processor with a different
     implementation such that even the public consumers can operate on
     the messages after processing them with the sensitive processor.
     Furthermore, we wish to be able to achieve these goals with as
     little code duplication as possible and without losing the
     ability to run the public version of the system even when
     operating in the sensitive environment as this may be important
     for testing the system.  We also wish to protect ourselves
     against ever accidentally creating a dependency from a public
     implementation to a sensitive implementation of any part of the
     system.
    </para>
    <para>
     In our sample implementation, each message is an integer, and the
     message processor receives the integer as input and returns a
     string.  Rather than having &ldquo;messages&rdquo; actually be
     &ldquo;received&rdquo;, we just accept integers on the command
     line and pass them through the process/consume loop in the
     system.
    </para>
    <para>
     This example may be found in
     <filename>doc/example/mixed-classification</filename>.  The
     public code is in the <filename>public</filename> subdirectory,
     and the sensitive code is in the <filename>sensitive</filename>
     subdirectory.  The example is implemented in Java, but there is
     nothing about it that wouldn't work the same way in C or C++.  We
     will study the <filename>public</filename> area first.
    </para>
    <para>
     In this example, we have a library of consumers and an executable
     program that calls each registered consumer the numbers passed in
     on the command line.  The consumers each call the processor
     function through an interface, an instance of which is passed to
     the consumer with each message.  The public version of consumer
     library includes two consumers.  In order for us to allow the
     sensitive version to add two more consumers and provide a new
     processor that completely replaces the one defined in the public
     version, the processor function's interface and implementation
     are separated as we will describe below.
    </para>
    <para>
     There are several things to note about the dependencies and
     directory layout.  First, observe that the Java
     <classname>Processor</classname> class defined in the
     <classname>processor</classname> build item implements a
     Java interface (not to be confused with an &abuild; interface)
     that is actually defined in the
     <classname>consumers.interface</classname> build item in
     the <filename>consumers/interface</filename> directory.
     Here is the interface from the
     <classname>consumers.interface</classname> build itme:
     <?example mixed-classification/public/consumers/interface/src/java/com/example/consumers/ProcessorInterface.java?>
     Here is its implementation from the
     <classname>processor</classname> build item:
     <?example mixed-classification/public/processor/src/java/com/example/processor/Processor.java?>
     This means that the <classname>processor</classname>
     build item depends on <classname>consumers</classname>
     and the <classname>consumers</classname> build items do
     not depend on <classname>processor</classname>.  This
     helps enforce that the implementation of the processor function
     can never be a dependency of the consumers (as that would create
     a circular dependency), thus allowing it to remain completely
     separate from the consumer implementations.
     <?example mixed-classification/public/processor/Abuild.conf?>
     <?example mixed-classification/public/consumers/Abuild.conf?>
     The consumers
     themselves accept a <classname>ProcessorInterface</classname>
     instance as a parameter, as you can see from the consumer
     interface:
     <?example mixed-classification/public/consumers/interface/src/java/com/example/consumers/Consumer.java?>
    </para>
    <para>
     Next we will study the executable.  If you look at the
     <classname>executable</classname> build item, you will observe that
     it depends on <classname>processor</classname> and
     <classname>executable.entry</classname>:
     <?example mixed-classification/public/executable/Abuild.conf?>
     Its <filename>Main.java</filename> is very minimal: it just
     invokes <varname>Entry.runExecutable</varname> passing to it an
     instantiated <classname>Processor</classname> object and
     whatever arguments were passed to <varname>main</varname>:
     <?example mixed-classification/public/executable/src/java/com/example/executable/Main.java?>
     It is important to keep this main routine minimal because we will
     have to have a separate main in the sensitive area as that is the
     only way we can have the sensitive version of the code register
     sensitive consumers prior to calling <function>main</function>.
     <footnote>
      <para>
       Well, it's not really the only way.  You could also do
       something like having a
       <classname>RegisterConsumers</classname> object that both
       versions of the code would implement and provide in separate
       jar files much as we do with the
       <classname>Processor</classname> object.  One reason for doing
       it this way, though, is that it makes the example easier to map
       to languages with static linkage.  In other words, we're trying
       to avoid doing anything that would only work in Java to make
       the example as illustrative as possible.  This is, after all,
       not a Java tutorial.
      </para>
     </footnote>
     If this were C++, the inclusion of the sensitive consumers would
     be achieved through linking with additional libraries.  In Java,
     it is achieved by adding additional JAR files to the classpath.
     In either case, with &abuild;, it is achieved by simply adding
     additional dependencies to the build item.  We will see this in
     more depth when we look at the sensitive version of the code.
    </para>
    <para>
     Turning our attention to the public
     <classname>executable.entry</classname> build item, we can see
     that our <filename>Entry.java</filename> file has a static
     initializer that registers our two consumers,
     <varname>C1</varname> and <varname>C2</varname>:
     <footnote>
      <para>
       If this were a C++ program and portability to Windows were not
       required, we could omit this static initializer block entirely
       and put the static initializers in <varname>C1</varname> and
       <varname>C2</varname> themselves as long as we used the whole
       archive flag (see <xref linkend="ref.example.whole-library"/>)
       with those libraries.  As with C++, however, there is no clean
       and portable way to force static initializers to run in a class
       before the class is loaded.
      </para>
     </footnote>
     <?example mixed-classification/public/executable/entry/src/java/com/example/executable/entry/Entry.java?>
     Even though no place else in the code has to know about
     <varname>C1</varname> and <varname>C2</varname> specifically, we
     do have to register them explicitly with the table of consumers
     so that the rest of the application can use them.  The main
     <varname>runExecutable</varname> function parses the command-line
     arguments and then passes each one along with the
     <classname>Processor</classname> object to each consumer in turn.
     Adding additional consumers would entail just making sure that
     they are registered.  Observe in the source to one of the
     consumers how we register the consumer in the consumer table:
     <?example mixed-classification/public/consumers/c1/src/java/com/example/consumers/c1/C1.java?>
     The consumer table is a simple vector of consumers:
     <?example mixed-classification/public/consumers/interface/src/java/com/example/consumers/ConsumerTable.java?>
    </para>
    <para>
     Now we will look at the sensitive version of the code.  We have
     the same three subdirectories in <filename>sensitive</filename>
     as in <filename>public</filename>.  In our
     <filename>consumers</filename> directory, we define new consumers
     <varname>C3</varname> and <varname>C4</varname>.  They are
     essentially identical to the public consumers
     <varname>C1</varname> and <varname>C2</varname>.  The
     <filename>processor</filename> directory defines the sensitive
     version of the <classname>Processor</classname> class:
     <?example mixed-classification/sensitive/processor/src/java/com/example/processor/Processor.java?>
     Note that the class name is the same as in the public version,
     which means that the public and sensitive versions cannot be used
     simultaneously in the same executable.  Also observe that the
     name of the build item is actually
     <classname>processor.sensitive</classname>, to make it different
     from <classname>processor</classname>, and that the build item
     sets its visibility to <varname>*</varname> so that it can be a
     dependency of the sensitive version of the executable:
     <?example mixed-classification/sensitive/processor/Abuild.conf?>
     In this particular example, there's no reason that we couldn't
     have given the build item a public name as there are no
     subcomponents of the public
     <classname>processor</classname> build item that the
     sensitive one needs.  In a real situation, perhaps this would be
     the real <classname>processor</classname> build item and
     the public one would be called something like
     <classname>processor-stub</classname>.  In any case, all
     &abuild; cares about is that the build items have different
     names.
    </para>
    <para>
     Looking at the sensitive version of the executable, we can
     observe that there is no separate sensitive version of the
     <varname>Entry</varname> class.  This effectively means that we
     are using the public main routine even though we have sensitive
     consumers.  This provides an example of how to implement the case
     that people might be inclined to implement by having conditional
     inclusion of sensitive JAR files or conditional linking of
     sensitive libraries.  Since &abuild; doesn't support doing
     anything conditionally upon the existence of a build item or even
     testing for the existence of a build item, this provides an
     alternative approach.  This approach is actually better because
     it enables the public version of the system to run intact even in
     the sensitive environment.  After all, if the system
     <emphasis>automatically</emphasis> used the sensitive handlers
     whenever they were potentially available, we couldn't run the
     public version of the test suite in the sensitive environment.
     This would make it too easy, while working in the sensitive
     environment, to make modifications to the system that break the
     system in a way that would only be visible in the public version.
     By pushing what would have been <function>main</function> into a
     library, we can avoid duplicating the code.  If you look at the
     actual build item and code in the <filename>executable</filename>
     directory, you will see that the build item is called
     <classname>executable.sensitive</classname> and that it depends
     on <classname>consumers.sensitive</classname> and
     <classname>processor.sensitive</classname>, both of which have
     made themselves visible to <varname>*</varname> in their
     respective <filename>Abuild.conf</filename> files.  We saw
     <classname>processor.sensitive</classname>'s
     <filename>Abuild.conf</filename> file above.  Here is
     <classname>consumers.sensitive</classname>'s
     <filename>Abuild.conf</filename>:
     <?example mixed-classification/sensitive/consumers/Abuild.conf?>
     Also observe that <classname>executable.sensitive</classname>
     depends on <classname>executable.entry</classname> just like the
     public version of the executable did:
     <?example mixed-classification/sensitive/executable/Abuild.conf?>
     Looking at the sensitive executable's
     <filename>Main.java</filename>, we can see that it is essentially
     identical to the public version except that it registers some
     additional consumers that were not available in the public
     version:
     <?example mixed-classification/sensitive/executable/src/java/com/example/executable/Main.java?>
    </para>
    <para>
     Here are some key points to take away from this:
     <itemizedlist>
      <listitem>
       <para>
        This example illustrates that it is possible to extend
        functionality in an area that uses the original area as a tree
        dependency with very little duplication of code.  This is
        partially achieved by thinking about our system in a different
        way: rather than having a public program behave differently in
        a sensitive environment, we move the main entry point into a
        library.  This completely eliminates the whole problem of
        conditional linking or making any other decisions
        conditionally upon the existence of particular build items or
        upon compile-time flags that differ across different
        environments.  In fact, the top of the
        <filename>public</filename> tree would happily function as the
        root of the forest if the <filename>sensitive</filename> tree
        and their common parent <filename>Abuild.conf</filename> file
        were not present on the system.
       </para>
      </listitem>
      <listitem>
       <para>
        This example shows an approach to separating interfaces from
        implementations that makes it possible, without conflict, to
        completely replace an implementation at runtime.  This is
        achieved by having the implementation be a dependency of the
        final executable and having the rest of the system depend on
        only the interfaces.
       </para>
      </listitem>
      <listitem>
       <para>
        Although, in this example, the sensitive versions of the
        consumers don't actually access any private build items from
        the public version of the code, the use of the build item name
        <classname>consumers.sensitive</classname> and the
        <varname>visible-to</varname> key would make it possible for
        them to do so.
       </para>
      </listitem>
      <listitem>
       <para>
        Creating run-time connections between objects without creating
        any compile-time connections requires some additional
        infrastructure to be laid.  In some languages and compilation
        environments, this can be done through use of static
        initializers combined with techniques to ensure that they get
        run even if there are no explicit references to the classes in
        question.  To keep things both simple and portable, it is
        still possible to use this pattern by performing some explicit
        registration step prior to the invocation of the main routine.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.whole-library">
   <title>Linking With Whole Libraries</title>
   <para>
    In C and C++, most environments create library archives that
    consist of a collection of object files.  Most linkers only link
    object files from libraries into executables if there is at least
    one function in the object file that is in the calling chain of
    the executable.  In other words, if an object file in a library
    appears not to contain any code that is ever accessed, that object
    file is not included in the final executable.  &Abuild; provides a
    way to force inclusion of all object files in a given library for
    underlying systems in which this is supported.
   </para>
   <sect1 id="ref.example.whole-library">
    <title>Whole Library Example</title>
    <indexterm>
     <primary>whole archive</primary>
    </indexterm>
    <indexterm>
     <primary>whole library</primary>
    </indexterm>
    <para>
     There are some instances in which it may be desirable to tell the
     linker to include all the object files from a library.  Common
     examples include times when static libraries are converted into
     shared libraries or when an object file is self-contained but
     contains a static initializer whose side effects are important.
     The <filename>doc/example/whole-library</filename> directory
     contains an example of doing this.  The <filename>lib1</filename>
     and <filename>lib2</filename> directories both contain
     self-contained classes and have static variables that call those
     classes' constructors:
     <?example whole-library/lib1/thing1.hh?>
     <?example whole-library/lib1/thing1.cc?>
     <?example whole-library/lib2/thing2.hh?>
     <?example whole-library/lib2/thing2.cc?>
     Neither library is referenced by <filename>main.cc</filename> (in
     <filename>bin</filename>):
     <?example whole-library/bin/Abuild.conf?>
     <?example whole-library/bin/main.cc?>
     Therefore, the linker would not ordinarily link them in even with
     the dependency on both library build items.
    </para>
    <para>
     In this example, we force <filename>lib1</filename> to be linked
     in but not <filename>lib2</filename>.  This is done by adding the
     variable <varname>WHOLE_lib_thing1</varname> (since
     <filename>thing1</filename> is the name of the library) to
     <filename>lib1</filename>'s
     <filename>Abuild.interface</filename>:
     <?example whole-library/lib1/Abuild.interface?>
     On systems that support this, defining this variable causes the
     corresponding library to be linked in its entirety into any
     executables that use the library.  This facility may not be
     supported by all compilers.  In particular, it is not supported
     for Microsoft Visual C++ in versions at least through .NET 2005,
     in which case setting this variable has cause an error.
    </para>
    <para>
     For cases in which some users of a library may want to link in
     the whole library and others may not, it is also possible to set
     the
     <varname>WHOLE_lib_<replaceable>libname</replaceable></varname>
     variable in an <filename>Abuild.mk</filename>.  For example, if
     you were converting a static library to a shared library, you
     might want to do this in the shared library build item's
     <filename>Abuild.mk</filename> rather than the static library's
     <filename>Abuild.interface</filename> file.  That would prevent
     other users of the static library from needlessly linking with
     the whole library.
    </para>
    <para>
     We do not set this variable for <filename>lib2</filename>:
     <?example whole-library/lib2/Abuild.interface?>
     This means that its static initializer will not be linked in on
     any system.  On a system that supports whole-library linking, the
     main program generates this output:
     <?qtest whole-library.out?>
     This output includes the static initializer from
     <classname>Thing1</classname> but not from
     <classname>Thing2</classname>.
    </para>
    <para>
     Note that, in order to be truly portable, an application would
     have to contain explicit code that accessed the static
     initializers.  We illustrate this in some Java code in <xref
     linkend="ref.example.mixed-classification"/>.  The same technique
     used for that example would work in C or C++ code.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.opaque-wrapper">
   <title>Opaque Wrappers</title>
   <para>
    One of the most important features of &abuild; is that a given
    build item automatically inherits the interfaces of not only all
    of its direct dependencies but of its indirect dependencies as
    well.  There may be instances, however, in which this is
    undesirable.  We present such a case here.
   </para>
   <sect1 id="ref.example.opaque-wrapper">
    <title>Opaque Wrapper Example</title>
    <para>
     This example shows how we can create a C/C++ build item that
     implements an &ldquo;opaque wrapper&rdquo; around some other
     interface.  In the
     <filename>doc/example/opaque-wrapper</filename> directory, there
     are three directories: <filename>hidden</filename>,
     <filename>public</filename>, and <filename>client</filename>.
     The <filename>hidden</filename> item implements some interface.
     The <filename>public</filename> item implements a wrapper around
     <filename>hidden</filename>'s interface, but uses
     <filename>hidden</filename> privately: only its source files, not
     its header files, access files from <filename>hidden</filename>:
     <?example opaque-wrapper/public/Public.hh?>
     <?example opaque-wrapper/public/Public.cc?>
     The intention is that users of <filename>public</filename> should
     not be able to access any parts of <filename>hidden</filename> at
     all.  The <filename>client</filename> directory contains an
     example of a build item that uses <filename>public</filename>.
     It doesn't include any files from <filename>hidden</filename>,
     and if it were to try, it would get an error since the
     <filename>hidden</filename> directory is not in its include path.
     However, it still must link against the
     <filename>hidden</filename> library.  The
     <filename>public</filename> build item achieves this by resetting
     the <varname>INCLUDES</varname> interface variable in an
     after-build file:
     <?example opaque-wrapper/public/Abuild.interface?>
     <?example opaque-wrapper/public/hide-hidden.interface?>
     This way, items that depend on <filename>public</filename> will
     see only this item's includes and not those of the items it
     depends on.  Here is the output of <command>abuild
     ccxx_debug</command> when run from the
     <filename>client</filename> directory:
     <?qtest opaque-wrapper-ccxx_debug.out?>
     As you can see, there is no reference to the
     <filename>hidden/include</filename> directory even though its
     library and library directory are present in
     <classname>opaque-client</classname>'s compilation environment.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.optional-dependencies">
   <title>Optional Dependencies</title>
   <para>
    In widely distributed systems, it is often the case that a
    particular component may be able to be configured to work in
    different ways depending on whether some optional functionality is
    present.  There are many ways to support this in any given
    software system, including having optional capabilities register
    themselves with some consumer of those capabilities as with our
    mixed classification example (see <xref
    linkend="ref.example.mixed-classification"/>).  There are some
    situations where, for whatever reason, the onus of determining how
    to behave must lie completely with the consumer of an optional
    capability rather than the supplier of the capability.  This could
    happen if, for example, the supplier of the capability is
    completely unaware of the consumer.  It could also happen if,
    because of the way the software is architected, the logic of how
    the consumer uses the producer must like with the consumer.  To
    support these cases, &abuild; supports the use of optional
    dependencies.
   </para>
   <sect1 id="ref.using-optional-dependencies">
    <title>Using Optional Dependencies</title>
    <para>
     Both item dependencies and tree dependencies may be declared as
     optional by placing the <option>-optional</option> option after
     the item or tree name in the <property>deps</property> or
     <property>tree-deps</property> declaration in the
     <filename>Abuild.conf</filename> file.  If an optional tree
     dependency is not found, &abuild; simply ignores the optional
     tree dependency.  If an optional item dependency is declared,
     &abuild; will create a local (non-inheriting) boolean interface
     variable called
     <varname>ABUILD_HAVE_OPTIONAL_DEP_<replaceable>item</replaceable></varname>
     where <replaceable>item</replaceable> is the name of the item
     that was declared as an optional dependency.  If the optional
     dependency is found, this variable will have a true value, and
     &abuild; will process the dependency normally.  If the optional
     dependency is not found, this variable will have a false value,
     and &abuild; will otherwise ignore the optional dependency.
    </para>
    <para>
     Sometimes an optional dependency may be satisfied by a build item
     or tree that may not always be present.  In this case, you may
     find that using <option>-optional</option> when listing the child
     directory that contains the item or tree when it's present makes
     it possible to use the exact same &abuild; configuration whether
     or not the optional item is present.  With this mode of use, a
     capability may be turned on or off simply by including or
     excluding a particular directory in a build.  Although there are
     certainly valid scenarios for this style of operation, this
     feature has a high potential for abuse, so you should consider
     carefully whether it is the right solution to your problem.  It
     is possible to create software that may behave differently based
     on combinations of presence or absence of optional features.
     Such software can become very difficult to maintain and test.
     Ideally, if you have optional capabilities that are configured in
     this way, they should be lightweight and independent from each
     other.  However, &abuild; leaves this choice up to you and
     provides you with this capability.  You are, of course, free to
     use it or not as you choose.
    </para>
   </sect1>
   <sect1 id="ref.example.optional-dependencies">
    <title>Optional Dependencies Example</title>
    <para>
     To illustrate optional dependencies, we have a very simple C++
     program that calls a function called <function>xdriver</function>
     if the <filename>xdriver</filename> build item, which supplies
     it, is present.  The tree containing this build item can be found
     at <filename>optional-dep/prog</filename>.  Here is its
     <filename>Abuild.conf</filename> file:
     <?example optional-dep/prog/Abuild.conf?>
     Observe that there is an optional tree dependency declared on a
     build tree called <filename>xdrivers</filename> and also an
     optional item dependency declared on the build item called
     <filename>xdriver</filename>.
    </para>
    <para>
     In the implementation of this build item, we use the
     <filename>Abuild.interface</filename> file to define a
     preprocessor symbol if the <filename>xdriver</filename> build
     item is present.  Here is the
     <filename>Abuild.interface</filename> file:
     <?example optional-dep/prog/Abuild.interface?>
     This is one approach, but it is by no means the only approach.
     Use of a preprocessor symbol in this way can be dangerous because
     there is no mechanism to trigger a rebuild if its value changes.
     However, as the presence of absence of optional dependencies is
     likely to be relatively fixed for any given build environment,
     use of a preprocessor symbol may be appropriate.  Since the
     interface variable is, like all interface variables, exported to
     the backend, we could have also done something based on its value
     in the <filename>Abuild.mk</filename> file.  There, the value
     would have a value of either <literal>1</literal> or
     <literal>0</literal> as with all boolean interface variables.
     This would be appropriate if we didn't want the results of
     whatever we do to be visible to our dependencies.  In this case,
     we use the <filename>Abuild.interface</filename> file, and the
     <filename>Abuild.mk</filename> file looks completely normal:
     <?example optional-dep/prog/Abuild.mk?>
    </para>
    <para>
     Let's look at the source code to the program.  It's not clever at
     all, but it illustrates how this mechanism works.  Here is
     <filename>prog.cc</filename>:
     <?example optional-dep/prog/prog.cc?>
     To build this without the optional build tree present, copy the
     file <filename>optional-dep/Abuild.conf.without</filename> to
     <filename>optional-dep/Abuild.conf</filename>.  Here is that
     file:
     <?example optional-dep/Abuild.conf.without?>
     Then run <command>abuild</command> from the
     <filename>optional-dep/prog</filename> directory.  This results
     in the following output:
     <?qtest optional-without.out?>
     The resulting <command>prog</command> executable produces this output:
     <?qtest optional-without-run.out?>
    </para>
    <para>
     Now let's try this again with the optional tree present.  First,
     we have to copy
     <filename>optional-dep/Abuild.conf.with</filename> to
     <filename>optional-dep/Abuild.conf</filename>.  Here is that
     file:
     <?example optional-dep/Abuild.conf.with?>
     This adds the <filename>xdriver</filename> directory as a child.
     This directory contains what are effectively &ldquo;extra
     drivers&rdquo; to be used by <command>prog</command>.  Here are
     the header and source to the <function>xdriver</function>
     function:
     <?example optional-dep/xdriver/xdriver.hh?>
     <?example optional-dep/xdriver/xdriver.cc?>
     Next, we have to do a clean build since, as pointed out above,
     there's no other mechanism for &abuild; to notice that the tree
     has appeared and the preprocessor symbol has since the last
     build.  (We could implement a dependency on a make variable if we
     wanted to.  See <xref linkend="ref.example.auto-from-variable"/>
     for an example of doing this.)  Once we have set up the new
     <filename>Abuild.conf</filename> and run <command>abuild -c
     all</command> to clean the tree, we can run
     <command>abuild</command> from <filename>prog</filename> again.
     This results in the following &abuild; output:
     <?qtest optional-with.out?>
     Running the resulting <command>prog</command> program in this
     case results in this output:
     <?qtest optional-with-run.out?>
     This time, you can see that the <function>xdriver</function>
     function was available.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.plugins">
   <title>Enhancing &Abuild; with Plugins</title>
   <para>
    <indexterm>
     <primary>plugin</primary>
    </indexterm>
    This chapter is geared toward people who may extend or enhance
    &abuild; by adding additional rules, platforms, or compilers.
    Anyone interested in extending &abuild; in this way should also be
    familiar with the material covered in <xref
    linkend="ref.best-practices"/>.  If you think you may need to
    modify the main code of &abuild; itself, please see also <xref
    linkend="ref.abuild-internals"/>.  This section covers the most
    common uses for plugins.  Examples of each topic presented may be
    found in <xref linkend="ref.example.plugin"/>.
   </para>
   <sect1 id="ref.plugin-functionality">
    <title>Plugin Functionality</title>
    <indexterm>
     <primary>plugin.interface</primary>
    </indexterm>
    <indexterm>
     <primary>plugin.mk</primary>
    </indexterm>
    <indexterm>
     <primary>preplugin.mk</primary>
    </indexterm>
    <indexterm>
     <primary>plugin.groovy</primary>
    </indexterm>
    <indexterm>
     <primary>preplugin.groovy</primary>
    </indexterm>
    <para>
     Plugins are build items that are named in the build tree root's
     <filename>Abuild.conf</filename> in the
     <property>plugins</property> key.  The list of which items are
     plugins is not inherited through either backing areas or tree
     dependencies.  In other words, if a tree your tree depends on
     declares something as a plugin, it does not automatically make
     you get it as a plugin.  The same applies to backing areas, but
     in practice, the list of plugins is generally effectively
     inherited because your local build tree's
     <filename>Abuild.conf</filename> is typically a copy of its
     backing area's <filename>Abuild.conf</filename>, assuming your
     partially populated build tree was checked out of the same
     version control system.  The non-inheritance of plugin status
     through tree dependencies is appropriate: since plugins can
     change &abuild;'s behavior significantly, it should be possible
     for a given build tree to retain tight control over which plugins
     are active and which are not.  For example, a build tree may
     include a plugin that enforces certain coding practices by
     default, and use of this build tree as a tree dependency should
     not necessarily cause that same set of restrictions to be applied
     to the dependent tree.  Plugins themselves are ordinary build
     items and can be resolved in tree dependencies and backing areas
     just like any other build item.  This makes it possible for a
     tree to provide a plugin without using it itself or for a build
     tree to not use all plugins used by its tree dependencies.
    </para>
    <para>
     Plugins are loaded by &abuild; and its backends in the order in
     which they are listed in a root build item's
     <filename>Abuild.conf</filename>.  Usually this doesn't matter,
     but if multiple plugins add native compilers the order in which
     plugins are listed can have an effect on which platforms are
     built by default.
    </para>
    <para>
     Plugins are subject to the following constraints beyond those
     imposed upon all build items:
     <itemizedlist>
      <listitem>
       <para>
        Plugins may not have any forward or reverse dependencies.  It
        is good practice to put plugin build items in a private
        namespace (such as prefixing their names with
        <literal>plugin.</literal>) to prevent people from
        accidentally declaring dependencies on them.
       </para>
      </listitem>
      <listitem>
       <para>
        Plugins may not belong to a platform type, have a build file,
        or have an <filename>Abuild.interface</filename> file.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Plugins may contain the following items that are not supported
     for ordinary build items:
     <itemizedlist>
      <listitem>
       <para>
        &Abuild; interface code loaded from
        <filename>plugin.interface</filename>
       </para>
      </listitem>
      <listitem>
       <para>
        A <filename>platform-types</filename> file to add new object-code
        platform types
       </para>
      </listitem>
      <listitem>
       <para>
        A <command>list_platforms</command> perl script to add new
        object-code platforms
       </para>
      </listitem>
      <listitem>
       <para>
        <filename>toolchains</filename> directories containing
        additional compiler support files
       </para>
      </listitem>
      <listitem>
       <para>
        Additional make code in <filename>preplugin.mk</filename> that
        is loaded by all make-based build items before their own
        <filename>Abuild.mk</filename> files are loaded
       </para>
      </listitem>
      <listitem>
       <para>
        Additional make code in <filename>plugin.mk</filename> that is
        loaded by all make-based build items after their own
        <filename>Abuild.mk</filename> files are loaded
       </para>
      </listitem>
      <listitem>
       <para>
        Additional Groovy code in
        <filename>preplugin.groovy</filename> that is loaded by all
        Groovy-based build items before their own
        <filename>Abuild.groovy</filename> files are loaded
       </para>
      </listitem>
      <listitem>
       <para>
        Additional Groovy code in <filename>plugin.groovy</filename>
        that is loaded by all Groovy-based build items after their own
        <filename>Abuild.groovy</filename> files are loaded
       </para>
      </listitem>
      <listitem>
       <para>
        Ant hook code in <filename>plugin-ant.xml</filename> that is used
        as a hook file by all build items using the deprecated
        xml-based ant framework.
       </para>
      </listitem>
      <listitem>
       <para>
        Arbitrary hook code in <filename>preplugin-ant.xml</filename>
        that is imported prior by all build items using the deprecated
        xml-based ant framework prior to reading
        <filename>Abuild-ant.properties</filename>.
       </para>
      </listitem>
     </itemizedlist>
     Additionally, plugins may have <filename>rules</filename>
     directories containing additional <application>make</application>
     or <application>Groovy</application> rules files, as is true with
     ordinary build items.
    </para>
    <para>
     Although plugins themselves can never be dependencies of other
     build items or have dependencies of their own, they are still
     subject to &abuild;'s integrity guarantee.  In the case of
     plugins, this means that it is impossible to have an item in your
     dependency tree whose build tree declares a plugin that you are
     shadowing in your local tree.  One way to avoid having this
     become a significant limitation is to keep your plugins in a
     separate build tree that others declare as a tree dependency.
    </para>
   </sect1>
   <sect1 id="ref.global-plugins">
    <title>Global Plugins</title>
    <indexterm>
     <primary>plugin</primary>
     <secondary>global</secondary>
    </indexterm>
    <para>
     It is possible for a build tree to declare one or more of its
     plugins to be global.  The effect of declaring an item to be a
     global plugin is the same as having it be listed as a plugin for
     every build tree in the forest.
     <footnote>
      <para>
       In fact, this is how &abuild; implements this internally.  As
       such, certain error conditions in global plugins may be
       repeated once for each build tree.  This is unfortunate, but
       fixing it doesn't seem worth the trouble for reporting what are
       likely to be infrequent problems with what is likely to be a
       rarely used feature.
      </para>
     </footnote>
     Global plugins should be used extremely sparingly, though there
     are some cases in which their use may be appropriate.  For
     example, if a particular project requires certain environment
     setup to be done, it would be possible to create a global plugin
     that checks to make sure it is correct.  It is often also
     appropriate to declare platform or platform type plugins globally
     so that dependent trees can be built with the declared compiler
     plugin.
    </para>
    <para>
     A build tree can declare one of its plugins to be global by
     following the plugin name with <option>-global</option> in the
     <property>plugins</property> entry of
     <filename>Abuild.conf</filename>, as in
     <programlisting>plugins: global-plugin -global
</programlisting>
     When a build item is declared as a global plugin, &abuild;
     disregards access checks based on tree dependencies.  In this
     sense, the affect of global plugins may &ldquo;flow
     backwards&rdquo; across tree dependencies.  This is yet another
     reason that they should be used only for enforcing project-wide
     policy.
    </para>
   </sect1>
   <sect1 id="ref.adding-platform-types-and-platforms">
    <title>Adding Platform Types and Platforms</title>
    <para>
     When &abuild; starts up, it reads its internal information about
     supported platforms and platform types.  It then reads additional
     information from plugins, which it combines with its built-in
     information.  This section contains information about the
     specific formats of the directives used to add platform types and
     platforms to &abuild;.
    </para>
    <para>
     Platform type information is read from a plain text file that
     contains platform type declarations.  Information about platforms
     is obtained by running a program, usually written in Perl.  The
     reason for putting platform type information in a file and
     platform information in a program is that the list of platform
     types should be static for a given build tree, while the list of
     available platforms is a function of what the build host can
     provide.  &Abuild; automatically skips build items that belong to
     a valid platform type that happens to have no platforms in it,
     but if it encounters a build item with invalid platform types, it
     considers that an error.
    </para>
    <sect2 id="ref.adding-platform-types">
     <title>Adding Platform Types</title>
     <para>
      Of the target types that &abuild; supports, the only one for
      which additional platform types and platforms may be specified
      is the <varname>object-code</varname> target type.  Platform
      types are declared in a file called
      <filename>platform-types</filename>.  &Abuild; looks for this
      file first in its own <filename>private</filename> directory and
      then at the root of each declared plugin.  The
      <filename>platform-types</filename> file contains a single
      platform type declaration on each line.  Comment lines starting
      with the <varname>#</varname> character and blank lines are
      ignored.  Each line may have the following syntax:

      <programlisting>platform-type <replaceable>new-platform-type</replaceable> [-parent <replaceable>parent-platform-type</replaceable>]
</programlisting>
      Platform type names may contain only alphanumeric characters,
      underscores, and dashes.
     </para>
     <para>
      You may optionally specify another previously-declared
      object-code platform type as the new platform type's parent.  If
      a platform type is declared without a parent platform type, it
      has <type>indep</type> as its implicit parent.  (Note that
      <type>indep</type> may not be declared explicitly as a parent;
      only other <varname>object-code</varname> platform types may be
      declared are parents.)  Declaring a parent platform type means
      that any platform in the new platform type may link against any
      platform in the parent platform type.  It is up to the creator
      of the platform types to ensure that this is actually the case.
     </para>
     <para>
      One example use of parent platform types would be to implement a
      base platform type for a particular environment and then to
      create derived platform types that refine some aspect of the
      base platform type.  For example, this could be used to overlay
      additional include directories or libraries on top of support
      for an embedded operating system to support selective hardware.
      It would also be possible to create platform types that refine
      the <type>native</type> platform type for specific
      circumstances.  Most uses of parent platform types could be
      achieved in some other way, such as through use of conditionals
      in <filename>Abuild.interface</filename> or
      <filename>Abuild.mk</filename> files or through use of
      pass-through build items with multiple dependencies, but when
      used properly, parent platform types can reduce the number of
      times common code has to be recompiled for different platform
      types.
     </para>
     <para>
      The ability to specify parent platform types was introduced in
      &abuild; 1.1.4 and is closely related to platform type
      compatibility as discussed in <xref
      linkend="ref.dependency-platform-compatibility"/>.  It's
      possible that a future version of &abuild; may further
      generalize the ability to create compatibility relationships
      among platform types.
     </para>
    </sect2>
    <sect2 id="ref.adding-platforms">
     <title>Adding Platforms</title>
     <para>
      Since platforms are, by their nature, dynamic, &abuild; runs a
      program that outputs platform declarations rather than reading
      them from a file.  This makes it possible for the existence of a
      platform to be conditional upon the existence of a specific
      tool, the value of an environment variable, or other factors.
      To get the list of platforms, &abuild; runs a program called
      <command>list_platforms</command>.  &Abuild; invokes
      <command>list_platforms</command> with the following arguments:

      <programlisting>list_platforms [ --windows ] --native-data <replaceable>os</replaceable> <replaceable>cpu</replaceable> <replaceable>toolset</replaceable>
</programlisting>
      The <option>--windows</option> option is only present when
      &abuild; is running on a Windows system.  The three options to
      <option>--native-data</option> provide information about the
      default native platform.  Most compiler plugins will not need to
      use this information since there is special way to add a native
      platform, as discussed below.
     </para>
     <para>
      To discover new platforms, &abuild; first runs the
      <command>list_platforms</command> program in its own
      <filename>private</filename> directory, and then it runs any
      <command>list_platforms</command> programs it finds at the root
      directories of any plugins.  On a Windows system, &abuild;
      explicitly invokes the <command>list_platforms</command> program
      as <command>perl list_platforms
      <replaceable>options</replaceable></command>.  For this reason,
      to support portability to a Windows system,
      <command>list_platforms</command> programs must be written in
      perl.  If necessary, a future version of &abuild; may provide a
      mechanism to make writing <command>list_platforms</command>
      programs in other languages.  Note that &abuild; passes the
      <command>--windows</command> flag to
      <command>list_platforms</command> when running on Windows.  This
      not only saves the <command>list_platforms</command> program
      from detecting Windows on its own but is actually necessary
      since <command>list_platforms</command> couldn't tell on its own
      whether it is being run to support a native Windows build of
      &abuild; or whether it is being run to support a Cygwin build of
      &abuild;.
      <footnote>
       <para>
        Note that Cygwin is not Windows.  Cygwin is really more like a
        UNIX environment.  Although &abuild; uses Cygwin to provide
        <application>make</application> and other UNIX-like tools, the
        Windows &abuild; executable is a native Windows application.
        If you were to compile a Cygwin version of &abuild;, it would
        not consider itself to be running in Windows and would not
        invoke <command>list_platforms</command> with the
        <option>--windows</option> option.  That said, there are a few
        pieces of code in the periphery of &abuild; that assume that,
        if we're in a Cygwin environment, it is to support Windows.
        These are all commented as such.  Those parts of the code
        would need to change if someone were to attempt to package
        <command>abuild</command> for Cygwin.
       </para>
      </footnote>
     </para>
     <para>
      Each line of output of <command>list_platforms</command>
      declares either a new platform or a new native compiler, which
      implies a new platform.  A given platform may be declared
      exactly one time across &abuild;'s internally defined platforms
      and plugins.  When a platform type contains multiple platforms,
      unless overridden, &abuild; always chooses to build on the last
      platform declared that belongs to a given platform type.  Since
      plugins are evaluated in the order in which they are declared,
      that means that platforms declared in later plugins can override
      earlier ones as well as &abuild;'s internal platform list with
      respect to determining which platforms will be built by default.
      <footnote>
       <para>
        Note, however, that the <option>--list-platforms</option>
        option shows highest priority platforms first, which
        effectively means that it shows the user platforms in the
        opposite of their declaration order.
       </para>
      </footnote>
      When specifying a new platform or local compiler, the
      <command>list_platforms</command> program may include the option
      <option>-lowpri</option> to indicate that this is a low priority
      platform or native compiler.  This will cause the new platform
      to be added with lower priority than previously declared
      compilers including the built-in ones.  Such compilers will only
      be chosen if explicitly selected.  The user can further refine
      the choice of which platforms are built, including selecting low
      priority compilers and platforms, by using platform selectors
      (see <xref linkend="ref.platform-selection"/>).
     </para>
     <para>
      Each line of output of <command>list_platforms</command> must
      take one of the following forms:

      <programlisting>platform [-lowpri] <replaceable>new-platform</replaceable> -type <replaceable>platform-type</replaceable>
native-compiler [-lowpri] <replaceable>compiler[.option]</replaceable>
</programlisting>
     </para>
     <para>
      By convention, each native compiler should support a platform
      with no options, a platform with the <type>debug</type> option,
      and a platform with the <type>release</type> option.  The
      default should be to select the platform with no options, which
      means the <command>list_platforms</command> program should
      output platforms with no options last.  The platform with no
      options should provide both debugging and optimization flags.
      The <type>debug</type> platform should omit all optimization
      flags, and the <type>release</type> platform should omit all
      debugging flags.  For normal, everyday development, it generally
      makes sense to have both debugging and optimization turned on.
      The reason to have debugging turned on is that it makes it
      possible to do light debugging in a debugger even with optimized
      code.  The reason to have optimization turned on is so that any
      problems introduced by the optimizer and additional static
      analysis that the compiler may do when optimizing will be
      enabled during normal development.  Since optimized code is
      harder to debug in a symbolic debugger, the <type>debug</type>
      version of a platform omits all optimization.  Since it is often
      desirable to ship code without debugging information in it, the
      <type>release</type> version of a platform omits all debug
      information.
     </para>
     <para>
      These options only define the default behavior.  It is still
      possible to override debugging and optimization information on a
      per-file basis or globally for a build item in
      <filename>Abuild.mk</filename> (see <xref linkend="ref.ccxx"/>).
      Note that on some platforms (such as Windows with Visual C++),
      mixing debugging and non-debugging code may not be reliable.  On
      most UNIX platforms, it works fine to mix debugging and
      non-debugging code.
     </para>
     <para>
      When declaring a platform, all platform types that contain the
      platform must have already been declared.
     </para>
     <para>
      Note that object code platform names take the form
      <type>os</type>.<type>cpu</type>.<type>toolset</type>.<type>compiler</type>[.<type>option</type>].
      When declaring a platform with the <type>native-compiler</type>
      directive, &abuild; automatically constructs a platform name by
      using the native values for <type>os</type>, <type>cpu</type>,
      and <type>toolset</type>.  This saves every
      <command>list_platforms</command> program from having to
      determine this information.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.adding-toolchains">
    <title>Adding Toolchains</title>
    <para>
     For a compiler to be used by &abuild;, it must be named in an
     &abuild; platform.  The platform can be added using either the
     <varname>platform</varname> or <varname>native-compiler</varname>
     directive as appropriate in the output of a
     <command>list_platforms</command> command.
    </para>
    <para>
     To add a new compiler toolchain to &abuild;, in addition to
     declaring the native compiler or platform to make &abuild; try to
     use it, you must create a file file called
     <filename><replaceable>compiler</replaceable>.mk</filename> where
     <replaceable>compiler</replaceable> is the name of the compiler
     that is being added, and place this file in the
     <filename>toolchains</filename> directory of a plugin.
     &Abuild;'s internal toolchains are under
     <filename>make/toolchains</filename>.  The best way to learn how
     to write a toolchain is to read existing ones.  Most compiler
     toolchains will be designed to support C and C++ compilation and
     are therefore used by the <filename>ccxx</filename> rules.
     Details on the requirements for such toolchains can be found in
     <filename>rules/object-code/ccxx.mk</filename> in the
     &abuild; distribution (<xref linkend="ref.ccxx.mk"/>).
    </para>
    <para>
     &Abuild; has some rudimentary support for allowing you to force
     compilation to generate 32-bit code or 64-bit code on systems
     that can generate both types of code.  As of &abuild; 1.1, this
     functionality is only supported for the <command>gcc</command>
     compiler.  If you are writing a plugin for a native compiler, you
     can check for the value of the variables
     <varname>ABUILD_FORCE_32BIT</varname> or
     <varname>ABUILD_FORCE_62BIT</varname> and adjust your compilation
     commands as necessary.  You can find an example of doing this in
     <filename>make/toolchains/gcc.mk</filename> in the &abuild;
     distribution.  On Linux-based Intel and Power PC platforms,
     &abuild; will also use these variables to change the platform
     string, which makes it possible to use 64-bit systems to build
     32-bit code that can be used natively without any special steps
     by 32-bit systems.  With an appropriate configured toolchain, you
     can also build 64-bit code on a 32-bit system, though such code
     would most likely not be able to be run natively on the 32-bit
     system.
    </para>
    <para>
     Once you have written a support file for a new compiler, you will
     need to verify to make sure that it is working properly.  A
     verification program is included with &abuild;: the program
     <filename>misc/compiler-verification/verify-compiler</filename>
     can be run to verify your compiler.  This program creates a build
     tree that contains a mixture of static libraries, shared
     libraries, and executables and puts those items in the platform
     type of your choice.  It then builds them with the specified
     compiler.  You provide the path to the build tree containing the
     plugin, the name of the plugin, the platform type, and the
     compiler.  The program can be used with either native compilers
     or non-native compilers.  It also makes it very clear whether
     everything is working or not.  Please run
     <command>verify-compiler --help</command> and see
     <filename>misc/compiler-verification/README.txt</filename> for
     additional details.
    </para>
    <para>
     Ordinarily, a toolchain in platform type <type>native</type> is a
     native compiler, and a toolchain in a platform type other than
     <type>native</type> is a cross-compiler.  There are, however,
     some instances in which it may make sense to have something in
     platform type <type>native</type> be treated as a cross compiler:
     specifically, you will want to do this when the compiler cannot
     create executables that run on your current platform.  Here are
     some examples of where this may occur:
     <itemizedlist>
      <listitem>
       <para>
        You are writing a compiler plugin for a static analyzer that
        is a drop-in replacement for the compiler but that produces
        reports instead of actual executables
       </para>
      </listitem>
      <listitem>
       <para>
        You are building 64-bit executables on a 32-bit system
       </para>
      </listitem>
      <listitem>
       <para>
        You are cross-compiling for a different architecture of the
        same operating system or at least of an operating system that
        is essentially compatible with your code base and could just
        as well support a native compiler; <emphasis>e.g.</emphasis>
        executables for a low-memory or slow embedded Linux without a
        native development toolchain might be built using a regular
        desktop Linux environment and a cross compiler
       </para>
      </listitem>
     </itemizedlist>
     Most of &abuild; will work just fine if the compiler you add to
     the <type>native</type> platform type is actually a cross
     compiler, but there are two notable exceptions: the
     <filename>autoconf</filename> rules, and the
     <command>verify-compiler</command> program.  For the
     <filename>autoconf</filename> rules, you just need to make sure
     <command>./configure</command> gets executed with some
     <option>--host</option> option.  This can be done by simply
     adding this single line:

     <programlisting>CONFIGURE_ARGS += --host=non-native
</programlisting>
     to your
     <filename><replaceable>compiler</replaceable>.mk</filename> file.
     Passing some value to <option>--host</option> that doesn't match
     what autoconf determines your current host to be tells autoconf
     that you are cross compiling.  There's nothing special about the
     specific value &ldquo;<literal>non-native</literal>&rdquo;.  When
     running <command>verify-compiler</command>, you will have to pass
     the <option>--cross</option> option to the
     <command>verify-compiler</command> command so that it will ask
     you to run the test executables instead of running them itself.
     The <option>--cross</option> option is not required if your new
     compiler is not in the <type>native</type> platform type.  In
     this case, &abuild; will automatically figure out that it is a
     cross compiler, just as it does in the
     <filename>autoconf</filename> rules.  Although these are the only
     cases within &abuild; that care whether the compiler can create
     native executables, you may run into others (such as ability to
     run test suites), so just keep this in mind when using a
     non-native compiler in the <type>native</type> platform type.
    </para>
   </sect1>
   <sect1 id="ref.example.plugin">
    <title>Plugin Examples</title>
    <para>
     In this section, we present examples of using &abuild;'s plugin
     facility.  The examples here illustrate all of the capabilities
     of &abuild;'s plugin system, albeit with simplistic cases.
     Plugins are a very powerful feature that can be used to do things
     that you could not otherwise do with &abuild;.  If you are not
     careful, they can also create situations that violate some of
     &abuild;'s design principles, so plugins should be used with
     particular care.  You should also be careful not to
     <emphasis>overuse</emphasis> plugins.  Many things you may
     consider implementing as a plugin would be better implemented as
     an ordinary build item with rules or hooks.  Plugins should be
     used only for adding capabilities that can't be added without
     plugins or that should apply broadly and transparently across
     many items in the build tree.
    </para>
    <para>
     &Abuild; enforces that no plugin may have dependencies or be
     declared as a dependency of another build item.  Still, it's good
     practice to name plugins by placing them in a private namespace.
     This prevents build trees that may have access to these items
     (but may not presently declare them as plugins) from declaring
     them as dependencies.  In these examples, we always place our
     plugins in the <classname>plugin</classname> namespace by
     starting their names with <classname>plugin.</classname> even
     though we have no actual <classname>plugin</classname> build
     item.  In order to use the plugins in this tree, we have to
     declare them as plugins in the root build item's
     <filename>Abuild.conf</filename>:
     <?example plugin/Abuild.conf?>
    </para>
    <sect2 id="ref.example.plugins-with-rules-and-interfaces">
     <title>Plugins with Rules and Interfaces</title>
     <para>
      Here we examine the <classname>plugin.counter</classname>
      plugin, which can be found in
      <filename>doc/example/plugin/plugins/counter</filename>.  This
      is a trivial plugin that illustrates use of an interface file
      and also creates a custom rule that can be referenced in the
      <varname>RULES</varname> variable of a build item's
      <filename>Abuild.mk</filename> file.  There's nothing special
      about the plugin's <filename>Abuild.conf</filename> file:
      <?example plugin/plugins/counter/Abuild.conf?>
      The <filename>plugin.interface</filename> file declares a new
      interface variable called <varname>TO_COUNT</varname> which
      contains a list of file names:
      <?example plugin/plugins/counter/plugin.interface?>
      This file gets loaded automatically before any regular build
      items' <filename>Abuild.interface</filename> files.  The file
      <filename>count.mk</filename> in the
      <filename>rules/all</filename> directory is the
      file that a build item may include by placing <literal>RULES :=
      count</literal> in its <filename>Abuild.mk</filename> file:
      <?example plugin/plugins/counter/rules/all/count.mk?>
      If a build item includes <filename>count</filename> in the value
      of its <varname>RULES</varname> variable, then any files listed
      in <varname>TO_COUNT</varname> will have their lines counted
      with <command>wc -l</command> when the user runs &abuild; with
      the <command>count</command> target.  The intention here is that
      items that the target build item depends on would add files to
      <varname>TO_COUNT</varname> in their
      <filename>Abuild.interface</filename> files.  Then the build
      item that actually uses the <filename>count</filename> rule
      would display the line counts of all of the files named by its
      dependencies.
     </para>
     <para>
      This is admittedly a contrived example, but it illustrates an
      important point.  Here we are adding some functionality that
      enables a build item to make use of certain information provided
      by its dependencies through their
      <filename>Abuild.interface</filename> files.  Although we could
      certainly add the <command>count</command> target using a normal
      build item that users would depend on, doing it that way would be
      somewhat more difficult because each item that wanted to add to
      <varname>TO_COUNT</varname> would also have to depend on
      something that declares the <varname>TO_COUNT</varname>
      interface variable.  By using a plugin, we cause the plugin's
      <filename>plugin.interface</filename> to be automatically loaded
      by all build items in the build tree.  That way, any build item
      can add to <varname>TO_COUNT</varname> without having to take
      any other special actions.  This type of facility could be
      particularly useful for adding support to &abuild; for other
      programming languages that require other information to be known
      from its dependencies.
     </para>
     <para>
      For an example of a build item that uses this plugin's
      capabilities, see the build items under
      <filename>doc/example/plugin/other/indep</filename>.  Here we
      have the build item <classname>indep-a</classname> in the
      <filename>a</filename> directory that adds a file to
      <varname>TO_COUNT</varname> in its
      <filename>Abuild.interface</filename>:
      <?example plugin/other/indep/a/Abuild.conf?>
      <?example plugin/other/indep/a/Abuild.interface?>
      We also have the build item <classname>indep-b</classname>
      (which depends on <classname>indep-a</classname>) in the
      <filename>b</filename> directory that uses the
      <filename>count</filename> rule in its <varname>RULES</varname>
      variable in its <filename>Abuild.mk</filename> file:
      <?example plugin/other/indep/b/Abuild.conf?>
      <?example plugin/other/indep/b/Abuild.mk?>
      Here is the output of running <command>abuild count</command>
      from the <filename>plugin/other/b</filename> directory:
      <?qtest count-b.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.plugin.backend-code">
     <title>Adding Backend Code</title>
     <para>
      Here we examine the <classname>plugin.echoer</classname> plugin
      in the <filename>plugins/echoer</filename> directory.  This
      plugin supplies automatic build code for both Groovy-based and
      make-based build items, something that cannot be done using
      ordinary build item-supplied rules.  This very simple plugin
      causes a message to be printed when running the
      <command>all</command> target.  The contents of the message have
      a default value but can be influenced by changes to a variable
      that users can make in their individual build files.  All build
      items in any build tree that includes this plugin in its list of
      plugins will get this functionality automatically without having
      to take any explicit action.  This would be preferable to
      declaring this as a dependency for every item and modifying
      <varname>RULES</varname> or <varname>abuild.rules</varname> for
      every build item.
     </para>
     <para>
      Here we show the code for both the make and Groovy backends in
      <filename>plugin.mk</filename> and
      <filename>plugin.groovy</filename> respectively:
      <?example plugin/plugins/echoer/plugin.mk?>
      <?example plugin/plugins/echoer/plugin.groovy?>
      Observe that the make version refers to the variable
      <varname>ECHO_MESSAGE</varname> and the Groovy version refers to
      the parameter <varname>echo.message</varname>.  Where do these
      come from?  The answer is that default values are provided by
      <firstterm>pre-plugin</firstterm> initialization files in
      <filename>preplugin.mk</filename> and
      <filename>preplugin.groovy</filename>.
      <footnote>
       <para>
        We had originally wanted to call these
        <filename>pre-plugin</filename> instead of
        <filename>preplugin</filename>, but this interferes with the
        way Groovy generates classes for scripts.  Since
        <classname>pre-plugin</classname> is not a valid class name
        and we want to avoid specific mixed case file names (like
        <filename>prePlugin</filename>, we went with
        <filename>preplugin</filename>.  The make version is called
        the same thing for consistency.
       </para>
      </footnote>
      The pre-plugin initialization code is loaded
      <emphasis>before</emphasis> your build file
      (<filename>Abuild.mk</filename> or
      <filename>Abuild.groovy</filename>), while the
      <filename>plugin.mk</filename> and
      <filename>plugin.groovy</filename> files are loaded after your
      build file.  Here are the files:
      <?example plugin/plugins/echoer/preplugin.mk?>
      <?example plugin/plugins/echoer/preplugin.groovy?>
     </para>
     <para>
      Although this example is trivial and doesn't do anything useful,
      it does illustrate how you can use pre-plugin initialization
      along with regular plugin code to interact with the user's build
      files.  Although adding specific code without going through the
      usual rules method should generally be used sparingly, there are
      other cases in which this type of facility might be useful.
      Examples could include targets that gather statistics or run
      static analysis checks that may be required by a certain
      project, or code that enforces policy.
     </para>
     <para>
      Although building any item in the <filename>plugin</filename>
      tree will illustrate use of the
      <filename>plugin.echoer</filename> plugin, the
      <filename>echo</filename> directory contains four items
      specifically designed to illustrate manipulation of the echo
      message.  Under the <filename>plugin/echo</filename> directory,
      there are four build items.  The item
      <filename>echo-a</filename> in the <filename>a</filename>
      directory uses the make backend and does not modify the
      <varname>ECHO_MESSAGE</varname> variable:
      <?example plugin/echo/a/Abuild.mk?>
      The item <filename>echo-b</filename> in the
      <filename>b</filename> directory uses the make backend and
      modifies the <varname>ECHO_MESSAGE</varname> variabel:
      <?example plugin/echo/b/Abuild.mk?>
      The item <filename>echo-c</filename> in the
      <filename>c</filename> directory uses the Groovy backend and does
      not modify the <varname>echo.message</varname> parameter:
      <?example plugin/echo/c/Abuild.groovy?>
      The item <filename>echo-d</filename> in the
      <filename>d</filename> directory uses the Groovy backend and
      modifies the <varname>echo.message</varname> parameter:
      <?example plugin/echo/d/Abuild.groovy?>
      To see this in action, run <command>abuild -b desc</command>
      from the <filename>plugin/echo</filename> directory:
      <?qtest plugin-echo.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.platforms-and-platform-type-plugins">
     <title>Platforms and Platform Type Plugins</title>
     <para>
      In the <classname>plugin.printer</classname> plugin defined in the
      <filename>plugins/printer</filename> directory, we create a new
      platform type and corresponding platform.  This is the mechanism
      that would be used to add support to &abuild; for an embedded
      platform, a cross compiler, or some other special environment.
      In this example, we stretch the idea of platform types a bit for
      the purpose of illustrating this capability with a simple
      example.
     </para>
     <para>
      Here we define a new platform type called <type>printer</type>.
      This is done by creating a <filename>platform-types</filename>
      file and declaring the platform type in it:
      <?example plugin/plugins/printer/platform-types?>
     </para>
     <para>
      In addition to adding the platform type, we also add a platform
      called
      <type>zzprinter.any.test-suite.abc</type>.
      <footnote>
       <para>
        This odd name has been picked to facilitate testing of all
        examples in &abuild;'s own automated test suite.  By starting
        the platform name with <literal>zz</literal>, we effectively
        ensure that it will always appear alphabetically after
        whatever the real native platform is on our build system.
       </para>
      </footnote>
      To add this platform, we print its name from the
      <command>list_platforms</command> command:
      <?example plugin/plugins/printer/list_platforms?>
      In this case, the program is trivial, but in a real
      implementation, the <command>list_platforms</command> command
      would probably be checking the environment or path for presence
      of certain tools before emitting the name of the platform.  A
      <command>list_platforms</command> program should only mention
      the name of a platform that can actually be built on the build
      host from which it is run.
     </para>
     <para>
      The fourth field of any <type>object-code</type> platform is
      always the name of the compiler, so this implies that we have an
      <type>abc</type> compiler defined somewhere.  This plugin also
      provides the rules for using the <type>abc</type> compiler in
      <filename>toolchains/abc.mk</filename>.  Here are the
      implementation file and help file:
      <?example plugin/plugins/printer/toolchains/abc.mk?>
      <?example plugin/plugins/printer/toolchains/abc-help.txt?>
      You can see the help text by running <command>abuild --help
      rules toolchain:abc</command>, and you can discover that this
      toolchain is available by provided <command>abuild --help rules
      list</command> from anywhere in the <filename>plugins</filename>
      tree.  To understand this file, you should read through the
      comments in <filename>rules/object-code/ccxx.mk</filename> in
      the &abuild; distribution (<xref linkend="ref.ccxx.mk"/>).  In
      this case, our plugin also creates the compiler itself in
      <filename>bin/abc</filename> and
      <filename>bin/abc-link</filename>.  Our &ldquo;compilers&rdquo;
      here just create text files of the source code with numbered
      lines.  Doing this particular operation with a plugin is a bit
      absurd&mdash;using some external utility would be a better
      implementation.  Still, it illustrates the mechanics of setting
      up an additional platform type, and it is not at all uncommon
      for a native compiler plugin to provide wrappers around the real
      compiler.
     </para>
     <para>
      Note that to invoke our compiler, the
      <filename>abc.mk</filename> file uses
      <varname>$(abDIR_plugin.printer)</varname> to refer to a file in
      its own directory, just as would be necessary in rules provided
      by a regular build item.  &Abuild; provides these variables to
      the <application>make</application> backend and also makes this
      information available to the Groovy backend.
      <footnote>
       <para>
        For the deprecated xml-based ant backend, corresponding ant
        properties
        <varname>abuild.dir.<replaceable>build-item</replaceable></varname>
        are available.
       </para>
      </footnote>
     </para>
     <para>
      To see this plugin in action, build the build item in
      <filename>other/bin</filename> with
      <command>--with-deps</command>.  You will see not only the
      normal native executable program being built, but you will also
      see a second output directory called
      <filename>abuild-zzprinter.any.test-suite.abc</filename> which
      contains a file called <filename>print-program</filename>.  This
      happens because both the <classname>bin</classname> build item
      and the <classname>lib</classname> build item on which it
      depends include the <filename>printer</filename> platform type
      in their <property>platform-types</property> keys in their
      <filename>Abuild.conf</filename> files:
      <?example plugin/other/lib/Abuild.conf?>
      <?example plugin/other/bin/Abuild.conf?>
      Here is the build output:
      <?qtest plugin-other-bin.out?>
      Here is the <filename>print-program</filename> file.  This file
      contains the concatenation of all the source files used to
      create the executable as well as the &ldquo;libraries&rdquo; it
      &ldquo;links&rdquo; against:
      <?qtest printer-program.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.plugins-and-tree-deps">
     <title>Plugins and Tree Dependencies</title>
     <para>
      In the <filename>example/plugin/outside</filename> build tree,
      we have a tree that includes our plugin tree as an tree
      dependency.  This tree contains the <classname>prog2</classname>
      build item which depends on the same <classname>lib</classname>
      as our previous example's <classname>bin</classname> build item.
      This build tree does not declare any plugins, so even though its
      tree dependency declares plugins, those plugins are not used
      within this tree.  When we build the
      <classname>prog2</classname> build item with dependencies,
      although the <classname>lib</classname> build item still builds
      as before, <classname>prog2</classname> completely disregards
      the existence of the other platform type and the echoer's
      additional build steps.  This is very important.  Sometimes, a
      build tree may declare a plugin that works for every item in its
      own tree but that would not necessarily work for items in other
      trees.  Examples might include strict static analyzers or other
      code checkers.  It may be desirable to allow the products of
      this build tree to be usable by others that do not wish to
      follow the same restrictions.  Here is the output of building
      <classname>prog2</classname> with dependencies:
      <?qtest plugin-outside.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.native-compiler-plugins">
     <title>Native Compiler Plugins</title>
     <para>
      In the <filename>example/native-compiler</filename> directory, we
      have a plugin that defines a native compiler.  The plugin is in
      the <filename>compiler</filename> directory and is called
      <filename>plugin.compiler</filename>.  In this plugin, we are
      adding a new platform to support our alternative compiler.  We
      don't have to add any new platform types since we are just adding
      this platform to the native platform type.  Since this is a
      relatively common operation, &abuild; provides a short syntax for
      doing it.  Here is the <command>list_platforms</command> program:
      <?example native-compiler/compiler/list_platforms?>
      It generates this output which automatically creates platforms
      with the same first three fields (<type>os</type>,
      <type>cpu</type>, and <type>toolset</type>) as other native
      platforms, with the <type>qcc</type> compiler as the fourth
      field, and with <type>release</type>, <type>debug</type>, or
      nothing as the fifth field:

      <programlisting>native-compiler qcc.release
native-compiler qcc.debug
native-compiler qcc
</programlisting>
      Since new platforms take precedence over old platforms by
      default when &abuild; chooses which platform to use for a given
      platform type, our <command>list_platforms</command> script
      offers the user a way of suppressing this platform and also of
      making these low priority compilers.  In this case, our
      <command>list_platforms</command> program doesn't generate any
      output if the <envar>NO_QCC</envar> environment variable is set,
      and if the QCC_LOWPRI environment variable is set, it declares
      these as low priority compilers which makes them available but
      prevents them from being selected by default over built-in
      compilers or compilers declared by earlier plugins.  Setting
      that environment variable would make that platform completely
      unavailable, regardless of any compiler preferences expressed by
      the user.  (We could also prevent the platform using this
      compiler from being built by default without making it disappear
      entirely by using platform selectors as discussed in <xref
      linkend="ref.platform-selection"/>).  Note that we generate
      output for the <type>qcc</type> compiler with the
      <type>release</type> and <type>debug</type> flags as per our
      usual convention.  By placing the compiler with no options last,
      we make &abuild; select it by default over the other two.  It
      will also be selected over any built-in platforms or platforms
      provided by earlier plugins.
     </para>
     <para>
      In addition to listing the compiler in
      <command>list_platforms</command>, we have to provide a support
      file for it in <filename>toolchains/qcc.mk</filename>:
      <?example native-compiler/compiler/toolchains/qcc.mk?>
      This file illustrates a degenerate compiler implementation,
      providing minimal implementations of all the variables and
      functions that <filename>ccxx.mk</filename> requires.  For
      details, please read the comments in
      <filename>rules/object-code/ccxx.mk</filename> in the &abuild;
      distribution (<xref linkend="ref.ccxx.mk"/>).
     </para>
     <para>
      In the <filename>native-compiler/outside</filename> directory,
      there is another build tree that lists the plugin tree, in this
      case <filename>native-compiler</filename>, as a tree dependency:
      <?example native-compiler/outside/Abuild.conf?>
      This tree doesn't know about the <filename>qcc</filename>
      compiler, so when we build the <classname>outside</classname>
      build item, it would build only with the default native
      compiler.  In a default invocation of &abuild;
      (<emphasis>i.e.</emphasis>, one without any platform selectors),
      the <classname>lib</classname> build item on which this depends
      would only be built with <filename>qcc</filename> because of the
      plugin in its build tree (which is a tree dependency of this
      tree).  However, the <classname>lib</classname> build item
      <emphasis>could</emphasis> also be built with the default native
      compiler.  &Abuild; recognizes this fact and will therefore
      compile <classname>lib</classname> with both
      <filename>qcc</filename> and the default native compiler.  This
      is an example of &abuild;'s ability to add additional build
      platforms as needed based on the dependency graph:
      <?qtest as-needed-platforms.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.plugin.rule-checker">
     <title>Checking Project-Specific Rules</title>
     <para>
      Another use of a plugin could be to enforce additional build
      tree-specific rules that fall outside of &abuild;'s normal
      dependency checking capabilities.  As an example, suppose you
      had a build item that you wanted all build items to depend on
      and that you couldn't make it a plugin because it had to build
      something.  You could have that build item set a variable to
      some specific value in its <filename>Abuild.interface</filename>
      file.  Then you could create a plugin that would check that the
      variable had that value, which would effectively make sure
      everyone depended on the item that set the variable.  This
      plugin would have a <filename>plugin.mk</filename> file that
      would check to make sure that the variable was set and report an
      error if not.  Since all build items would see the plugin code,
      it would make this plugin an effective checker for enforcing
      some rule that can't otherwise by expressed.
     </para>
     <para>
      We illustrate this pattern in our
      <filename>rule-checker</filename> example which can be found in
      <filename>doc/example/rule-checker</filename>.  This directory
      includes four build items:
      <classname>plugin.auto-checker</classname>,
      <classname>auto-provider</classname>,
      <classname>item1</classname>, and <classname>item2</classname>.
      The goal is that every build item whose target type is
      <type>object-code</type> should depend on
      <classname>auto-provider</classname>.  This rule is enforced
      with the <classname>plugin.auto-checker</classname> plugin which
      is declared as a plugin in the tree's root
      <filename>Abuild.conf</filename>:
      <?example rule-checker/Abuild.conf?>
      The <classname>plugin.auto-checker</classname> build item
      contains two files aside from its
      <filename>Abuild.conf</filename>.  It has a
      <filename>plugin.interface</filename> file that declares a
      variable that indicates whether the
      <classname>auto-provider</classname> build item has been seen:
      <?example rule-checker/auto-checker/plugin.interface?>
      This plugin interface file is automatically loaded by all build
      items before their own interface files or any of the interface
      files of their dependencies.  We include a fallback assignment
      of a false value to this variable.  The
      <classname>auto-provider</classname> build item sets this
      variable to true in its <filename>Abuild.interface</filename>
      file:
      <?example rule-checker/auto-provider/Abuild.interface?>
      For completeness, here are the rest of the files from
      <classname>auto-provider</classname>:
      <?example rule-checker/auto-provider/Abuild.mk?>
      <?example rule-checker/auto-provider/provide-auto.mk?>
     </para>
     <para>
      Since <classname>auto-provider</classname> sets the
      <varname>SAW_AUTO_PROVIDER</varname> variable, it possible for
      the <classname>plugin.auto-checker</classname> build item to
      detect that <classname>auto-provider</classname> is in the
      dependency list by checking the value of that variable.  It does
      this in its <filename>plugin.mk</filename> file, which is
      included by &abuild;'s <application>make</application> code for
      every <application>make</application>-based build item:
      <?example rule-checker/auto-checker/plugin.mk?>
     </para>
     <para>
      To see what happens when a build item forgets to depend on
      <classname>auto-provider</classname>, we will look at
      <classname>item1</classname>.  Here is its
      <filename>Abuild.conf</filename>:
      <?example rule-checker/item1/Abuild.conf?>
      As you can see, there is no dependency on
      <classname>auto-provider</classname>.  When we try to build this
      item, we get the following error:
      <?qtest rule-checker-item1-error.out?>
      This is the error that was issued from
      <classname>plugin.auto-checker</classname>'s
      <filename>plugin.mk</filename> above.  The build item
      <classname>item2</classname> does declare the appropriate
      dependency:
      <?example rule-checker/item2/Abuild.conf?>
      Its build proceeds normally:
      <?qtest rule-checker-item2-build.out?>
     </para>
     <para>
      This examples shows how little code is required to implement
      your own rule checking.  The possibilities for use of this
      technique are endless.  Such techniques could be used to enforce
      all sorts of project-specific architectural constraints, build
      item naming conventions, or any number of other possibilities.
      You could even create a single project-wide global plugin that
      checked to make sure other plugins defined in other trees were
      appropriate declared, thus effectively working around the
      limitation of only being able to declare a single global tree
      dependency in a forest.
     </para>
    </sect2>
    <sect2 id="ref.install-target">
     <title>Install Target</title>
     <para>
      Still another use of plugins could be to implement an
      <command>install</command> target.  Although &abuild; provides
      most of what is required to use build products within the source
      tree, in most real systems, there comes a time when a
      distribution has to be created.  You can write your own
      <command>install</command> target or similar using plugins.
     </para>
    </sect2>
   </sect1>
  </chapter>
  <chapter id="ref.best-practices">
   <title>Best Practices</title>
   <para>
    This chapter describes some &ldquo;best practices&rdquo; that
    should be kept in mind while using &abuild;.  It is based on
    experience using &abuild; and lessons learned from that
    experience.
   </para>
   <sect1 id="ref.guidelines-for-extension-authors">
    <title>Guidelines for Extension Authors</title>
    <para>
     If you are writing code to extent &abuild; through plugins or
     build item rules, there are several things you should keep in
     mind.  This section describes items that pertain to both
     <application>make</application> and
     <application>Groovy/ant</application> extensions.
     <itemizedlist>
      <listitem>
       <para>
        If your rules or plugin adds support for an optional tool, you
        must consider carefully what you will do if that tool is not
        available.  One option would be to fail.  Another option would
        be to simply not provide the added functionality.  For
        example, if you are providing a plugin that adds support for a
        new compiler, your plugin should detect whether the compiler
        is available, and if it is not, it should avoid listing it as
        an available compiler or platform.  This makes it possible for
        people to continue to build with other compilers on systems
        that lack your additional one.  If you are adding support for
        an optional code generator, &abuild;'s code generator caching
        program may be of use to you; see <xref
        linkend="ref.codegen-wrapper"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        Since you can't define your own custom
        <command>clean</command> target, you should generally avoid
        having rules create files outside of the output directory from
        which they are run.  Any such products will not be removed by
        &abuild; clean as run by ordinary users.  If you have
        situations in which you must create files in external
        locations, such as installer plugins, you may want to provide
        a specific target to remove them as well.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
   <sect1 id="ref.guidelines-for-make-rule-authors">
    <title>Guidelines for Make Rule Authors</title>
    <para>
     The code that goes into a make rule implementation file,
     <filename>preplugin.mk</filename>, or
     <filename>plugin.mk</filename> file is regular <application>GNU
     Make</application> code.  There are certain practices that you
     should follow when writing <application>GNU Make</application>
     code for use within &abuild;.  A good way to learn about writing
     rules for &abuild; is to study existing rules.  Here we will
     briefly list some things that rules authors must keep in mind:
     <itemizedlist>
      <listitem>
       <para>
        If you are about to write some rules, consider carefully
        whether they should be local rules for a specific build item
        (accessed with the <varname>LOCAL_RULES</varname> variable),
        exported rules provided by a build item (accessed with the
        <varname>RULES</varname> variable), or whether they should be
        made globally accessible by being included in a plugin.  The
        last case will be rare and should only be used for
        functionality that really should work &ldquo;out of the
        box&rdquo; in a particular build tree.  Plugin rules and build
        item rules must appear in the
        <filename>rules/<replaceable>target-type</replaceable></filename>
        directory or the <filename>rules/all</filename> directory
        within the providing build item.  Local rules can appear
        anywhere, and the location must be named in the
        <varname>LOCAL_RULES</varname> variable in
        <filename>Abuild.mk</filename>.  It is also possible to create
        global make code that is loaded from a plugin directory:
        &abuild; will load any <filename>preplugin.mk</filename> and
        <filename>plugin.mk</filename> files defined in plugins in the
        order in which the plugins are declared.  Remember that
        <filename>preplugin.mk</filename> is loaded before
        <filename>Abuild.mk</filename>, and
        <filename>plugin.mk</filename> is loaded after
        <filename>Abuild.mk</filename>.  This makes it possible for a
        plugin to provide some initial variable settings for the user
        in <filename>preplugin.mk</filename>, have the user do
        something with or modify those values in
        <filename>Abuild.mk</filename>, and then use the result that
        operation in <filename>plugin.mk</filename>.
       </para>
      </listitem>
      <listitem>
       <para>
        &Abuild; invokes make with the
        <command>--warn-undefined-variables</command> flag.  This means
        that your users will see warnings if you assume that an
        undefined variable has the empty string as a value.  If it is
        your intention to have an undefined variable default to the
        empty string, then you should include

        <programlisting><replaceable>VARIABLE</replaceable> ?=
</programlisting>
        in your rules, where <varname>VARIABLE</varname> is the name
        of the variable you are setting.  You can always provide
        default values for variables in this fashion if the intention
        is to allow users to override those values in their own
        <filename>Abuild.mk</filename> files.
       </para>
      </listitem>
      <listitem>
       <para>
        Note that <filename>Abuild.mk</filename> files are included
        before rules files.  This is necessary because the
        <filename>Abuild.mk</filename> file contains information about
        which rules are to be included.  If your rules are providing
        values that users will use in their
        <filename>Abuild.mk</filename> files, you should recognize
        that your users will need to avoid referencing those variables
        in assignment statements that use <literal>:=</literal>
        instead of <literal>=</literal> since the
        <filename>Rules.mk</filename> variables will not yet be
        defined when <filename>Abuild.mk</filename> is read.
        Alternatively, you can make use of the
        <filename>preplugin.mk</filename> functionality for rules
        supplied by plugins.
       </para>
      </listitem>
      <listitem>
       <para>
        You should always provide a help file for your rules.  The
        help file is called
        <filename><replaceable>rulename</replaceable>-help.txt</filename>,
        and lives in the same directory as the rule implementation.
        For an example and discussion of this, see <xref
        linkend="ref.code-generators"/> and <xref
        linkend="ref.help-system"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        If your rules require certain variables to be set, check for
        those variables and given an error if they are not defined.
        For an example of this, see <xref
        linkend="ref.example.code-generator.make"/>.  The
        <filename>ccxx.mk</filename> rules in the &abuild; sources
        (<xref linkend="ref.ccxx.mk"/>) provide a somewhat more
        elaborate example of doing this since they actually generate
        dynamically in terms of other values the list of variables
        that should be defined.
       </para>
      </listitem>
      <listitem>
       <para>
        All rules should provide an <command>all::</command> target.
        Note that &abuild; never invokes a user-supplied
        <command>clean</command> target, so providing a
        <command>clean</command> target is not useful.
        <footnote>
         <para>
          In &abuild; 1.0, user-supplied <command>clean</command>
          targets were run when &abuild; was invoked from inside an
          output directory, but this turned out not to be particularly
          useful or reliable.  The practice of having
          <command>clean</command> targets simply remove output
          directories seems to have emerged as a best practice in the
          community anyway.
         </para>
        </footnote>
        Although you can add additional targets in your rules files,
        think carefully before doing so.  Having too many custom
        targets will make a source tree hard to build and maintain.
        If you are adding functionality that should be done as part of
        every build, consider making it part of the
        <command>all::</command> target.
       </para>
      </listitem>
      <listitem>
       <para>
        If you are adding support for a new test driver, you should
        make sure that your test driver is invoked from the
        <command>check</command>, <command>test</command>, and
        <command>test-only</command> targets.  You must also ensure
        that both the <command>check</command> and
        <command>test</command> targets depend on the
        <command>all</command> target but that the
        <command>test-only</command> target does not depend on the
        <command>all</command> target.  &Abuild; internally provides
        this construct for these targets that don't do anything, so if
        your test support only operates conditionally upon the
        presence of test files, you don't have to worry about
        conditionally defining empty targets.  For an example, see
        <filename>make/qtest-support.mk</filename> in the &abuild;
        distribution.
       </para>
      </listitem>
      <listitem>
       <para>
        Sometimes it may be useful to provide debugging targets for your
        users that provide some information about the state as your
        rules see it.  The <filename>ccxx</filename> rules provide a
        <command>ccxx_debug</command> target for this purpose.
       </para>
      </listitem>
      <listitem>
       <para>
        Always remember that any targets you define in your rules files
        are run from the output subdirectory.  The variable
        <varname>$(SRCDIR)</varname> points to the directory that
        contains the actual <filename>Abuild.mk</filename> file and
        therefore presumably the source files.  &Abuild; sets the
        <varname>VPATH</varname> variable to this as well, but you may
        have to explicitly run your actions with arguments that point
        back to the source directory (e.g., <varname>-I
        $(SRCDIR)</varname>).  If make finds a target's prerequisite
        using <varname>VPATH</varname>, the full relative path to the
        prerequisite will be accurately reflected in
        <varname>$&lt;</varname> and <varname>$^</varname>, which will
        be sufficient for many cases.
       </para>
      </listitem>
      <listitem>
       <para>
        In order to have your rules behave properly with the
        <command>--verbose</command> and <command>--silent</command>
        flags, you should <emphasis>avoid</emphasis> putting
        <literal>@</literal> in front of commands that the user should
        see in verbose mode, and you should have all your rules print
        short, simple descriptive messages about what they are doing.
        These rules should be printed using
        <varname>@$(PRINT)</varname>.  The <varname>PRINT</varname>
        variable is usually set to <command>echo</command>, but it is
        set to <literal>@:</literal> when &abuild; is running in
        silent mode.  Note that we put an <literal>@</literal> sign at
        the beginning of the <varname>@$(PRINT)</varname> command so
        that the user will not see the echo command itself (in
        addition to what is being echoed) being echoed when they are
        running in verbose mode.
       </para>
      </listitem>
      <listitem>
       <para>
        There are some convenience functions provided by &abuild;'s
        GNU Make code.  The best way to learn is to read existing
        rules.  If you are going to be writing a lot of
        <application>make</application> code for &abuild;, it will be
        in your interest to familiarize yourself with the code in
        <filename>make/global.mk</filename> in the &abuild;
        distribution.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
   <sect1 id="ref.guidelines-for-groovy-target-authors">
    <title>Guidelines for Groovy Target Authors</title>
    <para>
     All Groovy files loaded by &abuild; are Groovy scripts.  This
     gives you plenty of rope with which you can hang yourself.  When
     creating rules or other Groovy code for use with &abuild; keep in
     mind following guidelines:
     <itemizedlist>
      <listitem>
       <para>
        If your code does anything more elaborate than adding
        stand-alone closures, consider having your script explicitly
        define a class and then instantiate it.  This provides a
        &ldquo;fence&rdquo; to protect us against certain types of
        errors, such as mistyping a field name and ending up adding
        something to the binding instead.  All built-in Groovy rules
        provided by &abuild; follow this convention.
       </para>
      </listitem>
      <listitem>
       <para>
        When writing custom rules or defining additional targets,
        allow all defaults to be overridable through parameter
        settings.  This helps to avoid locking the user into a set of
        conventions.  &Abuild;'s Groovy backend's
        <function>runActions</function> method provides an easy
        framework that enables your rules to offer the same layers of
        customization that are provided by &abuild;'s own rules.  For
        an example of using this construct, see <xref
        linkend="ref.example.code-generator.groovy"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        When developing support for a new test framework, you only
        have to add new closures for the <command>test-only</command>
        target.  &Abuild; automatically calls the
        <command>test-only</command> from both <command>test</command>
        and <command>check</command>.  This is actually different in
        the make backend, which requires adding code to all three
        test-related targets.  The reason we don't have to do this in
        Groovy is that our target framework allows to explicitly call
        one target from another in a dependency-aware fashion.
       </para>
       <para>
        Instead of adding closures to <command>test-only</command>,
        you may instead decide to create your own custom target, make
        it a dependency of <command>test-only</command>, and add your
        closures to your custom target.  This is what both QTest and
        JUnit support do.  The advantage of this approach is that it
        makes it possible for you invoke a particular collection of
        tests explicitly and, for build items that use more than one
        test framework, prevents later tests from being skipped if
        earlier ones fail.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     The best way to learn about what is offered by &abuild;'s Groovy
     backend is to study existing rules from the
     <filename>rules</filename> directory in your &abuild;
     distribution.  You can find a complete copy of the
     <filename>java</filename> rules in <xref
     linkend="ref.rules.java.groovy"/>.  If you're really adventurous,
     you can read the source to the Groovy backend itself in
     &abuild;'s source distribution.
    </para>
   </sect1>
   <sect1 id="ref.platform-dependent-in-indep-or-java">
    <title>Platform-Dependent Files in Non-<type>object-code</type> Build Items</title>
    <para>
     It's easy to fall into the trap of thinking that, just because a
     file is a text file or some other format that can be processed on
     any platform type, it is a platform-independent file.  A plain
     text file that contains platform-specific information is, in
     fact, a platform-specific file.  So if you have a build item that
     runs a platform-specific tool and caches platform-specific
     information, that build item should probably have platform type
     <type>native</type> rather than <type>indep</type>.
    </para>
    <para>
     This is one reasons that &abuild; doesn't provide information
     about the current platform to the &abuild; interfaces for
     <type>java</type> and <type>platform-independent</type> build
     items.  It would be a bug to have an interface variable have a
     different value in different contexts when it might influence a
     build that could be used on multiple platforms.  For example, an
     <type>indep</type> build item could write out some value based on
     a platform variable and then that information could be wrong when
     the results of the build were used on a different platform.
    </para>
    <para>
     &Abuild; itself actually breaks this rule for Java wrapper
     scripts.  This is a known problem for which we don't have a ready
     solution.  It just show that there may be instances in which you
     might break this rule, but be aware when you do that you are
     creating a situation in which a single built instance of build
     tree may not work properly when used across multiple platforms.
    </para>
   </sect1>
   <sect1 id="ref.hidden-dependencies">
    <title>Hidden Dependencies</title>
    <para>
     Suppose you have build items <classname>A</classname>,
     <classname>B</classname>, and <classname>C</classname>, and suppose
     that <classname>B</classname> doesn't actually require
     <classname>C</classname> to build, but anyone who needs
     <classname>B</classname> also needs <classname>C</classname>.  In
     this case, <classname>B</classname> should declare a dependency
     on <classname>C</classname>, or <classname>B</classname> and
     <classname>C</classname> should be combined.  In other words, a
     build item should depend on all build items that will be needed
     if you use it.
    </para>
    <para>
     Consider a concrete example.  Suppose our three build items are
     <classname>main</classname>, <classname>lib-headers</classname>, and
     <classname>lib-src</classname>.  Suppose
     <classname>lib-headers</classname> doesn't have an
     <filename>Abuild.mk</filename> and doesn't actually build
     anything.  Instead, it just has an
     <filename>Abuild.interface</filename> that adds its directory to
     your <varname>INCLUDES</varname> variable.  Suppose
     <classname>lib-src</classname> builds a library and has an
     <filename>Abuild.interface</filename> that adds the library
     directory to <varname>LIBDIRS</varname> and the library to
     <varname>LIBS</varname>.  If <classname>main</classname> uses the
     library built by <classname>lib-src</classname> but declares a
     dependency on <classname>lib-headers</classname>, then it will be
     able to compile but not link.  In order to link, it requires a
     dependency on <classname>lib-src</classname>.  This means that
     anyone that depends on <classname>lib-headers</classname> must
     also depend on <classname>lib-src</classname>.  Rather than
     having this situation, make <classname>lib-src</classname>'s
     <filename>Abuild.interface</filename> append to
     <varname>INCLUDES</varname> and just eliminate the
     <classname>lib-headers</classname> build item entirely.  It is
     still okay to have the headers in a separate directory; just
     don't place an <filename>Abuild.conf</filename> in that
     directory.
    </para>
   </sect1>
   <sect1 id="ref.interfaces-and-implementations">
    <title>Interfaces and Implementations</title>
    <para>
     Separation of implementations from interfaces can be a good idea
     and can reduce the complexity of the dependency graph of a build
     tree since users of a capability need to depend only on the
     interfaces and not the implementations.  If done incorrectly,
     however, separating implementations from interfaces has several
     pitfalls.  One may be tempted to implement separation of
     interfaces from implementations by using a scheme such as the one
     described in the previous section, <xref
     linkend="ref.hidden-dependencies"/>.  In addition to creating a
     potential hidden dependency issue, it is possible to create even
     worse situations, such as hidden circular dependencies.
    </para>
    <para>
     The case in the previous situation showed how we can create a
     link error that could be resolved by adding an extra dependency
     in <classname>main</classname>.  It is relatively easy to create
     situations that will cause unresolvable link errors as well by
     creating separate header-only build items.  For example, suppose
     you have libraries <classname>A</classname> and
     <classname>B</classname> and separate build items
     <classname>A-headers</classname> and
     <classname>B-headers</classname> to export their static header
     files.  Suppose now that <classname>A</classname> depends on
     <classname>A-headers</classname> and
     <classname>B-headers</classname> and that
     <classname>B</classname> also depends on
     <classname>A-headers</classname> and
     <classname>B-headers</classname>.  (See <xref
     linkend="fig.hidden-circular-dependency"/>) In this case,
     <classname>A</classname> and <classname>B</classname> are
     actually interdependent but there are no circular dependencies
     declared.  If there are any situations between
     <classname>A</classname> and <classname>B</classname> in which
     the first reference to something in <classname>B</classname>
     appears in <classname>A</classname> and the first reference to
     something else in <classname>A</classname> appears in
     <classname>B</classname>, then anything that depends on
     <classname>A</classname> and <classname>B</classname> will have a
     link error.
     <footnote>
      <para> Use of shared libraries or repeating libraries in the
      link statement could actually work around this specific case,
      but there are good reasons to avoid circular dependencies beyond
      just making &abuild; happy.  The point is that this technique
      allows them to hide in the dependency graph, which is a bad
      thing.
      </para>
     </footnote>
     This is a hidden circular dependency.  The best way to avoid this
     situation is to not split <classname>A-headers</classname> from
     <classname>A</classname>.
     <figure id="fig.hidden-circular-dependency">
      <title>Hidden Circular Dependency</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="hidden-circular-dependency.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>A</classname> and <classname>B</classname> are
         interdependent even though no explicit circular dependencies
         exist.
        </para>
       </caption>
      </mediaobject>
     </figure>
    </para>
    <para>
     There are other less insidious problems that are still annoying.
     For example, <classname>A-headers</classname> might really depend
     on <classname>B-headers</classname> but forget to declare this.
     As long as <classname>A-src</classname> declares a dependency on
     <classname>B-headers</classname>, we'll never notice that
     <classname>A-headers</classname> forgot to declare its dependency
     because <classname>A-headers</classname> isn't actually built.
     We might later try to build something else that declares a
     dependency on <classname>A-headers</classname>.  This other build
     may fail because of <classname>B-headers</classname> not being
     known.  We've then created a hidden dependency situation: anyone
     who depends on <classname>A-headers</classname> must also depend
     on <classname>B-headers</classname>.  The best way to this
     situation is also to not split <classname>A-headers</classname>
     from <classname>A</classname>.
    </para>
    <para>
     One cost of not separating these is that if one library depends
     only on another library's header files, the two libraries could
     be built in parallel.  By making one library depend on the other
     in its entirety, &abuild; will force the other library to be
     built before the dependent library.  This is unfortunate, but
     it's not a good idea to work around this by introducing holes in
     &abuild;'s dependency management.  A better technique would be to
     use some external analyzer that could detect at a finer level
     what things can actually be built in parallel.  There are
     commercial tools that are designed to do this.  Perhaps, over
     time, &abuild; will acquire this capability, or users of &abuild;
     can implement some solution on top of &abuild; that uses an
     external tool.
    </para>
    <para>
     Proper separation of interfaces from implementations, such as
     using a bridge pattern (as described in the <citetitle>Design
     Patterns</citetitle> book by Gamma, et al), which allows the
     implementation and interface to vary separately by implementing
     proxy methods that call real methods through a runtime-supplied
     implementation pointer, can solve the parallel build problem
     without introducing any of these other pitfalls.  Ultimately, as
     long as you don't create a situation where depending on one
     thing automatically requires you to depend on some other
     specific thing to avoid link errors, you should be in pretty good
     shape.  You can also see an example of true separation of
     interfaces from implementations in <xref
     linkend="ref.example.mixed-classification"/>.
    </para>
    <para>
     Note that another way to create this hidden dependency problem is
     to create a directory that contains header files for multiple
     build items.  Suppose, for example, that you have the directory
     structure shown in <xref linkend="fig.shared-include"/>:
     <figure id="fig.shared-include">
      <title>Shared Include Directory</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="shared-include.png"/>
       </imageobject>
       <caption>
        <para>
         Oops!  Both build items use the same include directory!
        </para>
       </caption>
      </mediaobject>
     </figure>
     and that <classname>A</classname> and <classname>B</classname>
     both have their header files in the <filename>include</filename>
     directory.  If both <classname>A</classname> and
     <classname>B</classname> add <filename>../include</filename> to
     <varname>INCLUDES</varname> in their
     <filename>Abuild.interface</filename> files, any build item that
     depends on <classname>A</classname> could accidentally include
     <classname>B</classname>'s header files and therefore
     accidentally require <classname>B</classname> as well.  A simple
     way to avoid this without having to distribute the public header
     files throughout <filename>module</filename>'s directory
     structure would be to create separate directories under include,
     such as shown in <xref linkend="fig.separate-include"/>.
     <figure id="fig.separate-include">
      <title>Separate Include Directories</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="separate-include.png"/>
       </imageobject>
       <caption>
        <para>
         Headers are still easy to find and are separated by build
         item.
        </para>
       </caption>
      </mediaobject>
     </figure>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.monitored-mode">
   <title>Monitored Mode</title>
   <para>
    When run with the <option>--monitored</option> flag, &abuild; runs
    in <emphasis>monitored mode</emphasis>.  In this mode, &abuild;
    generates output that would be useful to an external program that
    may be monitoring its progress.  This includes the output of
    <option>--dump-data</option> (see <xref
    linkend="ref.dump-data"/>).  With the data output in monitored
    mode, it is possible to present information to the user that
    reveals considerable detail about &abuild;'s progress during the
    course of a build.  Monitored mode was introduced into &abuild; to
    support development of graphical front ends or IDE plugins for
    &abuild;, but it could be useful for other purposes as well.
   </para>
   <para>
    All additional information in monitored mode is either prefixed by
    the string <varname>abuild-monitored:</varname> followed by a
    keyword or is delimited on both ends by strings so prefixed.  The
    following information is provided in monitored mode:
   </para>
   <variablelist>
    <varlistentry>
     <term>begin-dump-data ... end-dump-data</term>
     <listitem>
      <para>
       Lines delimited by these keywords surround
       <option>--dump-data</option> output.  In monitored mode,
       <option>--dump-data</option> output appears just before build
       graph output or, if there were errors, just before it exits.
       Note that <option>--dump-data</option> output is always
       included in monitored mode, so inclusion of the
       <option>--dump-data</option> option is not required and would
       in fact make &abuild; exit before it built anything.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>begin-dump-build-graph ... end-dump-build-graph</term>
     <listitem>
      <para>
       Lines delimited by these keywords surround
       <option>--dump-build-graph</option> output.  In monitored mode,
       <option>--dump-build-graph</option> output appears just before
       &abuild; begins a build.  It is not included if there were
       errors.  Note that <option>--dump-build-graph</option> output
       is always included in monitored mode, so inclusion of the
       <option>--dump-build-graph</option> option is not required and
       would in fact make &abuild; exit before it built anything.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>error</term>
     <listitem>
      <para>
       Any error message output by &abuild; is repeated in a monitor
       output message prefixed by this keyword.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>fatal-error</term>
     <listitem>
      <para>
       Any fatal error message output by &abuild; is first issued in a
       monitor output message prefixed by this keyword.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>state-change</term>
     <listitem>
      <para>
       During a build, &abuild; outputs state changes from the dependency
       evaluator using this keyword.  State change monitor output lines
       will always have this form:

       <programlisting>abuild-monitor: state-change item-name platform state
</programlisting>
       where <varname>state</varname> is one of the following:
       <variablelist>
        <varlistentry>
         <term><varname>waiting</varname></term>
         <listitem>
          <para>
           The item is scheduled to be built but still has dependencies
           that have not yet been built
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>ready</varname></term>
         <listitem>
          <para>
           The item is scheduled to be built, and all its dependencies
           have been successfully built
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>running</varname></term>
         <listitem>
          <para>
           The item is currently being built
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>completed</varname></term>
         <listitem>
          <para>
           The item has been built successfully
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>failed</varname></term>
         <listitem>
          <para>
           An attempt was made to build the item, but the build failed
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>dependency-failed</varname></term>
         <listitem>
          <para>
           The item was previously scheduled to be built, but a build
           will no longer be attempted because of the failure of one of
           its dependencies
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>targets</term>
     <listitem>
      <para>
       Before &abuild; invokes the backend to perform a build, it will
       output a line of the form

       <programlisting>abuild-monitor: targets item-name platform target [target ...]
</programlisting>
       to indicate a space-separated list of targets that will be
       passed to the backend.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Additional monitor output lines may be added in the future.  To
    ensure forward compatibility, programs intending to consume &abuild;
    monitor output should ignore any &abuild; monitor output lines that
    they do not recognize.
   </para>
  </chapter>
  <chapter id="ref.misc-xslt">
   <title>Sample XSL-T Scripts</title>
   <para>
    &Abuild; has various options that output or otherwise generate XML
    data.  Among these are <option>--dump-data</option>,
    <option>--dump-build-graph</option>, and
    <option>--dump-interfaces</option>.  XML data can be hard to read
    and cumbersome for people to operate on directly, but it is a very
    convenient input format for additional processing.  See the
    <filename>misc/xslt</filename> directory in the &abuild; source or
    binary distribution for some example XSL-T scripts.  There is a
    <filename>README.txt</filename> file in that directory which
    contains additional information.
   </para>
  </chapter>
  <chapter id="ref.abuild-internals">
   <title>&Abuild; Internals</title>
   <para>
    This chapter provides detailed information about the inner
    workings of parts of &abuild;.  Understanding this material is not
    essential even for using &abuild; in an advanced way, but reading
    it may provide insight into some of the reasons that &abuild;
    works the way it does.  Understanding this material
    <emphasis>is</emphasis> essential to anyone who would want to
    modify any of &abuild;'s core functionality.
   </para>
   <sect1 id="ref.avoiding-recursive-make">
    <title>Avoiding Recursive Make</title>
    <para>
     There has been some thought and writing about recursive make, and
     there are various approaches to the problem of make recursion.
     On one extreme, you can write makefiles that iterate through
     subdirectories and invoke make recursively for each subdirectory.
     These are hostile to parallelism and invoke make recursively
     bounded by the depth of the file system.  This use of recursive
     make is expensive in terms of time and system resources.  At the
     other end of the spectrum, you can create makefiles that include
     all the other makefiles and effectively create one monolithic
     makefile for the entire project.  These makefiles are fragile and
     very hard to maintain because you have to make sure that no
     makefile defines any targets or variables that conflict with
     those defined by other makefiles, and you have to jump through
     hoops to make sure that whatever paths are in the makefiles can
     be resolved properly regardless of the starting directory of the
     build.
    </para>
    <para>
     &Abuild; takes a middle ground.  The only files that may be
     included in multiple contexts that actually set variables and
     contain end-user knowledge are rules files.  To make this work,
     we provide variables that contain the currently resolved path of
     each build item.  This is necessary anyway in order to support
     backing areas.  &Abuild; then allows users to create
     <filename>Abuild.mk</filename> files that don't have to coexist
     with other <filename>Abuild.mk</filename> files at runtime.
     Since &abuild; knows all the dependencies between build items, it
     can build items iteratively or even in parallel without using any
     recursion at all.  Although a monolithic makefile system that is
     perfectly constructed would allow arbitrarily complex
     dependencies to be declared between specific targets in specific
     directories, maintaining this for a system of any size or for a
     system that was dynamic would be impractical.  &Abuild; replaces
     this with precise management of inter-build item dependencies.
     Even so, &abuild;'s make code actually does generate fine-grained
     dependencies at the file level, so most of the advantages of the
     monolithic non-recursive makefile approach are realized with
     &abuild;.  We believe that this achieves the right balance
     between granularity and ease of maintenance and makes &abuild;'s
     approach robust and efficient for both small and large build
     trees.
    </para>
   </sect1>
   <sect1 id="ref.running-in-output-directory">
    <title>Starting &Abuild; in an Output Directory</title>
    <para>
     When &abuild; starts up, it decides that it is running in an
     output directory if all of the following conditions hold:
     <itemizedlist>
      <listitem>
       <para>
        The current directory <emphasis>does not</emphasis> contain an
        <filename>Abuild.conf</filename> file
       </para>
      </listitem>
      <listitem>
       <para>
        The parent directory <emphasis>does</emphasis> contain an
        <filename>Abuild.conf</filename> file
       </para>
      </listitem>
      <listitem>
       <para>
        The current directory name starts with <filename>abuild-</filename>
       </para>
      </listitem>
      <listitem>
       <para>
        The current directory contains a file called
        <filename>.abuild</filename>
       </para>
      </listitem>
     </itemizedlist>
     If &abuild; is invoked in an output directory, it determines the
     current platform from the name of the output directory (which is
     always called
     <filename>abuild-<replaceable>platform</replaceable></filename>)
     and the current build item from the
     <filename>Abuild.conf</filename> in the parent directory.  Then
     it will run a build only for that specific platform on that
     specific build item.  In this mode, &abuild; explicitly prohibits
     specification of a build set or clean set and does not build
     dependencies, as if <option>--no-deps</option> were specified.
     In this mode, the <command>clean</command> target recursively
     removes all files only in the current output directory (except
     that it leaves the empty <filename>.abuild</filename> file
     behind).  The main use for this feature would be in testing rules,
     but it could also be useful in helping to track down some
     hard-to-trace build problem that applies to only one of several
     platforms that are being built for a specific build item.  Most
     users will never use this functionality.
    </para>
   </sect1>
   <sect1 id="ref.traversal-details">
    <title>Traversal Details</title>
    <para>
     This section describes how &abuild; traverses build trees to
     resolve build item names to paths.  Here we describe the process
     at a level of detail that is closer to the code.  The
     <function>traverse</function> function in the &abuild; source
     code is responsible for the behavior described here.  It will
     likely be necessary to read this section more than once to fully
     understand what is happening as some parts of the description
     won't make sense without knowing about parts you won't have read
     yet.  (Fortunately, the human brain is better at resolving
     circular dependencies than a build system is.)
    </para>
    <para>
     Internally, &abuild; maintains tree data structures to hold onto
     the shape and contents of build forests:
     <classname>BuildForest</classname>,
     <classname>BuildTree</classname> and
     <classname>BuildItem</classname>.  The
     <classname>BuildForest</classname> object has a map from build
     tree names to <classname>BuildTree</classname> objects and also
     from build item names to <classname>BuildItem</classname>
     objects.  The <classname>BuildForest</classname> object also
     contains the list of backing areas that apply to the forest as
     well as the list of items and trees that are specified as deleted
     in the <filename>Abuild.backing</filename> file.
    </para>
    <para>
     The <classname>BuildTree</classname> object contains
     tree-specific information, such as the tree's list of plugins,
     tree dependencies, supported traits, etc.  It also contains the
     absolute path of the root build item of the tree.  The
     <classname>BuildItem</classname> object contains the absolute
     path of the build item, the name of the containing build tree,
     its dependencies, and various other information from the
     <filename>Abuild.conf</filename> file.  Additionally, both
     objects store the tree's or item's <firstterm>backing
     depth</firstterm>, which is a count of the number of backing
     areas that had to be followed to resolve the item or tree.
     Although the backing depth is an integer value, nothing in
     &abuild; cares about the depth other than whether it is zero or
     not.  A backing depth of zero indicates that the tree or item
     appears locally in the current forest.
    </para>
    <para>
     When &abuild; starts up, it first locates the root of the local
     forest.  It does this by starting with the current directory and
     walking up the file system (toward the root) until it encounters
     an <filename>Abuild.conf</filename> that is not referenced as a
     child of the next higher <filename>Abuild.conf</filename>, if
     any.  When it finds such an <filename>Abuild.conf</filename>, it
     verifies that it is either a tree root build item or that is has
     only a <property>child-dirs</property> key.  In either case, it
     is the root of the forest.  Otherwise, it is an error, and
     &abuild; indicates that it is not able to find the forest root.
    </para>
    <para>
     Once &abuild; has found the root of the local build tree, it
     begins traversal.  The actual traversal logic is more complicated
     than what is described here because it contains code to recognize
     the &abuild; 1.0 build tree structure (with external directories
     and unnamed trees) as well as the simpler 1.1 format.  We omit
     those details from the description and refer you instead to
     comments in the code.  Continuing with our description of the 1.1
     traversal algorithm, we just read each build item's
     <filename>Abuild.conf</filename> doing a breadth-first traversal
     of the tree formed by following <property>child-dirs</property>
     keys.  If the child directory does not exist and the forest has a
     backing area, we ignore this condition.  This is what allows
     backed forests to be sparse.  Otherwise, if the directory exists,
     it must have an <filename>Abuild.conf</filename>, and no
     directory between the child directory and the parent may have
     <filename>Abuild.conf</filename> files (possible only if a
     <property>child-dirs</property> value has multiple path
     elements).
    </para>
    <para>
     After traversing the local forest, &abuild; traverses each
     backing area, creating a separate
     <classname>BuildForest</classname> object for each backing
     forest.  Finally, once &abuild; has traversed all the build items
     in all known forests, &abuild; creates a dependency graph of
     backing areas.  Then, working from the leaves of the dependency
     graph, it copies into the forest from the backing areas all the
     <classname>BuildTree</classname> and
     <classname>BuildItem</classname> objects of items and trees that
     do not appear locally and increments the backing depth of the
     local copies.  Items that are marked as deleted or that are in
     trees that are marked as deleted are not copied.  Also, trees
     that are marked as deleted are not copied.  This is where
     &abuild; notices if you have multiple backing areas and one of
     them backs to another.  In this case, &abuild; simply ignores the
     further back of the backing areas since it will already get
     copies of those items and trees through the closer backing area.
    </para>
    <para>
     Finally, after all the traversal is completed, &abuild; validates
     each forest, again starting with the furthest back forest and
     working toward the local forest.  Numerous validations are
     performed.  For details, please refer to the
     <function>validateForest</function> method in the &abuild; source
     code.
    </para>
   </sect1>
   <sect1 id="ref.compatibility">
    <title>Compatibility Framework</title>
    <para>
     Internally to &abuild;'s implementation, there is an object
     called <classname>CompatLevel</classname> that encapsulates the
     compatibility level for any given run of &abuild;.  The code
     itself is careful to wrap deprecated or backward compatibility
     code in checks to <function>compat_level.allow_1_0()</function>
     (or whatever version is appropriate).  This helps to keep
     backward compatibility code isolated and makes it easy to remove
     at some future time.  It also makes it relatively straightforward
     to implement being able to run &abuild; at a newer compatibility
     level.
    </para>
    <para>
     Many of &abuild;'s test suites run the same tests at different
     compatibility levels to ensure that, when compatibility code is
     not required, it doesn't get in the way.
    </para>
    <para>
     If one were to remove compatibility code from &abuild;, it would
     be necessary to check for variables that are no longer used
     because of the removal of compatibility support.  The intent is
     that all such variables are commented with something that
     contains the string <literal>compat</literal>.  Searching for
     <literal>compat</literal> should be an excellent starting point
     for locating all backward compatibility code.
    </para>
    <para>
     As of version 1.1, there is no backward compatibility code in the
     Groovy backend (since it is new in 1.1) or the old ant backend
     (since it is deprecated in 1.1).  When &abuild; invokes the make
     backend, it passes the compatibility level in a make variable.
     This makes it possible for various make code to be conditional
     upon whether a particular version is supported.  In versions
     after 1.1, if the need arises, a similar capability could easily
     be added to the Groovy backend by using the
     <classname>BuildArgs</classname> object to hold into this
     information.
    </para>
   </sect1>
   <sect1 id="ref.construction-of-build-sets">
    <title>Construction of the Build Set</title>
    <para>
     This section describes the process that &abuild; uses to
     construct the build set.  First, &abuild; creates a list of build
     items that directly match the criteria of the specified build
     set.  If <option>--only-with-traits</option> was specified, only
     build items that match the build set criteria and have all of the
     named traits are included.  This is considered the explicit build
     set.  In the absence of <option>--related-by-traits</option> or
     <option>--apply-target-to-deps</option>, this is the set of build
     items that will be built with any explicitly specified target.
    </para>
    <para>
     Once this is finished, expansion of the build set is performed
     based on dependencies, <property>build-also</property>
     specification, traits, or reverse dependencies.  Expansion is
     performed in two phases.  In the first phase of expansion, all
     dependencies of any item in the build set is added to the build
     set, as are any item specified in any
     <property>build-also</property> key of any item's
     <filename>Abuild.conf</filename>.  In the second phase, the build
     set is additionally expanded based on traits or reverse
     dependencies.  Specifically, if &abuild; was invoked with the
     <option>--with-rdeps</option> option, all direct or indirect
     <emphasis>reverse dependencies</emphasis> of every item in the
     build set are added to the build set.  Then, if
     <option>--related-by-traits</option> was specified, every build
     item that is related to an item in the set by the named traits is
     added to the build set.
    </para>
    <para>
     After the completion of phase 2, we repeat the expansion process
     until we go through an expansion pass that adds no items.  During
     repetitions of the expansion, the default behavior is that only
     phase 1 (dependencies and <property>build-also</property>) is
     repeated.  However, if <option>--repeat-expansion</option> was
     specified, then phase 2 is repeated as well.
    </para>
    <para>
     To understand the distinction between whether phase 2 of the
     expansion process is repeated, consider the following scenario.
     Suppose the original build set contains <classname>A</classname>
     and <classname>B</classname>, and that
     <classname>AC-test</classname> is declared as a tester of item
     <classname>A</classname>, which is in the build set, and also of
     item <classname>C</classname> which is not in the build set.  If
     we are adding items related by the <property>tester</property>
     trait, the <classname>AC-test</classname> build item will be
     added to the build set.  Assuming <classname>AC-test</classname>
     depends on <classname>C</classname>, then
     <classname>C</classname> will also be added to the build set
     since this is part of phase 1 of the expansion, which is always
     repeated until no new items are added.  Now if there is another
     build item called <classname>C-test</classname> that tests
     <classname>C</classname>, it will only be added to the build set
     if <option>--repeat-expansion</option> was specified since it
     test an item that wasn't an original member of the build set.
     <footnote>
      <para>
       In versions of &abuild; prior to 1.0.3, the second expansion
       phase was never repeated.  In version 1.0.3, it was always
       repeated.  When the <option>--with-rdeps</option> flag was
       introduced in &abuild; 1.1 and reverse dependency expansion was
       added to the second phase of expansion, the differences between
       repeating and not repeating the second phase became
       significant, so the <option>--repeat-expansion</option> option
       was added.
      </para>
     </footnote>
     When <option>--with-rdeps</option> is specified, the
     <option>--repeat-expansion</option> option is likely to have a
     much greater affect.  In fact, it will cause any build item that
     is reachable in the dependency graph from any initial build item
     to be added to the build set.  For many build trees, the
     combination of <option>--with-rdeps</option> and
     <option>--repeat-expansion</option> may end up causing every
     build item to be built.
     <footnote>
      <para>
       Formally, if the dependency graph is divided into independent
       sets, the combination of <option>--with-rdeps</option> and
       <option>--repeat-expansion</option> will cause inclusion of all
       build items in any independent set that contains any of the
       initial build set members.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.construction-of-build-graph">
    <title>Construction of the Build Graph</title>
    <para>
     During validation, &abuild; creates a
     <classname>DependencyGraph</classname> object to represent the
     space of build items and their dependencies.  It performs a
     topological sort on this graph to determine dependency order as
     well as to detect errors and cycles in the dependency graph.
     During the actual build, &abuild; needs to expand the dependency
     graph to include not just build items but build item/platform
     pairs.  Every &ldquo;instantiated&rdquo; build item has to exist
     on a particular platform.  We refer to this platform-aware
     dependency graph as the <firstterm>build graph</firstterm>.  The
     build graph can be inspected by running &abuild; with the
     <option>--dump-build-graph</option> command-line option.  For
     information about the format of this output, see <xref
     linkend="ref.build-graph-dtd"/>.
    </para>
    <sect2 id="ref.build-graph.validation">
     <title>Validation</title>
     <para>
      There are several steps required in order to determine exactly
      which build items are to be built on which platforms and which
      build item/platform pairs depend on which other pairs.  Before
      we do anything else, we need to perform several validations and
      computations.  The first of these is the determination of what
      platform types a build item belongs to.  For most build items,
      this is simply the list of platform types declared in the build
      item's <filename>Abuild.conf</filename> file.  For build items
      that have no build or interface files, there are no platform
      types declared.  In this case, the rules are different: if the
      build item declares any dependencies and all of its directly
      declared dependencies have identical platform type sets, then
      the build item inherits its platform types from the items it
      depends on.  Otherwise, it has no platform types and has the
      special target type <type>all</type>.  Note that this analysis
      is performed on build items in reverse dependency order (forward
      build order).  That way, every build item's platform types and
      target type has been determined before any items that depend on
      it are analyzed.
     </para>
     <para>
      Once we have determined the list of platform types for each
      build item, we can figure out which platforms a build item may
      be built on.  We refer to the list as the <firstterm>buildable
      platform list</firstterm>.  The buildable platform list for a
      build item is included in the <option>--dump-data</option>
      output (see <xref linkend="ref.dump-data"/>).  Note that this is
      generally a broader list than the list of platforms on which a
      given build item will actually be built; the actual build
      platform list is determined later in the build graph
      construction process.  For build items that have a specific
      target type and platform types, the list of buildable platforms
      is the union of all platforms supported on all platform types a
      build item has.  For items of target type <type>all</type>, we
      don't explicitly compute a buildable platform list.  These
      platforms are allowed to &ldquo;build&rdquo; on any platform
      since there are no actual build steps for such build items.
      (Remember that for a build item to have target type
      <type>all</type>, it must not have any declared platform types,
      and this in turn means that it must have no build or interface
      files.)
     </para>
     <para>
      When we compute the buildable platform lists, we also
      pre-initialize the build platform list (the list of platforms on
      which the item will actually be built) by including all
      buildable platforms that are selected by default on the basis of
      any platform selectors, as described in <xref
      linkend="ref.platform-selection"/>, that may be in effect.  For
      build items of target type <type>all</type>, we would not add
      any items to the list at this step.
     </para>
     <para>
      All of the above steps can be completed without knowing which
      build items are actually included in the build set.  These
      computations, in fact, are determined at startup for every build
      item in every known build tree regardless of whether the items
      are in the build set.
     </para>
     <para>
      The above validations are all completed before &abuild; starts
      to build.  If any errors are found in the above checks, &abuild;
      will report them and exit before it attempts to construct the
      build graph.  This means that the build graph construction
      itself can operate under the assumption that all of the above
      constraints have been satisfied.
     </para>
    </sect2>
    <sect2 id="ref.build-graph.construction">
     <title>Construction</title>
     <para>
      The next step is the construction of the actual build graph
      itself.  This is performed only when all previous validations
      have been performed successfully, and this step is also
      performed only for build items that are actually in the build
      set.  We present a prose description of the process here.  For a
      fully detailed description, please read the comments and code in
      <function>addItemToBuildGraph</function> in
      <filename>Abuild-build.cc</filename> (and in other places it
      references) in the &abuild; sources.
     </para>
     <para>
      We construct the build graph in reverse build order;
      <emphasis>i.e.</emphasis>, we start with least depended-on build
      item and end with the most depended-on build item.  That way,
      each item is added to the build graph before any item it depends
      on is added.  This is the opposite of the order in which we
      compute the platform types.  This makes it possible to modify an
      item's build platform list while processing items that depend on
      it.  Therefore, at the time a build item is added to the build
      graph, its build platform list will have been fully computed.
      The build platform list may be the initial list as computed
      during validation, or it may have been modified during the
      addition of its reverse dependencies to the build graph.  When a
      build item is added to the build graph, a node is added to the
      build graph for each platform on which the item is being built.
      Each node of the build graph therefore corresponds to a
      <firstterm>build item/platform pair</firstterm>.
      <footnote>
       <para>
        The actual build graph node is a string made up of three
        fields: a fixed-width numeric prefix representing the build
        tree, the item name, and the platform name.  Numeric prefixes
        for the trees are assigned based on a topological sort of the
        tree dependency graph.  When build graph nodes are sorted
        lexically, the result is a topologically sorted list of trees
        each containing a lexically sorted list of items in the tree.
        This is the mechanism that &abuild; uses to build items in
        less dependent trees before items in more dependent trees.
       </para>
      </footnote>
     </para>
     <para>
      Then, for each direct dependency, we determine which instance of
      it (which of its platforms) we will depend on for each of our
      platforms.  If the dependency in question is declared with a
      platform selector, we pick the best platform from among the
      dependency's buildable platform list that satisfies the platform
      selector and make this the <firstterm>override
      platform</firstterm>.  If there are no matches, it is an error.
      If an override platform is selected, it applies to this
      dependency for all instances of the current item.
     </para>
     <para>
      Next, still processing an individual dependency, we iterate
      through the item's list of build platforms to decide which of
      the dependency's platforms each instance will depend on.  We
      refer to this as the dependency platform.  If we previously
      computed an override platform for this dependency, we just use
      that as the dependency platform.  Otherwise, we pick the best
      match from among the dependency's buildable platform list.  If
      the dependency is type <type>all</type>, it can be
      &ldquo;built&rdquo; on any platform, so the dependency platform
      is the current build platform of the item.  If the dependency is
      actually buildable on the exact platform that we are
      considering, then it is the best match and the dependency
      platform is the current platform.  Otherwise, we have to search
      for a platform from a compatible platform type.  To do this, we
      determine the platform type that contains the current platform
      and then get a list of compatible platform types (as discussed
      in <xref linkend="ref.dependency-platform-compatibility"/>) in
      order of preference.  Then we iterate through this list until we
      find a platform type that is in the dependency's list of
      platform types.  Once we have identified this type, we find the
      best matching platform in that type and use that as the
      dependency platform.  The best matching platform will be first
      selected platform, or if no platforms are selected, then it will
      be the first unselected platform.  If no platforms are
      available, it is an error.
     </para>
     <para>
      If we have successfully determined a dependency platform from
      among the dependency's buildable platform list, we next add that
      to the dependency's actual build platform list if it's not
      already there.  This is the mechanism by which as-needed
      platform selection occurs.  An example of this is presented in
      <xref linkend="ref.example.cross-platform-dependency"/>.  So if
      item <classname>A</classname> on <type>p1</type> wants item
      <classname>B</classname> on <type>p2</type>, then item
      <classname>B</classname> will be built on <type>p2</type> even
      if <type>p2</type> would not have been selected to build for
      <classname>B</classname> based on platform selectors.  There are
      many ways in which this can happen including
      <classname>B</classname> being in a different build tree with
      different plugins or <classname>A</classname> using a
      platform-specific dependency to depend on
      <classname>B</classname>.
     </para>
    </sect2>
    <sect2 id="ref.build-graph.implications">
     <title>Implications</title>
     <para>
      Even if the exact steps of constructing the build graph are
      involved, there are some implications that are worth separate
      discussion.  Specifically, a build item of target type
      <type>all</type> may depend on any build item, and any build
      item may depend on an item of target type <type>all</type>.  For
      other build items, if a build item depends on another build item
      and declares the dependency with a
      <option>-platform=<replaceable>selector</replaceable></option>
      option, the dependency must have the platform type mentioned in
      the platform selector.  If a build item depends on another item
      without a platform-specific dependency, the dependency must be
      buildable on at least one platform type that is compatible with
      (or exactly matches) each platform type of the depending build
      item.  Since all platform types are compatible with
      <type>indep</type>, this means that any build item may depend on
      any other build item whose target type is
      <type>platform-independent</type>.  (This was actually a special
      case prior to &abuild; 1.1.4, but now it falls out from the fact
      that <type>indep</type> is made the parent platform type of all
      platform types that don't declare a parent.)  For example, if
      <classname>A</classname> has platform types <type>X</type> and
      <type>Y</type> and depends on <classname>B</classname> which has
      types <type>X</type>, <type>Y</type>, and <type>Z</type>, this
      is okay because <classname>B</classname> has all of
      <classname>A</classname>'s platform types.  Likewise, if
      platform types <type>X</type> and <type>Y</type> both declared
      type <type>XY</type> as a parent and <classname>B</classname>
      has types <type>XY</type> and <type>Z</type>, that would also be
      fine since each of <classname>A</classname>'s types can be
      matched with at least one of <classname>B</classname>'s types.
      It would be an error if <classname>B</classname> depended on
      <classname>A</classname> in either case since the instances of
      <classname>B</classname> building for platform type
      <type>Z</type> would not be able to satisfy their dependences on
      <classname>A</classname> since it doesn't support that platform
      type or anything compatible with that platform type.
     </para>
     <para>
      Another important point involves the exact way in which we
      search for a compatible platform.  Note that we first search for
      a compatible platform type and, once we have found one, we pick
      the best platform in that type.  This is subtly different from
      picking the first matching platform from any compatible platform
      type.  To illustrate the difference, consider the case of
      <classname>A</classname>, which has platform type
      <type>X</type>, depending on <classname>B</classname>, which has
      platform types <type>Y</type> and <type>Z</type>, where
      <type>X</type> declares <type>Y</type> as a parent and
      <type>Y</type> declares <type>Z</type> as a parent.  In this
      case, <classname>A</classname> on <classname>X</classname> will
      always depend on <classname>B</classname> on
      <classname>Y</classname> even if <classname>Y</classname> has no
      platforms and <classname>Z</classname> does.  The reason for
      this is that platform types are static but platforms within
      types are influenced by the environment.  If <type>Y</type> has
      no platforms, this should result in a build error.  If we fell
      back to <classname>Z</classname>, instead the lack of platforms
      for <classname>Y</classname> would actually change the shape of
      the build graph, which goes against &abuild;'s design.  If it
      were specifically desired to fall back on one thing if something
      else weren't available, there are ways to make that happen
      (using autoconfiguration or other similar mechanisms) that don't
      require the actual build graph itself to change shape.
     </para>
     <para>
      There are also some implications of the way pass-through items
      (items of type <type>all</type>) ignore dependencies when no
      matching platform is available.  This is discussed in <xref
      linkend="ref.pass-through-dependencies"/>.  Specifically, if a
      pass-through item depends on multiple items of different types,
      it's possible for the pass-through to effectively connect one of
      its reverse dependencies to multiple of its forward
      dependencies.  So if <classname>A</classname> depends on
      <classname>P</classname> which depends on one item of type
      <type>indep</type> and one item of <classname>A</classname>'s
      platform type, <classname>A</classname> will end up with
      <emphasis>both</emphasis> of <classname>P</classname>'s
      dependencies in its dependency list.  This is a consequence of
      the fact that the dependency platform computation is performed
      separately for each build platform and for each dependency of a
      given item.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.interface-implementation">
    <title>Implementation of the &Abuild; Interface System</title>
    <para>
     Up to this point, we have pretended that when &abuild; builds an
     item, it recursively reads the interface files of all its
     dependencies.  Although this is the effect of what the interface
     system does, it is not exactly what happens.  In this section, we
     will explain what really happens.
    </para>
    <para>
     Internally, &abuild; implements an
     <classname>Interface</classname> object and an
     <classname>InterfaceParser</classname> object.  Each
     <classname>InterfaceParser</classname> instance contains one
     <classname>Interface</classname> object.  We use one
     <classname>InterfaceParser</classname> instance to load each
     <filename>Abuild.interface</filename> file and all of its
     <filename>after-build</filename> files.  The scope of
     <function>reset</function> and <function>reset-all</function>
     statements is the <classname>InterfaceParser</classname>
     instance.
    </para>
    <para>
     Internally, an <classname>Interface</classname> object maintains
     a list of variables, each of which has a declaration and a list
     of assignments.  Each declaration and assignment is marked with
     the file location (file name, line number, and column number) at
     which it appeared.  Additionally, assignment information includes
     any flag that the assignment may be conditional upon.  &Abuild;
     does not actually maintain the value of a variable.  It only
     maintains the list of assignments.  Values of variables are
     computed on the fly as they are needed.  For list variables, all
     assignment statements are maintained.  For scalar variables, we
     store first all fallback assignments in the opposite of the order
     in which they appeared (with later fallback assignments being
     pushed onto the beginning of the history), the one normal
     assignment (as more than one normal assignment is an error), and
     then all override assignments in the order in which they appear
     (with later assignments added to the end of the history).  When
     we perform a <function>reset</function> operation on an interface
     variable, we do not store the <function>reset</function>
     operation (other than to record that it happened for purposes of
     showing it in the <option>--dump-interfaces</option> output).
     Rather, we actually clear out the variable's assignment history.
     We discuss this further momentarily.
    </para>
    <para>
     When a build item or another <classname>Interface</classname>
     object attempts to retrieve the value of a variable, &abuild;
     determines what flags, if any, are in effect and filters out any
     assignments that are connected with flags that are not set.
     Then, for list variables, the results of each remaining
     assignment are appended or prepended to the list, depending upon
     whether the list was declared as <type>append</type> or
     <type>prepend</type>.  For scalar variables, only the last item
     in the assignment history is used.  In this way, if there were
     only fallback assignments, the first fallback assignment would be
     at the end of the list.  If there were any override assignments,
     the last override assignment would be at the end of the list.  If
     there were only normal assignments, the normal assignment would
     be there.  It is important that we maintain all of this
     information because we might filter out some assignments based on
     flags.  We discuss this in more depth below.
    </para>
    <para>
     One <classname>Interface</classname> object may
     <firstterm>import</firstterm> other
     <classname>Interface</classname> objects.  When one
     <classname>Interface</classname> object imports another, the
     object merges the imported object's variable history with its
     own.  Any declarations or assignments that are exactly duplicated
     (that is, they have the same file location as a previously seen
     operation) are ignored.  This is important since we may import
     the same interface file through more than one path.
    </para>
    <para>
     The import process is the only part of the interface system
     implementation that is affected by the scope of a variable
     (whether the variable is a normal recursive variable or was
     declared <type>non-recursive</type> or <type>local</type>).
     Specifically, when importing an interface, if the variable was
     declared as <type>local</type>, the declaration and assignments
     are both ignored by the import process.  If the variable was
     declared as <type>non-recursive</type>, the declaration is always
     imported, but only assignments that were made in the item that
     owns the interface are actually imported.  For example, suppose
     <filename>A</filename> imports <filename>B</filename>'s interface
     which in turn imports <filename>C</filename>'s interface.  In
     this case, <filename>A</filename> would not see the affect of any
     assignments to non-recursive variables that were made in
     <filename>C</filename> since it does not directly import
     <filename>C</filename>'s interface.  It would also not see
     declarations or local variable assignments to any local variables
     in either <filename>B</filename> or <filename>C</filename>.
    </para>
    <para>
     There is a subtle aspect of how <function>reset</function> works
     in connection with loading interfaces as a result of the fact
     that a <function>reset</function> actually clears the assignment
     history of a variable at the time of the reset operation rather
     than storing the <function>reset</function> as part of the
     history.  For example, suppose you have interfaces
     <classname>Q</classname> and <classname>R</classname> and that
     <classname>R</classname> imports <classname>Q</classname>,
     <classname>Q</classname> assigns to variable
     <varname>A</varname>, and <classname>R</classname> resets
     variable <varname>A</varname>.  If interface
     <classname>S</classname> imports just <classname>R</classname>,
     it will not see <classname>Q</classname>'s assignment to
     <varname>A</varname> because that assignment is not part of
     <classname>R</classname>.  On the other hand, if
     <classname>S</classname> imports both <classname>Q</classname>
     and <classname>R</classname> in any order, it
     <emphasis>will</emphasis> see <classname>Q</classname>'s
     assignment to <varname>A</varname>.  If the reset operation were
     actually part of the assignment history rather than being a local
     operation, then whether or not <classname>S</classname> saw
     <classname>Q</classname>'s assignment to <varname>A</varname>
     would be dependent upon the order in which
     <classname>S</classname> loaded <classname>Q</classname> and
     <classname>R</classname>.  For items that are not in each other's
     dependency chains, the order is not deterministic.  This could
     cause very strange side effects: if one build item depended on
     other, it could sometimes not see all of that item's interface
     because of some third item that did a reset.  Note also that
     &abuild; uses a single interface parser to load a given interface
     file and any after-build files, so a reset in an after-build
     actually does effectively remove the effect of any assignments to
     that variable in the file that loads it.  Since a reset in an
     after-build file is not visible to the item itself, this is a
     useful construct for clearing interface variables that a build
     item means to set for its own use but not for its dependencies.
     For an example of this construct, see <xref
     linkend="ref.example.opaque-wrapper"/>.
    </para>
    <para>
     When a variable assignment is prefixed by a
     <function>flag</function> statement, the assignment entry that
     goes into the variable's assignment history is associated with
     the name of the build item and the flag.  When a variable value
     is retrieved, &abuild; filters out any assignments that are
     marked with a flag that is not set.  This makes it possible for
     &abuild; to store exactly one representation of each interface
     object rather than having to keep track of different instances
     for each possible combination of flags.  It also makes it
     possible for different build items to actually see different
     results for the same interface objects depending upon what flags
     they are requesting.
    </para>
    <para>
     &Abuild; only turns on interface flags when it retrieves variable
     values for export into the automatically generated file used by
     the back end (the <firstterm>dynamic output file</firstterm>,
     first introduced in <xref
     linkend="ref.abuild-interface-functionality-overview"/>).  It
     does not have any flags set when it references variables inside
     of other <filename>Abuild.interface</filename> files.  For
     example, if <classname>A</classname> does this:

     <programlisting>declare X string
declare Y string
X = v1
flag f1 override X = v2
Y = $(X)
</programlisting>
     the value of <varname>Y</varname> will
     <emphasis>always</emphasis> be <literal>v1</literal> in every
     build item's dynamic output file regardless of whether or not
     that build item sets the <varname>f1</varname> flag in its
     dependency on <classname>A</classname>.  This is because that is
     the value that <varname>X</varname> had at the time when
     <varname>Y</varname> was assigned since the flag was not in
     effect during the parsing of the interface file.  The value of
     <varname>X</varname> in the dynamic output files
     <emphasis>will</emphasis> be dependent upon whether the flag is
     in effect for the dependency on <classname>A</classname> because
     &abuild; does set flags before generating the dynamic output
     files.  This makes sense when you consider that &abuild; reads
     each <filename>Abuild.interface</filename> file once for each
     platform and that values of variables are not computed until they
     are needed.
    </para>
   </sect1>
   <sect1 id="ref.interface-loading">
    <title>Loading &Abuild; Interfaces</title>
    <para>
     When &abuild; prepares to build, it creates the
     <varname>base</varname> <classname>Interface</classname> object
     by reading <filename>private/base.interface</filename> from the
     &abuild; distribution.  Then, for every item that is a plugin in
     any known build tree (remember: an item can be a plugin in one
     build tree but not in another because plugin status is not
     inherited through tree dependencies), &abuild; creates an
     <classname>InterfaceParser</classname> object, imports the base
     interface, and loads the plugin's
     <filename>plugin.interface</filename> file, if any.  Plugins'
     interface files are not allowed to have
     <function>after-build</function> files, so it is an error if any
     are declared.
    </para>
    <para>
     After this preparation has been done, &abuild; constructs the
     build graph (see <xref
     linkend="ref.construction-of-build-graph"/>.) and traverses the
     graph in dependency order to build each build item/platform pair.
     For each build item/platform pair, &abuild; creates an
     <classname>InterfaceParser</classname> object and retrieves the
     underlying <classname>Interface</classname> object.  Before
     loading that item's <filename>Abuild.interface</filename> file,
     if any, &abuild; first imports the base interface and the
     interfaces for any plugin that pertains to this build item.
     (These would be all items that were declared as plugins in the
     build item's home build tree.)  Then it imports the interfaces of
     all of its direct dependencies which, as nodes in the build
     graph, are actually build item/platform pairs.  Those interfaces,
     therefore, already include the interfaces of
     <emphasis>their</emphasis> direct dependencies, and so
     forth&mdash;this is how we achieve the effect of having each
     build item read the interfaces of its entire dependency chain.
    </para>
    <para>
     Once this has been done, &abuild; performs override assignments
     for all variables that are specific to the build item
     (<varname>ABUILD_THIS</varname>,
     <varname>ABUILD_OUTPUT_DIR</varname>, etc.) and then uses the
     <classname>InterfaceParser</classname> object to load the item's
     own <filename>Abuild.interface</filename> file.  At this point,
     the build item's interface is in the state required to build the
     item itself, so we perform the build.  If the build succeeds, we
     then see whether the <filename>Abuild.interface</filename> had
     any any <function>after-build</function> statements.  If so, we
     use the same <classname>InterfaceParser</classname> object to
     load those, verifying that each one has no
     <function>after-build</function> declarations of its own.  The
     resulting <classname>Interface</classname> object is then stored
     with the build item by platform so that it can be imported by
     items that depend on it.
    </para>
   </sect1>
   <sect1 id="ref.parameter-blocks-implementation">
    <title>Parameter Block Implementation</title>
    <para>
     The <function>parameters</function> function in the binding for
     scripts loaded by &abuild;'s Groovy backend is actually a closure
     returned by <function>ParameterHelper.createClosure</function>.
     This function takes a closure as an argument.  In order to make
     things that look like assignments inside that closure modify
     &abuild; parameters, the <function>parameters</function> call
     changes the delegate of the closure to an instance of
     <function>ParameterHelper</function> helper class constructed
     with a reference to the <varname>abuild</varname> object, an
     instance of <classname>BuildState</classname>.  Within
     <classname>ParameterHelper</classname>, the
     <function>get</function>, <function>set</function>, and
     <function>leftshift</function> methods are overridden to result
     in fields being translated into
     <classname>ParameterHelper</classname> objects which, when
     assigned to or appended to, relay the action through appropriate
     calls in <classname>BuildState</classname>, which implements the
     <classname>Parameterized</classname> interface.  The code is
     relatively small.  For additional details, please find
     <filename>ParameterHelper.groovy</filename> and
     <filename>Parameterized.groovy</filename> in &abuild;'s source
     code and look at the <filename>parameter-helper</filename> test
     suite.
    </para>
   </sect1>
 </chapter>
 </part>
 <part id="ref.part4" label="IV">
  <title>Appendices</title>
  <appendix id="ref.release-notes">
   <title>Release Notes</title>
   <para>
    This table includes a list of user-visible changes or changes to
    the documentation broken down by the specific release in which
    they were entered.  This can help get you &ldquo;caught up&rdquo;
    if you are upgrading from an older release.
   </para>
   <note>
    <para>
     If you are interested in seeing a summary of all the changes made
     between versions 1.0 and 1.1 of &abuild;, please refer to <xref
     linkend="ref.changes-in-1.1"/>.  You can also get this
     information from the release notes, but the information is
     presented there in a more compact and organized fashion.
    </para>
   </note>
   <variablelist>
<!-- template for release notes

    <varlistentry>
     <term>VERSION: DATE</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Deprecated Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           ...
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         HEADING
        </para>
        <itemizedlist>
         <listitem>
          <para>
           LIST ITEM
          </para>
         </listitem>
         <listitem>
          <para>
           LIST ITEM
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         HEADING
        </para>
        <itemizedlist>
         <listitem>
          <para>
           LIST ITEM
          </para>
         </listitem>
         <listitem>
          <para>
           LIST ITEM
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>

 end template -->
    <varlistentry>
     <term>1.1.6: June 30, 2011</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The <command>verify-compiler</command> command used for
           testing your own compiler plugins did not work with nested
           platform types.  Nested platform types were added to abuild
           in version 1.1.5, and compiler plugins worked with them; it
           was only the <command>verify-compiler</command> command
           itself that was broken.
          </para>
         </listitem>
         <listitem>
          <para>
           When using qtest, the <command>test-only</command> target
           no longer depends on the <command>all</command> target.
          </para>
         </listitem>
         <listitem>
          <para>
           When dependencies are duplicated and platform
           specifications are associated with at least one of the
           dependencies, it is reported as an error.  In the past, the
           last platform specifier given would silently be used over
           others, which could lead people to a false sense of
           security if they were trying to declare a dependency on two
           different platform types.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Enhancements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Duplicated dependencies and duplicated tree dependencies
           are now reported as warnings.
          </para>
         </listitem>
         <listitem>
          <para>
           New variables <varname>ABUILD_TRAITS</varname> and
           <varname>abuild.traits</varname> are available to make and
           groovy (respectively) backends that indicate which traits
           are declared for the current build item.
          </para>
         </listitem>
         <listitem>
          <para>
           A new interface variable,
           <varname>SYSTEM_INCLUDES</varname> has been added.  For
           compilers that support it, any include directory that
           starts with any of the values in SYSTEM_INCLUDES will be
           specified to compiler with a flag that indicates that it is
           a system include directory.  For details, see <xref
           linkend="ref.interface.object-code"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.5: February 18, 2011</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Enhancements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           When &abuild; is run with the <option>-k</option> flag, the
           condition of a particular item not being able to be built
           on a particular platform because a dependency can't be
           built on a compatible platform now causes a failure of only
           that item on that platform rather than causing a failure of
           the entire build.
          </para>
         </listitem>
         <listitem>
          <para>
           Platform types may now have parents, which makes it
           possible to make some platform types specializations of
           other platform types.  This is discussed in <xref
           linkend="ref.dependency-platform-compatibility"/>.  Three
           sections of the documentation have been significantly
           updated based on this change: <xref
           linkend="ref.cross-platform-support"/>, <xref
           linkend="ref.adding-platform-types"/>, and <xref
           linkend="ref.construction-of-build-graph"/>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <type>skip</type> platform selector may now be used
           without a platform type qualifier to prevent default
           selection of any platform in any object-code platform type.
           See <xref linkend="ref.platform-selection"/> for details.
          </para>
         </listitem>
         <listitem>
          <para>
           The <property>build-also</property> key has been enhanced
           to allow specification of trees to build in addition to
           items.  It also allows options to be added to the
           <property>build-also</property> items to further refine
           what is built.  The result is that anything can be built
           from the command-line using build sets (except for the
           regular expression pattern build set), and more, can now be
           specified in a <property>build-also</property> key.  This
           enables much greater flexibility in creating project-level
           top-level build items.  For details, see <xref
           linkend="ref.build-also"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Miscellaneous Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Minor tweaks were made to &abuild;'s code and test suite to
           enable it to be built with Visual C++ 2010 and boost 1.43.
          </para>
         </listitem>
         <listitem>
          <para>
           The embedded version of Groovy has been updated to 1.7.8.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           A bug to the groovy backend that prevented relative
           directories from working properly when assigned to
           java.dir.src and similar variables has been fixed.  Thanks
           to Brian Reid for the report, test case, and proper
           diagnosis for the problem.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.4: February 17, 2011</term>
     <listitem>
      <para>
       This release was not made publicly.  It was basically what
       1.1.5 is except that it had a logic error that rendered it
       inoperative under certain conditions.  The problem was caught
       moments after internal release but prior to public release.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.3: October 1, 2010</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Output Capture
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; is now able to capture the output of builds and
           associate each line of output with the build item that
           produced it.  For additional details, please see <xref
           linkend="ref.output-processing"/>.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to have &abuild; prefix every line of
           normal output and/or every line of error output with fixed
           prefixes.  For details, see <xref
           linkend="ref.output-processing"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           File-specific variables for <varname>XCPPFLAGS</varname>,
           <varname>XCFLAGS</varname>, and
           <varname>XCXXFLAGS</varname> were referenced in a manner
           that prevented them from being properly expanded.  They are
           now properly expanded, so their values may include
           references to other variables.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Miscellaneous Enhancements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The <command>codegen-wrapper</command> command now accepts
           the <option>--normalize-line-endings</option> flag, which
           tells it to disregard differences in line endings when
           checking cached files to see whether their sources have
           changed.  Thanks to Jeremy Trimble for the suggestion.
          </para>
         </listitem>
         <listitem>
          <para>
           When a platform plugin's <command>list_platforms</command>
           script had Windows-style line endings, &abuild; (or, more
           accurately, the underlying system) would produce a
           confusing error message when trying to execute the script.
           On non-Windows systems, &abuild; now explicitly calls your
           attention to the incorrect line endings if
           <command>list_platforms</command> fails.
          </para>
         </listitem>
         <listitem>
          <para>
           The first line of output produced by the processing of any
           build item now always includes an indication of the build
           item name and output directory.  In prior versions, there
           were certain rare instances in which this would not
           happen.  For example, if an interface-only build item
           depended on two other items whose
           <filename>Abuild.interface</filename> files declared
           conflicting variables, &abuild; would complain about the
           conflict and indicate where it occurred, but it would not
           provide any hint as to what build item caused the two
           interface files to be loaded together.  Now &abuild; will
           always indicate which build item is responsible for causing
           the problem to be detected.
          </para>
         </listitem>
         <listitem>
          <para>
           When a platform selector specifies a platform type,
           platform, compiler, or option specification that doesn't
           match any items anywhere in the entire forest, &abuild; now
           reports that as an error.  It remains (and must remain)
           perfectly normal for platform selectors to apply to only a
           subset of the trees or items in a forest since most plugins
           only apply to subsets of the forest.  The previous behavior
           of ignoring invalid platform types in platform selectors
           was intended to allow the same platform selectors to work
           across multiple forests, but in practice, having &abuild;
           tell you about potential typos in platform selectors is
           much more important functionality, and it's not really
           practical to use the same platform selectors across
           multiple forests in general anyway.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Documentation Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           New help topics, <filename>make</filename> and
           <filename>groovy</filename>, provide brief reminders of
           things you can do in <filename>Abuild.mk</filename> and
           <filename>Abuild.groovy</filename> files or local rules
           files that they reference.
          </para>
         </listitem>
         <listitem>
          <para>
           Fix errors in documentation for global plugins and platform
           selectors.
          </para>
         </listitem>
         <listitem>
          <para>
           Create new section on capturing and parsing &abuild;'s
           output.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.2: April 16, 2010</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Java Backend Implementation Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           A minor improvement has been made to how abuild
           communicates with its java backends.  This is not a
           user-visible change, but should eliminate any possibility
           of protocol errors between abuild and its backend.  This
           problem has never been reported in production, but there
           was a race condition under which it was possible.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; invokes the JVM that runs the Java backends with a
           parameter that sets the maximum PermGen space to 200
           megabytes, overriding the default of 64 megabytes.  This
           should hopefully eliminate the out of memory problems that
           are sometimes encountered with large builds.
          </para>
         </listitem>
         <listitem>
          <para>
           New command line arguments <option>--jvm-append-args
           ... --end-jvm-args</option> and <option>--jvm-replace-args
           ... --end-jvm-args</option> have been added to provide
           finer control over how the JVM that runs &abuild;'s java
           backends is invoked.  These options are intended for use in
           debugging &abuild;.  If you have to use them to make your
           build work, you should submit a bug report with the
           details.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.1: March 1, 2010</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The Groovy-based Java backend was separating elements of
           the manifest classpath with the path separator rather than
           a space character.  Thanks to Brian Reid for the fix.
          </para>
         </listitem>
         <listitem>
          <para>
           Fix threading error in the Groovy backend that could, on
           very rare occasion, cause a crash with multithreaded
           builds.  Thanks to Katie Outram for observing and reporting
           the problem.
          </para>
         </listitem>
         <listitem>
          <para>
           The Groovy backend was not including the
           <filename>classes</filename> directory in the compile-time
           classpath.  This prevented java and groovy compiles in the
           same build item from being able to see each other's
           classes.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Other Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           For compatibility with &abuild; 1.0 and to reduce warnings
           with ant version 1.8.0, the Groovy backend sets
           <option>includeantruntime</option> to
           <option>false</option> by default in the
           <command>javac</command> task.  This can be overridden by
           setting the <varname>java.includeAntRuntime</varname>
           parameter in <filename>Abuild.groovy</filename>.
          </para>
         </listitem>
         <listitem>
          <para>
           Minor fixes were made to &abuild;'s ant backend to make it
           work properly with ant version 1.8.0.  Due to a bug in ant,
           &abuild;'s test suite may fail in spite of proper
           operation.  For details, please see <ulink
           url="https://issues.apache.org/bugzilla/show_bug.cgi?id=48746">ant
           bug 48746</ulink> for details.
          </para>
         </listitem>
         <listitem>
          <para>
           Minor fixes were made to &abuild;'s build so that it works
           properly on systems that require special arguments to use
           pthread.
          </para>
         </listitem>
         <listitem>
          <para>
           A new build set <option>descdeptrees</option> has been
           added.  This is the intersection of <option>desc</option>
           and <option>deptrees</option>.  It does what
           <option>desc</option> did in &abuild; 1.0 and was added
           just so that there was a 1.1 equivalent to &abuild; 1.0's
           <option>desc</option> build set.  Most users will never
           need to use this build set.
          </para>
         </listitem>
         <listitem>
          <para>
           Environment variable references in interface files may now
           be specified with defaults.  To do this, use
           <varname>$(ENV:VARIABLE:default-value)</varname>.  The
           <replaceable>default-value</replaceable> portion of the
           variable reference may not contain spaces or parentheses.
          </para>
         </listitem>
         <listitem>
          <para>
           Command line parameters may now also be referenced from
           interface files.  To do this, use
           <varname>$(PARAM:PARAMETER)</varname> or
           <varname>$(PARAM:PARAMETER:default-value)</varname>.  The
           <replaceable>default-value</replaceable> portion of the
           variable reference may not contain spaces or parentheses.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.0: December 7, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Miscellaneous Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; version 1.1.0 runs at compatibility level 1.1 by
           default.  You can still turn on backward compatibility with
           1.0 by running &abuild; with the
           <option>--compat-level=1.0</option> flag or by setting that
           <envar>ABUILD_COMPAT_LEVEL</envar> environment variable,
           though it is recommended that you do this only while
           upgrading trees to avoid accidentally re-introducing
           deprecated features.  Also, &abuild; will often be able to
           give a clearer error message with backward compatibility
           mode turned off.
          </para>
         </listitem>
         <listitem>
          <para>
           The embedded version of Groovy has been updated to 1.6.7.
          </para>
         </listitem>
         <listitem>
          <para>
           The <command>verify-compiler</command> command now accepts
           the <option>--cross</option> option to better support cross
           compilers that are in the <type>native</type> platform
           type.  See <xref linkend="ref.adding-toolchains"/> for a
           discussion.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
      <itemizedlist>
       <listitem>
        <para>
         Usability Improvements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           When error messages are tied to a file but not to a
           specific line in the file, the error message now assumes
           the line number &ldquo;1&rdquo; rather than not outputting
           a line number.  This makes tools like emacs, vim, or
           eclipse that can automatically take users to the error
           location more likely to handle those conditions.
          </para>
         </listitem>
         <listitem>
          <para>
           The format of the build duration has been changed to
           something that is not mistakenly interpreted as an error
           message by <application>vim</application>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
      <itemizedlist>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Initialize ant <classname>Project</classname> properly so
           that tasks using the deprecated xml-based ant framework can
           properly access <classname>System.in</classname>.
          </para>
         </listitem>
         <listitem>
          <para>
           Tighten up the logic for detecting tree roots in partially
           upgraded build trees.  This reduces the number of false
           positives when running an upgrade process over an already
           upgraded forest, though it does not entirely eliminate
           them.  The upgrade caveats section of the documentation has
           also been clarified slightly.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.b6: November 10, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The implementation of global plugins has changed again.
           Now, instead of having items declare themselves to be
           global plugins, a tree can declare a plugin to be global
           for the forest by adding the <option>-global</option> flag
           to the plugin declaration in
           <filename>Abuild.conf</filename>.  This actually makes
           global plugins usable in a real setting.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
      <itemizedlist>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The logic to detect shadowed plugins has been corrected to
           eliminate false positives and to provide enough information
           to resolve the problem.  In many cases, multiple distinct
           error messages will be issued when a plugin is actually
           shadowed, but this is better than not having the required
           information to resolve the problem.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
      <itemizedlist>
       <listitem>
        <para>
         Minor Updates
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Parsing of interface files has improved slightly.  Some
           &abuild; reserved words are now valid on the right hand
           side of assignments without quoting, and handling of
           whitespace is more robust, including allowing lines to be
           split with continuation characters in some places where
           they could not previously be split.
          </para>
         </listitem>
         <listitem>
          <para>
           When an &abuild; 1.0-style
           <filename>Abuild.backing</filename> file is found in an
           otherwise upgraded area, a deprecation warning is given
           rather than telling the user to run the upgrade process.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.b5: October 28, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The <option>-optional</option> flag may follow a child
           directory in the <property>child-dirs</property> key in
           <filename>Abuild.conf</filename>.  In this case, &abuild;
           will not complain if the child directory is missing.  This
           can be especially useful for
           <filename>Abuild.conf</filename> files that may contain
           that are optional trees or optional dependencies.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Windows-related Enhancements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Both the mingw and msvc toolchains now create DLL file
           names that include the major version number of the library.
           The static library that goes with the DLL remains
           versionless so that linking works, but executables that use
           the DLL will expect its name to contain the version number.
           This is described in <xref
           linkend="ref.shared-libraries"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.b4: September 28, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The global tree dependency feature has been removed as
           there was no way to make its use practical.  As such,
           global plugins no longer have to be in trees declared as
           global tree dependencies.  Instead, &abuild; disregards
           tree dependency-based access checks when turning on global
           plugins.  To ensure build consistency when global plugins
           are used, &abuild; disallows use of global tree
           dependencies if any tree in the forest uses
           <property>external-dirs</property>.  Otherwise, a global
           plugin may not be in effect if a build were started in the
           root of an external tree from which the real forest root
           could not be determined.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Changes to Deprecated xml-based Ant Framework
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The file <filename>preplugin-ant.xml</filename> is now
           <emphasis>imported</emphasis> for each plugin prior to
           loading the local build file or running any targets.  This
           makes it possible for a plugin to override built-in tasks,
           set properties, and do other activities that would not be
           possible from inside of hooks.  This was introduced
           primarily to support static analyzers and similar tools
           that require replacing built-in tasks.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.b3: July 28, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Command-line Parsing Improvements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           When specifying build set options cases, later options now
           supersede earlier ones rather than contradicting them.
           This makes it possible to alias <command>abuild</command>
           to <command>abuild --no-deps</command>, <command>abuild
           --build=desc</command>, or other similar invocations to
           suit your preferences while still being able to get
           different behavior just by appending additional arguments
           on the command line.
          </para>
         </listitem>
         <listitem>
          <para>
           As a convenience, &abuild; now recognizes <command>abuild
           --build=<replaceable>set</replaceable> clean</command> as a
           synonym for <command>abuild
           --clean=<replaceable>set</replaceable></command>.  This
           means that if you have <command>abuild</command> aliased to
           <command>abuild --build=desc</command>, typing
           <command>abuild clean</command> will now have the effect of
           running <command>abuild --clean=desc</command>.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild;'s command-line parsing has been made more
           flexible.  For options with arguments,
           <option>--option=value</option> and <option>--option
           value</option> both work, among other possibilities.  In
           previous versions of &abuild;, there were inconsistencies
           in how options took arguments.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.b2: June 13, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Miscellaneous Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Reworked the mutex protection in main build loop slightly
           to remove all possibility of concurrent write access to
           shared data during a multithreaded build.  This appears to
           have removed a rarely encountered race condition in which
           &abuild; could crash while building multiple instances of
           the same build item on multiple platforms simultaneously in
           separate threads.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--dump-build-graph</option> option has been
           changed to output XML data and is now always included in
           the output when &abuild; is running in monitored mode.  A
           new directory, <filename>misc/xslt</filename> has been
           included in the &abuild; distribution that includes some
           sample XSL-T script that can process some of &abuild;'s XML
           output.  There are three scripts that generate
           <filename>dot</filename> output of various dependency
           graphs.  This output is intended to be used as input to the
           <command>dot</command> program, which is part of <ulink
           url="http://www.graphviz.org">graphviz</ulink>.  Thanks to
           Joe Davidson for the dot code and the idea of using
           graphviz to visualize the build graph.
          </para>
         </listitem>
         <listitem>
          <para>
           Moved reference DTDs from <filename>src</filename> to
           <filename>doc</filename> so that they're in the same place
           in the source and binary distributions.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.b1: May 22, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Version numbering
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The version numbering conventions for &abuild; have changed
           slightly such that the first 1.1 release will be called
           1.1.0 instead of just 1.1.  This makes the phrase
           &ldquo;&abuild; 1.1&rdquo; unambiguously refer to all 1.1.x
           releases rather than just the first 1.1 release, which will
           now be called 1.1.0.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Documentation Updates
        </para>
        <itemizedlist>
         <listitem>
          <para>
           There are no significant user-visible changes in
           functionality between the latest alpha release and this
           first beta release of version 1.1.  The principal change is
           that the documentation has been largely brought up to date.
           The documentation is still very rough and incomplete in
           several places, and it has not yet had a full proofreading
           pass.  However, in most cases, it should now accurately
           reflect &abuild; 1.1 functionality.  Additionally, many new
           sections have been added.  Of particular interest are <xref
           linkend="ref.changes-in-1.1"/> and <xref
           linkend="ref.upgrading-to-1.1"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Other Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           QTest-based test suites are now invoked using a custom
           <command>qtest</command> ant task from both the Groovy
           backend and the legacy ant backend.  This means that when
           qtest-based test suites are run on Windows from the
           legacy-based ant backend, it now works to have
           <command>qtest-driver</command> be a shell-script wrapper
           around the actual perl implementation.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a9: May 4, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Enhancements to gcc toolchain support
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The behavior of <varname>ABUILD_FORCE_32BIT</varname> has
           been expanded, and the variable
           <varname>ABUILD_FORCE_64BIT</varname> has been added.  If
           exactly one of these variables has the value
           &ldquo;<literal>1</literal>&rdquo;, the option
           <option>-m32</option> or <option>-m64</option>, as
           appropriate, will be added to all gcc compilation steps.
           Additionally, in some cases the CPU portion of the platform
           string may be changed.  This is a generalization of the
           behavior introduced in version 1.0.1, and also a change of
           the status of the <varname>ABUILD_FORCE_32BIT</varname>
           variable to &ldquo;supported&rdquo; instead of temporary,
           at least pending some better solution.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The <property>attributes</property> key in
           <filename>Abuild.conf</filename> may now have the value
           <property>serial</property> for any build item that is
           built with GNU Make (<emphasis>i.e.,</emphasis> any build
           item that has an <filename>Abuild.mk</filename> file).  In
           this case, &abuild; will never instruct make to build that
           item in parallel even if <option>--make-jobs</option> is
           specified.  This is useful for build items that, for
           whatever reason, do not build properly in parallel.  Many
           build items that use autoconf will benefit from setting
           this, as will builds that use other tools that create
           temporary files whose names may clash with other instances
           of themselves.
          </para>
         </listitem>
         <listitem>
          <para>
           The behavior of whether expansion by trait and reverse
           dependency is repeated has changed again.  Now, expansion
           by related traits or by reverse dependency is performed
           only once by default.  In order to have the expansion
           process repeated until no more build items are added,
           specify the new option <option>--repeat-expansion</option>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Groovy Framework Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The junit test target now accepts attributes that allow the
           <command>batchtest</command> task to be run in addition to
           or instead of the <command>test</command> task.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Fix bug that caused an assertion failure when platform
           selectors were used if there were any platform-specific
           dependencies on java build items.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a8: April 22, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Bug fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Various refinements have been made to &abuild;'s
           multithreaded building code, which should improve both
           performance and reliability of multithreaded builds.  This
           includes correction of a few possible race conditions,
           strengthening of multithreaded testing in the test suite,
           and correction of a long-standing problem that was visible
           only on Solaris but actually turned out to be present on
           all platforms.
          </para>
         </listitem>
         <listitem>
          <para>
           The java builder code has been corrected so that it invokes
           IBM's JDK according to its requirements.
          </para>
         </listitem>
         <listitem>
          <para>
           The built-in support for sun RPC's rpcgen has been fixed to
           avoid using a GNU-specific option to sed.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Building &abuild;
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; now uses a re-entrant scanner in the lexical
           portion of the interface parser, which should further
           simplify building &abuild;.  Additional notes have been
           added to <filename>src/README.build</filename> regarding
           this and other build-related issues.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a7: April 20, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Deprecated Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The interface variable <varname>ABUILD_THIS</varname> is no
           longer deprecated.  We can't really deprecate an interface
           variable because there's no way to detect or warn for the
           use of a specific variable in backend configuration files.
           People should use <varname>ABUILD_ITEM_NAME</varname>
           instead of <varname>ABUILD_THIS</varname>, but the
           <varname>ABUILD_THIS</varname> variable will stick around.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--ant</option> command line option, which had
           been removed in an earlier alpha release, has been
           restored, but it only supports arguments of the form
           <option>-Dprop=value</option>.  Using it will generate a
           deprecation warning and will point out the new syntax.
           This is to make it easier for users to discover the new way
           to pass parameters to builds and to avoid breaking some
           scripted builds.
          </para>
         </listitem>
         <listitem>
          <para>
           External directories crossing symbolic links is no longer
           an error condition.  Instead, this will generate a
           deprecation warning, and <command>abuild
           --upgrade-trees</command> will refuse to upgrade any build
           trees that have symbolically linked externals.  This change
           should make it easier for people to test &abuild; 1.1
           without having to make unwanted changes to their build
           areas, particularly when things outside of &abuild; may be
           relying on the symbolic links.  As allowing symbolically
           linked externals is just postponing the inevitable, people
           are still encouraged to avoid them.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Usability Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Add new flag <option>--find</option> that can be used to
           show the location of a build item or build tree.  Use
           <command>abuild --find
           <replaceable>item-name</replaceable></command> to show the
           location and containing tree name of a build item, and
           <command>abuild --find
           tree:<replaceable>tree-name</replaceable></command> to show
           the location of a tree name.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; is somewhat quieter with <option>--silent</option>
           than it used to be.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Older versions of &abuild; would allow assignment of
           multiple words to scalar interface variables.  This was
           never intended functionality, and only happened to work
           because of the syntax of make and ant.  With the Groovy
           backend, this actually causes a problem, so &abuild; no
           properly gives an error when multiple words are assigned to
           a scalar interface variable.  (Thanks to Brian Reid for
           noticing the problem.)
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         New Help System
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; has a new help system.  The new help system
           provides a more robust ways for help to be provided for
           built-in and user-provided toolchains and rules.  Pending
           full documentation, run <command>abuild --help
           help</command> for details.  For information on creating
           help files, see
           <filename>src/manual/pending.txt</filename>.  Help files
           have not yet been written for all built-in rules and
           toolchains, but this will be done prior to the release of
           &abuild; version 1.1.
          </para>
         </listitem>
         <listitem>
          <para>
           The targets <command>rules-help</command> and
           <command>interface-help</command> have been removed.  For
           the ant framework, the targets
           <command>properties-help</command> and
           <command>hooks-help</command> are still there since the new
           help system does not have any support for the ant backend.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Improved Code Generator Support
        </para>
        <itemizedlist>
         <listitem>
          <para>
           A new tool, <filename>util/codegen-wrapper</filename>, has
           been provided.  This tool can be used to wrap code
           generation that uses optional code generators.  It is
           invoked with a source directory (automatically supplied by
           abuild), a cache directory, a list of input files, a list
           of output files, and a command used to generate the output
           files.  It caches the generated output files and checksums
           of the input files.  If all input files have matching
           checksums and all output files are present in the cache,
           codegen-wrapper will copy the cached output files into the
           output directory.  Otherwise, it will run the command and
           then cache the output files and update the input file
           checksums.  Pending documentation of this tool, see
           <filename>src/qtest/abuild-misc/codegen-wrapper</filename>
           for an example of its use.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; uses <command>codegen-wrapper</command> in its own
           build.  As such, the <command>save-autos</command> target
           and all support for it have been removed from the build of
           &abuild; itself.  The &abuild; source, as distributed, now
           includes automatically generated scanners and parsers, so
           flex and bison are no longer needed to build it from the
           source distribution.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Backend Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Reverted earlier change to the order in which
           <filename>plugin.mk</filename> files are loaded relative to
           <filename>Abuild.mk</filename>.  As in &abuild; 1.0,
           &abuild; 1.1 now loads <filename>plugin.mk</filename> after
           loading <filename>Abuild.mk</filename>.  A new file,
           <filename>preplugin.mk</filename>, is now loaded before
           <filename>Abuild.mk</filename> to allow plugins to provide
           initialization that is run prior to parsing of the
           <filename>Abuild.mk</filename> file.  The previous change
           to loading order was an unnecessary non-backward-compatible
           change.
          </para>
         </listitem>
         <listitem>
          <para>
           To be consistent with the make backend, the file
           <filename>plugin.groovy</filename> is now loaded after
           <filename>Abuild.groovy</filename>, and the file
           <filename>preplugin.groovy</filename> has been provided for
           pre-plugin initialization.
          </para>
         </listitem>
         <listitem>
          <para>
           QTest support for both make and Groovy now exports the
           <varname>TC_SRCS</varname> variable automatically.
          </para>
         </listitem>
         <listitem>
          <para>
           Built-in flex and bison support have been expanded to use
           the <command>codegen-wrapper</command>.  The variables
           <varname>FLEX_CACHE</varname> and
           <varname>BISON_CACHE</varname> must be set to enable this.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a6: April 13, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Ant framework
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Reverting an earlier change, &abuild; will no longer import
           <filename>ant-hooks.xml</filename> or
           <filename>plugin-ant.xml</filename> files.  This
           enhancement to the ant framework had unintended side
           effects that broke some existing builds.  As the goal is to
           move from the ant framework to the Groovy framework, we
           wish to avoid any needless distractions caused by changes
           to the ant framework.  This means that it is once again no
           longer possible to add targets in hook files.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Both item dependencies and tree dependencies can be made
           optional by adding the <option>-optional</option> flag to
           them in <filename>Abuild.conf</filename>.  Optional
           dependencies are ignored if the items referenced do not
           exist.  For details, see
           <filename>src/manual/pending.txt</filename>.
          </para>
         </listitem>
         <listitem>
          <para>
           New command-line argument <option>--with-rdeps</option>
           causes expansion of the build set to include reverse
           dependencies of all items in the build set.  Running
           <command>abuild --with-rdeps</command> in a build item's
           directory would cause all items that depend on it, directly
           or indirectly, to be built.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Visual C++ Toolchain Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           New make variables have been added for increasing the
           flexibility of configuring Visual C++.  See <xref
           linkend="ref.msvc"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Building &Abuild;
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; does a better job of detecting the appropriate
           libraries for networking, threading, and boost.  In
           particular, when using a custom installation of boost, it
           is necessary only to set <varname>BOOST_TOP</varname> to
           the location of the boost installation.  &Abuild;'s build
           will automatically figure out includes, library paths,
           preprocessor settings, and library naming conventions.  For
           details, see <filename>src/README.build</filename>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a5: April 7, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Non-compatible changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Absolute path externals are no longer supported.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--winpath</option> option to externals has been
           removed.  Without absolute path externals, it is no longer
           needed.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Note: in a later release, this was changed to a
           warning.</emphasis> Externals may no longer be symbolic
           links nor may they cross symbolic links.  If you were
           relying on symbolically linked externals before, you can
           instead create dummy directories with
           <filename>Abuild.backing</filename> files or with their own
           externals pointing to the real location.
          </para>
         </listitem>
         <listitem>
          <para>
           Read-only externals are no longer supported.  Use of the
           <option>-ro</option> flag generates a deprecation warning
           and is ignored.  Instead, if you need to make parts of your
           build tree read-only, use <option>--ro-path</option> or
           <option>--rw-path</option> (described below).  This gives
           you much greater and more precise control over what is
           read-only than read-only externals did.
          </para>
         </listitem>
         <listitem>
          <para>
           Child directories (specified with
           <property>child-dirs</property>) may no longer be nor may
           they cross symbolic links.  Most likely, this would not
           have worked in previous versions either, but &abuild; now
           specifically checks for this case.
          </para>
         </listitem>
         <listitem>
          <para>
           When <property>parent-dir</property> appears, it must point
           up, and <property>child-dirs</property> values must point
           down in the file system.  &ldquo;Interleaved&rdquo; build
           items are no longer permitted.  There must be no
           <filename>Abuild.conf</filename> files in any directories
           between a parent directory and its child build items.  In
           practice, the chances of ever finding a build tree that
           doesn't already obey these restrictions are very low, and
           any configuration that fails to follow these guidelines
           would have been very confusing, so this change is not
           likely to be noticed.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Deprecated Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Use of read-only externals generates a deprecation warning,
           but in fact, it's more than deprecated&mdash;it's entirely
           ignored.  The deprecation warning indicates that use of
           <option>-ro</option> could potentially become an error in a
           post-1.1 &abuild; release.
          </para>
         </listitem>
         <listitem>
          <para>
           Use of <property>external-dirs</property> to point to a
           build tree that has been upgraded to use 1.1 syntax will
           generate a deprecation warning.
          </para>
         </listitem>
         <listitem>
          <para>
           Use of <property>this</property>,
           <property>deleted</property>, or
           <property>parent-dir</property> in
           <filename>Abuild.conf</filename>, or having a tree root
           that does not include the <property>tree-name</property>
           key will generate a single warning suggesting that you
           should upgrade your build trees using <command>abuild
           --upgrade-trees</command>.  The specific locations of the
           deprecated features is not reported.  This is to discourage
           attempts to manually upgrade trees.  The upgrade process is
           complex, and all the complexities are managed automatically
           by <command>abuild --upgrade-trees</command>.  In general,
           &abuild; tries to avoid suggesting that you run an upgrade
           if it concludes that the upgrade will not be able to do
           anything.  Detailed documentation of the upgrade process
           will be included in the manual prior to the final 1.1
           release.  In the interim, see
           <filename>src/manual/pending.txt</filename> in the source
           distribution.
          </para>
         </listitem>
         <listitem>
          <para>
           Use of <filename>Abuild.backing</filename> files below the
           root of the build forest (defined) below is deprecated.  A
           new syntax for <filename>Abuild.backing</filename> files
           has been introduced and is also described below.  Use of
           the old format is deprecated.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Note: <varname>ABUILD_THIS</varname> was removed
           from the deprecated list in a later release.</emphasis> The
           interface variable <varname>ABUILD_THIS</varname> is
           deprecated and has been replaced by
           <varname>ABUILD_ITEM_NAME</varname>.  Note that &abuild; is
           not able to detect use of <varname>$(ABUILD_THIS)</varname>
           in Makefile fragments.  It will, however, warn about them
           when they are used in <filename>Abuild.interface</filename>
           files.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Pending Documentation
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Documentation for significant new features that have not
           yet been incorporated into the manual now appear in the
           file <filename>src/manual/pending.txt</filename>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Groovy Framework Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Compiled rules files are now cached, resulting in a
           significant performance improvement.
          </para>
         </listitem>
         <listitem>
          <para>
           When the <filename>groovy</filename> rules are used, Groovy
           sources are now expected to be in
           <filename>src/groovy</filename> instead of
           <filename>src/java</filename>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <command>package-rar</command> target has been replaced
           with <command>package-high-level-archive</command>.
           Various parameter and attribute names have been updated for
           consistency.  The <filename>java</filename> rules should
           now be considered in a soft freeze for version 1.1.
           Non-compatible changes can still be made for cosmetic
           reasons or to fix minor problems, but the rules should be
           in pretty close to final form.  Generation of javadoc and
           junit testing may still change more significantly.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Compatibility Mode
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Compatibility level can be set using the
           <envar>ABUILD_COMPAT_LEVEL</envar> environment variable in
           addition to use the <option>--compat-level</option> command
           line argument.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         New Build Tree Structure
        </para>
        <itemizedlist>
         <listitem>
          <para>
           This version of &abuild; includes a new build tree
           structure.  The highlights of this structure are named
           build trees, name-based tree dependencies instead of
           externals, multiple backing areas, improved build ordering,
           and removal for the need of
           <property>parent-dir</property>.
          </para>
          <para>
           With the exception of the non-compatible changes listed
           above, &abuild; will continue to recognize the old build
           tree structure and will internally map it to the new
           structure by assigning randomly generated names to build
           trees.  If &abuild; finds deprecated 1.0 features while
           traversing the build tree, it will notify the user that the
           trees can be upgraded with the <command>abuild
           --upgrade-trees</command> command.  Needless to say, if you
           are trying to use the same build tree under both versions
           1.0 and 1.1 (during a transition period), you should hold
           off on performing your upgrades.  Upgraded trees will not
           be recognized by &abuild; 1.0.
          </para>
          <para>
           The way backing areas work has been significantly improved.
           As in the case of the new build tree structure, &abuild;
           will continue to recognize 1.0-style
           <filename>Abuild.backing</filename> files when running in
           1.0 compatibility mode (the default).
          </para>
          <para>
           For a brief summary of changes in the new build tree
           structure, please refer to <xref
           linkend="ref.new11.new-tree-structure"/>.
          </para>
         </listitem>
         <listitem>
          <para>
           New interface variables <varname>ABUILD_ITEM_NAME</varname>
           and <varname>ABUILD_TREE_NAME</varname> have been
           introduced.  These variables contain the value of the
           current build item name and its containing tree.  The
           <varname>ABUILD_ITEM_NAME</varname> variable replaces the
           deprecated <varname>ABUILD_THIS</varname> variable.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Command Invocation Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Build set <command>all</command> builds all items in all
           known trees as before, but with the new build structure,
           this may include trees that were not previously included.
           In particular, &abuild; now knows about all trees in the
           forest, not just those that are tree dependencies of the
           current build item.
          </para>
         </listitem>
         <listitem>
          <para>
           The new build set <command>deptrees</command> builds all
           items in the current tree and all its tree dependencies.
           It has the same semantics as <command>all</command> had in
           &abuild; 1.0, and does the same thing as
           <command>all</command> in 1.0-compatibility mode.
          </para>
         </listitem>
         <listitem>
          <para>
           New arguments <option>--ro-path</option> and
           <option>--rw-path</option> have been added.  These replace
           read-only externals as the way to make parts of the local
           build forest read-only.  See discussion in
           <filename>src/manual/pending.txt</filename> for details.
          </para>
         </listitem>
         <listitem>
          <para>
           New option <option>--no-deps</option> is described below.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Build Behavior Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           When &abuild; is run with no build set arguments,
           <option>--with-deps</option> is enabled by default.  In
           order to build a build item <emphasis>without</emphasis>
           its dependencies (effectively assuming that the
           dependencies are up to date), run &abuild; with the
           <option>--no-deps</option> option.
          </para>
         </listitem>
         <listitem>
          <para>
           Removed all <command>clean</command> targets previously
           provided by backends.  In older versions of &abuild;, the
           <command>clean</command> target was passed to the backend
           under the special case of &abuild; being invoked from
           inside the output directory.  Now &abuild; implements the
           <command>clean</command> target internally for that case.
           &Abuild; always has and continues to implement
           <command>clean</command> internally for invocations that
           are not in an output directory.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; always has and continues to guarantee that it will
           build all dependencies of an item before it builds the
           item.  Previous versions of &abuild; would rearrange an
           initial build that built all items alphabetically,
           deviating from that order only to satisfy dependencies.
           &Abuild; now uses, as an initial ordering, build items
           sorted alphabetically within trees, with trees sorted in
           dependency order.  In other words, if tree
           <filename>A</filename> declares a tree dependency on tree
           <filename>B</filename>, then &abuild; will build all items
           in <filename>A</filename> before building any build items
           in <filename>B</filename>.  As always, build ordering is
           considered an implementation detail that should not be
           relied upon.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Platform Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Platform-specific dependencies now obey user-supplied
           platform selectors.  The rationale for not doing this
           before was that the command-line and environment should not
           affect the shape of the build graph, but that's not really
           a good reason since this is a myth anyway.  People can
           always run with <option>DFLAGS=-g</option> or set an
           environment variable used by a specific platform plugin's
           <command>list_platforms</command> script to suppress the
           platform.  If a specific compiler or option is required, it
           can be specified explicitly with the platform-specifier in
           the dependency.
          </para>
          <para>
           To explicitly disregard user-supplied platform selectors,
           it is possible to specify "default" as the platform
           selector, as in

           <programlisting>deps: item -platform=platform-type:default
</programlisting>
          </para>
          <para>
           It is also possible to specify an explicitly empty option,
           as in

           <programlisting>deps: item -platform=platform-type:option=
</programlisting>
          </para>
          <para>
           Both the empty option and <type>default</type> platform
           selector are available on the command-line as well, making
           it possible to run

           <programlisting>abuild -p option=debug -p native:default
</programlisting>
           or

           <programlisting>abuild -p option=debug -p native:option=
</programlisting>
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; now passes information about the native platform
           to all <command>list_platforms</command> programs, which
           are supplied by plugins that are offering support for new
           compilers.  <command>list_platforms</command> is now
           invoked as follows:

           <programlisting>list_platforms [ --windows ] --native-data <replaceable>os</replaceable> <replaceable>cpu</replaceable> <replaceable>toolset</replaceable>
</programlisting>
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; now supports global plugins.  This is implemented
           through introduction of a new, general-purpose key in
           <filename>Abuild.conf</filename>:
           <property>attributes</property>.  (<emphasis>Note:
           implementation of this feature was changed in a subsequent
           release.</emphasis>) This key can be used to flag certain
           build items as having specific properties that &abuild;
           recognizes.  At present, only two attributes are
           recognized:
           <itemizedlist>
            <listitem>
             <para>
              <emphasis>Note: this feature was removed in a subsequent
              release.</emphasis>
              <property>global-tree-dep</property>: This attribute may
              be assigned to any root build item of an explicitly
              named tree.  Such a tree may not have any tree
              dependencies of its own and is implicitly treated as if
              it were declared as a tree dependency by all other
              trees.
             </para>
            </listitem>
            <listitem>
             <para>
              <emphasis>Note: this feature was changed in a subsequent
              release.</emphasis>
              <property>global-plugin</property>: This attribute may
              be assigned to any build item that otherwise meets the
              qualifications for being a plugin.  It must reside in a
              tree with the <property>global-tree-dep</property>
              attribute.  <emphasis>Note:
              <property>global-tree-dep</property> was removed in a
              later release.</emphasis> This item will then be treated
              as if it had been explicitly listed as a plugin for all
              build trees.  This is a very powerful feature which must
              used with care.  Good uses for it might include
              implementing project-wide checks, such as making sure
              appropriate environment variables are set or appropriate
              dependency rules are followed, or for adding new
              platforms or platform types that may be used by all
              build items in a forest.  Care should be taken to avoid
              introducing global plugins that wider consequences than
              you might initially expect.  Global plugins should
              generally be coded in such a way that their impact can
              be disabled in some way.
             </para>
            </listitem>
           </itemizedlist>
          </para>
         </listitem>
         <listitem>
          <para>
           Implemented <command>abuild --upgrade-trees</command>.  You
           should use this command to upgrade your build trees rather
           than attempting to upgrade your trees manually.  Although
           abuild will work fine with mixed 1.0/1.1 trees, you will
           get a lot more warnings and possibly incorrect results in
           some cases (though no such cases are known) if you
           partially upgrade your trees.  There is <emphasis>a
           lot</emphasis> to keep track of when upgrading your trees.
           You are much better off letting abuild do it for you.
           Documentation on the upgrade process, for the time being,
           can be found in
           <filename>src/manual/pending.txt</filename>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a4: March 19, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Deprecated Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           No features have been deprecated in this release.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Documentation Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Documentation for the Groovy framework has been moved to
           <filename>src/manual/groovy-framework.txt</filename>
           pending full inclusion in the manual.
          </para>
         </listitem>
         <listitem>
          <para>
           Java examples that are not specifically illustrating the
           ant framework have been converted to use the Groovy
           framework.  The rest have been moved into an ant-specific
           portion of the test suite.  The text remains in the manual,
           but the files are no longer included.  Prior to the release
           of version 1.1, new examples to illustrate the Groovy
           framework will be introduced, ant the ant framework will be
           mentioned briefly in an appendix.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Support
           <option>--compat-level=<replaceable>x.y</replaceable></option>.
           When specified, backward compatibility support is disabled
           for features that were deprecated at or before version
           <replaceable>x.y</replaceable>.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; now prints the total clock time that elapsed
           during a build right before it exits.  The time is printed
           in the form HH:MM:SS.
          </para>
         </listitem>
         <listitem>
          <para>
           In preparation for deprecation of
           <property>parent-dir</property>, the value of
           <property>parent-dir</property> is required to point up in
           the file system, and all values of
           <property>child-dirs</property> are required to point
           down.  Additionally, if either
           <property>parent-dir</property> or
           <property>child-dirs</property> reach more than one
           directory away, no <filename>Abuild.conf</filename> files
           are permitted in intervening directories.
          </para>
          <para>
           These changes, along with the existing check that an item's
           child's parent point back to the item, are sufficient to
           enable abuild to safely ignore the value of the
           <property>parent-dir</property> key.
          </para>
         </listitem>
         <listitem>
          <para>
           As an intermediate step toward adoption of the new
           traversal system, we now walk up the tree looking for an
           item that doesn't have us as its child when finding the top
           of the forest.  The old behavior was to follow
           <property>parent-dir</property>, which is now ignored.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a3: March 16, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Deprecated Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           No features have been deprecated in this release.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Changes to Groovy Framework
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Some default path names have changed.  See
           <filename>rules/java/_base.groovy</filename> for details.
           This will likely continue to change until the main
           <filename>java</filename> rules have been nailed down.
          </para>
         </listitem>
         <listitem>
          <para>
           Targets have been added for copying and signing JARs, and
           for creating RARs, WARs, and EARs.  The RAR target happens
           after copying and signing of jars.  There's nothing
           RAR-specific about it.  It could be generalized to create
           any kind of JAR that could contain other JARs.
          </para>
         </listitem>
         <listitem>
          <para>
           Support for JUnit-based tests have been added to the
           built-in <filename>java</filename> rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Calls to abuild.appendParameter will pre-initialize the
           parameter with the result of calling
           <function>resolve</function> on it.  This means that
           attempting to append to an interface variable will
           effectively copy the interface variable to a parameter and
           then append it.
          </para>
         </listitem>
         <listitem>
          <para>
           Variable-like constructs on the right-hand side of an
           assignment or left shift inside of
           <function>parameters</function> call are no longer
           automatically resolved as parameters.  You now must use
           <function>resolve</function> explicitly.  This is to reduce
           confusion that could step from the fact that you always had
           to do this for some cases, and that using a parameter in a
           context where it is not magically resolved would result in
           having a <classname>ParameterHelper</classname> object,
           which is not useful in itself.  This is a case of removing
           a little bit of convenience in a common case to avoid
           creating a very obscure error in a less common case.
           Although having to explicitly resolve variables on the
           right hand side of assignments is not &ldquo;normal&rdquo;
           in a programming language environment, it is similar to
           variable assignment in a properties file, shell script,
           make file, or even &abuild; interface file, which makes it
           consistent with the rest of &abuild;.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           It is now possible to declare local variables in an
           interface file.  Local variables are visible to the backend
           of the build item to which they belong, and their scope
           extends from the main <filename>Abuild.interface</filename>
           file to any after-build files, but nothing about them,
           including their declarations, is exported to depending
           build items.  This means that local variables with the same
           names may be used in multiple build items' interface
           files.  Declare local variables using the syntax
           <programlisting>declare <replaceable>variable</replaceable> local <replaceable>type</replaceable>[ = <replaceable>initialization</replaceable>]
</programlisting>
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a2: March 11, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Deprecated Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The following features, each of which is discussed
           elsewhere in these relates notes, have been deprecated in
           this version:
           <itemizedlist>
            <listitem>
             <para>
              <varname>LINK_SHLIBS</varname>.  No functionality
              changes have been introduced relative to version 1.0.3,
              but using <varname>LINK_SHLIBS</varname> now results in
              a deprecation warning.
             </para>
            </listitem>
           </itemizedlist>
          </para>
          <para>
           The following feature was listed as deprecated in 1.1.a1
           but is no longer deprecated:
           <itemizedlist>
            <listitem>
             <para>
              The <varname>abuild.hook-build-items</varname> is no
              longer deprecated since the <option>-with-rules</option>
              flag for dependencies as been removed in favor of a
              different solution that can't be applied to the
              <application>ant</application> backend.
             </para>
            </listitem>
           </itemizedlist>
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Changes to Groovy Framework
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The <filename>java</filename> rules have been completely
           rewritten.
          </para>
         </listitem>
         <listitem>
          <para>
           The <filename>src/TODO</filename> file remains the primary
           location of documentation of the Groovy framework while it
           is still in flux, so these notes contain only a very brief
           summary of changes.
          </para>
         </listitem>
         <listitem>
          <para>
           An improved syntax has been provided for setting
           parameters.  This takes advantage of Groovy's
           meta-programming capabilities to allow a closure passed to
           the <function>parameters</function> method to contain
           parameter settings that look like normal variable
           assignments.
          </para>
         </listitem>
         <listitem>
          <para>
           Parameter names have been changed to use camelCaps instead
           of dashed-components to make the syntax more natural when
           setting parameters from a closure.
          </para>
         </listitem>
         <listitem>
          <para>
           All <function>getVariable</function> methods have been
           replaced with calls to methods whose name start with
           <function>resolve</function>.
          </para>
         </listitem>
         <listitem>
          <para>
           There is now a <function>replaceClosures</function> method
           that allows closures for a target to be replaced rather
           than appended to.  This practice should generally be
           avoided, and seldom be necessary based on the way the
           default rule implementations work.  (You can already
           provide your own closures to run instead of the default
           ones.)
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Changes to <application>ant</application> framework
        </para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis>Note: this change was removed in a subsequent
           release.</emphasis> This change was actually introduced in
           version 1.1.a1.  &Abuild; now complains if the
           <filename>ant-hooks.xml</filename> file for a hook build
           item does not exist.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Changes to <application>make</application> Framework
        </para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis>Note: this change was reverted in a subsequent
           release.</emphasis> The order in which files are loaded by
           the <application>GNU Make</application> backend has been
           changed slightly.  <filename>plugin.mk</filename> files and
           the base rules (which load the compiler toolchain support
           files) are now loaded before
           <filename>Abuild.mk</filename>.  This makes it possible for
           <filename>Abuild.mk</filename> files to modify variables
           set in those places and also provides a mechanism for
           plugins and built-in rules to supply default values for
           parameters that can be referenced from
           <filename>Abuild.mk</filename>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The <option>-with-rules</option> option to the
           <property>deps</property> key in
           <filename>Abuild.conf</filename>, introduced in 1.1.a1, has
           been removed.  It didn't turn out to be a very good idea.
           Instead, a new, unified method for build items to provide
           rules has been added.  All build items, not just plugins,
           provide rules by creating a <filename>rules</filename>
           directory and putting a named rules file in a subdirectory
           named after the target type.  In addition, a subdirectory
           named <filename>all</filename> may be used to provide rules
           that are valid for all target types.
          </para>
          <para>
           As a result of this change, all uses of
           <varname>BUILD_ITEM_RULES</varname> and of
           <filename>Rules.mk</filename> are now deprecated.
           Additionally, since there is no facility to provide loading
           of named rules in the <application>ant</application>
           framework, use of <varname>abuild.hook-build-items</varname>
           is no longer deprecated (except in as much as the entire
           <application>ant</application> framework is deprecated).
          </para>
          <para>
           When build items want to use rules provided by another build
           item, they just place the name of the rules (without the
           <filename>.mk</filename> or <filename>.groovy</filename>
           suffix in <varname>RULES</varname> or
           <varname>abuild.rules</varname> just as they would for
           plugin or built-in rules.
          </para>
          <para>
           As part of this change, the <filename>make/rules</filename>
           and <filename>groovy/rules</filename> directories have been
           merged and placed in <filename>rules</filename> at the top
           of the &abuild; distribution.  Additionally, the
           <filename>empty</filename> rule sets for both Groovy and
           make have been moved into the <filename>rules/all</filename>
           directory.
          </para>
         </listitem>
         <listitem>
          <para>
           The interface system now supports
           <emphasis>non-recursive</emphasis> variables.  A variable
           can be declared non-recursive by putting the keyword
           <type>non-recursive</type> in the declaration after the
           variable name and before the type.
          </para>
          <para>
           When an interface variable is declared as non-recursive,
           only assignments from the item itself and its directly
           declared dependencies are effective.  Specifically, when
           importing an interface, only assignments from the item that
           owns the interface imported.  Since abuild imports
           interfaces of its direct dependencies, this causes the
           behavior of seeing only assignments in direct dependencies
           and in the item.  To avoid seeing assignments from the item
           itself, place those assignments in an after-build file.
          </para>
          <para>
           Non-recursive variables can be useful for carrying
           information for subsystems that handle recursive
           dependencies on their own.  Examples could include manifest
           classpaths or shared library information.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to initialize an interface variable at
           the time of declaration using the shorthand syntax

           <programlisting>declare <replaceable>variable</replaceable> <replaceable>type</replaceable> = <replaceable>initialization</replaceable>
</programlisting>
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.1.a1: February 20, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Deprecated Features
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Some features have been deprecated.  Deprecated features
           always result in a warning.  You can pass the
           <option>--deprecation-is-error</option> to &abuild; to
           cause it to treat use deprecated features as an error
           instead.
          </para>
          <para>
           The following features, each of which is discussed
           elsewhere in these relates notes, have been deprecated in
           this version:
           <itemizedlist>
            <listitem>
             <para>
              <varname>BUILD_ITEM_RULES</varname>
             </para>
            </listitem>
            <listitem>
             <para>
              <varname>abuild.hook-build-items</varname>
              (<emphasis>Note: removed from deprecated list in a
              subsequent release</emphasis>)
             </para>
            </listitem>
            <listitem>
             <para>
              <varname>abuild.use-local-hooks</varname>
             </para>
            </listitem>
           </itemizedlist>
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Major Enhancements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           A new <application>Groovy</application>-based backend has
           been added.  Although, like all backends, it could be used
           to build build items of any target type, it is primarily
           intended as a replacement for the <application>Apache
           Ant</application> backend.  This first alpha release of 1.1
           includes a rudimentary collection of rules for building
           Java and Groovy code currently called
           <filename>java_proto</filename>.  These rules may change in
           non-compatible ways throughout the 1.1 alpha testing
           period.  The <application>Groovy</application> backend is
           invoked through Java APIs.  A single instance of the Java
           Virtual Machine is shared for all Groovy-based builds.
          </para>
          <para>
           For now, documentation on the interface to the Groovy
           framework can be found in <filename>src/TODO</filename> in
           the abuild distribution.  It will be moved into the manual
           as it is stabilized.
          </para>
         </listitem>
         <listitem>
          <para>
           The same JVM that is used to run Groovy-based builds is now
           also used to invoke ant-based builds.  As such, &abuild;
           runs all ant builds from a single JVM and no longer invokes
           ant from the command line.  This can result in a noticeable
           performance improvement.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Licensing Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; itself remains under the terms of Version&nbsp;2
           of the Artistic license.  &Abuild; now also embeds the
           embeddable JAR from the Groovy distribution.  Groovy is
           distributed under the terms of the Apache License.  A
           <filename>NOTICE.txt</filename> file has been included in
           &abuild;'s source distribution in accordance with that
           license.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Changes to command-line syntax
        </para>
        <itemizedlist>
         <listitem>
          <para>
           The <option>--deprecation-is-error</option> option has been
           added.  When specified, deprecation is considered an error
           rather than a warning.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Note: a limited version of <option>--ant</option>
           was added back in a subsequent release.</emphasis> The
           <option>--ant</option> and
           <option>--no-abuild-logger</option> options are no longer
           supported since &abuild; now invokes ant through Java APIs.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; now recognizes arguments of the form
           <option><replaceable>variable</replaceable>=<replaceable>value</replaceable></option>
           as variable definitions.  Any such variable definitions are
           automatically passed to all backends.  This, rather than
           using <option>--make</option> or <option>--ant</option> is
           now the recommended way of overriding variables.  Any
           variables defined in this way are made available to the
           <application>ant</application> backend and to the ant
           project in the <application>Groovy</application> backend as
           properties, and to the GNU Make backend as variables passed
           on the command line.  They are also passed to the
           <application>Groovy</application> backend in a manner that
           causes them to override variable values that are set in
           other ways, as long as the documented interfaces are used
           for getting and setting variables.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--just-print</option>,
           <option>--dry-run</option>, and <option>--recon</option>
           options are no longer synonyms for <option>-n</option>.
           These are accepted as synonyms by GNU Make, which is why
           they were originally supported by &abuild; as well.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Core Functionality Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis>Note: this change was reverted in a subsequent
           release, and a different solution was implemented in its
           place.</emphasis> When declaring dependencies, a new flag
           <option>-with-rules</option> may be specified.  This causes
           the build item to load <filename>Rules.mk</filename>
           (make), <filename>ant-hooks.xml</filename> (ant), or
           <filename>Rules.groovy</filename> (Groovy).  This replaces
           the now deprecated <varname>BUILD_ITEM_RULES</varname> make
           variable and <varname>abuild.hook-build-items</varname> ant
           property.  This change means that there is now a unified
           mechanism for forcing build item-supplied rules to be run
           rather than having a separate mechanism for each backend.
           In some rare cases, it may be that a build file
           <emphasis>only</emphasis> has item-based rules.  In this
           case, you will have to create an empty build file (or one
           containing only comments) so that &abuild; will still know
           which backend to use for building the item.
          </para>
          <para>
           Since you can't declare a dependency on yourself, if you
           wish to use your own rules, you can specify
           <filename>Rules.mk</filename> in
           <varname>LOCAL_RULES</varname> (make) or
           <filename>ant-hooks.xml</filename> in
           <varname>abuild.local-buildfile</varname> (ant).
          </para>
         </listitem>
         <listitem>
          <para>
           When traversing a build tree with a backing area, &abuild;
           now accepts non-existent child directories without
           requiring a corresponding directory to exist in the
           backing area.  This check served no useful purpose, and it
           was removed in preparation for the upcoming revamping of
           how backing areas work.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>-n</option> is now supported for all the
           backends, not just make.  For the ant and Groovy backends,
           &abuild; doesn't actually invoke the backend but instead
           just prints some information on what targets would be run.
          </para>
         </listitem>
         <listitem>
          <para>
           Considerable additional information is output when &abuild;
           is run with <option>--verbose</option>.  In particular,
           there is much more information about how &abuild; starts up
           and invokes backends.  This should make it easier to solve
           certain types of configuration problems, such as &abuild;
           picking the wrong version of make.
          </para>
         </listitem>
         <listitem>
          <para>
           Although &abuild; still does not require
           <envar>JAVA_HOME</envar> or <envar>ANT_HOME</envar> to be
           set, it will start up slightly faster if they are set.  The
           reason for this is that &abuild; actually invokes
           <command>java</command> and <command>ant</command> to more
           reliably infer values for <envar>JAVA_HOME</envar> and
           <envar>ANT_HOME</envar> if they are not already set.
          </para>
         </listitem>
         <listitem>
          <para>
           Build item names are no longer permitted to start with the
           &ldquo;-&rdquo; character.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Changes to <application>ant</application> framework
        </para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis>Note: this change was reverted in a subsequent
           release.</emphasis> All files from which hooks may be
           loaded, including hook build items'
           <filename>ant-hooks.xml</filename> files, plugins'
           <filename>plugin-ant.xml</filename> files, and any file
           specified as <varname>abuild.local-buildfile</varname> are
           now <emphasis>imported</emphasis>.  Before, plugin and
           build item-supplied files were used only for loading hooks.
           This means that it is possible to add new targets in
           plugins and hook build items.  Some caveats are described
           in the documentation for this feature.  Most notably, when
           multiple instances of a new target are imported, only one
           will actually be used.  The recommended practice is for
           newly defined targets to do nothing other than call
           <command>run-hooks</command> to run a hook of the same
           name.
          </para>
         </listitem>
         <listitem>
          <para>
           The property <varname>abuild.use-local-hooks</varname> is
           no longer used.  Instead, the ant backend always behaves as
           if it were set, meaning that it always uses the local build
           file for hooks.  People were in the habit of setting the
           now deprecated <varname>abuild.hook-build-items</varname>
           to contain the current build item and writing hooks that
           apply only to the local build item.  This functionality is
           intended to be offered by local build files, and that
           mechanism should be used instead.  If you have a build item
           that offers hooks for others and also wants to use them for
           itself, it can set
           <varname>abuild.local-buildfile</varname> to
           <filename>ant-hooks.xml</filename> or import
           <filename>ant-hooks.xml</filename> from its existing local
           build file.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Note: this change was reverted in a subsequent
           release.</emphasis> &Abuild; now loads the
           <command>groovy</command> ant task.  Parts of the &abuild;
           ant framework use this task to embed Groovy code.  It is
           recommended that you switch to the
           <application>groovy</application> backend rather than using
           this task, but embedding Groovy code in your ant files may
           help with a transition to the new backend.
          </para>
         </listitem>
         <listitem>
          <para>
           Since &abuild; no longer invokes ant from the command line,
           the <option>--ant</option> option has been removed.
           <emphasis>Note: a limited version of <option>--ant</option>
           was added back in a subsequent release.</emphasis> As such,
           it is no longer possible to pass arbitrary flags to ant.
           The most common use of this was to pass
           <option>-Dprop-value</option> options to ant.  This can now
           be accomplished through &abuild;'s new
           <option>VAR=value</option> argument syntax as described
           above.  Certain things that used to be possible before,
           such as running <command>abuild --ant -p</command>, are no
           longer supported.  A future 1.1 alpha version of abuild
           will introduce a new help system, so this feature should
           hopefully not be missed.
          </para>
         </listitem>
         <listitem>
          <para>
           Since &abuild; now uses its own ant launcher to start
           ant-based builds using the ant Java API, the old problem of
           ant.bat not properly reporting failures on Windows is no
           longer relevant.  This means that ant-based failures are
           now properly detected on Windows.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--no-abuild-logger</option> is no longer
           supported.  &Abuild; now always uses the abuild logger when
           running ant.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Building &Abuild;
        </para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; has already required Java 1.5 since its own Java
           code uses generics.  This requirement is made more firm now
           since &abuild;'s own Java code now also makes use of some
           thread pool functionality that was added in version 1.5.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; now requires boost version 1.35 or greater since
           it uses the asio (Asynchronous I/O) library to communicate
           with its Java build launcher.
          </para>
         </listitem>
         <listitem>
          <para>
           When bootstrapping &abuild;, you must now run the
           BootstrapJava.groovy script in &abuild;'s
           <filename>src</filename> directory to build the Java code.
           A full Groovy installation (>= 1.5.7) is needed to build
           &abuild; from scratch.  A Groovy installation is not
           required run &abuild; as &abuild; embeds Groovy.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Usability Improvements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Starting in 1.0.3, if any build failures occur in a given
           &abuild; run, &abuild; issues an error message indicating
           this at the end of its output.  Now this error message is
           followed by a list of which build items failed on which
           platforms.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.3: January 9, 2009</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         <emphasis role="bold">NON-COMPATIBLE CHANGE</emphasis>:
         removal of <varname>LINK_SHLIBS</varname>
        </para>
        <itemizedlist>
         <listitem>
          <para>
           Although care is taken to avoid introducing non-compatible
           changes within a minor release, it was necessary to change
           how shared libraries are linked as the old behavior caused
           too many problems.  Specifically, prior to &abuild; 1.0.3,
           shared libraries were not linked unless the
           <varname>LINK_SHLIBS</varname> variable was set.  Starting
           with version 1.0.3, this variable has been removed, and
           builds are conducted as if the variable were set: shared
           libraries are always linked.  This is almost always the
           correct behavior for systems that support linking of shared
           libraries.  Without this, it is very easy to end up in a
           situation where replacing one version of a shared library
           with another one results in undefined or multiply-defined
           symbols at runtime.  One possible consequence of this
           change is that, in some cases involving mixing of shared
           and static libraries, a single shared library may be linked
           into multiple shared libraries.  This is usually (but not
           always) harmless, but it is also usually wasteful.  If you
           encounter this situation, the best option would be to
           rework your build to avoid whatever arrangement is causing
           this.  Alternatively, you can manipulate the value of the
           <varname>LIBS</varname> variable in your shared library
           build item's <filename>Abuild.mk</filename> file.  The old
           behavior was based on an incomplete analysis of usage of
           shared libraries.  It optimized for the unusual case of
           mixing shared libraries with static libraries rather than
           the more normal case of being able to replace earlier
           versions of shared libraries with later versions that may
           have different dependencies.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Enhancements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           A new command line option,
           <property>--clean-platforms</property>, can be used to
           restrict which platforms' directories are removed by any
           &abuild; clean operation.
          </para>
         </listitem>
         <listitem>
          <para>
           A new key, <property>build-also</property>, is now
           supported in <filename>Abuild.conf</filename>.  This key's
           value is a space-separated list of build items that should
           be automatically built if the original build item is added
           to a build set.  No dependency relationship is implied.
           This provides a more robust method than dependencies of
           creating virtual &ldquo;top-level&rdquo; build items.  A
           corresponding element has been added to the dump data
           output as well.
          </para>
         </listitem>
         <listitem>
          <para>
           When <option>--clean</option> is used to clean a build set,
           &abuild; now attempts to clean <emphasis>all</emphasis>
           build items, not just items with build files.  This means
           &abuild; will attempt to clean interface-only items,
           plugins, and other items that it previously would not have
           attempted to clean.
          </para>
         </listitem>
         <listitem>
          <para>
           A new option, <option>--dump-interfaces</option>, has been
           added.  Using this option during a build causes &abuild; to
           write an XML dump file of the full state of the interface
           system for every writable build item.  For details, see
           <xref linkend="ref.interface-debugging"/>.
          </para>
         </listitem>
         <listitem>
          <para>
           Build sets <option>down</option> and
           <option>descending</option> have been added as aliases for
           <option>desc</option>.
          </para>
         </listitem>
         <listitem>
          <para>
           Behavior of the special platform selector <type>skip</type>
           has improved.  Rather than unconditionally disabling builds
           of the given platform type, it just prevents them from
           being selected by default.  Builds for a platform type for
           which <type>skip</type> has been specified may now be done
           in order to satisfy a platform-specific dependency.
          </para>
         </listitem>
         <listitem>
          <para>
           The <type>skip</type> platform selector may now be used for
           platform types <type>indep</type> and <type>java</type>.
           When <type>java:skip</type> or <type>indep:skip</type> is
           specified as a platform selector, no builds for the given
           platform type will be performed unless needed to satisfy a
           dependency.
          </para>
         </listitem>
         <listitem>
          <para>
           When expanding the build set with
           <option>--related-by-traits</option>, &abuild; now repeats
           the expansion until no more items are added.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Bug Fixes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           A failing qtest test suite when invoked from ant now
           properly causes the build of that item with the
           <command>check</command> or <command>test</command> targets
           to fail.
          </para>
         </listitem>
         <listitem>
          <para>
           If a build item has instances of another build item in its
           dependency chain for more than one platform, &abuild;
           previously ignored all but the first instance of the second
           item's interface.  (Recall that &abuild; creates a separate
           instance of each item's interface for every platform on
           which that item builds.)  &Abuild; now properly treats each
           instance of the interface separately for purposes of
           importing interfaces into a dependent item's build.  This
           bug could only be exercised by creating multiple build
           items that depend on a common build item using different
           platform-specific dependencies.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Usability Improvements
        </para>
        <itemizedlist>
         <listitem>
          <para>
           If any build failures occur in a given &abuild; run,
           &abuild; now issues an error message indicating this at the
           end of its output just before exiting.  This makes it
           easier to recognize a failed build by looking at the end of
           &abuild;'s output.  This is especially helpful when for
           parallel builds or builds with <option>-k</option> since,
           in those cases, the output of the failed builds may not be
           at the end of the output.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; is clearer about reporting when a build item
           fails.  Additionally, if a build failure of one item causes
           other items to be skipped, this is now reported as well.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>
         Internal Changes
        </para>
        <itemizedlist>
         <listitem>
          <para>
           A minor change was made to make it easier for users to
           create plugins that would enable use of GNU Make to build
           Java code.  This could make it easier to create prototypes
           of different back-end build approaches for Java without
           having to modify &abuild;'s internals.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.2: October 7, 2008</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         &Abuild; no longer includes the minor release of Red Hat
         Enterprise Linux and Centos releases in the platform string.
         The minor release number is not necessary as the minor
         releases are intended to be binary compatible.  This allows a
         Red Hat Enterprise Linux 5.2 system to use a backing area
         built by a Red Hat Enterprise Linux 5.1 system, for example.
        </para>
       </listitem>
       <listitem>
        <para>
         Minor fixes were made to C++ source files in the test suite
         and examples so that they would compile properly with gcc
         4.3.
        </para>
       </listitem>
       <listitem>
        <para>
         In some cases, shared libraries would be linked with the C++
         compiler even when <varname>LINK_AS_C</varname> was set.
         This has been corrected.
        </para>
       </listitem>
       <listitem>
        <para>
         Setting <varname>OFLAGS</varname>, <varname>DFLAGS</varname>,
         and <varname>WFLAGS</varname> in
         <filename>Abuild.mk</filename> files had no effect because of
         the way these variables were assigned in toolchain support
         files.  &Abuild;'s built-in toolchains have been fixed to
         initialize these with <literal>?=</literal> instead of
         <literal>=</literal>.  This should make it possible to
         override these variables globally at least for &abuild;'s
         built-in toolchains.  Overriding these variables globally is
         generally not a good idea in any case, however.  Thanks to
         Ben Muzal for reporting the problem.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.1: May 28, 2008</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Minor updates to test suite to make it more portable.  In
         particular, &abuild;'s test suite is now known to pass on
         Solaris 8.
        </para>
       </listitem>
       <listitem>
        <para>
         Internal code change: avoid using boost regular expression
         objects across multiple threads in hopes of solving
         occasional assertion failures inside the boost library when
         running with multiple threads under Windows.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; was previously passing a JAR file rather than a
         directory to <application>ant</application>'s
         <command>-lib</command> argument.  This has been corrected.
         (Thanks for the problem report from Craig Pell.)
        </para>
       </listitem>
       <listitem>
        <para>
         If <varname>AUTOCONFIGH</varname> is not set, &abuild;'s
         autoconf rules will not run <command>autoheader</command>.
         This makes it possible to create an autoconf build item
         without generating a header file if desired.
        </para>
       </listitem>
       <listitem>
        <para>
         When autoconf invokes the compiler, it now honors any flags
         or includes set by dependencies.  (Thanks for the problem
         report from Joe Davidson.)
        </para>
       </listitem>
       <listitem>
        <para>
         Include two small patches to make &abuild; build properly in
         MacOS Darwin.  (Thanks for the patches from Joe Davidson.)
        </para>
       </listitem>
       <listitem>
        <para>
         With <command>--verbose</command>, &abuild; now prints the
         backend command that is invoking.  (Thanks for the suggestion
         from Craig Pell.)
        </para>
       </listitem>
       <listitem>
        <para>
         Documentation updated to add autoconf, automake, and GNU
         diffutils, and gcc configured with gnu ld to the list of
         system requirements.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now mentions when nothing is built but some native
         build items were skipped due to lack of available platforms.
         Hopefully this will reduce confusion when Windows users
         without any valid compilers or cygwin perl type &abuild; and
         don't get any output.  Also, when
         <command>--verbose</command> is specified, &abuild; always
         mentions when it skips any build item because of lack of
         build platforms.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: if tree <filename>A</filename> contained a plugin
         but did not use it, tree <filename>B</filename> had
         <filename>A</filename> as an external and used the plugin,
         and tree <filename>C</filename> had <filename>A</filename>
         and <filename>B</filename> in that order as externals and did
         not use the plugin, <filename>C</filename> would have not
         realize that the plugin was a plugin in any tree.  This would
         cause a segmentation fault when loading the interface.  This
         problem has been corrected because &abuild; now has a more
         robust way of keeping track of whether a given build item is
         ever a plugin.
        </para>
       </listitem>
       <listitem>
        <para>
         Enhancement: When the <varname>abuild.main-class</varname>
         property is set in <filename>Abuild.properties</filename>,
         &abuild; now sets the <property>Main-Class</property>
         attribute in the JAR file's manifest.  This doesn't solve the
         problem of adding custom attributes to manifest files in the
         general case, but it does address the most common situation.
         Thanks to Craig Pell for providing an implementation.
        </para>
       </listitem>
       <listitem>
        <para>
         When building with Visual C++, embed the manifest file, if
         any, into the executable or dll file.  Thanks to Matt Nassr
         for the suggestion and pointer to the relevant information.
        </para>
       </listitem>
       <listitem>
        <para>
         <emphasis>Temporary change</emphasis>: for &abuild; version
         1.0.1, the environment variable
         <envar>ABUILD_FORCE_32BIT</envar> may be set to the value
         <literal>1</literal> to force &abuild; to generate 32-bit
         code on 64-bit platforms under certain conditions.
         Specifically, on a <type>ppc64</type> platform, &abuild; will
         pass <option>-m32</option> to <command>gcc</command> and will
         use <type>ppc</type> as the CPU type in the platform string.
         Likewise, on an <type>x86_64</type> platform, &abuild; will
         pass <option>-m32</option> to <command>gcc</command> and will
         use <type>ix86</type> as the CPU type in the platform string.
         Note that &abuild; will not otherwise override the type of
         object file generated by your compiler based on the platform
         string.  This means if you are building on a 64-bit system
         with a compiler that generates 32-bit object files, &abuild;
         will happily create 32-bit object files in a directory whose
         name suggests 64-bit code.  (This is the case on Red Hat's
         <type>ppc64</type> distribution at least with Red Hat
         Enterprise Linux 4 and 5.)  This change is temporary and may
         be removed in a future release in favor of a more robust
         solution for generating both 32-bit code and 64-bit code on
         64-bit systems.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0: February 12, 2008</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         <emphasis role="bold">WARNING ABOUT Java SUPPORT</emphasis>:
         <emphasis>Java support is considered alpha at the time of
         release of &abuild; version 1.0.  This means the Java support
         in &abuild; version 1.1 may not be compatible with the Java
         support in &abuild; version 1.0.</emphasis>  We are in the
         process of rethinking how &abuild; should support Java, and
         it is possible that a wholesale redesign of &abuild;'s Java
         support will be forthcoming.
        </para>
       </listitem>
       <listitem>
        <para>Changes from earlier versions</para>
        <itemizedlist>
         <listitem>
          <para>
           Added <option>--no-dep-failures</option> option.  When used
           with <option>-k</option>, tells &abuild; to attempt to
           build items even when their dependencies have failed.
          </para>
         </listitem>
         <listitem>
          <para>
           Bug fix: a failing JUnit test suite run now causes the
           build item to fail.
          </para>
         </listitem>
         <listitem>
          <para>
           Added <command>test-only</command> target to test a build
           item without depending on <command>all</command>.
          </para>
         </listitem>
         <listitem>
          <para>
           Documentation update: clarify that
           <varname>XLINKFLAGS</varname> should not be used for
           libraries.  The documentation still reflected an earlier
           idea of what this variable should be used for.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.rc1: December 3, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Hitting CTRL-C in Windows while &abuild; was running
         <application>ant</application> would sometimes leave the
         console window in an unusable state as
         <application>ant</application>, a batch file, tried to ask
         the user whether to terminate the batch job.  On Windows,
         &abuild; now waits for subsidiary processes to exit before
         exiting itself.
        </para>
       </listitem>
       <listitem>
        <para>
         Trailing whitespace is now trimmed around
         <varname>abuild.hook-build-items</varname> in
         <filename>Abuild-ant.properties</filename>.
        </para>
       </listitem>
       <listitem>
        <para>
         New command line option <option>--find-conf</option>
         directs &abuild; to find the first
         <filename>Abuild.conf</filename> at or above the current
         directory and to run the build from there.
        </para>
       </listitem>
       <listitem>
        <para>
         Enhance handling of absolute externals so that an absolute
         external directory may be a symbolic link.
        </para>
       </listitem>
       <listitem>
        <para>
         Many additional improvements have been made to the
         documentation, thanks to input from reviewers mentioned in
         <xref linkend="ref.acknowledgments"/>.
        </para>
       </listitem>
       <listitem>
        <para>
         The HTML version of this complete document in the binary
         distributions is now in
         <filename>doc/html/abuild-manual.html</filename> instead of
         <filename>doc/abuild-manual.html</filename>.  A multi-file
         version of the HTML documentation is now also generated.  Its
         entry point is <filename>doc/html/index.html</filename>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.b3: November 13, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Support has been added for read only externals and for
         specifying a separate path for an external that is used only
         on Windows.
        </para>
       </listitem>
       <listitem>
        <para>
         If a
         <varname>WHOLE_lib_<replaceable>libname</replaceable></varname>
         variable is set during a build using the
         <filename>msvc</filename> compiler, an error message will be
         generated.  Previously, the whole library instruction would
         be silently ignored.
        </para>
       </listitem>
       <listitem>
        <para>
         Numerous improvements have been made to the documentation,
         thanks to input from reviewers mentioned in <xref
         linkend="ref.acknowledgments"/>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.b2: November 2, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Removal of Deprecated Functionality</para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; no longer automatically removes stray
           automatically generated files created by versions older
           than 1.0.a14.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; no longer accepts <varname>BI_RULES</varname> as a
           synonym for <varname>BUILD_ITEM_RULES</varname>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Movement of Functionality to External Plugins</para>
        <itemizedlist>
         <listitem>
          <para>
           VxWorks and XLC support have been removed from &abuild; and
           are now available as plugins in a build tree maintained
           separately from &abuild;.
          </para>
         </listitem>
         <listitem>
          <para>
           Javadoc support is no longer provided by the default ant
           rules but is instead provided by a <command>doc</command>
           hook, which is provided separately.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>New Features</para>
        <itemizedlist>
         <listitem>
          <para>
           External trees may now be specified as absolute paths.
           This makes it easier to support external trees that contain
           things like libraries of build items that may be maintained
           separately from the projects that use them.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>-C
           <replaceable>directory</replaceable></option> option to the
           &abuild; command tells &abuild; to change directories to
           the given directory before doing anything.  Similar to
           <application>make</application>'s <option>-C</option>
           option.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>-lowpri</option> option to
           <command>platform</command> and
           <command>native-compiler</command> commands output from
           <command>list_platforms</command> scripts may now be
           specified when adding new platforms and native compilers
           from plugins.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; interface variable
           <varname>ABUILD_PLATFORM_TYPE</varname> is now defined.
          </para>
         </listitem>
         <listitem>
          <para>
           A program is now provided to verify proper operation of
           compiler plugins.  (See <xref
           linkend="ref.adding-toolchains"/>.)
          </para>
         </listitem>
         <listitem>
          <para>
           C/C++ rules will, in most cases, recognize orphan targets
           are deal with them properly.  (Stray object files in
           subdirectories of the output directory will not currently
           be detected.)
          </para>
         </listitem>
         <listitem>
          <para>
           The new make variable <varname>LINKWRAPPER</varname> can be
           set on the command line or in the
           <filename>Abuild.mk</filename> file to specify the name of
           a command to wrap the link step.  This is intended to be
           used to support tools such as
           <application>Purify</application> which wrap the link
           command in this fashion.
          </para>
         </listitem>
         <listitem>
          <para>
           The new variable <varname>LINK_AS_C</varname> may be set in
           an <filename>Abuild.mk</filename> file to cause all shared
           libraries and executables in that build item to be linked
           as straight C code instead of C++ code.  This avoids a
           dependency on the C++ runtime libraries for straight C
           code.
          </para>
         </listitem>
         <listitem>
          <para>
           A new example has been created to illustrate how to pass
           information safely from a <application>make</application>
           variable to your source code.  See <xref
           linkend="ref.example.auto-from-variable"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Functionality Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <option>-ansi</option> flag is no longer passed to
           <command>g++</command> by default for the
           <filename>gcc</filename> and <filename>mingw</filename>
           compilers.  If you want it, create a plugin that adds it to
           <varname>XCXXFLAGS</varname> (or
           <varname>XCFLAGS</varname>) in
           <filename>plugin.mk</filename> conditionally upon the
           compiler.  In older versions, <option>-ansi</option> was
           passed to <command>g++</command> but not
           <command>gcc</command>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <command>doc</command> target for Java builds no longer
           runs <command>javadoc</command>.  Instead, this capability
           must be provided by a plugin.  The reason for this change
           is that there is too much site-specific policy in how the
           <command>javadoc</command> task would be invoked.  In light
           of this, the <command>pre-doc</command> and
           <command>post-doc</command> hooks have been replaced by a
           <command>doc</command> hook.
          </para>
         </listitem>
         <listitem>
          <para>
           A few error messages have been cleaned up so that, whenever
           possible, all &abuild; error messages are of a form that is
           parseable by the error-handling code in Emacs and Eclipse.
           (Most error messages already conformed, but a small number
           did not.)
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Bug Fixes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <filename>autoconf</filename> rules have been fixed so
           that they do not generate warnings about undefined
           variables and work better by default for cross compiles.
          </para>
         </listitem>
         <listitem>
          <para>
           File-specific <varname>OFLAGS</varname>,
           <varname>DFLAGS</varname>, and <varname>WFLAGS</varname>
           variables now work properly when set to the empty string.
          </para>
         </listitem>
         <listitem>
          <para>
           On Windows, &abuild; no longer attempts to run perl if
           Cygwin perl is not the first perl in the path.  In verbose
           mode, a message to this effect is printed when perl is not
           found.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.b1: September 28, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Warnings About Next Release</para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis role="bold">Note:</emphasis> This is intended to
           be the last release to include VxWorks and xlc support
           inside of &abuild;.  &Abuild;'s VxWorks and xlc support
           code should be moved into plugins prior to the next beta
           release of &abuild;.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Documentation Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The documentation has been substantially reorganized.  Many
           new sections have been added, and many parts have been
           rewritten.
          </para>
         </listitem>
         <listitem>
          <para>
           Examples are now spread throughout the documentation rather
           than being grouped together in one section.  (See <xref
           linkend="ref.list-of-examples"/> for a convenient list of
           examples.)  The contents of files referenced from the
           examples are now included inline in the text.  The contents
           of every file in the <filename>doc/example</filename>
           directory are no longer included in the document.
          </para>
         </listitem>
         <listitem>
          <para>
           The documentation has been converted from Texinfo to
           docbook.
          </para>
         </listitem>
         <listitem>
          <para>
           The documentation in the binary distribution is now
           installed as <filename>doc/abuild-manual.pdf</filename> and
           <filename>doc/abuild-manual.html</filename>.  There is also
           now a cascading stylesheet called
           <filename>doc/stylesheet.css</filename> that has to be in
           the same directory as the HTML version of the
           documentation.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>VxWorks Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Shared library and partial load script support has been
           added to vxworks.  When building an executable, &abuild;
           generates
           <filename><replaceable>binname</replaceable>.loaddata</filename>
           which is an executable shell script that copies all files
           that need to be loaded to a given directory in sequential
           order.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Basic Functionality Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Subtle changes have been made to how &abuild; picks which
           targets to apply to which build items: explicit targets are
           no longer applied to build items being built just to
           satisfy dependencies unless the new
           <option>--apply-targets-to-deps</option> option is
           specified.
          </para>
         </listitem>
         <listitem>
          <para>
           New name and pattern based build sets have been added.  See
           <xref linkend="ref.build-sets"/> for details.
          </para>
         </listitem>
         <listitem>
          <para>
           <option>--with-deps</option> is now exactly the same as
           <option>--build=current</option>.  Both behave the way
           <option>--with-deps</option> behaved in previous releases.
           To get the old behavior of
           <option>--build=current</option>, also specify the
           <option>--apply-targets-to-deps</option> option.
          </para>
         </listitem>
         <listitem>
          <para>
           When cleaning with a clean set, dependencies of items in
           the clean set are no longer cleaned by default.  To cause
           them to be cleaned as well, use the
           <option>--apply-targets-to-deps</option> option along with
           <option>--clean</option>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--verbose</option> option now prints additional
           information about what &abuild; is doing in addition to
           passing verbose flags to <application>make</application>
           and <application>ant</application>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--silent</option> flag now passes
           <option>-quiet</option> to <application>ant</application>
           in addition to suppressing some make output and some of
           &abuild;'s own output.
          </para>
         </listitem>
         <listitem>
          <para>
           Build item scoping rules have changed slightly: a build
           item no longer has automatic access to items in grandchild
           scopes or lower (<classname>A</classname> can still see
           <classname>A.B</classname>, but it can no longer see
           <classname>A.B.C</classname>).  Access can still be granted
           using the <property>visible-to</property> key if needed.
          </para>
         </listitem>
         <listitem>
          <para>
           Bug fix: if <option>--dump-data</option> and
           <option>--monitored</option> were both specified, the dump
           data output is now properly delimited by monitor
           statements.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Ant/Java changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <envar>ANT_HOME</envar> and <envar>JAVA_HOME</envar>
           environment variables are no longer required.  If
           <envar>ANT_HOME</envar> is set, &abuild; will still run the
           copy of <command>ant</command> in
           <filename>${ANT_HOME}/bin</filename>, but if it is not set,
           &abuild; will now attempt to run <command>ant</command>
           from the path.  This makes &abuild; completely free of
           mandatory environment variable settings.
          </para>
         </listitem>
         <listitem>
          <para>
           The ability to generate wrapper scripts to run Java
           &ldquo;executables&rdquo; has been moved into the standard
           <application>ant</application> support for &abuild;.  The
           old Java wrapper example has been changed to use this
           functionality instead of implementing it with a special
           build item.
          </para>
         </listitem>
         <listitem>
          <para>
           The new property
           <varname>abuild.include-ant-runtime</varname> has been
           added to include <application>ant</application>'s runtime
           libraries in your compilation class path.  This removes the
           need to access <envar>ANT_HOME</envar> (and therefore
           require it to be set) when compiling custom ant tasks.
          </para>
         </listitem>
         <listitem>
          <para>
           Boolean <filename>Abuild.interface</filename> variables are
           now converted to &ldquo;<literal>1</literal>&rdquo; and
           &ldquo;<literal>0</literal>&rdquo; for
           <application>ant</application>-based builds just as they
           are for <application>make</application>-based builds.
           Earlier versions of &abuild; used
           &ldquo;<literal>1</literal>&rdquo; and
           &ldquo;<literal>0</literal>&rdquo; for
           <application>make</application>-based builds and
           &ldquo;<literal>yes</literal>&rdquo; and
           &ldquo;<literal>no</literal>&rdquo; for
           <application>ant</application>-based builds.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Make/C/C++ Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; now supports the creation of shared library files
           on UNIX platforms and DLL files on Windows platforms.  It
           also compiles all library files as position-independent
           code.  Users wishing to take advantage of this new
           functionality are recommended to rebuild from a clean
           state.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to generate the preprocessed version of
           any C or C++ source file by running <command>abuild
           <replaceable>SourceFile</replaceable>.i</command>.
          </para>
         </listitem>
         <listitem>
          <para>
           The old <filename>dummy</filename>
           <application>make</application> rules, never previously
           documented, have been renamed to <filename>empty</filename>
           and are now documented and officially supported.
          </para>
         </listitem>
         <listitem>
          <para>
           The <filename>texinfo</filename> rules have been removed.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a20: September 4, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Configuration changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Writable backing areas are no longer supported; all backing
           areas are read only.  The
           <filename>Abuild.backing</filename> file now contains only
           the path name of the backing area.
          </para>
         </listitem>
         <listitem>
          <para>
           Added new <varname>deleted</varname> key to
           <filename>Abuild.conf</filename>, making it possible to make
           build items in a backing area that are not present in the
           local tree inaccessible.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Invocation changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Platform selection criteria are now supported via the
           <option>--platform-selector</option> or
           <option>-p</option> command-line option and the
           <varname>ABUILD_PLATFORM_SELECTORS</varname> environment
           variable.  This makes it possible to more tightly control
           which platforms will be built.  Along with this, the option
           field, formerly known as the flags field, of object code
           platforms is implemented along with a recommended method for
           generating release and debug builds.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>all</varname> build set no longer ever builds
           items in backing areas since all backing areas are now read
           only.  The <varname>local</varname> build set no longer
           builds externals.  If you wish to build the local tree and
           its externals as well, use the <varname>all</varname> build
           set.  This makes the <varname>local</varname> build set do
           what people always thought it did anyway.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--list-platforms</option> command-line
           argument lists all known object-code platforms grouped by
           platform type.
          </para>
         </listitem>
         <listitem>
          <para>
           The command <command>abuild --dump-data</command> will now
           attempt to generate dump data output even when there were
           errors.  This makes it possible to use the dump data output
           to help figure out what may be causing the errors.  The
           <varname>errors</varname> attribute will be present and
           have the value <literal>1</literal> when errors have been
           detected.
          </para>
         </listitem>
         <listitem>
          <para>
           Added <varname>--monitored</varname> flag to put &abuild; into
           monitored mode.  This is primarily intended to support
           front-ends to &abuild; that want to monitor progress.  For
           information, see <xref linkend="ref.monitored-mode"/>.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild;'s choice of backend is no longer determined by the
           target type of the build item but is instead determined by
           the type of build file it has.  This change is invisible to
           users of older versions of &abuild; as it will always do the
           same thing for any existing configurations.  It does, in
           principle, make it possible to use ant for C/C++ builds and
           make for Java-based builds, provided the proper support code
           was added, and it also opens the door for supporting a wider
           array of backends.
          </para>
         </listitem>
         <listitem>
          <para>
           In many error messages, relative paths to
           <filename>Abuild.conf</filename> files have been replaced
           with absolute paths.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Make changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <varname>BI_RULES</varname> variable has been renamed to
           <varname>BUILD_ITEM_RULES</varname>.  A deprecation warning
           will be issued if <varname>BI_RULES</varname> is used.  This
           backward compatibility will be removed before 1.0.
          </para>
         </listitem>
         <listitem>
          <para>
           New documented flags have been added to
           <filename>ccxx.mk</filename>.  These changes are mostly
           user-invisible, but end user <filename>Abuild.mk</filename>
           files that set the <varname>DFLAGS</varname> make variable
           will need to be changed.
          </para>
         </listitem>
         <listitem>
          <para>
           Previously undocumented toolchain-specific make flags
           variables have been removed in favor of using conditionals
           based on <varname>$(CCXX_TOOLCHAIN)</varname>.
          </para>
         </listitem>
         <listitem>
          <para>
           <filename>ccxx.mk</filename> has been reworked somewhat to
           make it easier to write new compiler support files and to
           simplify overriding of debug, optimization, and warning
           flags.  These changes are invisible to the vast majority of
           end-user <filename>Abuild.mk</filename> files but have a
           significant impact on toolchain support files, which prior
           to this release, were all included in &abuild; anyway.  The
           <filename>ccxx.mk</filename> file itself is heavily
           commented.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Java changes</para>
        <itemizedlist>
         <listitem>
          <para>
           An alternative for Java builds has been provided.  In this
           alternative, you can write your own
           <filename>build.xml</filename> files with some minor
           limitations.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: there is now
           only one java platform, <filename>java</filename>.  The
           interface variable
           <varname>abuild.platform.bytecode</varname> is no longer
           defined.  &Abuild; no longer attempts to manage different java
           bytecode versions itself.  However, two new properties:
           <varname>abuild.source-java-version</varname> and
           <varname>abuild.target-java-version</varname> can now be set
           in <filename>Abuild-ant.properties</filename>.  This change
           is invisible to people who did not either access the
           <varname>abuild.platform.bytecode</varname> variable or the
           <filename>abuild-java5</filename> path.
          </para>
         </listitem>
         <listitem>
          <para>
           Bug fix: &abuild; will now work properly if
           <varname>$(ANT_HOME)</varname> points to a path with a space
           it in.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Platform changes</para>
        <itemizedlist>
         <listitem>
          <para>
           There is no longer support for nested platform types.  All
           the operating system-specific platform types
           (<filename>unix</filename>, <filename>windows</filename>,
           etc.) have been removed.  This is not a user-visible change
           since there were never any platforms in those platform
           types.  Note that new platforms and platform types may now
           be added in plugins.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild;'s internal <command>list_platforms</command> command
           has moved from <filename>private/bin</filename> to
           <filename>private</filename> and generates new kinds of
           output.  &Abuild;'s own bootstrapping uses
           <filename>private/bin/bootstrap_native_platform</filename>.
          </para>
         </listitem>
         <listitem>
          <para>
           Full cross-platform dependency support is fully implemented.
           It is now possible to mention a platform type and platform
           selection criteria on a dependency declaration using the
           <varname>-platform</varname> option in the
           <varname>deps</varname> key in
           <filename>Abuild.conf</filename>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>USE_MSVC</varname> environment variable is no
           longer required for using Visual C/C++.  Instead, &abuild;
           will try to use it if the <varname>VCINSTALLDIR</varname>
           variable is set.  Based on Microsoft documentation, this
           appears to be a reliable test that the appropriate Visual
           Studio variables are in the environment.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para><option>--dump-data</option> changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Since writable backing areas are no longer supported, there
           is no longer a <varname>writable</varname> attribute to the
           <varname>backing-area</varname> element.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>platform-data</varname> element has been added.
           This gives overall platform information as well as
           build-tree-specific platform information.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>deleted-items</varname> element has been added
           to <varname>build-tree</varname>.
          </para>
         </listitem>
         <listitem>
          <para>
           Several attributes and elements have been added because of
           plugin support.  In particular, the
           <varname>is-plugin</varname> and
           <varname>is-plugin-anywhere</varname> attributes have been
           added to <varname>build-item</varname>, the
           <varname>has-shadowed-dependencies</varname> attribute has
           been changed to <varname>has-shadowed-references</varname>
           and is also true if plugins are shadowed, and the new
           <varname>plugins</varname> element has been added.
          </para>
         </listitem>
         <listitem>
          <para>
           The new attribute <varname>external-depth</varname> has been
           added to <varname>build-item</varname>.  Items local to the
           build tree from which &abuild; was started are now
           detectable by having both <varname>external-depth</varname>
           and <varname>backing-depth</varname> equal to
           <varname>0</varname>.  (They can, as before, also be
           detected by having their home tree be the current build
           tree.)
          </para>
         </listitem>
         <listitem>
          <para>
           With full cross-platform dependencies supported, the
           <varname>dependency</varname> element now has an optional
           <varname>platform-type</varname> attribute.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>build-platforms</varname> and
           <varname>known-platforms</varname> attributes have been
           removed from <varname>build-item</varname>, and the
           <varname>buildable-platforms</varname> attribute has been
           added.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a19: July 31, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Java changes</para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: Previously
           undocumented <filename>ear-contents</filename> and
           <filename>war-classpath</filename> directories are no longer
           used.  New documented <filename>classpath</filename>
           directory has been introduced for use in copying classpath
           files into archives.  This mechanism may change in the
           future.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: It is no longer
           possible to create a local JAR file in the same build item
           as an EAR file.  The EAR example in the Java Archive Types
           example has been updated to illustrate a different way to do
           this.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: For WAR build
           items, the property <varname>abuild.war-type</varname> must
           now be set to either <varname>client</varname> or
           <varname>server</varname>.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to add arbitrary files to an EAR file and
           to populate an EAR file's <filename>META-INF</filename>
           directory.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>New functionality</para>
        <itemizedlist>
         <listitem>
          <para>
           The new <option>--print-abuild-top</option> flag has been
           added to print the name of the &abuild;'s installation
           directory.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: the
           <varname>autofiles</varname> statement in
           <filename>Abuild.interface</filename> has been changed to
           <function>after-build</function> to more accurately reflect
           its purpose and functionality.
          </para>
         </listitem>
         <listitem>
          <para>
           Interface flags are now supported.  Build items can declare
           supported flags in their <filename>Abuild.conf</filename>
           files and can reference those flags in their
           <filename>Abuild.interface</filename> files.  They can also
           specify which flags should be set for other build items in
           their direct dependency list.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: in light of the
           introduction of interface flags,
           <varname>BI_PRIVATE</varname> and
           <filename>Private.mk</filename> are no longer supported.
           The private interface example illustrates how to support
           this construct in a cleaner way using interface flags.
          </para>
         </listitem>
         <listitem>
          <para>
           Build item traits are now supported.  This allows build
           items to be grouped based on functionality or relationships
           to other build items that fall outside of the dependency
           graph.
          </para>
         </listitem>
         <listitem>
          <para>
           Several examples in the documentation have been updated to
           demonstrate new functionality.  Some new examples have also
           been added.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to reset a variable in
           <filename>Abuild.interface</filename> using the
           <varname>reset</varname>, <varname>reset-all</varname>, and
           <varname>no-reset</varname> statements.  Please see the
           relevant sections of the document to understand how these
           work and the subtleties of their use.
          </para>
         </listitem>
         <listitem>
          <para>
           Externals that are resolved through backing areas now appear
           in the <option>--dump-data</option> output with the
           <varname>backed="1"</varname> attribute.  Before, they did
           not appear at all.
          </para>
         </listitem>
         <listitem>
          <para>
           Information about traits and flags have been added to
           <option>--dump-data</option> output.
          </para>
         </listitem>
         <listitem>
          <para>
           All whitespace-separated lists have been removed from
           <option>--dump-data</option> output and have been replaced
           by nested elements instead.  This made room for inclusion of
           flag and trait information in the dump data output and also
           makes it easier for applications to parse the XML.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Bug fixes</para>
        <itemizedlist>
         <listitem>
          <para>
           Incorrect regular expression could cause &ldquo;memory
           exhausted&rdquo; to be printed when certain syntax errors
           appeared in <filename>Abuild.conf</filename> files.
          </para>
         </listitem>
         <listitem>
          <para>
           Several cases involving whitespace handling were fixed in
           the interface parser.  Specifically, the following patterns
           could result in parse errors: trailing whitespace at the end
           an interface file without a line terminator, a continuation
           character in a file with Windows-style newlines, and a
           continuation character followed by a line that did not start
           with a space.
          </para>
         </listitem>
         <listitem>
          <para>
           Path comparison on Windows is now case-insensitive when
           computing one path relative to another.  When asking for one
           path relative to a path on a different drive, the first path
           is returned unchanged.  This should make &abuild; itself able
           to use backing areas on different drives, though this case
           has not been thoroughly tested.
          </para>
         </listitem>
         <listitem>
          <para>
           Short forms of command-line options added in 1.0.a14 have
           been added to <command>abuild --help</command>'s output.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a18: July 18, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Run junit tests with <varname>fork="true"</varname> for better
         performance.
        </para>
       </listitem>
       <listitem>
        <para>
         Support added for WAR files.
        </para>
       </listitem>
       <listitem>
        <para>
         The <filename>src/java</filename> directory is now optional.
         It makes sense to omit it for some WAR files as well as for
         JAR files that consist entirely of resources or automatically
         generated code.
        </para>
       </listitem>
       <listitem>
        <para>
         In order to support a wider range of java archive types, the
         <varname>abuild.jar-name</varname> and
         <varname>abuild.ear-name</varname> properties in
         <filename>Abuild-ant.properties</filename> must now include
         the filename extension of the archive file.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a17: July 9, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Implemented new build item accessibility scheme that allows
         nested namespace scopes.  To upgrade your build item names,
         please run <filename>misc/upgrade-scope-names</filename> from
         the &abuild; installation directory.  Two consecutive dashes
         (<varname>--</varname>) no longer has any special meaning in
         build item names.  &Abuild; also no longer requires the
         public parent of a private build item to exist.  For details
         on the new accessibility system, see <xref
         linkend="ref.build-item-name-scoping"/>.
        </para>
       </listitem>
       <listitem>
        <para>
         Added optional <varname>visible-to</varname> field to the
         <filename>Abuild.conf</filename> file to allow build items to
         expand their visibility as otherwise restricted by the new
         scoping rules.  This is also an optional attribute to
         <classname>BuildItem</classname> in the
         <option>--dump-data</option> output.
        </para>
       </listitem>
       <listitem>
        <para>
         Added &ldquo;mixed classification&rdquo; example to the
         complete example section.  This shows a pattern of how one
         might organize build items in a mixed classification
         environment.  It also shows a real-world application of the
         new <varname>visible-to</varname> field in the
         <filename>Abuild.conf</filename> file.
        </para>
       </listitem>
       <listitem>
        <para>
         Added an optional <varname>description</varname> field to
         <filename>Abuild.conf</filename>.  This is for informational
         use only.  It appears in the <option>--dump-data</option>
         output if present.
        </para>
       </listitem>
       <listitem>
        <para>
         Run pre- and post- compile and package hooks in Java even if
         the compile and package targets are not being run.  This makes
         it possible to, for example, generate wrappers from
         post-package hooks even if no packages are being created.  The
         Java example has been enhanced to illustrate this case.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: autoconf rules have been modified slightly so that
         they should work properly when <option>--make-jobs</option>
         is used.
        </para>
       </listitem>
       <listitem>
        <para>
         Added cygwin as a valid platform type as distinct from
         Windows.  Although &abuild; should in principle work just fine
         if compiled as a cygwin application, this has not been tested
         and there is no intention of actually supporting it.  However,
         there's also no good reason to hard-code into &abuild; the idea
         that when cygwin is present, it means Windows, not cygwin.
        </para>
       </listitem>
       <listitem>
        <para>
         Change layout of source directory: manual sources are now in
         <filename>src/manual</filename> and dump data DTD is now in
         the <filename>src</filename> directory.  The compiled manual
         in PDF and HTML formats along with the DTD are included in the
         <filename>doc</filename> directory in the binary distribution.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a16: June 22, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         &Abuild; no longer has to be in a directory called
         <filename>abuild</filename>.  Instead, it looks above the full
         path of the &abuild; executable for a directory that contains
         <filename>make/abuild.mk</filename>.  This means it's possible
         to install &abuild; under a directory named
         <filename>abuild-</filename><varname>version</varname>, for
         example.
        </para>
       </listitem>
       <listitem>
        <para>
         The ant <varname>package</varname> target has been recoded to
         avoid multiple invocations of the <varname>compile</varname>
         target.
        </para>
       </listitem>
       <listitem>
        <para>
         A small error was corrected in
         <filename>abuild_data.dtd</filename>.  A test case has been
         added to ensure that it is always accurate in future releases.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a15: June 18, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Basic Java support has been added.
        </para>
       </listitem>
       <listitem>
        <para>
         Add <option>-mlongcall</option> to vxworks compilation
        </para>
       </listitem>
       <listitem>
        <para>
         The documentation has been reorganized somewhat for greater
         clarity.  The contents of the example files have been moved to
         an appendix at the back of the document which makes them
         easier to separate when going through examples.
        </para>
       </listitem>
       <listitem>
        <para>
         A standard <command>doc</command> target has been added,
         though it does not yet do anything for make-based target types
        </para>
       </listitem>
       <listitem>
        <para>
         The <command>test</command> and <command>check</command>
         targets are now identical in functionality.  It used to be
         that <command>test</command> did not depend on all, but this
         is no longer the case.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now looks in the <filename>qtest</filename> directory
         rather than the <filename>tests</filename> for qtest test
         suites.
        </para>
       </listitem>
       <listitem>
        <para>
         Environment variables may now appear in interface files using
         the syntax <varname>$(ENV:VARIABLE)</varname>.  Use sparingly.
        </para>
       </listitem>
       <listitem>
        <para>
         When cleaning with a clean set, items that have no build files
         are skipped.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>--</option> argument has been dropped in favor
         of <option>--make</option> and <option>--ant</option>
         options which pass arguments specifically to make or ant.
         Both options can be specified so that a mixed build can pass
         different arguments to make and to ant.
        </para>
       </listitem>
       <listitem>
        <para>
         The style of element names used in
         <option>--dump-data</option> has been changed from
         <varname>ThisStyle</varname> to <varname>this-style</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         There is no longer a default value for the
         <varname>platform-types</varname> key in
         <filename>Abuild.conf</filename>.  The
         <filename>upgrade-interfaces</filename> script that assists
         with upgrading from pre-1.0.a14 versions of &abuild; will create
         values when necessary based on the old rules.
        </para>
       </listitem>
       <listitem>
        <para>
         Build item names are restricted to containing only
         alphanumeric characters, underscores, periods, and dashes.
        </para>
       </listitem>
       <listitem>
        <para>
         Added <option>--dump-build-graph</option> debugging option.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a14: May 18, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         A new XML-based <option>--dump-data</option> format has been
         implemented.
        </para>
       </listitem>
       <listitem>
        <para>
         Short forms of <option>--build=set</option>,
         <option>--clean=set</option>, and
         <option>--with-deps</option> options have been provided.
         See command line syntax for details.
        </para>
       </listitem>
       <listitem>
        <para>
         Clean sets are no longer automatically expanded to include
         recursively expanded dependencies.  The
         <varname>deps</varname> and <varname>current</varname>
         build/clean sets have been redefined to explicitly include
         expanded dependencies and therefore have no change of
         semantics.  The main result of this change is that running
         <option>--clean=desc</option> now no longer ever cleans
         anything not below the directory from which &abuild; was
         invoked.
        </para>
       </listitem>
       <listitem>
        <para>
         The option to pass <option>VAR=value</option> arguments to
         &abuild; and to have those passed on to make has been removed.
         If you need to do this, place these arguments after
         <option>--</option>, since all those arguments are passed
         directly to the backend anyway.
        </para>
       </listitem>
       <listitem>
        <para>
         The documentation was updated to accurately reflect recent
         changes of platform handling, the new interface system, and
         refactoring that was performed during the C++ port.
        </para>
       </listitem>
       <listitem>
        <para>
         Implementation of completely new interface system.  Interfaces
         now use <filename>Abuild.interface</filename> instead of
         <filename>Interface.mk</filename>.  The new interface files
         are loaded internally by &abuild; and are no longer tied to GNU
         Make.
        </para>
       </listitem>
       <listitem>
        <para>
         Remove Windows-only <varname>XLIBS</varname> interface
         variable.  Instead of appending <filename>xyz</filename> to
         <varname>XLIBS</varname>, append <filename>xyz.lib</filename>
         to <varname>XLINKFLAGS</varname>.  (Note: in a later change,
         we now recommend using LIBS and LIBDIRS for third-party
         libraries just as you would for your own libraries.)
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: detect parent/child loops better while reading
         <filename>Abuild.conf</filename> files.  Parent loops were
         previously detected properly, but child loops were not
         necessarily detected.
        </para>
       </listitem>
       <listitem>
        <para>
         Terminology change: &ldquo;architecture&rdquo; is now
         &ldquo;platform&rdquo;, &ldquo;architecture category&rdquo; is
         now &ldquo;platform type&rdquo;, and &ldquo;architecture
         class&rdquo; is now &ldquo;target type.&rdquo; The
         <varname>arch</varname> key in
         <filename>Abuild.conf</filename> is now
         <varname>platform-types</varname>.  The
         <varname>archclass</varname> key in
         <filename>Abuild.interface</filename> is now
         <varname>target-type</varname>.
        </para>
       </listitem>
       <listitem>
        <para>
         Changes to platform identifiers: this release includes an
         early implementation of the new
         <varname>os.cpu.toolset.compiler[.flags]</varname> format.
        </para>
       </listitem>
       <listitem>
        <para>
         The <filename>vc7</filename> C/C++ toolchain is now called
         <filename>msvc</filename> since it works with Visual C++
         version 8 as well as version 7.  The environment variable
         USE_MSVC, rather than USE_VC7, now selects it.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a13: May 1, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         &Abuild;, previously implemented in Perl, was rewritten in C++.
        </para>
       </listitem>
       <listitem>
        <para>
         For compilers that support it, gen_deps is bypassed in favor
         of the compiler's internal dependency generation capabilities.
         This will improve build performance for those compilers.  As
         of 1.0.a13, the only compiler that produces exactly what
         &abuild; needs is gcc.
        </para>
       </listitem>
       <listitem>
        <para>
         The default optimization for gcc and xlc has been changed from
         -O3 to -O2 as many people have reported problems with -O3.
         For most cases, -O3 will not make a big difference in
         performance, but there are some cases in which it can be a
         significant difference.  For those cases, it is still possible
         to override this for individual files or individual build
         items if desired.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer provides the variables
         <varname>abHOST_ARCH</varname>, <varname>abHOST_OS</varname>,
         <varname>abHOST_DIST</varname>, or
         <varname>abHOST_CPU</varname> as they did not previously
         contain reliably useful values and were never documented.
        </para>
       </listitem>
       <listitem>
        <para>
         When looking for GNU Make, &abuild; now checks all occurrences
         of gmake and then of make in the path, stopping with the first
         one that appears to be GNU Make version 3.81 or newer.  It
         previously checked only the first occurrence of make or gmake
         and required that occurrence to be GNU Make 3.81 or newer.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now only checks for GNU Make if at least one build item
         requires it.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer calls umask 002 before starting to build.
         This means that it will not create group-writable files unless
         the calling user's umask is set appropriately.  The old
         behavior of calling umask 002 was a vestige of the past when
         it was common for multiple users to be building in the same
         directory.  Although this may sometimes still be desirable,
         it's not the place of &abuild; to override the user's umask
         setting.
        </para>
       </listitem>
       <listitem>
        <para>
         Starting in version 1.0.a11, &abuild; no longer creates
         <filename>.ab-dynamic.mk</filename> outside of architecture
         directories.  Versions 1.0.a11 and 1.0.a12 deleted stray
         <filename>.ab-dynamic.mk</filename> files created by older
         versions of &abuild;.  This version no longer does.  If you
         are upgrading from a version older than 1.0.a11, you should
         manually remove any <filename>.ab-dynamic.mk</filename> files
         that are left lying around.  Since &abuild; automatically
         creates those that it needs on each run, running
         <command>find . -name .ab-dynamic.mk -exec rm {} \;</command>
         will do the job.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>--host-arch</option> command line argument was
         removed.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a12: April 2, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         It is now possible to specify that a library should be linked
         in its entirety by defining the variable
         <varname>WHOLE_lib_libname</varname> for library
         <filename>libname</filename> in the
         <filename>Interface.mk</filename> file that provides
         <filename>libname</filename>.  For systems that use the gnu
         linker, this results in the <varname>--whole-archive</varname>
         flag being used for the specified library.  Note that not all
         systems support this feature, so this behavior should not be
         relied upon when not absolutely necessary.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a11: March 30, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Move <varname>XLINKFLAGS</varname> to the end of the link step
         (after <varname>LIBS</varname>) for all C/C++ compilers.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>-j</option> flag now controls how many build
         items &abuild; will attempt to build in parallel and is no
         longer passed to make.  The new command-line option
         <option>--make-jobs</option> can be used to pass the
         <option>-j</option> flag to make.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer uses any recursion at all.  Rather than
         having a top-level &abuild; process invoke subsidiary &abuild;
         processes for specific builds, &abuild; computes all the
         directories in which builds will be run and invokes the
         backend directly in each directory.  &Abuild; now manages all of
         its build order computations and parallelism computations
         itself rather than relying on GNU Make.  This means that
         &abuild; now uses GNU Make only for performing the actual
         compiles, which greatly simplifies &abuild;'s make code and
         makes it much more able to support alternative backends.  A
         pleasant side effect of this change is that &abuild; runs much
         more quickly and no longer needs to cache any information.  A
         version of &abuild; to appear in the very near future will
         change the mechanism through which build items publish their
         build interfaces, eliminating
         <filename>Interface.mk</filename> and replacing it with some
         other mechanism.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer creates <filename>.abuild-cache.*</filename>
         directories at all and also no longer creates
         <filename>.ab-dynamic.mk</filename> files outside of
         architecture subdirectories.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a10: March 26, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Various Windows portability fixes including changing cache
         file names to make them shorter.
        </para>
       </listitem>
       <listitem>
        <para>
         Deprecated debugging flag removed from VC7 toolchain support
         file.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now works when run via a symbolic link.  In other
         words, it now works to add a symlink called &abuild; in your
         path and have it point to the real &abuild;.  If you attempted
         to do this in prior versions, you would get an error because
         &abuild; would not be able to find its data files.
        </para>
       </listitem>
       <listitem>
        <para>
         The support test framework is now called
         <filename>qtest</filename>, and the name of its driver is
         <filename>qtest-driver</filename>.  &Abuild; has been updated
         with the new name information.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: &abuild; was previously invoking qtest-driver in a
         manner such that test coverage files would never been seen.
         This is now fixed.  (Requires the qtest version >= 1.0.a1 as
         well.)
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a9: March 14, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Use <varname>$WIND_HOME</varname> instead of
         <filename>/opt/WindRiver</filename> to find the vxworks
         toolchain.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a8: March 13, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Change the hacked vxworks support to be just a little bit less
         hacked.  &Abuild; no longer uses the hacked toolchain on hydra1;
         it now recognizes the vendor-supplied cross compiler toolchain
         if installed in <filename>/opt/WindRiver</filename>, resulting
         in working C++ support for a Linux Intel to vworks ppc cross
         compilation.  This is still a temporary solution, but it is
         closer to the real thing.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a7: March 7, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Make a few changes to the temporary vxworks support to allow
         C++ compilation to succeed.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a6: March 6, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         &Abuild; now loads <filename>Interface.mk</filename> files in
         forward rather than reverse dependency order.  In order to
         avoid having to change all the
         <filename>Interface.mk</filename> files to ensure that library
         ordering is still correct, special case code has been added to
         handle the <varname>INCLUDES</varname>,
         <varname>LIBS</varname>, and <varname>LIBDIRS</varname>
         variables.  This turned out to be a temporary solution, as
         hoped.  For a detailed description of this change, please see
         the 1.0.a6 documentation.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now loads the C/C++ toolchain configuration before
         loading any architecture-specific rules.  This means that the
         <filename>autoconf</filename> rules will know the proper C/C++
         toolchain even if the <filename>ccxx</filename> rules are not
         also loaded.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: some of the <varname>XCFLAGS</varname>-like variables
         were not being used at all the right places after the
         refactoring of the toolchain support.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a5: March 5, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Bug fix: don't include <filename>Interface.mk</filename> files
         for build items whose architecture categories don't match what
         is being built.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a4: February 23, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Change VxWorks support so that library targets build normal
         <filename>.a</filename> files and executable targets build
         <filename>.out</filename> files that can link with libraries.
         This is still not necessarily the final way it's going to
         work.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a3: February 20, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Fix <varname>.LIBPATTERNS</varname> warning on VxWorks
        </para>
       </listitem>
       <listitem>
        <para>
         Detect when a build set contains no buildable items and exit
         cleanly without attempting to build.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a2: February 19, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         The strings <varname>as C</varname> or <varname>as
         C++</varname> are included in &abuild;'s output when compiling C
         and C++ respectively.
        </para>
       </listitem>
       <listitem>
        <para>
         Internal <filename>make</filename> directory has been
         reorganized.  The two changes that affect the documentation
         are that <filename>make/rules/arch-indep</filename> is now
         <filename>make/rules/indep</filename> and
         <filename>make/rules/arch-dep</filename> is now
         <filename>make/rules/archdep</filename>.  Other changes were
         also made.
        </para>
       </listitem>
       <listitem>
        <para>
         Hacked in support for xlc (IBM compiler) and vxworks.  The xlc
         and vxworks are specific to a particular configuration and
         will disappear in a future release when a suitable facility is
         added for extending &abuild; with external rules.
        </para>
       </listitem>
       <listitem>
        <para>
         The beginning of multiple architecture support has been
         implemented.  It now works to set <varname>arch</varname> in
         <filename>Abuild.conf</filename> to <varname>native
         vxworks</varname> to build for both the native platform and
         for VxWorks or to set it to <varname>vxworks</varname> to
         build for VxWorks only.  The rest of the documentation has not
         been updated to reflect this yet.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a1: February 8, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Separate specification of private interfaces are now supported
         through use of the <filename>Private.mk</filename> file.
         (This mechanism was changed in a later release.)
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now enforces that <varname>BI_RULES</varname> in
         <filename>Abuild.mk</filename> may not contain inaccessible
         private build items.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
   </variablelist>
  </appendix>
  <appendix id="ref.changes-in-1.1">
   <title>Major Changes from Version 1.0 to Version 1.1</title>
   <para>
    This chapter presents a summary of the major changes to &abuild;
    that were introduced in version 1.1.  If you are already familiar
    with &abuild; 1.0, this material should help you come up to speed
    with version 1.1 fairly quickly.
   </para>
   <para>
    With few exceptions, &abuild; 1.1 is able to build trees that
    version 1.0 could build, which should make it possible, in almost
    all cases, to operate in a mixed 1.0/1.1 environment during a
    transitional period.  Once you are ready to start taking full
    advantage of new functionality in 1.1, it is recommended that you
    upgrade your trees.  &Abuild; includes a utility that will do
    almost all of the work of upgrading your
    <filename>Abuild.conf</filename> files.  You will have to perform
    upgrades to your <filename>Abuild.mk</filename> files manually,
    though there are relatively few such upgrades, and most build
    items will not require any changes.  For details on the upgrade
    process, please see <xref linkend="ref.upgrading-to-1.1"/>.
   </para>
   <warning>
    <para>
     Please do not use the list below to try to upgrade your build
     trees manually.  You shouldn't go through this list and start
     manually fixing your <filename>Abuild.conf</filename> files.
     Doing this will only waste your time and making the automated
     upgrade process less reliable.  There is a lot of complex logic
     involved in doing the upgrades, so you're best off leaving it to
     &abuild; which has the benefit of knowing the entire build tree
     structure of all your trees.  Refer to <xref
     linkend="ref.upgrading-to-1.1"/> for details.
    </para>
   </warning>
   <sect1 id="ref.new11.non-compatible">
    <title>Non-compatible Changes</title>
    <para>
     As a general rule, we avoid making non-compatible changes in
     &abuild; minor releases.  There are some instances, however, in
     which supporting the old feature is very difficult or problematic
     in comparison to fixing existing build trees.  In all cases,
     there is a solution that provides the desired functionality that
     will work in a hybrid 1.0/1.1 environment.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       The make backend now loads the toolchain support file
       <emphasis>before</emphasis> your <filename>Abuild.mk</filename>
       file.  This will almost never make a difference, and it allows
       build items to manipulate or override variables defined by the
       toolchain.  This greatly simplifies things like selectively
       overriding warning or optimization flags, and is also used by
       the new variables that allow for tighter configuration of the
       <filename>msvc</filename> toolchain.  It's possible that
       certain incorrect <filename>Abuild.mk</filename> code that you
       might have gotten away with in the past may cause problems now
       as a result of this change.  This is discussed in <xref
       linkend="ref.upgrade11.caveats"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       Absolute path externals are no longer supported.  Use of the
       absolute path externals or of the <option>-winpath</option>
       option in the <property>external-dirs</property> key will
       result in an error message.  If you are relying on absolute
       path externals, you can replace them with relative-path
       externals, and make the relative path externals be empty except
       for an <filename>Abuild.backing</filename> file that points to
       the absolute path previously referenced.  This provides the
       exact functionality of the absolute path external.  You will
       use this only as a temporary workaround, since after you
       upgrade your trees to version 1.1, you will no longer have any
       <property>external-dirs</property> keys.
      </para>
     </listitem>
     <listitem>
      <para>
       Read-only externals are no longer supported.  In &abuild; 1.1,
       you can force parts of your build tree to be read only by using
       the much more flexible <option>--ro-path</option> and
       <option>--rw-path</option> options, described in <xref
       linkend="ref.read-only-paths"/>.  In order to allow hybrid
       1.0/1.1 environments to work properly, &abuild; 1.1 will allow
       the <option>-ro</option> option to be specified in your
       <filename>Abuild.conf</filename>'s
       <property>external-dirs</property> keyword, but it will issue a
       warning and ignore the option.  Once you upgrade to version
       1.1, you will no longer have any
       <property>external-dirs</property> keys anyway.
      </para>
     </listitem>
     <listitem>
      <para>
       The value of the <property>parent-dir</property> key must now
       point up in the file system.  That is, if the value has more
       than one path element, every path element must be
       &ldquo;<literal>..</literal>&rdquo;.  (So, for example,
       &ldquo;<literal>../..</literal>&rdquo; is valid.)  Once you
       upgrade your build trees to &abuild; 1.1, you will no longer
       have any <property>parent-dir</property> keys.  This check for
       existing <property>parent-dir</property> keys effectively just
       makes sure that whatever &abuild; 1.1 would now automatically
       figure out is consistent with you explicitly specified in your
       1.0 trees.
      </para>
     </listitem>
     <listitem>
      <para>
       Each value of the <property>child-dirs</property> key must now
       point down in the file system.  That is, the path element
       &ldquo;<literal>..</literal>&rdquo; may not appear in a
       <property>child-dirs</property> key.  This check is important
       to ensure that whatever parent/child relationships between
       build items &abuild; 1.1 would now automatically figure out is
       consistent with you explicitly specified in your 1.0 trees.
      </para>
     </listitem>
     <listitem>
      <para>
       The values of <property>child-dirs</property> keys may not be
       or cross over any symbolic links.  In most cases, use of
       symbolic links for child directories would not have worked in
       &abuild; 1.0 anyway and would have resulted in a cryptic error
       message.  Now &abuild; explicitly detects and disallows this
       case.
      </para>
     </listitem>
     <listitem>
      <para>
       If you use multi-element paths in your
       <property>child-dirs</property> keys (skipping directories),
       none of the intermediate directories may contain
       <filename>Abuild.conf</filename> files.  In other words, you
       can't <emphasis>interleave</emphasis> unrelated &abuild; trees.
       Trying to do this with &abuild; 1.0 would have been crazy
       anyway, but &abuild; would not have noticed if you tried.  Now
       it will notice and prevent you from doing so.  This check is
       required in order to ensure that &abuild; 1.1 is always able to
       accurately locate the parent of any build item.
      </para>
     </listitem>
    </itemizedlist>
   </sect1>
   <sect1 id="ref.new11.deprecated">
    <title>Deprecated Features</title>
    <para>
     This section includes a complete list of all features from
     &abuild; 1.0 that are deprecated in &abuild; 1.1.  Use of any of
     these features will generate a warning when running in
     1.0-compatibility mode.  When running in 1.1-compatibility mode,
     these features will not be recognized.  Depending on the nature
     of the feature, this may result in an error (such as using a
     deprecated <filename>Abuild.conf</filename> key), and in other
     cases, use of the feature will be ignored (such as setting a
     particular make variable).
    </para>
    <warning>
     <para>
      You should avoid trying to upgrade your
      <filename>Abuild.conf</filename> files by hand.  See earlier
      warnings in this chapter, and refer to <xref
      linkend="ref.upgrading-to-1.1"/> for details.
     </para>
    </warning>
    <variablelist>
     <varlistentry>
      <term>
       <filename>Abuild.conf</filename> keys
      </term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          Use of the <property>this</property> key is deprecated.
          This key has been replaced by <property>name</property>.
          When you run <command>abuild --upgrade-trees</command>
          (described in <xref linkend="ref.upgrading-to-1.1"/>), your
          <filename>Abuild.conf</filename> files will be updated
          automatically.
         </para>
        </listitem>
        <listitem>
         <para>
          The <property>deleted</property> key is deprecated.
          Item deletion is now specified with the
          <property>deleted-items</property> key in the
          <filename>Abuild.backing</filename> file.
         </para>
        </listitem>
        <listitem>
         <para>
          The <property>external-dirs</property> key is deprecated.
          External build trees have been replaced by tree dependencies
          as discussed in <xref
          linkend="ref.new11.new-tree-structure"/>
         </para>
        </listitem>
        <listitem>
         <para>
          The <property>parent-dir</property> key is deprecated.
          &Abuild; 1.1 automatically finds parent build items, thus
          rendering the <property>parent-dir</property> unnecessary.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <application>GNU Make</application> variables
      </term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          <varname>BUILD_ITEM_RULES</varname> is deprecated and has
          been replaced by a new and more flexible mechanism for
          specifying build-item supplied rules.  See <xref
          linkend="ref.code-generators"/> for details.
         </para>
        </listitem>
        <listitem>
         <para>
          <varname>LINK_SHLIBS</varname> is ignored and treated as if
          it were always set.  This change was actually made in
          version 1.0.3, but now use of <varname>LINK_SHLIBS</varname>
          generates a deprecation warning.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Properties for deprecated ant framework
      </term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          <varname>abuild.use-local-hooks</varname> is deprecated;
          &abuild;'s ant framework now acts as if this is always on.
          Note that the entire 1.0 ant framework is considered
          deprecated.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Command line arguments
      </term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          The <option>--ant</option> option is no longer supported
          since &abuild; no longer invokes ant.  However, for backward
          compatibility, &abuild; will still look through any
          <option>--ant</option> arguments for arguments of the form
          <option>-Dprop-val</option> and treat them as regular
          variable definitions (specified as just
          <option>prop=val</option> in &abuild; 1.1).
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Interface Variables
      </term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          The variable <varname>ABUILD_THIS</varname> should no longer
          be used as it has been replaced by the more descriptively
          named <varname>ABUILD_ITEM_NAME</varname>.  However, it is
          not actual deprecated since &abuild; has no way to detect
          and report its use in build files.  As such,
          <varname>ABUILD_THIS</varname> will likely not be removed in
          a future version of &abuild;, though its use in new code is
          discouraged.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <filename>Abuild.backing</filename> files
      </term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          In &abuild; 1.1, there is a new syntax for
          <filename>Abuild.backing</filename> files, and backing areas
          are at the forest level rather than at the tree level.  (For
          details, see <xref linkend="ref.backing-areas"/>.)
          <filename>Abuild.backing</filename> files that just contain
          a path name are deprecated.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.new11.small-changes">
    <title>Small, Localized Changes</title>
    <para>
     This section describes small, localized changes to &abuild;.
     Some of changes described here are small changes that be
     accommodated by editing individual build or configuration files.
     Others are new, special-purpose features.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       When &abuild; is invoked with no options, the effect is now as
       if the <option>--with-deps</option> or, equivalently,
       <option>--build=current</option> option had been specified.  To
       select the old behavior of building just the item without its
       dependencies, use the newly added <option>--no-deps</option>
       option.
      </para>
     </listitem>
     <listitem>
      <para>
       The preferred way of passing variables to backend build systems
       is now to specify <option>VAR=value</option> on the command
       line.  Such definitions are passed to all backends.  You should
       use this rather than the <option>--make</option> or (now
       deprecated and mostly unsupported) <option>--ant</option>
       option.
      </para>
     </listitem>
     <listitem>
      <para>
       &Abuild; has a new online help system, described in <xref
       linkend="ref.help-system"/>.  The targets
       <command>rules-help</command> and
       <command>interface-help</command> have been removed in favor of
       the new system.
      </para>
     </listitem>
     <listitem>
      <para>
       &Abuild; now prints elapsed clock time before it exits.
      </para>
     </listitem>
     <listitem>
      <para>
       When one or more build items fail, &abuild; now provides a
       summary that lists the failed build items.
      </para>
     </listitem>
     <listitem>
      <para>
       It is now possible to declare local and non-recursive interface
       variables and also to declare and initialize interface
       variables in a single statement.  For details, see <xref
       linkend="ref.abuild-interface-system"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       The new <filename>Abuild.conf</filename> key
       <property>name</property> replaces <property>this</property> as
       the way to provide the name of a build item.  Note that you
       should not go around replacing <property>this</property> with
       <property>name</property> manually in existing
       <filename>Abuild.conf</filename> files as &abuild; will do this
       automatically when you run <command>abuild
       --upgrade-trees</command> (<xref
       linkend="ref.upgrading-to-1.1"/>).
      </para>
     </listitem>
     <listitem>
      <para>
       The new <filename>Abuild.conf</filename> key
       <property>attributes</property> can be used to assign
       particular supported attributes to build items.  For details,
       see <xref linkend="ref.abuild.conf-syntax"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       It is possible to declare plugins to be global.  Global plugins
       are discussed in <xref linkend="ref.global-plugins"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       Build item dependencies and also newly added build tree
       dependencies can be declared optional; see <xref
       linkend="ref.optional-dependencies"/>.  To go along with this,
       child directories specified in <property>child-dirs</property>
       can also be made optional.
      </para>
     </listitem>
     <listitem>
      <para>
       The <envar>ABUILD_FORCE_32BIT</envar> environment variable is
       no longer considered temporary, and the
       <envar>ABUILD_FORCE_64BIT</envar> has been added to encourage
       &abuild; to generate code of the specified word size.  It is
       initially only supported for builds that use the
       <command>gcc</command> compiler.  A future version of &abuild;
       may offer a better solution.
      </para>
     </listitem>
     <listitem>
      <para>
       The <filename>msvc</filename> toolchain can now be configured
       to make it easier to support different runtime and management
       flags, making it possible to build applications that statically
       link the runtime environment or work with the .NET framework.
       For details, see <xref linkend="ref.msvc"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       Shared library version information is now partially supported
       when building DLL files.  For details, see <xref
       linkend="ref.shared-libraries"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       The behavior of when expansion of the build set is repeated
       during application of <option>--related-by-traits</option> has
       changed and is now controlled by
       <option>--repeat-expansion</option>.  For details, see <xref
       linkend="ref.construction-of-build-sets"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       The new argument <option>--with-rdeps</option> can be used to
       add reverse dependencies of all specified items to the build
       set.
      </para>
     </listitem>
     <listitem>
      <para>
       The new command line option <option>--find</option> has been
       added to print the location of build items or build trees.
      </para>
     </listitem>
     <listitem>
      <para>
       The new command line options <option>--ro-path</option> and
       <option>--rw-path</option> have been added to allow certain
       parts of the build tree to be treated as read only.  For
       details, see <xref linkend="ref.read-only-paths"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       The new command line argument <option>--compat-level</option>
       and environment variable <envar>ABUILD_COMPAT_LEVEL</envar>
       have been added to specify &abuild;'s compatibility level.
       &Abuild; will not support any features that were deprecated at
       a version equal to or older than the specified compatibility
       level.
      </para>
     </listitem>
     <listitem>
      <para>
       Some build sets will build more items in an upgraded forest
       than they would have in version 1.0.  For example, the build
       set <option>all</option> now really builds all items including
       those in trees that your starting build item's tree doesn't
       depend on.  Also, the build set <option>desc</option> will
       really include all build items at or below the current
       directory even if they are in trees that are not dependencies
       of the current tree.
      </para>
     </listitem>
     <listitem>
      <para>
       A new build set, <option>deptrees</option>, has been added.
       This build set includes all items in the current tree and its
       tree dependencies.  It essentially does what
       <option>all</option> did in version 1.0.  These concepts are
       described in <xref linkend="ref.multiple-trees"/>.  See also
       <xref linkend="ref.new11.new-tree-structure"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       The <command>clean</command> target is no longer passed to the
       backend when &abuild; is invoked from an output directory.  All
       <command>clean</command> targets have been removed from rules
       provided by &abuild; and from the examples.
      </para>
     </listitem>
     <listitem>
      <para>
       Platform-specific dependencies on <type>object-code</type>
       build items are now influenced platform selectors.  To create a
       dependency on the default platform of a given platform type
       regardless of platform selectors (which was the old behavior),
       specific
       <option>-platform=<replaceable>type</replaceable>:default</option>
       in your dependency declaration.
      </para>
     </listitem>
     <listitem>
      <para>
       The <command>list_platforms</command> script, for plugins that
       add platforms, is now invoked with information about the native
       platform.  See <xref linkend="ref.adding-platforms"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       A new utility has been added to help with caching the results
       of code generators.  For details, see <xref
       linkend="ref.codegen-wrapper"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       A new file, <filename>preplugin.mk</filename>, can now contain
       make code to be run by every selected plugin
       <emphasis>before</emphasis> <filename>Abuild.mk</filename> is
       loaded.  This can be used to provide initialization of certain
       variables, among other purposes.
      </para>
     </listitem>
     <listitem>
      <para>
       QTest support now automatically exports the
       <varname>TC_SRCS</varname> variable to the environment, so
       individual <filename>Abuild.mk</filename> files no longer need
       to do so.
      </para>
     </listitem>
     <listitem>
      <para>
       The <command>verify-compiler</command> command now accepts the
       <option>--cross</option> option to better support cross
       compilers that are in the <type>native</type> platform type.
       See <xref linkend="ref.adding-toolchains"/> for a discussion.
      </para>
     </listitem>
   </itemizedlist>
   </sect1>
   <sect1 id="ref.new11.groovy-backend">
    <title>Groovy-based Backend for Java Builds</title>
    <para>
     An entirely new backend has been added to support Java builds,
     replacing the ant framework from &abuild; 1.0.  The new framework
     uses ant through a Groovy backend.  For details, see <xref
     linkend="ref.abuild.groovy"/>.
    </para>
   </sect1>
   <sect1 id="ref.new11.new-tree-structure">
    <title>Redesigned Build Tree Structure</title>
    <para>
     &Abuild; 1.1 introduces a new build tree structure that replaces
     externals with named trees and named tree dependencies.  In
     &abuild; 1.0, one build tree established a one-way relationship
     with another tree, gaining the ability to use the other tree's
     build items without making its own build items available to the
     other tree, by declaring the other tree as an external.
     Externals were set up by specifying a relative path to the other
     tree.  Externals could be resolved in backing areas by resolving
     that relative path as relative to the backing area instead of to
     the tree itself.
    </para>
    <para>
     There were three major problems with this approach.  The first
     and most important problem is that externals were based on path.
     Not only is this in violation of a fundamental design principle
     of &abuild;, but it forced build environments with multiple trees
     to organize those trees in a strict relative directory structure.
     Worse, knowledge of that directory structure was not contained in
     any one location but was, instead, spread out among all the root
     build trees in the system.  This made it very hard to reuse
     specific trees across multiple projects or even across multiple
     configurations of the same project.  The second problem with the
     1.0 scheme was that there was no way for you to get a complete
     list of all the trees that comprised any given build environment.
     The third problem is that the interaction with backing areas an
     externals was too complex and didn't scale.  People were never
     really able to understand how backing areas and externals
     interacted.
    </para>
    <para>
     &Abuild; 1.1 resolves all of these problems by requiring build
     trees to be named and by setting up the one-way relationship
     among build trees through named tree dependencies.  The new
     mechanism is discussed in detail in <xref
     linkend="ref.multiple-trees"/>.  Here is a brief summary of the
     changes:
     <itemizedlist>
      <listitem>
       <para>
        &Abuild; 1.1 introduces the term <emphasis>build
        forest</emphasis> to refer to the collection of all the build
        trees that are built together.  The 1.1 concept of build
        forests roughly corresponds to an &abuild; 1.0 build tree with
        all of its externals.
       </para>
      </listitem>
      <listitem>
       <para>
        The <property>this</property> key has been replaced with
        <property>name</property>.
       </para>
      </listitem>
      <listitem>
       <para>
        Build trees are required to be named.  Root build items must
        contain a key called <property>tree-name</property> which
        gives the name of the tree.
       </para>
      </listitem>
      <listitem>
       <para>
        Rather than using the deprecated
        <property>external-dirs</property> key to indicate by path a
        one-way dependency on another build tree, use
        <property>tree-deps</property> to indicate this dependency
        using the <emphasis>name</emphasis> of the other build tree.
        This removes &abuild;&nbsp;1.0's flawed use of paths for this
        purpose.
       </para>
      </listitem>
      <listitem>
       <para>
        The <property>parent-dir</property> key is no longer used.
       </para>
      </listitem>
      <listitem>
       <para>
        It is permissible to have <filename>Abuild.conf</filename>
        files above the roots of all your build trees that contain
        only <filename>child-dirs</filename> keys.  These files, in
        addition to build tree root files, may be roots of the entire
        forest of build trees.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Additionally, the way backing areas work has been significantly
     improved.  Backing areas are discussed in <xref
     linkend="ref.backing-areas"/>.  Here is a summary of the changes:
     <itemizedlist>
      <listitem>
       <para>
        Backing areas are at the forest level, not at the tree level.
        When &abuild; 1.1 is used, any given development effort
        requires only a single <filename>Abuild.backing</filename>
        file, and that file will be located at the root of the forest.
        In 1.0 compatibility mode, &abuild; will still use information
        from old style <filename>Abuild.backing</filename> files at
        the roots of not-yet-upgraded trees in the forest, though such
        files are considered deprecated.
       </para>
      </listitem>
      <listitem>
       <para>
        <filename>Abuild.backing</filename> files are now key/value
        pairs like <filename>Abuild.conf</filename> files.  Valid keys
        are <property>backing-areas</property>,
        <property>deleted-trees</property>, and
        <property>deleted-items</property>.
       </para>
      </listitem>
      <listitem>
       <para>
        The paths to your backing areas are specified as the value to
        the <property>backing-areas</property> key in
        <filename>Abuild.backing</filename>.  You may now have
        multiple backing areas.  &Abuild; will issue an error if
        unrelated backing areas try to supply build items or build
        trees with the same name.  (If one of your backing areas backs
        to another one of your backing areas, &abuild; will notice
        this case and handle it appropriately.)
       </para>
      </listitem>
      <listitem>
       <para>
        The <property>deleted</property> key is no longer valid in
        <filename>Abuild.conf</filename>.  Instead, use the
        <property>deleted-items</property> key in
        <filename>Abuild.backing</filename>.  In 1.0 compatibility
        mode, &abuild; will still read the information from the
        <filename>Abuild.conf</filename> file and treat it as if it
        had been read from an <filename>Abuild.backing</filename>
        file.
       </para>
      </listitem>
      <listitem>
       <para>
        It is possible to suppress inheritance of entire trees from
        backing ares using the <property>deleted-trees</property> key
        in <filename>Abuild.backing</filename>.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
  </appendix>
  <appendix id="ref.upgrading-to-1.1">
   <title>Upgrading from 1.0 to Version 1.1</title>
   <note>
    <para>
     &Abuild; is purposely stealth about pinpointing specific
     locations of outdated constructs in trees that are not upgraded
     to encourage you to use the automated upgrade process.  If you
     are working in a previously upgraded tree and some deprecated
     feature has snuck back in but you can't find where it is, the
     easiest way to find it is to run in 1.1-compatibility mode.  Most
     outdated constructs will generate errors in 1.1-compatibility
     mode.
    </para>
   </note>
   <para>
    &Abuild; 1.1 offers many new capabilities relative to 1.0.  These
    are summarized in <xref linkend="ref.changes-in-1.1"/>.  Among the
    most significant of these changes is the redesigned build tree
    structure.  When &abuild; 1.1 is run on a set of build trees that
    were created to work with &abuild; 1.0, it internally maps the old
    structure into its new representation.  &Abuild; can make this
    mapping explicit by actually upgrading your trees from 1.0 to 1.1.
    To use &abuild; to upgrade your trees, you can run the command
    <command>abuild --upgrade-trees</command>.  &Abuild; will analyze
    your build area and generate a file that you have to edit.  By
    editing this file, you supply the information that &abuild; can't
    possibly know on its own.  Once all the information is available,
    &abuild; will rewrite your <filename>Abuild.conf</filename> and
    <filename>Abuild.backing</filename> files.  In this chapter, we
    discuss a general strategy for upgrading and then proceed to
    provide specific instructions.
   </para>
   <sect1 id="ref.upgrade11.strategy">
    <title>Upgrade Strategy</title>
    <para>
     &Abuild; 1.1 can operate in 1.0 compatibility mode.  If you are
     testing out &abuild; 1.1 on a build tree that is still under
     active development with &abuild; 1.0, you should obviously wait
     before you try to upgrade the trees.  Once you have upgraded your
     build trees, &abuild; 1.0 will no longer be able to build them.
    </para>
    <para>
     As a general rule, it's best to start your upgrade process with
     build trees that don't have any backing areas.  This will save
     you a lot of trouble.  Most of the time, if you have backing
     areas and your backing areas are already upgraded, &abuild;'s
     upgrade process can run without any intervention.  But we'll come
     back to that in the next section.
    </para>
    <para>
     Once you are ready to start upgrading, the first thing you should
     do is to make sure your build is working with &abuild; 1.0.  You
     must be sure to start with this as a known baseline so you can be
     sure problems that you find during upgrade weren't already there.
    </para>
    <para>
     The next thing you should do is to make sure your build still
     works with &abuild; 1.1 running in 1.0-compatibility mode, which
     you can enable by passing <option>--compat-level="1.0"</option>
     on the command line or by setting the environment variable
     <envar>ABUILD_COMPAT_LEVEL</envar> to
     &ldquo;<literal>1.0</literal>&rdquo;.  There are a small number
     of non-compatible changes (<xref
     linkend="ref.new11.non-compatible"/>).  If your build trees run
     into any of those, you should try to fix them in a way that is
     still compatible with &abuild; 1.0.  You should fairly quickly be
     able to reach a point where you have a build tree that builds the
     same way under 1.0 and 1.1.  Only when you have reached this
     stage should you attempt to upgrade.  If you run into trouble
     during this process, ask for help or consult <xref
     linkend="ref.upgrade11.caveats"/>.
    </para>
    <para>
     Once you have your build trees in a state where your build
     produces identical results with both &abuild; 1.0 and 1.1, you
     should find a directory that is above all the trees you are
     trying to upgrade.  If your intention is to upgrade an entire
     forest of trees at once, meaning that you wish to upgrade a
     collection of build trees that refer to each other through
     <property>external-dirs</property>, you should go to a common
     ancestor of all those trees.  This will be the root of your
     upgraded build forest.  If you only wish to upgrade specific
     trees, you can just go to the root of the trees you are
     upgrading.  The upgrade process will allow you to upgrade your
     forests a little bit at a time.  This is especially important for
     distributed development environments in which different trees are
     maintained by different teams.  Whichever case you pick, your
     starting directory must either contain a root build item or be
     above the top of trees with root build items.  You can't pick a
     directory that's in the middle of a build tree.  For example, you
     can't start in a directory that has a
     <property>parent-dir</property> key or that is referred to as a
     child in a higher <filename>Abuild.conf</filename> file.
    </para>
    <para>
     Once you have identified your start directory, you should run
     <command>abuild --upgrade-trees</command> and follow the upgrade
     process as described in <xref
     linkend="ref.upgrade11.procedures"/>.  At the end of that
     process, your trees will be upgraded, but you are not done yet!
     There are still a few ways in which things can be broken, so read
     on.
    </para>
    <para>
     After you have finished this stage of the upgrade process, you
     should once again run &abuild; in 1.0-compatibility mode to make
     sure your build still works.  If you run into problems, please
     consult <xref linkend="ref.upgrade11.caveats"/>.
    </para>
    <para>
     Once your build is once again working as it should, you will want
     to address deprecation errors that are reported by the backends.
     Mostly this would involve moving build item-supplied rules from
     <filename>Rules.mk</filename> to their new locations under
     <filename>rules</filename> (see <xref
     linkend="ref.code-generators"/>) and then replacing
     <varname>BUILD_ITEM_RULES</varname> with appropriate
     <varname>RULES</varname> entries by the items that use them.  You
     could also remove <varname>LINK_SHLIBS</varname> variables that
     you find.  After you have done this, you should hopefully reach a
     point where you are no longer getting any deprecation warnings.
    </para>
    <para>
     When you think you have eliminated all deprecation warnings, you
     should retry your build in 1.0-compatibility mode with the
     <option>--deprecation-is-error</option> flag.  In this mode, any
     deprecated features will be reported as errors instead of
     warnings.  Once your build gets past this point, then you can be
     confident that you are no longer using any deprecated features.
    </para>
    <para>
     If you have upgraded a tree that has externals that point into an
     area that has not yet been upgraded, though you won't be getting
     any deprecation warnings, &abuild; will still tell you that it
     sees deprecated features and that you should upgrade.  This is
     because your root build item will still have a
     <property>external-dirs</property> key in it.  &Abuild; is not
     warning you about it specifically because there's nothing you can
     do about it if the directory it points to is the root of a tree
     that hasn't been upgraded yet.  The solution to this problem is
     to run the upgrade process from a higher level directory to
     upgrade the other tree.  If you can't do that, you'll just have
     to wait until the other tree is upgraded.  As soon as it is,
     &abuild; will notify you that you have an
     <property>external-dirs</property> that points to the root of an
     upgraded tree.  Then you can run <command>abuild
     --upgrade-trees</command> again to let &abuild; replace the
     <property>external-dirs</property> key with
     <property>tree-deps</property>.  In the mean time, you will
     continue to see the upgrade suggestion until
     <emphasis>all</emphasis> your build trees have been upgraded.
    </para>
    <para>
     When you finally get to the point where all your build trees are
     upgraded, you should once again run with the
     <option>--deprecation-is-error</option> flag.  This will give you
     one last check that you are not using any deprecated features.
     Once that passes, you are finally ready to try running in
     1.1-compatibility mode.  To do this, either run &abuild; with
     <option>--compat-level=1.1</option>, set the
     <envar>ABUILD_COMPAT_LEVEL</envar> environment variable to the
     value &ldquo;<literal>1.1</literal>&rdquo;, or just unset
     <envar>ABUILD_COMPAT_LEVEL</envar> and don't specify a
     compatibility level on the command line.  If all goes well, you
     should see no difference.  Once you have reached this point, you
     can be sure that your upgrade process is complete.
    </para>
   </sect1>
   <sect1 id="ref.upgrade11.caveats">
    <title>Potential Upgrade Problems: Things to Watch Out For</title>
    <para>
     For the most part, &abuild; upgrades are expected to be quite
     smooth as extensive testing as been done to &abuild;'s
     compatibility mode.  There are a few subtleties that might cause
     problems.  Here are some things to watch out for.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       If you have upgraded some trees in a forest and not others, you
       may have build trees that are fully upgraded except that they
       still contain <property>external-dirs</property> keys in their
       <filename>Abuild.conf</filename> files.  If this happens, when
       you run &abuild;, you will get a warning that tells you that
       you should run <command>abuild --upgrade-trees</command>.
       However, if you try to run the upgrade process from the root of
       that tree, it will tell you that there is nothing to upgrade.
       The solution is to run the upgrade process from a directory
       that is above all the externals that are still there.  Once the
       externals are upgraded, then &abuild; will be able to replace
       the remaining <property>external-dirs</property> keys with
       <property>tree-deps</property>.
      </para>
     </listitem>
     <listitem>
      <para>
       In &abuild; 1.0, if you have a collection of trees that refer
       to each other through their <property>external-dirs</property>
       keys, in the context of any tree, &abuild; only knows about
       items that are reachable from that tree.  In &abuild; 1.1,
       &abuild; knows about all items that are reachable from any tree
       in the forest.  For example, if you have trees
       <filename>A</filename> and <filename>B</filename> that both
       refer to <filename>C</filename> but don't refer to each other,
       in &abuild; 1.0, <filename>A</filename> and
       <filename>B</filename> could have build items with the same
       name.  This would work because &abuild; would never know about
       <filename>A</filename> and <filename>B</filename> at the same
       time.  If you came along later and make build tree
       <filename>D</filename> refer to both <filename>A</filename> and
       <filename>B</filename>, you would get an error message at that
       time since &abuild; would complain about seeing the same item
       in multiple locations.  In &abuild; 1.1, &abuild; would know
       about all three trees and would immediately complain that
       <filename>A</filename> and <filename>B</filename> both
       contained an item with the same name.  So it's possible that,
       after running the upgrade process, you may need to rename some
       build items.  If you have been careful to stick to build item
       naming conventions that avoid duplications across tree
       boundaries, you should not run into this problem.  During alpha
       testing of &abuild; 1.1, at least one case was encountered in
       which a build item had been copied from one tree to an
       unrelated tree without changing its name.  &Abuild; was able to
       upgrade the all the trees and complained about the problem
       after the upgrade was finished.
      </para>
     </listitem>
     <listitem>
      <para>
       When &abuild; 1.1 encounters a build item with neither a
       <property>tree-name</property> key nor a
       <property>parent-dir</property> key, and if that build item is
       not referenced as a child of the next higher build item,
       &abuild; can't tell whether it is the root of a
       non-yet-upgraded build tree or whether it just hasn't been
       properly added to its parent's <filename>Abuild.conf</filename>
       as a child.  In 1.0-compatibility mode, &abuild; will guess
       that it's missing from its parents
       <filename>Abuild.conf</filename> if there is a
       <property>name</property> key.  Otherwise, it will guess that
       it is the root of a forest.  In 1.1-compatibility mode,
       &abuild; will issue an error.  If you are running in
       1.0-compatibility mode on upgraded trees and you get
       unexplained errors about build items not being known, you might
       first try running in 1.1-compatibility mode where you might get
       a better error message.  If you have intentionally left it out
       of the parent's <filename>Abuild.conf</filename> file because
       you want to disable the build item for some reason, then you
       must either enter this directory in the ignored directories
       section of the <filename>abuild.upgrade-data</filename> file or
       add it back as a child of its parent during the upgrade process
       and remove it again later.
      </para>
     </listitem>
     <listitem>
      <para>
       In the make backend, compiler toolchain implementation files
       are now loaded before <filename>Abuild.mk</filename>.  Most of
       the time, this won't matter, but sometimes it might,
       particularly in the case of errors in
       <filename>Abuild.mk</filename> that may have not mattered
       before.  For example, a <filename>Abuild.mk</filename> file may
       check to see whether a variable is defined or not and take some
       action based on that.  If the variable in question is defined
       by a toolchain support file, it could change the semantics of
       such a check.  At least one case was found during testing in
       which a <filename>Abuild.mk</filename> file assigned to
       <varname>XCPPFLAGS</varname> using
       &ldquo;<literal>:=</literal>&rdquo; in
       <filename>Abuild.mk</filename> thus overwriting values supplied
       by the interface system.  Additional values supplied by the
       toolchain support file in turn modified the value as supplied
       by the user's <filename>Abuild.mk</filename>, which allowed the
       incorrect assignment to go unnoticed.  With the 1.1 load
       ordering change, the error in <filename>Abuild.mk</filename>
       suddenly caused the build to stop working.
      </para>
      <para>
       Again, in the vast majority of cases,
       <filename>Abuild.mk</filename> files should not need to be
       changed as a result of this ordering change, but if your
       <filename>Abuild.mk</filename> is inspecting or modifying
       variables that are also used by the toolchain support files,
       you may see a slight change in semantics.
      </para>
     </listitem>
    </itemizedlist>
   </sect1>
   <sect1 id="ref.upgrade11.procedures">
    <title>Upgrade Procedures</title>
    <para>
     This section covers the specific steps involved in running
     <command>abuild --upgrade-trees</command> to upgrade the
     <filename>Abuild.conf</filename> and
     <filename>Abuild.backing</filename> files in your tree.  Recall
     that this is only one step of the overall upgrade process, though
     it is the most significant step.
    </para>
    <note>
     <para>
      The <command>abuild --upgrade-trees</command> process will
      create some new files and will remove or modify some old files,
      always saving the old versions.  When you run <command>abuild
      --upgrade-trees</command>, it is highly recommend that you
      capture the output using <command>script</command> or
      <command>tee</command> so you can see a log of exactly which
      files were removed, added, and changed by the process.
     </para>
    </note>
    <sect2 id="ref.upgrade11.procedures.outline">
     <title>High-level Summary of Upgrade Process</title>
     <para>
      Here is an outline of the basic process:
      <itemizedlist>
       <listitem>
        <para>
         Change your current directory (<command>cd</command>) to a
         directory that is above all your build trees and that you
         wish to use as the new <emphasis>forest root</emphasis>.
         This should be a common ancestor of all the trees you wish to
         upgrade.
        </para>
       </listitem>
       <listitem>
        <para>
         Run <command>abuild --upgrade-trees</command>.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; analyze all <filename>Abuild.conf</filename> files
         that it finds at or below your starting directory.  It will
         then generate a file called
         <filename>abuild.upgrade-data</filename> that you will have
         to edit.  Edit the file as described below.
        </para>
       </listitem>
       <listitem>
        <para>
         Once you have filled in all required information in
         <filename>abuild.upgrade-data</filename>, rerun
         <command>abuild --upgrade-trees</command>.  This time, it
         will perform the upgrade by rewriting any
         <filename>Abuild.conf</filename> or
         <filename>Abuild.backing</filename> that needs to be
         rewritten.  The original file will be renamed to
         <filename>Abuild.conf-1_0</filename> or
         <filename>Abuild.backing-1_0</filename>.  When you are
         satisfied with the upgrade, you can delete the
         <filename>*-1_0</filename> files, as those files are never
         used by &abuild;.  You should also be sure to remove deleted
         files and check in added and modified files with your version
         control system.  Remember that, in addition to modifying
         files, some files may be added or removed.
        </para>
       </listitem>
      </itemizedlist>
     </para>
     <para>
      Generally, if you have a backing area, you should upgrade the
      backing area first.  If your backing areas are set up such that
      each tree backs to the corresponding tree in the backing area
      and if you have not added any new trees in your area, the
      upgrade of your regular area may work without any intervention,
      as &abuild; will use the backing area to figure out tree names
      for trees that are backed.
     </para>
     <para>
      Among the most significant changes to &abuild; for version 1.1
      is the requirement that all build trees have names.  In order
      for &abuild; to upgrade your trees from version 1.0 to version
      1.1, it will need to know what name you wish to assign to all
      your build trees.  You will use the
      <filename>abuild.upgrade-data</filename> file to provide this
      information to abuild.
     </para>
     <para>
      Note that &abuild;'s upgrade process is extremely tolerant of
      partially upgraded forests.  It uses exactly the same logic as
      &abuild;'s normal build process (it <emphasis>is</emphasis> part
      of &abuild;, after all) to internally map a forest consisting of
      a mixture of 1.0 and 1.1 files into an internal 1.1 structure.
      The main difference between the upgrade procedure and &abuild;'s
      normal build process is that, when upgrading, &abuild; requires
      you to provide names of previously unnamed trees, while during
      the build process (in 1.0-compatibility mode only) it will
      generate a temporary name on the fly.  So if a tree already has
      a name, or if &abuild; can figure out what its name is from a
      backing area, it will use that information.  Otherwise, it will
      use the information you supply in
      <filename>abuild.upgrade-data</filename>.
     </para>
     <para>
      Once it has all the required information, abuild will insert the
      <property>tree-name</property> key into the root
      <filename>Abuild.conf</filename> file of every tree, and it will
      replace any <property>external-dirs</property> keys with
      <property>tree-deps</property> keys.  It will also remove
      <property>parent-dir</property> keys, replace
      <property>this</property> with <property>name</property>,
      upgrade <filename>Abuild.backing</filename> files including
      merging tree-level <filename>Abuild.backing</filename> files
      into a single forest-level <filename>Abuild.backing</filename>
      file, and remove any occurrences of <property>deleted</property>
      from root <filename>Abuild.conf</filename> files, moving the
      information into the <property>deleted-items</property> key of
      the new forest-wide <filename>Abuild.backing</filename> file.
      In addition, if you have any trees that are nested inside your
      existing trees, &abuild; will add
      <property>child-dirs</property> entries to those root items'
      parent <filename>Abuild.conf</filename> files to connect them
      into the forest.  (Recall that, in &abuild; 1.1, nested tree
      roots are discovered through <property>child-dirs</property>
      just like any other build items.  In 1.0, they were connected
      into the forest using path names in other trees'
      <property>external-dirs</property> keys instead.)
     </para>
     <para>
      During the analysis process, &abuild; will find all tree roots
      at or below your starting directory.  It will study them,
      examining any <property>external-dirs</property> or
      <property>tree-deps</property> keys to figure out which trees
      refer to which other trees.  It will then group trees into
      separate, independent forests so that it can upgrade each forest
      separately.  The list of forests is generated such that no tree
      in one forest refers to any tree in another forest through any
      of its items' <filename>Abuild.conf</filename> files.  In many
      cases, you will find that there is only one forest.  However, if
      you have self-contained collections of build trees nested within
      your primary forest, those will be recognized as separate.  This
      could happen for several reasons, including the following:
      <itemizedlist>
       <listitem>
        <para>
         Maybe you used &abuild; to build some self-contained,
         third-party software and you kept a copy of the
         <filename>Abuild.conf</filename> files.
        </para>
       </listitem>
       <listitem>
        <para>
         You might have test suites that contain self-contained build
         trees.  This is certainly true of &abuild;'s own source tree
         which contains numerous self-contained build trees in its own
         test suite.
        </para>
       </listitem>
       <listitem>
        <para>
         You may have stray <filename>Abuild.conf</filename> files
         that you never actually connected into your regular build
         trees.  You might just be able to delete them as part of the
         upgrade process.
        </para>
       </listitem>
      </itemizedlist>
     </para>
     <para>
      For each independent forest &abuild; finds, it will pick a
      top-level directory for that forest.  This will be the lowest
      directory &abuild; can find that is a common ancestor of all the
      trees in the forest.  This directory might, in some cases, be
      the root of one of the trees in the forest.  If not, it might be
      a directory that contains no <filename>Abuild.conf</filename>
      file.  In that case, &abuild; will create a
      <filename>Abuild.conf</filename> file containing only a
      <property>child-dirs</property> key whose value is the relative
      paths to all the root directories of all the build trees in the
      forest.  You may wish to manually edit this file depending on
      how you intend to organize your forest.  In some cases, &abuild;
      may include references to trees that are not always present.
      When this happens, you may wish to add the
      <option>-optional</option> flag after the directory name in the
      <property>child-dirs</property> key.
     </para>
    </sect2>
    <sect2 id="ref.upgrade11.procedures.editing">
     <title>Editing <filename>abuild.upgrade-data</filename></title>
     <para>
      This section describes how to edit the
      <filename>abuild.upgrade-data</filename> file. Here's a
      &ldquo;quick start&rdquo; for the impatient or those who are
      already basically familiar with the process:
      <itemizedlist>
       <listitem>
        <para>
         For each directory whose contents you wish to (recursively)
         ignore (such as nested trees you're not ready to upgrade),
         place the directory in the [ignored-directories] section.
         Place one directory per line, and specify directories
         relative to the one containing the
         <filename>abuild.upgrade-data</filename> file.
        </para>
       </listitem>
       <listitem>
        <para>
         For each remaining detected build tree root below, replace
         &ldquo;<literal>***</literal>&rdquo; with the name you intend
         to give the tree.
        </para>
       </listitem>
       <listitem>
        <para>
         Lather, rinse, repeat.
        </para>
       </listitem>
      </itemizedlist>
     </para>
     <para>
      The <filename>abuild.upgrade-data</filename> file is a
      configuration file used to assist <command>abuild
      --upgrade-trees</command>.  Every time <command>abuild
      --upgrade-trees</command> is run, it will replace this file, so
      any comments or formatting changes you make will be lost.  Any
      tree names you assign will be preserved even if &abuild; no
      longer believes the directory is a tree root, so it is very
      unlikely that &abuild; will throw away work you have already
      done toward editing this file.  If you're paranoid, make a
      backup copy of <filename>abuild.upgrade-data</filename> before
      rerunning <command>abuild --upgrade-trees</command>.
     </para>
     <para>
      The abuild.upgrade-data file consists of sections Each section
      is opened with a line of the form

      <programlisting>[<replaceable>section-name</replaceable>]
</programlisting>
      where <replaceable>section-name</replaceable> is replaced by one
      of the valid section names.
     </para>
     <para>
      There are three sections:
      <variablelist>
       <varlistentry>
        <term><property>[ignored-directories]</property></term>
        <listitem>
         <para>
          lists directories that will be skipped during the upgrade
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><property>[forest]</property></term>
        <listitem>
         <para>
          a repeatable section; one occurs for each group of trees
          that &abuild; finds to be in a given forest
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><property>[orphan-trees]</property></term>
        <listitem>
         <para>
          an optional section used to hang onto names previously
          assigned to any trees root at directories that no longer
          appear in a known forest
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      If there are directories below the start directory that you wish
      to ignore during the conversion process, list them in the
      <property>[ignored-directories]</property> section.  &Abuild;
      will ignore those directories when looking for
      <filename>Abuild.conf</filename> files.
     </para>
     <para>
      In each forest that &abuild; discovers, it will require a name
      for each tree.  If the tree already has a name, that name will
      appear in the file.  Otherwise, the place-holder
      &ldquo;<literal>***</literal>&rdquo; will appear.  Your job is
      to go through and replace all occurrences of
      &ldquo;<literal>***</literal>&rdquo; with the name you wish to
      assign to the tree rooted at that directory.
     </para>
     <para>
      In some cases, there may be a tree that you are not ready to
      upgrade, perhaps because that tree is still being used by a
      project that hasn't yet upgraded its version of abuild.  In that
      case, just list the path to the root of the tree in the
      <property>[ignored-directories]</property> section.  You do not
      need to remove it from the <property>[forest]</property> section
      in which it appears; &abuild; will remove it from there
      automatically next time it writes the file.  If you subsequently
      change your mind and remove the path from
      <property>[ignored-directories]</property>, &abuild; will move
      it back to the appropriate <property>[forest]</property>
      section.  This is also where <property>[orphan-trees]</property>
      comes into play: if you had assigned a name to a tree that ended
      up later under an ignored directory, that path and assigned name
      will get moved to <property>[orphan-trees]</property>.  if you
      later remove the ignored directory entry, &abuild; will move the
      path back out of <property>[orphan-trees]</property> so you will
      not lose the name you previously assigned to the tree.
     </para>
     <para>
      Abuild is able to perform the actual upgrade when all of the
      following conditions are met:
      <itemizedlist>
       <listitem>
        <para>
         &Abuild; is able to parse all
         <filename>Abuild.conf</filename> files at or below the
         current directory, excluding any ignored directories, without
         finding any errors.
        </para>
       </listitem>
       <listitem>
        <para>
         Every <property>external-dirs</property> entry exists or can
         be resolved through a backing area.  There is one exception,
         discussed below.
        </para>
       </listitem>
       <listitem>
        <para>
         No <property>external-dirs</property> entries cross over any
         symbolic links
        </para>
       </listitem>
       <listitem>
        <para>
         Every tree root listed in every <property>[forest]</property>
         section has a name assigned to it.
        </para>
       </listitem>
       <listitem>
        <para>
         Every tree that abuild finds during its scan as well as every
         <property>external-dirs</property> entry referenced by those
         trees that points to a place at or below the start directory
         appears in a <property>[forest]</property> section and has a
         name assigned to it.
        </para>
       </listitem>
      </itemizedlist>
     </para>
     <para>
      &Abuild; is usually able to upgrade forests with backing areas,
      but it will not do so if any externals resolve to 1.0-style
      trees in backing areas.  (That is, the external doesn't exist
      relative to the tree that declares it but does exist relative to
      that tree's backing area.)  In that case, you must either
      upgrade the backing area first (which is the recommended
      practice) or make the external resolve locally.  You can make
      the external local by just creating a directory and populating
      it with an <filename>Abuild.conf</filename> and an
      <filename>Abuild.backing</filename>.  The reason for this
      restriction is that &abuild; will not read the
      <filename>Abuild.backing</filename> file of an upgraded tree
      root that is not at the root of a forest.  This means that
      &abuild; would no longer be able to resolve the external in the
      backing area.  As discussed, it is best to upgrade your backing
      area first anyway since upgrades to forests with upgraded
      backing areas often require no manual intervention.
     </para>
    </sect2>
   </sect1>
  </appendix>
  <appendix id="ref.known-limitations">
   <title>Known Limitations</title>
   <para>
    Here we list known limitations of &abuild;.  These limitations will
    hopefully be addressed over time.
   </para>
   <variablelist>
    <varlistentry>
     <term>dependence on Cygwin for <application>make</application> on
     Windows</term>
     <listitem>
      <para>
       On Windows, using &abuild; to build Java code works fine and
       should be comparable in performance to building Java code with
       &abuild; on a UNIX platform.  For C/C++ builds, &abuild; uses Cygwin
       for GNU Make and perl.  It can use Visual Studio for compilation
       and can produce targets that don't depend on Cygwin, but
       &abuild; itself uses Cygwin.  The overhead of running things in
       Cygwin is very high, and the result is that &abuild; for C/C++ is
       slow on Windows even though the Windows compilers are actually
       quite fast.  We need to get &abuild; working properly with a
       native GNU Make and remove the last uses of perl from &abuild;,
       which means rewriting <command>gen_deps</command> in C++ or
       otherwise folding it into the &abuild; sources.  The automated
       test system that is integrated in &abuild; is likely to stay in
       perl and likely to continue to require Cygwin, but perhaps that
       can be rewritten or can be ported to a native perl when a native
       Windows perl that supports the <varname>"|-"</varname> form of
       open is released.  Empirical tests suggest that compiling
       multiple source files at once results in negligible performance
       improvement.  Most of the performance penalty on Windows appears
       to be spawning processes, particularly when Cygwin is involved.
       This is true, however, even with Visual Studio's nmake utility
       and not the result of something about how &abuild; is implemented.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Incomplete mingw Support</term>
     <listitem>
      <indexterm>
       <primary>mingw</primary>
      </indexterm>
      <para>
       Although mingw is partially supported and the mingw compiler
       passes the compiler verification support, mingw support is not
       really complete in &abuild;.  In particular, we only offer
       mingw as a valid compiler if the <envar>MINGW</envar>
       environment variable is set to <literal>1</literal>, and we use
       <command>gcc -mnocygwin</command> from cygwin to get mingw.
       This means that absolute Windows paths won't work.  Although
       &abuild; tries to use relative paths when possible, paths on
       different drive letters are always given as absolute paths.  In
       spite of these limitations, mingw support should work okay for
       build environments in which everything is under the same drive
       letter.  If necessary, builds that have to work with both
       Microsoft Visual C++ and mingw can have conditionals in their
       build or interface files.  Hopefully a future version of
       &abuild; will better address this.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </appendix>
  <appendix id="ref.help-files">
   <title>Online Help Files</title>
   <para>
    This appendix includes the text of all of &abuild;'s internal
    online help.
   </para>
   <?strip?>
   <!-- These are here so the document will validate before being
        processed.  These sections will be provided inside the text
        produced by <?help-files?>
   -->
   <sect1 id="ref.help.rule.autoconf"><title/><para/></sect1>
   <sect1 id="ref.help.rule.ccxx"><title/><para/></sect1>
   <sect1 id="ref.help.rule.java"><title/><para/></sect1>
   <sect1 id="ref.help.rule.groovy"><title/><para/></sect1>
   <sect1 id="ref.help.topic.helpfiles"><title/><para/></sect1>
   <?end-strip?>
   <?help-files?>
  </appendix>
  <appendix id="ref.dump-data">
   <title><option>--dump-data</option> Format</title>
   <para>
    The <option>--dump-data</option> option outputs all the
    information &abuild; knows about the build trees after reading all
    the <filename>Abuild.conf</filename> files and performing all of
    its validations.  Its output is in an XML format that corresponds
    to the following DTD.  Comments in the DTD describe the meanings
    of the fields.  The DTD may be found in
    <filename>doc/abuild_data.dtd</filename> in the &abuild;
    distribution.  For additional ways to use the build graph output,
    see also <xref linkend="ref.misc-xslt"/>.
   </para>
   <para>
    When there are no errors, the <option>--dump-data</option> output
    always presents build trees and build items such that no
    dependency reference is ever made to an item that has not already
    been seen.  (This does not apply to items referenced by
    <property>build-also</property> since no dependency relationship
    is implied in that case.)  When there are errors, the
    <varname>errors</varname> attribute to the
    <varname>abuild-data</varname> element will be present and will
    have the value <varname>1</varname>.  In this case, this guarantee
    does not apply as the output may contain circular dependencies,
    unknown build items, etc.
   </para>
   <para>
    The contents of the <filename>abuild_data.dtd</filename> file are
    included here for reference.
    <?include-file doc/abuild_data.dtd?>
   </para>
  </appendix>
  <appendix id="ref.interface-dump">
   <title><option>--dump-interfaces</option> Format</title>
   <para>
    The <option>--dump-interface</option> option causes &abuild; to
    create various XML output files exposing everything &abuild; knows
    about the interface system before and after processing each build
    item.  For details, please refer to <xref
    linkend="ref.interface-debugging"/>.  The format of those files
    conforms to an XML DTD.  Comments in the DTD describe how to
    interpret the elements and attributes.  The DTD may be found in
    <filename>doc/interface_dump.dtd</filename> in the &abuild;
    distribution.  Its contents are included here for reference.
    <?include-file doc/interface_dump.dtd?>
   </para>
  </appendix>
  <appendix id="ref.build-graph-dtd">
   <title><option>--dump-build-graph</option> Format</title>
   <para>
    The <option>--dump-build-graph</option> option causes &abuild; to
    output XML data showing the internal build graph as described in
    <xref linkend="ref.construction-of-build-graph"/>.  The format of
    those files conforms to an XML DTD.  Comments in the DTD describe
    how to interpret the elements and attributes.  The DTD may be
    found in <filename>doc/build_graph.dtd</filename> in the &abuild;
    distribution.  Its contents are included here for reference.
    <?include-file doc/build_graph.dtd?>
   </para>
  </appendix>
  <appendix id="ref.ccxx.mk">
   <title>The <filename>ccxx.mk</filename> File</title>
   <para>
    Here we include a complete copy of
    <filename>rules/object-code/ccxx.mk</filename>.
   </para>
   <?include-file rules/object-code/ccxx.mk?>
  </appendix>
  <appendix id="ref.rules.java.groovy">
   <title>The <filename>java.groovy</filename> and <filename>groovy.groovy</filename> Files</title>
   <para>
    Here we include a complete copy of
    <filename>rules/groovy/java.groovy</filename> and
    <filename>rules/groovy/groovy.groovy</filename>.
   </para>
   <?include-file rules/java/java.groovy?>
   <?include-file rules/java/groovy.groovy?>
  </appendix>
  <appendix id="ref.deprecated-ant">
   <title>The Deprecated XML-based Ant Backend</title>
   <warning>
    <para>
     This appendix briefly describes the deprecated xml-based ant
     backend, which was the only mechanism for building Java code in
     &abuild; 1.0.  To ease the transition to the newer Groovy-based
     framework, which still uses ant through Groovy's
     <classname>AntBuilder</classname> object, the old xml-based ant
     framework has been left largely intact.  With one notable change,
     it works just as it did in &abuild; 1.0.  New code should not use
     this framework.  The rest of this appendix is mostly excerpts
     from &abuild; 1.0's documentation with explicit examples removed.
     The text may not be entirely coherent because of the omissions.
     Although much of the text is written as if this is the supported
     way to build Java code (which it was when the text was originally
     written), in no way should anything in this appendix be taken as
     a suggestion that this backend should be used for new code.
    </para>
    <para>
     The one major difference is that &abuild; now invokes all Java
     builds from a single JVM.  This JVM runs one build per thread up
     to the number of threads specified by &abuild;'s
     <option>-j</option> option.  In &abuild; 1.0, &abuild; actually
     ran an instance of the <command>ant</command> command, which it
     started with its current directory set to the output directory.
     Now, &abuild; launches ant through its Java API.  Although the
     <varname>basedir</varname> property is still set to the name of
     the output file, certain poorly-behaved tasks that don't use that
     for local paths may find themselves resolving local paths
     relative to &abuild;'s start directory instead of the output
     directory.  This seems like a small price to pay though given
     that even the old ant framework runs many times faster using
     &abuild; 1.1's java build launcher as it prevents creation of a
     new JVM for each build.
    </para>
   </warning>
   <warning>
    <para>
     There are two different build files that trigger use of the
     deprecated xml-based ant framework:
     <filename>Abuild-ant.properties</filename> for property-driven
     builds, and <filename>Abuild-ant.xml</filename> for
     <filename>build.xml</filename>-driven builds.  The
     <filename>build.xml</filename>-based approach was introduced as a
     means to allow for greater flexibility in experimenting with
     alternative Java build approaches.  However, as use of ant
     through XML files has been abandoned in &abuild; 1.1, it no
     longer serves any purpose.  The way it works is that, if your
     build file is <filename>Abuild-ant.xml</filename>, &abuild;
     launches ant from the output directory using the source
     directory's <filename>Abuild-ant.xml</filename> as the build
     file.  Other than having to resolve paths relative to the output
     directory rather than the directory containing
     <filename>Abuild-ant.xml</filename> as well as having access to
     the <filename>.ab-dynamic-ant.properties</filename> file, this
     was essentially just using ant to do your builds.  Nothing
     further will be said about this method in this appendix.  The
     remainder of the appendix will focus only on the property-based
     build method.
    </para>
   </warning>
   <sect1 id="ref.the-abuild-ant.properties-file">
    <title>The <filename>Abuild-ant.properties</filename> File</title>
    <indexterm>
     <primary>Abuild-ant.properties</primary>
    </indexterm>
    <para>
     The <filename>Abuild-ant.properties</filename> file is the build
     configuration file for Java build items.  It serves the same
     function for Java build items as <filename>Abuild.mk</filename>
     serves for platform-independent and C/C++ build items.
    </para>
    <indexterm>
     <primary>abuild.java-source-version</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.java-target-version</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.use-ant-runtime</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.jar-name</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.main-class</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.wrapper-name</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.ear-name</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.application-xml</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.war-name</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.war-type</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.web-xml</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.hook-build-items</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.local-buildfile</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.use-local-hooks</primary>
    </indexterm>
    <indexterm>
     <primary>abuild.junit.testsuite</primary>
    </indexterm>
    <para>
     Below is a list of supported properties.  You can also see this
     list by running <command>abuild properties-help</command> from
     any Java build item.
     <!--  This list of properties is also documented in            -->
     <!--  ant/properties-help.txt                                  -->
     <variablelist>
      <varlistentry>
       <term>abuild.application-xml</term>
       <listitem>
        <para>
         The name of the <filename>application.xml</filename> to put
         into an EAR file.  This must be set (along with
         <varname>abuild.ear-name</varname>) for an EAR file to be
         generated.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.ear-name</term>
       <listitem>
        <para>
         The name of the EAR file, including the
         <filename>.ear</filename> suffix, to be generated.  This must
         be set for an EAR file to be generated.  EAR files contain
         any archive files in the <varname>abuild.classpath</varname>
         property.  They do not contain JAR files in the
         <varname>abuild.classpath.external</varname> property.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.hook-build-items</term>
       <listitem>
        <para>
         A comma-separated list of build items from which hooks should
         be loaded.  For details about using hooks, see <xref
         linkend="ref.deprecated-ant-hooks"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.jar-name</term>
       <listitem>
        <para>
         The name of the JAR file, including the
         <filename>.jar</filename> or other archive suffix, to be
         created by this build item.  This must be set in order for a
         JAR file to be generated.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.java-source-version</term>
       <listitem>
        <para>
         If specified, the value of this property will be used for the
         <varname>source</varname> attribute of the
         <command>javac</command> task.  Otherwise, the value will
         come from the <varname>abuild.java-target-version</varname>
         if set or from the Java environment used to run ant if not.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.java-target-version</term>
       <listitem>
        <para>
         If specified, the value of this property will be used for the
         <varname>target</varname> attribute of the
         <command>javac</command> task.  If
         <varname>abuild.java-source-version</varname> is not set and
         this property is, then this property's value will also be
         used to set the <varname>source</varname> attribute of the
         <command>javac</command> task.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.junit.testsuite</term>
       <listitem>
        <para>
         This property contains the name of the class that implements
         this build item's junit test suite.  It must be set in order
         for the <varname>test</varname> target to attempt to run a
         junit test suite.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.local-buildfile</term>
       <listitem>
        <para>
         The name of a local build file, specified relative to the
         build item's directory, that will be imported by
         <application>ant</application>.  It may contain additional
         properties that can't be specified in a property file,
         resource collections, or even additional targets.  If you are
         using this too often, please consider whether a build item
         hooks file should be used instead, or whether there is some
         functionality that is missing from the core &abuild; ant
         framework code.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.main-class</term>
       <listitem>
        <para>
         The name of a class, if any, that implements main.  Setting
         this property causes the <property>Main-Class</property>
         attribute to be set in the manifest file.  It also influences
         generation of the wrapper script if
         <varname>abuild.wrapper-name</varname> is set.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.use-ant-runtime</term>
       <listitem>
        <para>
         If set, ant runtime libraries will be included in the
         compilation classpath.  This can be useful for compiling
         custom ant tasks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.use-local-hooks</term>
       <listitem>
        <para>
         If this and <varname>abuild.local-buildfile</varname> are both
         set, &abuild; will attempt to run hooks from the local build file
         as well as from any hook build items.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.war-name</term>
       <listitem>
        <para>
         The name of the WAR file, including the
         <filename>.war</filename> suffix, to be generated.  This must
         be set for a WAR file to be generated.  WAR files contain any
         JAR files in the <varname>abuild.classpath</varname> property.
         They do not contain JAR files in the
         <varname>abuild.classpath.external</varname> property.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.war-type</term>
       <listitem>
        <para>
         The type of the WAR file, which must be either
         <varname>client</varname> or <varname>server</varname>.  This
         property determines where items in
         <varname>abuild.classpath</varname> are copied.  For
         <varname>client</varname> WAR files, classpath JAR files are
         copied into the root of the WAR file where the are accessible
         to clients' browsers.  For <varname>server</varname> WAR
         files, they are copied into the
         <filename>WEB-INF/lib</filename> directory of the WAR file.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.web-xml</term>
       <listitem>
        <para>
         The name of the <filename>web.xml</filename> to put into a WAR
         file.  This must be set (along with
         <varname>abuild.war-name</varname>) for a WAR file to be
         generated.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.wrapper-name</term>
       <listitem>
        <para>
         If this property and <varname>abuild.main-class</varname> are
         both set, a script by this name will be generated that will
         invoke the Java runtime environment to invoke this main.  The
         script will include the classpath as determined by &abuild;.
         On Windows, the script is usable to invoke the application
         from a Cygwin environment, and a stand-alone batch file (that
         does not reference the script or require Cygwin) is generated
         as well.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Note that at most of one <varname>abuild.jar-name</varname>,
     <varname>abuild.war-name</varname>, or
     <varname>abuild.ear-name</varname> may be set for any given build
     item.
    </para>
   </sect1>
   <sect1 id="ref.deprecated-directory-structure-for-java-builds">
    <title>Directory Structure For Java Builds</title>
    <para>
     &Abuild;'s <application>ant</application> code assumes a
     particular directory structure for Java-based build items.  The
     following table describes the directories &abuild; looks for and
     what they mean.  All paths are relative to the build item
     directory.  Note that <filename>abuild-java</filename> is the
     &abuild; output directory for Java builds.  All directories under
     <filename>abuild-java</filename> are created automatically.  All
     other directories are optional: &abuild; will use them if they
     exist but will not complain if they are missing.  Note that the
     <command>clean</command> target removes the entire &abuild;
     output directory, which includes all the unused empty
     directories.
    </para>
    <variablelist>
     <varlistentry>
      <term><filename>src/java</filename></term>
      <listitem>
       <para>
        This directory contains java source code.  Any files it
        contains will be compiled into class files and included in the
        JAR or WAR file.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>src/resources</filename></term>
      <listitem>
       <para>
        Any files contained here will be copied to the JAR file named
        in the <varname>abuild.jar-name</varname> property or the EAR
        file named in the <varname>abuild.ear-name</varname> property.
        Standard ant exclusions (for CM directories, editor backup
        files, etc.) are in effect.  Files will be placed under the
        root of the JAR or EAR in the same relative location as they
        are to <filename>src/resources</filename> in the source tree.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>src/web</filename></term>
      <listitem>
       <para>
        Any files contained here will be copied to the WAR file named
        in the <varname>abuild.war-name</varname> property.  Standard
        ant exclusions (for CM directories, editor backup files, etc.)
        are in effect.  Files will be placed under the root of the WAR
        in the same relative location as they are to
        <filename>src/web</filename> in the source tree.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>src/conf</filename></term>
      <listitem>
       <para>
        Any files contained here will be added to the
        <filename>META-INF</filename> directory in the JAR or EAR file
        named in the <varname>abuild.jar-name</varname> property or
        <varname>abuild.ear-name</varname> property or the
        <filename>WEB-INF</filename> directory in the WAR file named in
        the <varname>abuild.war-name</varname> property.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>qtest</filename></term>
      <listitem>
       <para>
        This directory contains any qtest test suites.  It must exist
        in order for the <varname>test</varname> target to attempt to
        run any qtest-based test suites.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/src/java</filename></term>
      <listitem>
       <para>
        This directory contains any automatically generated java code.
        It is created automatically by &abuild;'s ant rules and may be
        populated by a <varname>generate</varname> hook from a local
        build file or build item hook file.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/src/resources</filename></term>
      <listitem>
       <para>
        This directory is created automatically by &abuild;'s ant rules.
        It should be populated with any automatically generated files
        that are to be added to the JAR.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/classpath</filename></term>
      <listitem>
       <para>
        This directory is created automatically if an EAR or WAR file
        is being generated.  If an EAR file is generated, it is
        populated automatically with all files in the
        <varname>abuild.classpath</varname> property.  If a WAR file is
        being generated, it is populated with the jar-file versions of
        all the files in the <varname>abuild.classpath</varname>
        property.  No action is required with this directory, but if
        necessary, a build item may create a
        <command>pre-package</command> hook to modify or rearrange the
        contents of that directory.  This can be useful for certain EAR
        and WAR file construction cases.  This mechanism may change in
        the future.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/classes</filename></term>
      <listitem>
       <para>
        This directory contains class files that result from compiling
        files in both <filename>src/java</filename> and
        <filename>abuild-java/src/java</filename>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/dist</filename></term>
      <listitem>
       <para>
        This directory is where &abuild; targets place files that are
        intended to be used outside of this build item.  Among other
        things, generated archive files are placed into this
        directory.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/junit</filename></term>
      <listitem>
       <para>
        This directory contains the output of junit tests.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/junit/html</filename></term>
      <listitem>
       <para>
        This directory contains the HTML summary of junit test output.
        Loading <filename>index.html</filename> from this directory
        into a browser will allow you to view the test results.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <!-- keep this directory last -->
      <term><filename>abuild-java/empty</filename></term>
      <listitem>
       <para>
        This is an empty directory used to substitute in &abuild;'s
        <application>ant</application> code for optional directories
        that don't exist.  You should never put any files here.  If
        you do, they will show up in generated archives in mysterious
        places.
        <footnote>
         <para>
          If you really want to know why we do it this way, read the
          comments in <filename>ant/abuild.xml</filename> in your
          &abuild; distribution.
         </para>
        </footnote>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Most of these directory names are all made available to ant
     target authors through properties.
    </para>
   </sect1>
   <sect1 id="ref.deprecated-ant-hooks">
    <title>Ant Hooks</title>
    <!--  This information is duplicated in ant/hooks-help.txt.    -->
    <!--  Please ensure that the material there is consistent      -->
    <!--  with the material here.                                  -->
    <indexterm>
     <primary>ant-hooks.xml</primary>
    </indexterm>
    <para>
     In order to make it possible for users to add additional steps to
     the build process, &abuild;'s <application>ant</application> code
     makes extensive use of hooks.
    </para>
    <para>
     Since hooks are called in separate projects from the main build,
     it is not useful to set properties from hook targets and expect
     them to be available to later targets not invoked directly by the
     hook.
    </para>
    <para>
     We define several hooks whose names start with
     <command>-pre-</command> or <command>-post-</command>.  These
     hooks are run before and after the corresponding target, and they
     are run even when the target itself is not being run.  For
     example, the <command>-post-package</command> hook may be run
     even if the package target is not run.  This makes it possible to
     implement packaging or compilation strategies, for example, that
     would be beyond &abuild;'s ant code's ordinary purview.  An
     example may be the implementation of a wrapper post-package hook
     that can create a wrapper around things in an item's classpath
     even if that item itself doesn't generate any new packages.
    </para>
    <para>
     The following hooks are defined:
     <itemizedlist>
      <listitem>
       <para>
        <command>init</command>: called from the
        <command>init</command> target after any internal
        initialization has been completed.  Use this to perform any
        additional initialization.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>generate</command>: called from the
        <command>generate</command> target, which is a dependency of
        the <command>compile</command> target.  Use this hook to
        automatically generate code to be compiled as part of the
        calling build item.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>pre-compile</command>: called right before
        compilation.  Use this hook to perform any compilation tasks
        that should precede invocation of the Java compiler but follow
        automatic generation of any source files.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>post-compile</command>: called right after
        compilation.  Use this hook to perform any operations that
        should follow invocation of the Java compiler and should be
        performed whether or not packaging is being done.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>pre-package</command>: called right before packaging.
        Use this hook to perform any operations that should be
        performed before packaging is performed but after all
        compilation steps have been completed.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>post-package</command>: called right after packaging.
        Use this hook to perform any operations that must follow
        packaging.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>pre-test</command>: called before any test suites are
        executed.  Use this to perform any unconditional setup
        required for automated testing.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>test</command>: called after any internally supported
        test suites are run but after pre-test and before post-test.
        Use this hook to provide support for additional automated test
        frameworks beyond those supported directly by abuild.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>post-test</command>: called after any internally
        supported or externally provided test suites have been run.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>deploy</command>: called from the
        <command>deploy</command> target.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>doc</command>: called from the <command>doc</command>
        target.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>other</command>: called from the
        <command>other</command> target.  This hook is provided as a
        mechanism for allowing build-item-specific or local targets to
        be defined that don't fit into the build in any other way.
        The expected mode of operation is that your
        <command>-other</command> target would depend upon various
        other targets that would be invoked conditionally upon the
        value of some user-provided property.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>properties-help</command>: called from the
        <command>properties-help</command> target.  Use this hook to
        provide help to your users about any properties that may need
        to set to make use of the services provided by your hooks.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Any file that provides hooks must create an
     <filename>ant-hooks.xml</filename> file.  For each hook that it
     wants to provide, it should create a target called
     <replaceable>-hook</replaceable> where
     <replaceable>hook</replaceable> is replaced by the hook name
     above.  For example, a hook file that provides a
     <command>generate</command> hook would define a target called
     <command>-generate</command>.
     <footnote>
      <para>
       We use target names that start with a hyphen
       (&ldquo;<literal>-</literal>&rdquo;) because
       <application>ant</application> considers these to be private
       targets.  This prevents users from invoking them explicitly
       from the command line but still allows them to be invoked as
       dependencies of other targets.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.deprecated-jar-like-archives">
    <title>JAR-like Archives</title>
    <para>
     &Abuild; knows how to create JAR files, WAR files, and EAR files.
     The names of the archives that &abuild; creates do not have to
     end with the suffix corresponding to the type.  In particular,
     &abuild; is able to create JAR files that are not called
     <filename>*.jar</filename> as is necessary in some instances.
     When it does, it will also create a copy of that file whose name
     does end in <filename>.jar</filename> for compilation purposes as
     some versions of <command>javac</command> ignore classpath
     elements that are not either directories or files whose names end
     with <filename>.zip</filename> or <filename>.jar</filename>, a
     behavior that is consistent with the documentation.
     <footnote>
      <para>
       This behavior was based on a misunderstanding of how these
       archives might be used.  This behavior is not present in the
       new Groovy-based framework.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.deprecated.war-files">
    <title>WAR Files</title>
    <para>
     The structure of WAR files is slightly different from the
     structure of ordinary JAR files.  In particular, when
     constructing a WAR file, the <filename>src/resources</filename>
     directory is ignored and the <filename>src/web</filename>
     directory is used instead.  Anything in
     <filename>src/web</filename> is added to the WAR file at its
     root, just as with <filename>src/resources</filename> for a JAR
     file.  Other than the name, there is no difference between how
     these directories are used.  Additionally, the
     <filename>src/conf</filename> directory is used to populate the
     <filename>WEB-INF</filename> directory in the WAR rather than the
     <filename>META-INF</filename>.  At present, there is no way to
     add files to <filename>META-INF</filename> other than manually
     creating a <filename>META-INF</filename> directory under
     <filename>src/web</filename>.  (The
     <filename>MANIFEST.MF</filename> file is created automatically by
     the <command>jar</command> task.)  Another difference is that
     compiled classes go in <filename>WEB-INF/classes</filename>
     instead of at the root as with a normal JAR file.
    </para>
    <para>
     If the <varname>abuild.war-type</varname> property in
     <filename>Abuild-ant.properties</filename> has the value
     <varname>server</varname>, we copy all JAR files in the
     <varname>abuild.classpath</varname> variable into the
     <filename>WEB-INF/lib</filename> directory.  If
     <varname>abuild.war-type</varname> has the value
     <varname>client</varname>, they are copied into the root of the
     WAR file.  Before copying the JAR files from the classpath into
     the WAR file, &abuild; places them in the
     <filename>abuild-java/classpath</filename> directory.  If you
     need to create a WAR file that includes files from
     <varname>abuild.classpath</varname> both at the root and in the
     <filename>WEB-INF/lib</filename> directory, create a
     <varname>client</varname> WAR file and use a
     <command>pre-package</command> hook to move some of the files
     from <filename>classpath</filename> into
     <filename>src/conf/lib</filename> (remember that both of these
     paths are relative to the output directory, which is directory
     from which <application>ant</application> is run) so that they
     will end up in <filename>WEB-INF/lib</filename>.
    </para>
   </sect1>
   <sect1 id="ref.deprecated.ear-files">
    <title>EAR Files</title>
    <para>
     The <varname>abuild.application-xml</varname> property has to be
     set in <filename>Abuild-ant.properties</filename> in addition to
     the <varname>abuild.ear-name</varname> property in order for an
     EAR to be created.
    </para>
    <para>
     Suppose you wanted to avoid inclusion of just the
     <filename>jar-example.jar</filename> file from the EAR file.  You
     can do this by creating a local <command>pre-package</command>
     hook that removes it from the <filename>classpath</filename>
     directory.  This same mechanism can be used to create hybrid
     client/server WAR files.  The main problem with this approach is
     that it requires you to know the name of the archives you want to
     move or remove, though this is not as bad as knowing their
     locations.  A comparable alternative would be to define custom
     interface variables in your dependencies to name the actual
     archives.  These interface variables would be available as
     <application>ant</application> properties from your local build
     file.
    </para>
    <para>
     As with a JAR file, anything in the <filename>src/conf</filename>
     directory will appear under <filename>src/META-INF</filename>,
     and anything in <filename>src/resources</filename> will appear in
     the EAR file relative to its location in
     <filename>src/resources</filename>.
    </para>
   </sect1>
  </appendix>
  <appendix id="ref.list-of-examples">
   <title>List of Examples</title>
   <para>
    The following sections within this document describe examples from
    <filename>doc/example</filename>.  Many of the files from the
    example directory are included in the document, but not all of
    them are.  For the maximum benefit, you are encouraged to make a
    copy of the <filename>doc/example</filename> directory so that you
    can follow along and make modifications.
   </para>
   <?list-of-examples?>
  </appendix>
 </part>
 <index id="abuild.index"/>
</book>
