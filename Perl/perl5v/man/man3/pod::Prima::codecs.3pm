.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::codecs 3"
.TH pod::Prima::codecs 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::codecs \- How to write a codec for Prima image subsystem
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
How to write a codec for Prima image subsystem
.SH "Start simple"
.IX Header "Start simple"
There are many graphical formats in the world, and yet more
libraries, that depend on them. Writing a codec that supports 
particular library is a tedious task, especially if one wants many
formats. Usually you never want to get into internal parts, the
functionality comes first, and who needs all those funky options that
format provides? We want to load a file and to show it. Everything
else comes later \- if ever. So, in a way to not scare you off, we
start it simple.
.SS "Load"
.IX Subsection "Load"
Define a callback function like:
.PP
.Vb 4
\&   static Bool   
\&   load( PImgCodec instance, PImgLoadFileInstance fi)
\&   {
\&   }
.Ve
.PP
Just that function is not enough for whole mechanism to work,
but bindings will come later. Let us imagine we work with an imaginary 
library libduff, that we want to load files of .duf format. 
\&\fI[ To discern imaginary code from real, imaginary will be prepended
with _  \- like, _libduff_loadfile ]\fR. So, we call \fI_libduff_loadfile()\fR,
that loads black-and-white, 1\-bits/pixel images, where 1 is white and 0
is black.
.PP
.Vb 5
\&   static Bool   
\&   load( PImgCodec instance, PImgLoadFileInstance fi)
\&   {
\&      _LIBDUFF * _l = _libduff_load_file( fi\-> fileName);
\&      if ( !_l) return false;
\&
\&      // \- create storage for our file
\&      CImage( fi\-> object)\-> create_empty( fi\-> object,
\&        _l\-> width, _l\-> height, imBW);
\&
\&      // Prima wants images aligned to 4\-bytes boundary,
\&      // happily libduff has same considerations
\&      memcpy( PImage( fi\-> object)\-> data, _l\-> bits, 
\&        PImage( fi\-> object)\-> dataSize);
\&
\&      _libduff_close_file( _l);
\&
\&      return true;
\&   }
.Ve
.PP
Prima keeps an open handle of the file; so we can use it if
libduff trusts handles vs names:
.PP
.Vb 5
\&   {
\&     _LIBDUFF * _l = _libduff_load_file_from_handle( fi\-> f);
\&      ...
\&   // In both cases, you don\*(Aqt need to close the handle \- 
\&   // however you might, it is ok:
\&
\&      _libduff_close_file( _l);
\&      fclose( fi\-> f);
\&   // You just assign it to null to indicate that you\*(Aqve closed it
\&      fi\-> f = null;
\&      ...
\&   }
.Ve
.PP
Together with \fIload()\fR you have to implement minimal \fIopen_load()\fR
and \fIclose_load()\fR.
.PP
Simplest \fIopen_load()\fR returns non-null pointer \- it is enough to report 'o.k'
.PP
.Vb 5
\&   static void * 
\&   open_load( PImgCodec instance, PImgLoadFileInstance fi)
\&   {
\&      return (void*)1;
\&   }
.Ve
.PP
Its result will be available in \f(CW\*(C`PImgLoadFileInstance\-> instance\*(C'\fR,
just in case. If it was dynamically allocated, free it in \fIclose_load()\fR.
Dummy \fIclose_load()\fR is doing simply nothing:
.PP
.Vb 4
\&   static void
\&   close_load( PImgCodec instance, PImgLoadFileInstance fi)
\&   {
\&   }
.Ve
.ie n .SS "Writing to ""PImage\-> data"""
.el .SS "Writing to \f(CWPImage\-> data\fP"
.IX Subsection "Writing to PImage-> data"
As mentioned above, Prima insists on keeping its image data
in 32\-bit aligned scanlines. If libduff allows reading from 
file by scanlines, we can use this possibility as well:
.PP
.Vb 3
\&   PImage i = ( PImage) fi\-> object; 
\&   // note \- since this notation is more convenient than
\&   // PImage( fi\-> object)\-> , instead i\-> will be used 
\&
\&   Byte * dest = i\-> data + ( _l\-> height \- 1) * i\-> lineSize;
\&   while ( _l\-> height\-\-) {
\&      _libduff_read_next_scanline( _l, dest);
\&      dest \-= i\-> lineSize;
\&   }
.Ve
.PP
Note that image is filled in reverse \- Prima images are built
like classical XY-coordinate grid, where Y ascends upwards.
.PP
Here ends the simple part. You can skip down to 
\&\*(L"Registering with image subsystem\*(R" part, if you want it fast.
.SH "Single-frame loading"
.IX Header "Single-frame loading"
.SS "Palette"
.IX Subsection "Palette"
Our libduff can be black-and-white in two ways \-
where 0 is black and 1 is white and vice versa. While
0B/1W is perfectly corresponding to imbpp1 | imGrayScale
and no palette operations are needed ( Image cares 
automatically about these), 0W/1B is although black-and-white
grayscale but should be treated like general imbpp1 type.
.PP
.Vb 4
\&     if ( l\-> _reversed_BW) {
\&        i\-> palette[0].r = i\-> palette[0].g = i\-> palette[0].b = 0xff;
\&        i\-> palette[1].r = i\-> palette[1].g = i\-> palette[1].b = 0;
\&     }
.Ve
.PP
\&\s-1NB.\s0 Image creates palette with size calculated by exponent of 2, since it can't know
beforehand of the actual palette size. If color palette for, say, 4\-bit
image contains 15 of 16 possible for 4\-bit image colors, code like
.PP
.Vb 1
\&     i\-> palSize = 15;
.Ve
.PP
does the trick.
.SS "Data conversion"
.IX Subsection "Data conversion"
As mentioned before, Prima defines image scanline
size to be aligned to 32 bits, and the formula for 
lineSize calculation is
.PP
.Vb 1
\&    lineSize = (( width * bits_per_pixel + 31) / 32) * 4;
.Ve
.PP
Prima defines number of converting routines between different
data formats. Some of them can be applied to scanlines, and
some to whole image ( due sampling algorithms ). These are
defined in img_conv.h, and probably ones that you'll need
would be \f(CW\*(C`bc_format1_format2\*(C'\fR, which work on scanlines
and probably ibc_repad, which combines some \f(CW\*(C`bc_XX_XX\*(C'\fR with byte
repadding.
.PP
For those who are especially lucky, some libraries do not
check between machine byte format and file byte format.
Prima unfortunately doesn't provide easy method for determining
this situation, but you have to convert your data in appropriate 
way to keep picture worthy of its name. Note the \s-1BYTEORDER\s0 symbol
that is defined ( usually ) in sys/types.h
.SS "Load with no data"
.IX Subsection "Load with no data"
If a high-level code just needs image information rather than
all its bits, codec can provide it in a smart way. Old code
will work, but will eat memory and time. A flag 
\&\f(CW\*(C`PImgLoadFileInstance\-> noImageData\*(C'\fR is indicating if image data
is needed. On that condition, codec needs to report only
dimensions of the image \- but the type must be set anyway.
Here comes full code:
.PP
.Vb 7
\&   static Bool
\&   load( PImgCodec instance, PImgLoadFileInstance fi)
\&   {
\&      _LIBDUFF * _l = _libduff_load_file( fi\-> fileName);
\&      HV * profile = fi\-> frameProperties;
\&      PImage i = ( PImage) fi\-> frameProperties;
\&      if ( !_l) return false;
\&
\&      CImage( fi\-> object)\-> create_empty( fi\-> object, 1, 1, 
\&         _l\-> _reversed_BW ? imbpp1 : imBW);
\&
\&      // copy palette, if any
\&      if ( _l\-> _reversed_BW) {
\&         i\-> palette[0].r = i\-> palette[0].g = i\-> palette[0].b = 0xff;
\&         i\-> palette[1].r = i\-> palette[1].g = i\-> palette[1].b = 0;
\&      }
\&
\&      if ( fi\-> noImageData) {
\&         // report dimensions
\&         pset_i( width,  _l\-> width);
\&         pset_i( height, _l\-> height);
\&         return true;
\&      } 
\&
\&      // \- create storage for our file
\&      CImage( fi\-> object)\-> create_empty( fi\-> object,
\&           _l\-> width, _l\-> height, 
\&           _l\-> _reversed_BW ? imbpp1 : imBW);
\&
\&      // Prima wants images aligned to 4\-bytes boundary,
\&      // happily libduff has same considerations
\&      memcpy( PImage( fi\-> object)\-> data, _l\-> bits, 
\&        PImage( fi\-> object)\-> dataSize);
\&
\&
\&      _libduff_close_file( _l);
\&
\&      return true;
\&   }
.Ve
.PP
The newly introduced macro \f(CW\*(C`pset_i\*(C'\fR is a convenience operator, 
assigning integer (i) as a value to a hash key, given as a
first parameter \- it becomes string literal upon the
expansion. Hash used for storage is a lexical of type \f(CW\*(C`HV*\*(C'\fR.
Code
.PP
.Vb 2
\&        HV * profile = fi\-> frameProperties;
\&        pset_i( width, _l\-> width);
.Ve
.PP
is a prettier way for
.PP
.Vb 5
\&        hv_store( 
\&            fi\-> frameProperties, 
\&            "width", strlen( "width"),
\&            newSViv( _l\-> width),
\&            0);
.Ve
.PP
\&\fIhv_store()\fR, \s-1HV\s0's and \s-1SV\s0's along with other funny symbols are
described in perlguts.pod in Perl installation.
.SS "Return extra information"
.IX Subsection "Return extra information"
Image attributes are dimensions, type, palette and data.
However, it is only Prima point of view \- different formats
can supply number of extra information, often irrelevant but
sometimes useful. From perl code, Image has a hash reference 'extras'
on object, where comes all this stuff. Codec can report also
such data, storing it in \f(CW\*(C`PImgLoadFileInstance\-> frameProperties\*(C'\fR.
Data should be stored in native perl format, so if you're not 
familiar with perlguts, you better read it, especially if
you want return arrays and hashes. But just in simple, you can
return:
.IP "1." 4
integers:       pset_i( integer, _l\-> integer);
.IP "2." 4
floats:         pset_f( float, _l\-> float);
.IP "3." 4
strings:        pset_c( string, _l\-> charstar); 
\&\- note \- no malloc codec from you required
.IP "4." 4
prima objects:  pset_H( Handle, _l\-> primaHandle);
.IP "5." 4
\&\s-1SV\s0's:           pset_sv_noinc( scalar, newSVsv(sv));
.IP "6." 4
hashes:         pset_sv_noinc( scalar, ( \s-1SV\s0 *) \fInewHV()\fR); 
\&\- hashes created through \fInewHV()\fR can be filled just in the same manner
as described here
.IP "7." 4
arrays:         pset_sv_noinc( scalar, ( \s-1SV\s0 *) \fInewAV()\fR); 
\&\- arrays (\s-1AV\s0) are described in perlguts also, but
most useful function here is av_push. To push 4 values, 
for example, follow this code:
.Sp
.Vb 3
\&    AV * av = newAV();
\&    for ( i = 0;i < 4;i++) av_push( av, newSViv( i));
\&    pset_sv_noinc( myarray, newRV_noinc(( SV *) av);
.Ve
.Sp
is a C equivalent to
.Sp
.Vb 1
\&      \->{extras}\-> {myarray} = [0,1,2,3];
.Ve
.PP
High level code can specify if the extra 
information should be loaded. This behavior is determined by
flag \f(CW\*(C`PImgLoadFileInstance\-> loadExtras\*(C'\fR. Codec may skip this 
flag, the extra information will not be returned, even if
\&\f(CW\*(C`PImgLoadFileInstance\-> frameProperties\*(C'\fR was changed. However, 
it is advisable to check for the flag, just for an efficiency.
All keys, possibly assigned to frameProperties should
be enumerated for high-level code. These strings should be 
represented into \f(CW\*(C`char ** PImgCodecInfo\-> loadOutput\*(C'\fR array.
.PP
.Vb 5
\&   static char * loadOutput[] = { 
\&      "hotSpotX",
\&      "hotSpotY",
\&      nil
\&   };
\&
\&   static ImgCodecInfo codec_info = {
\&      ...
\&      loadOutput 
\&   };
\&
\&   static void * 
\&   init( PImgCodecInfo * info, void * param)
\&   {
\&      *info = &codec_info;
\&      ...
\&   }
.Ve
.PP
The code above is taken from codec_X11.c, where X11 bitmap can 
provide location of hot spot, two integers, X and Y. The type
of the data is not specified.
.SS "Loading to icons"
.IX Subsection "Loading to icons"
If high-level code wants an Icon instead of an Image,
Prima takes care for producing and-mask automatically.
However, if codec knows explicitly about transparency
mask stored in a file, it might change object in the way
it fits better. Mask is stored on Icon in a \f(CW\*(C`\-> mask\*(C'\fR field.
.PP
a) Let us imagine, that 4\-bit image always
carries a transparent color index, in 0\-15 range. In this case,
following code will create desirable mask:
.PP
.Vb 8
\&      if ( kind_of( fi\-> object, CIcon) && 
\&           ( _l\-> transparent >= 0) &&
\&           ( _l\-> transparent < PIcon( fi\-> object)\-> palSize)) {
\&         PRGBColor p = PIcon( fi\-> object)\-> palette;
\&         p += _l\-> transparent;
\&         PIcon( fi\-> object)\-> maskColor = ARGB( p\->r, p\-> g, p\-> b);
\&         PIcon( fi\-> object)\-> autoMasking = amMaskColor;
\&      }
.Ve
.PP
Of course,
.PP
.Vb 1
\&      pset_i( transparentColorIndex, _l\-> transparent);
.Ve
.PP
would be also helpful.
.PP
b) if explicit bit mask is given, code will be like:
.PP
.Vb 5
\&      if ( kind_of( fi\-> object, CIcon) && 
\&           ( _l\-> maskData >= 0)) {
\&         memcpy( PIcon( fi\-> object)\-> mask, _l\-> maskData, _l\-> maskSize);
\&         PIcon( fi\-> object)\-> autoMasking = amNone;
\&      }
.Ve
.PP
Note that mask is also subject to \s-1LSB/MSB\s0 and 32\-bit alignment 
issues. Treat it as a regular imbpp1 data format.
.PP
c) A format supports transparency information, but image does not
contain any. In this case no action is required on the codec's part;
the high-level code specifies if the transparency mask is created 
( iconUnmask field ).
.SS "\fIopen_load()\fP and \fIclose_load()\fP"
.IX Subsection "open_load() and close_load()"
\&\fIopen_load()\fR and \fIclose_load()\fR are used as brackets for load requests,
and although they come to full power in multiframe load
requests, it is very probable that correctly written
codec should use them. Codec that assigns \f(CW\*(C`false\*(C'\fR to 
\&\f(CW\*(C`PImgCodecInfo\-> canLoadMultiple\*(C'\fR claims that it cannot load
those images that have index different from zero. It may
report total amount of frames, but still be incapable of
loading them. 
There is also a load sequence, called null-load,
when no \fIload()\fR calls are made, just \fIopen_load()\fR and \fIclose_load()\fR.
These requests are made in case codec can provide some file
information without loading frames at all. It can be any
information, of whatever kind. It have to be stored into the hash
\&\f(CW\*(C`PImgLoadFileInstance\-> fileProperties\*(C'\fR, to be filled once on
\&\fIopen_load()\fR. The only exception is \f(CW\*(C`PImgLoadFileInstance\-> frameCount\*(C'\fR,
which can be filled on \fIopen_load()\fR. Actually, frameCount could be 
filled on any load stage, except \fIclose_load()\fR, to make sense in
frame positioning. Even single frame codec is advised to fill
this field, at least to tell whether file is empty ( frameCount == 0) or
not ( frameCount == 1). More about frameCount comes into chapters
dedicated to multiframe requests.
For strictly single-frame codecs it is therefore advised
to care for \fIopen_load()\fR and \fIclose_load()\fR.
.SS "Load input"
.IX Subsection "Load input"
So far codec is expected to respond for noImageData
hint only, and it is possible to allow a high-level code to alter
codec load behavior, passing specific parameters. 
\&\f(CW\*(C`PImgLoadFileInstance\-> profile\*(C'\fR is a hash, that contains these
parameters. The data that should be applied to all frames and/or
image file are set there when \fIopen_load()\fR is called. These data, 
plus frame-specific keys passed to every \fIload()\fR call.
However, Prima passes only those hash keys, which are
returned by \fIload_defaults()\fR function. This functions returns newly
created ( by calling \fInewHV()\fR) hash, with accepted keys and their
default ( and always valid ) value pairs.
Example below defines speed_vs_memory integer value, that 
should be 0, 1 or 2.
.PP
.Vb 10
\&   static HV *
\&   load_defaults( PImgCodec c)
\&   {
\&      HV * profile = newHV();
\&      pset_i( speed_vs_memory, 1);
\&      return profile;
\&   }
\&   ...
\&   static Bool   
\&   load( PImgCodec instance, PImgLoadFileInstance fi)
\&   {
\&        ...
\&        HV * profile = fi\-> profile;
\&        if ( pexist( speed_vs_memory)) {
\&           int speed_vs_memory = pget_i( speed_vs_memory);
\&           if ( speed_vs_memory < 0 || speed_vs_memory > 2) {
\&                strcpy( fi\-> errbuf, "speed_vs_memory should be 0, 1 or 2");
\&                return false;
\&           }
\&           _libduff_set_load_optimization( speed_vs_memory);
\&        }
\&   }
.Ve
.PP
The latter code chunk can be applied to \fIopen_load()\fR as well.
.SS "Returning an error"
.IX Subsection "Returning an error"
Image subsystem defines no severity gradation for codec errors.
If error occurs during load, codec returns false value, which
is \f(CW\*(C`null\*(C'\fR on \fIopen_load()\fR and \f(CW\*(C`false\*(C'\fR on load. It is advisable to 
explain the error, otherwise the user gets just \*(L"Loading error\*(R"
string. To do so, error message is to be copied to 
\&\f(CW\*(C`PImgLoadFileInstance\-> errbuf\*(C'\fR, which is \f(CW\*(C`char[256]\*(C'\fR.
On an extreme severe error codec may call \fIcroak()\fR,
which jumps to the closest G_EVAL block. If there is no G_EVAL 
blocks then program aborts. This condition could also happen if 
codec calls some Prima code that issues \fIcroak()\fR. This condition 
is untrappable, \- at least without calling perl functions. 
Understanding that that behavior is not acceptable, 
it is still under design.
.SH "Multiple-frame load"
.IX Header "Multiple-frame load"
In order to indicate that a codec is ready to read
multiframe images, it must set \f(CW\*(C`PImgCodecInfo\-> canLoadMultiple\*(C'\fR
flag to true. This only means, that codec should respond to the
\&\f(CW\*(C`PImgLoadFileInstance\-> frame\*(C'\fR field, which is integer that
can be in range from \f(CW0\fR to \f(CW\*(C`PImgLoadFileInstance\-> frameCount \- 1\*(C'\fR.
It is advised that codec should change the frameCount from
its original value \f(CW\*(C`\-1\*(C'\fR to actual one, to help Prima filter range
requests before they go down to the codec. The only real problem that
may happen to the codec which it strongly unwilling to initialize
frameCount, is as follows.
If a loadAll request was made ( corresponding boolean
\&\f(CW\*(C`PImgLoadFileInstance\-> loadAll\*(C'\fR flag is set for codec's information)
and frameCount is not initialized, then Prima starts loading all frames,
incrementing frame index until it receives an error. Assuming the
first error it gets is an \s-1EOF,\s0 it reports no error, so there's no
way for a high-level code to tell whether there was an loading error or
an end-of-file condition. 
Codec may initialize frameCount at any time during \fIopen_load()\fR
or \fIload()\fR, even together with false return value.
.SH "Saving"
.IX Header "Saving"
Approach for handling saving requests is very similar to a load ones.
For the same reason and with same restrictions functions \fIsave_defaults()\fR
\&\fIopen_save()\fR, \fIsave()\fR and \fIclose_save()\fR are defined. Below shown a 
typical saving code and highlighted differences from load.
As an example we'll take existing codec_X11.c, which
defines extra hot spot coordinates, x and y.
.PP
.Vb 8
\&   static HV *
\&   save_defaults( PImgCodec c)
\&   {
\&      HV * profile = newHV();
\&      pset_i( hotSpotX, 0);
\&      pset_i( hotSpotY, 0);
\&      return profile;
\&   }
\&
\&   static void *
\&   open_save( PImgCodec instance, PImgSaveFileInstance fi)
\&   {
\&      return (void*)1;
\&   }
\&
\&   static Bool   
\&   save( PImgCodec instance, PImgSaveFileInstance fi)
\&   {
\&      PImage i = ( PImage) fi\-> object;
\&      Byte * l;
\&      ...
\&
\&      fprintf( fi\-> f, "#define %s_width %d\en", name, i\-> w);
\&      fprintf( fi\-> f, "#define %s_height %d\en", name, i\-> h);
\&      if ( pexist( hotSpotX))
\&         fprintf( fi\-> f, "#define %s_x_hot %d\en", name, (int)pget_i( hotSpotX));
\&      if ( pexist( hotSpotY))
\&         fprintf( fi\-> f, "#define %s_y_hot %d\en", name, (int)pget_i( hotSpotY));
\&      fprintf( fi\-> f, "static char %s_bits[] = {\en  ", name);
\&      ...
\&      // printing of data bytes is omitted
\&   }   
\&
\&   static void 
\&   close_save( PImgCodec instance, PImgSaveFileInstance fi)
\&   {
\&   }
.Ve
.PP
Save request takes into account defined supported types, that
are defined in \f(CW\*(C`PImgCodecInfo\-> saveTypes\*(C'\fR. Prima converts image
to be saved into one of these formats, before actual \fIsave()\fR call
takes place.
Another boolean flag, \f(CW\*(C`PImgSaveFileInstance\-> append\*(C'\fR
is summoned to govern appending to or rewriting a file, but
this functionality is under design. Its current value
is a hint, if true, for a codec not to rewrite but rather
append the frames to an existing file. Due to increased
complexity of the code, that should respond to the append hint, 
this behavior is not required.
.PP
Codec may set two of PImgCodecInfo flags, canSave and
canSaveMultiple. Save requests will never be called if canSave
is false, and append requests along with multiframe save requests
would be never invoked for a codec with canSaveMultiple set to false.
Scenario for a multiframe save request is the same as for a load one. All the
issues concerning palette, data converting and saving extra 
information are actual, however there's no corresponding flag like
loadExtras \- codec is expected to save all information what it can extract from
\&\f(CW\*(C`PImgSaveFileInstance\-> objectExtras\*(C'\fR hash.
.SH "Registering with image subsystem"
.IX Header "Registering with image subsystem"
Finally, the code have to be registered. It is not as illustrative 
but this part better not to be oversimplified.
A codec's callback functions are set into ImgCodecVMT structure.
Those function slots that are unused should not be defined as
dummies \- those are already defined and gathered under struct
CNullImgCodecVMT. That's why all functions in the illustration code
were defined as static.
A codec have to provide some information that Prima
uses to decide what codec should load this particular file.
If no explicit directions given, Prima asks those codecs whose
file extensions match to file's.
\&\fIinit()\fR should return pointer to the filled struct, that describes 
codec's capabilities:
.PP
.Vb 2
\&   // extensions to file \- might be several, of course, thanks to dos...
\&   static char * myext[] = { "duf", "duff", nil };
\&
\&   // we can work only with 1\-bit/pixel
\&   static int    mybpp[] = { 
\&       imbpp1 | imGrayScale, // 1st item is a default type
\&       imbpp1, 
\&       0 };   // Zero means end\-of\-list. No type has zero value.
\&
\&   // main structure
\&   static ImgCodecInfo codec_info = {
\&      "DUFF", // codec name 
\&      "Numb & Number, Inc.", // vendor
\&      _LIBDUFF_VERS_MAJ, _LIBDUFF_VERS_MIN,    // version
\&      myext,    // extension
\&      "DUmb Format",     // file type
\&      "DUFF",     // file short type
\&      nil,    // features 
\&      "",     // module
\&      true,   // canLoad
\&      false,  // canLoadMultiple 
\&      false,  // canSave
\&      false,  // canSaveMultiple
\&      mybpp,  // save types
\&      nil,    // load output 
\&   };
\&
\&   static void * 
\&   init( PImgCodecInfo * info, void * param)
\&   {
\&      *info = &codec_info;
\&      return (void*)1; // just non\-null, to indicate success
\&   }
.Ve
.PP
The result of \fIinit()\fR is stored into \f(CW\*(C`PImgCodec\-> instance\*(C'\fR, and
info into \f(CW\*(C`PImgCodec\-> info\*(C'\fR. If dynamic memory was allocated
for these structs, it can be freed on \fIdone()\fR invocation.
Finally, the function that is invoked from Prima,
is the only that required to be exported, is responsible for
registering a codec:
.PP
.Vb 11
\&   void 
\&   apc_img_codec_duff( void )
\&   {
\&      struct ImgCodecVMT vmt;
\&      memcpy( &vmt, &CNullImgCodecVMT, sizeof( CNullImgCodecVMT));
\&      vmt. init          = init;
\&      vmt. open_load     = open_load;
\&      vmt. load          = load; 
\&      vmt. close_load    = close_load; 
\&      apc_img_register( &vmt, nil);
\&   }
.Ve
.PP
This procedure can register as many codecs as it wants to, 
but currently Prima is designed so that one codec_XX.c file 
should be connected to one library only.
.PP
The name of the procedure is apc_img_codec_ plus
library name, that is required for a compilation with Prima.
File with the codec should be called codec_duff.c ( is our case)
and put into img directory in Prima source tree. Following
these rules, Prima will be assembled with libduff.a ( or duff.lib,
or whatever, the actual library name is system dependent) \- if the library is present.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Image, Prima::internals, Prima::image\-load
