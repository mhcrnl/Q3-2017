.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDL::Graphics::Prima::Palette 3"
.TH PDL::Graphics::Prima::Palette 3 "2015-11-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Graphics::Prima::Palette \- a set of palettes for the Prima graph widget
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Suppose you want to use color to convey some meaningful value. For example,
you want the color to represent the topography of a landscape, darker is
lower, lighter is higher. In that case, you need a mapping from a height to
a color, i.e. from a scalar value to a color. This is what palettes provide.
.PP
If all you need is basic palette, you can use one of the
palette builders provided below. That said, creating
custom color palettes, when you have some idea of what you're doing and a
simple means for doing so, is a lot of fun. This, for example, creates a
palette that runs from black to red. You could just use
pal::BlackToHSV, but what's the fun in that?
.PP
.Vb 4
\& my $palette = PDL::Graphics::Prima::Palette\->new(
\&     apply => sub {
\&         my $data = shift;
\&         my ($min, $max) = $data\->minmax;
\&         
\&         # Build the rgb piddle
\&         my $rgb = zeroes(3, $data\->dims);
\&         $rgb\->slice("0") .= (($data\->double \- $min) / ($max \- $min)) * 255;
\&         
\&         # Convert to Prima colors
\&         return $rgb\->rgb_to_color;
\&     }
\& );
.Ve
.PP
Applying the palette to some data simply calls the subref that your provided
earlier:
.PP
.Vb 1
\& my $colors = $palette\->apply($some_data);
.Ve
.PP
Using this with a standard palette builder is pretty easy, too:
.PP
.Vb 1
\& my $colors = pal::Rainbow\->apply($some_data);
.Ve
.PP
And, you can provide the palette to customize how
pgrid::Matrix
colorizes its data:
.PP
.Vb 6
\& plot(
\&     \-data => ds::Grid( $matrix,
\&         plotType => pgrid::Matrix(palette => $palette),
\&         bounds => [0, 0, 1, 1],
\&     )
\& );
.Ve
.SS "new"
.IX Subsection "new"
Accepts key/value pairs. The only required key is the \f(CW\*(C`apply\*(C'\fR key, which
should have a coderef that accepts a data piddle and performs the
data-to-color conversion, returning a piddle of Prima colors.
.SS "apply"
.IX Subsection "apply"
Every palette knows how to apply itself to its data. The apply function
returns a piddle of Prima color values given a piddle of scalar values.
.SS "plotType"
.IX Subsection "plotType"
Every Palette knows the specific data and plot type to which it belongs.
The first time that a Palette is used in a drawing operation, it will become
associated with that specific plotType object, which is in turn associated
with that specific dataSet and widget. Thereafter, you can retrieve the
plotType object using this accessor, but you cannot change it.
If you want to use the same Palette with a different plotType, you can
create a copy of your palette using the \*(L"copy\*(R" method.
.SS "copy"
.IX Subsection "copy"
You can make a copy of a Palette that is identical to your current pallete
except that it does not have an associated plotType. This way, if you put a
lot of effort into making a palette, you can easily reuse that palette with
minimal effort.
.PP
Note that this mechanism does not perform a deep copy, and any nested data
structures will be copied by reference to the new palette object.
.SH "Special Palettes"
.IX Header "Special Palettes"
This module provides many ready-made palettes with short-name constructors
in the \f(CW\*(C`pal\*(C'\fR namespace.
.IP "pal::Rainbow" 4
.IX Item "pal::Rainbow"
Runs from red\->orange\->yellow\->green\->blue\->purple in ascending order.
.IP "pal::RainbowSV" 4
.IX Item "pal::RainbowSV"
Runs from red\->orange\->yellow\->green\->blue\->purple in ascending order. The two
arguments it accepts are the saturation and value, which it holds uniformly.
This makes it much easier to create palettes that can be easily seen against a
white background. For example, the yellow from this palette is much eaiser to
see against a white background than the yellow from pal::Rainbow:
.Sp
.Vb 1
\& pal::RainbowSV(1, 0.8)
.Ve
.IP "pal::BlackToWhite" 4
.IX Item "pal::BlackToWhite"
Larger values are white, smaller values are black. The optional argument is
the gamma exponent correction value, which should be positive. Typically,
gamma exponents are near 0.5.
.IP "pal::WhiteToBlack" 4
.IX Item "pal::WhiteToBlack"
Larger values are black, smaller values are white. The optional argument is
the gamma exponent correction value, which should be positive. Typically,
gamma exponents are near 0.5.
.IP "pal::WhiteToHSV" 4
.IX Item "pal::WhiteToHSV"
Smaller values are closer to white, larger values are closer to the color
indicated by the \s-1HSV\s0 values that you specify, which are supplied to the
function as three different scalars. The first three arguments are hue,
saturation, and value. The optional fourth value is a gamma correction
exponent.
.Sp
For example:
.Sp
.Vb 2
\& my $white_to_red = pal::WhiteToHSV(0, 1, 1);
\& my $gamma_white_to_red = pal::WhiteToHSV(0, 1, 1, 0.8);
.Ve
.IP "pal::BlackToHSV" 4
.IX Item "pal::BlackToHSV"
Like WhiteToHSV, but smaller values are closer to black instead of white.
.IP "pal::HSVrange" 4
.IX Item "pal::HSVrange"
Maps data in ascending order from the start to the stop values in hue, saturation,
and value. You can specify the initial and final hue, saturation, and value
in one of two ways: (1) a pair of three-element arrayrefs/piddles with the
initial and final hsv values, or (3) a set of key/value pairs describing the initial
and final hue, saturation and value.
.Sp
For example, this creates a palette that runs from red (H=360) to blue
(H=240):
.Sp
.Vb 1
\& my $blue_to_red = pal::HSVrange([360, 1, 1] => [240, 1, 1]);
.Ve
.Sp
If you know the Prima name of your color, you can use the
conversion functions provided by
PDL::Drawing::Prima::Utils to build an \s-1HSV\s0
range. This example produces a palette from blue to red:
.Sp
.Vb 3
\& my $blue_hsv = pdl(cl::LightBlue)\->color_to_rgb\->rgb_to_hsv;
\& my $red_hsv = pdl(cl::LightRed)\->color_to_rgb\->rgb_to_hsv;
\& my $blue_to_red = pal::HSVrange($blue_hsv, $red_hsv);
.Ve
.Sp
The final means for specifying a range in \s-1HSV\s0 space is to provide key/value
pairs that describe your initial and final points in \s-1HSV\s0 space. You can
also specify a non-unitary gamma correction exponent. For example,
to go from blue to red with a gamma of 0.8, you could say:
.Sp
.Vb 9
\& my $blue_to_red = pal::HSVrange(
\&       h_start => 240,
\&       s_start => 1,
\&       v_start => 1,
\&       h_stop  => 360,
\&       s_stop  => 1,
\&       v_stop  => 1,
\&       gamma   => 0.8,
\&   );
.Ve
.Sp
However, you do not need to provide all of these values. Any key that you do
not supply will use a default value:
.Sp
.Vb 9
\& Key       Default
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& h_start   0
\& s_start   1
\& v_start   1
\& h_stop    360
\& s_stop    1
\& v_stop    1
\& gamma     1
.Ve
.Sp
So the blue-to-red palette, without a gamma correction, could be specified
as:
.Sp
.Vb 3
\& my $blue_to_red = pal::HSVrange(
\&     h_start => 240, h_stop => 360,
\& );
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Mertens (dcmertens.perl@gmail.com)
.SH "ADDITIONAL MODULES"
.IX Header "ADDITIONAL MODULES"
Here is the full list of modules in this distribution:
.IP "PDL::Graphics::Prima" 4
.IX Item "PDL::Graphics::Prima"
Defines the Plot widget for use in Prima applications
.IP "PDL::Graphics::Prima::Axis" 4
.IX Item "PDL::Graphics::Prima::Axis"
Specifies the behavior of axes (but not the scaling)
.IP "PDL::Graphics::Prima::DataSet" 4
.IX Item "PDL::Graphics::Prima::DataSet"
Specifies the behavior of DataSets
.IP "PDL::Graphics::Prima::Limits" 4
.IX Item "PDL::Graphics::Prima::Limits"
Defines the lm:: namespace
.IP "PDL::Graphics::Prima::Palette" 4
.IX Item "PDL::Graphics::Prima::Palette"
Specifies a collection of different color palettes
.IP "PDL::Graphics::Prima::PlotType" 4
.IX Item "PDL::Graphics::Prima::PlotType"
Defines the different ways to visualize your data
.IP "PDL::Graphics::Prima::ReadLine" 4
.IX Item "PDL::Graphics::Prima::ReadLine"
Encapsulates all interaction with the Term::ReadLine family of
modules.
.IP "PDL::Graphics::Prima::Scaling" 4
.IX Item "PDL::Graphics::Prima::Scaling"
Specifies different kinds of scaling, including linear and logarithmic
.IP "PDL::Graphics::Prima::Simple" 4
.IX Item "PDL::Graphics::Prima::Simple"
Defines a number of useful functions for generating simple and not-so-simple
plots
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Unless otherwise stated, all contributions in code and documentation are
copyright (c) their respective authors, all rights reserved.
.PP
Portions of this module's code are copyright (c) 2011 The Board of
Trustees at the University of Illinois.
.PP
Portions of this module's code are copyright (c) 2011\-2013 Northwestern
University.
.PP
Portions of this module's code are copyright (c) 2013\-2014 Dickinson
College.
.PP
This module's documentation is copyright (c) 2011\-2014 David Mertens.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
