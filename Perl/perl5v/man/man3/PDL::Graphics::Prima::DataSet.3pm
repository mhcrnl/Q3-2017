.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDL::Graphics::Prima::DataSet 3"
.TH PDL::Graphics::Prima::DataSet 3 "2015-11-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Graphics::Prima::DataSet \- the way we think about data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\& \-distribution => ds::Dist(
\&     $data, plotType => ppair::Lines,
\&     binning => bt::Linear,
\& ),
\& \-lines => ds::Pair(
\&     $x, $y, plotTypes => [ppair::Lines, ppair::Diamonds]
\& ),
\& \-contour => ds::Grid(
\&     $matrix,
\&     # Specify your bounds in one of these three ways
\&     bounds => [$left, $bottom, $right, $top],
\&     y_edges => $ys, x_edges => $xs, 
\&     x_bounds => [$left, $right], y_bounds => [$bottom, $top],
\&     # Unnecessary if you want the default palette
\&     plotType => pgrid::Matrix(palette => $palette),
\& ),
\& \-image => ds::Image(
\&     $image, format => \*(Aqstring\*(Aq,
\&     ... ds::Grid bounder options ...
\&     # Unnecessary at the moment
\&     plotType => pimage::Basic,
\& ),
\& \-function => ds::Func(
\&     $func_ref, xmin => $left, xmax => $right, N_points => 200,
\& ),
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`PDL::Graphics::Prima\*(C'\fR fundamentally conceives of two different kinds of
data representations. There are pairwise representations, such as line plot
used to visualize a time series, and there are gridded representations,
such as raster images used to visualize heat maps (or images). Any data that
you want to represent must have some way to conceive of itself as either
pairwise or gridded.
.PP
Of course, there are plenty of things we want to visualize that are not
pairwise data or grids. For example, what if we want to plot the
distribution of scores on an exam? In this case, we would probably use a
histogram. When you think about it, a histogram is just a pairwise
visual representation. In other words, to visualize a distribution, we have
to first map the distribution into a pairwise representation, and then
choose an appropriate way to visualize that representation, in this case a
histogram.
.PP
So, we have two fundamental ways to represent data, but many possible
data sets. For pairwise representations, we have ds::Pair, the
basic pairwise DataSet. ds::Dist is a derived DataSet which
includes a binning specification that bins the distribution into bin centers
(x) and heights (y) to get a pairwise representation. ds::Func
is another derived DataSet that generates evenly sampled data based on the
axis bounds and evaluates the supplied function at those points to get a
pairwise representation. ds::Image provides a simple means for
visualizing images, and ds::Grid provides a means for mapping a
gridded collection of data into an image, using
palettes.
.SS "Base Class"
.IX Subsection "Base Class"
The Dataset base class provides a few methods that work for all datasets.
These include accessing the associated widget and drawing the data.
.IP "widget" 4
.IX Item "widget"
The widget associated with the dataset.
.IP "draw" 4
.IX Item "draw"
Calls all of the drawing functions for each plotType of the dataSet. This also
applies all the global drawing options (like \f(CW\*(C`color\*(C'\fR, for example) that were
supplied to the dataset.
.IP "compute_collated_min_max_for" 4
.IX Item "compute_collated_min_max_for"
This function is part of the collated min/max chain of function calls that
leads to reasonable autoscaling. The Plot widget asks each dataSet to determine
its collated min and max by calling this function, and this function simply
agregates the collated min and max results from each of its plotTypes.
.Sp
In general, you needn't worry about collated min and max calculations unless
you are trying to grapple with the autoscaling system or are creating a new
plotType.
.Sp
working here \- link to more complete documentation of the collation and
autoscaling systems.
.IP "new" 4
.IX Item "new"
This is the universal constructor that is called by the short-name constructors
introduced below. This handles the uniform packaging of plotTypes (for
example, allowing the user to say \f(CW\*(C`plotType =\*(C'\fR ppair::Diamonds> instead of
the more verbose \f(CW\*(C`plotTypes =\*(C'\fR [ppair::Diamonds]>). In general, you (the
user) will not need to invoke this constructor directly.
.IP "check_plot_types" 4
.IX Item "check_plot_types"
Checks that the plotType(s) passed to the constructor or added at runtime are
built on the data type tha we expect. Derived classes must specify their
\&\f(CW\*(C`plotType_base_class\*(C'\fR key before calling this function.
.IP "init" 4
.IX Item "init"
Called by new to initialize the dataset. This function is called on the new
dataset just before it is returned from \f(CW\*(C`new\*(C'\fR.
.Sp
If you create a new dataSet, you should provide an \f(CW\*(C`init\*(C'\fR function that
performs the following:
.RS 4
.IP "supply a default plotType" 4
.IX Item "supply a default plotType"
If the user supplied something to either the \f(CW\*(C`plotType\*(C'\fR or \f(CW\*(C`plotTypes\*(C'\fR keys,
then \f(CW\*(C`new\*(C'\fR will be sure you have you will already have that something in
an array reference in \f(CW\*(C`$self\->{plotTypes}\*(C'\fR. However, if they did not supply
either key, you should supply a default. You should have something that looks
like this:
.Sp
.Vb 1
\& $self\->{plotTypes} = [pset::CDF] unless exists $self\->{plotTypes};
.Ve
.IP "check the plot types" 4
.IX Item "check the plot types"
After supplying a default plot type, you should check that the provided plot
types are derived from the acceptable base plot type class. You would do this
with code like this:
.Sp
.Vb 1
\& $self\->check_plot_types(@{self\->{plotTypes}});
.Ve
.RE
.RS 4
.Sp
This is your last step to validate or pre-calculate anything. For example, you
must provide functions to return your data, and you should probably make
guarantees about the kinds of data that such accessors return, such as the data
always being a piddle. If that is the case, then it might not be a bad idea to
say in your \f(CW\*(C`init\*(C'\fR function something like this:
.Sp
.Vb 1
\& $self\->{data} = PDL::Core::topdl($self\->{data});
.Ve
.RE
.IP "change_data" 4
.IX Item "change_data"
Sets the data to the given data by calling the derived class's \f(CW\*(C`_change_data\*(C'\fR
method. Unlike \f(CW\*(C`_change_data\*(C'\fR, this method also issues a \f(CW\*(C`ChangeData\*(C'\fR
notification to the widget. This means that you should only use this method
once the dataset has been associated with a widget. Each class expects
different arguments, so you should look at the class's documentation for
details on what to send to the method.
.SS "Pair"
.IX Subsection "Pair"
Pairwise datasets are collections of paired x/y data. A typical Pair dataset
is the sort of thing you would visualize with an x/y plot: a time series
such as the series of high temperatures for each day in a month or the x\- and
y\-coordinates of a bug walking across your desk. PDL::Graphics::Prima provides
many ways of visualizing Pair datasets, as discussed under
\&\*(L"Pair\*(R" in PDL::Graphics::Prima::PlotType.
.PP
The dimensions of pluralized properties (i.e. \f(CW\*(C`colors\*(C'\fR) should
thread-match the dimensions of the data. An important exception to this is
\&\f(CW\*(C`ppair::Lines\*(C'\fR, in which case you must specify how you want properties to thread.
.PP
The default plot type is \f(CW\*(C`ppair::Diamonds\*(C'\fR.
.IP "ds::Pair \- short-name constructor" 4
.IX Item "ds::Pair - short-name constructor"
.Vb 1
\&    ds::Pair($x_data, $y_data, option => value, ...)
.Ve
.Sp
The short-name constructor to create pairwise datasets. The x\- and y\-data
can be either piddles or array references (which will be converted to a
piddle during initialization).
.IP "expected_plot_class" 4
.IX Item "expected_plot_class"
Pair datasets expect plot type objects that are derived from
\&\f(CW\*(C`PDL::Graphics::Prima::PlotType::Pair\*(C'\fR.
.IP "get_xs, get_ys, get_data" 4
.IX Item "get_xs, get_ys, get_data"
Returns piddles with the x, y, or x\-y data. The last function returns two
piddles in a list.
.IP "get_data_as_pixels" 4
.IX Item "get_data_as_pixels"
Uses the reals_to_pixels functions for the x\- and y\- axes to convert the
values of the x\- and y\- data to actual pixel positions in the widget.
.IP "change_data" 4
.IX Item "change_data"
Changes the data to the piddles passed in. For example,
.Sp
.Vb 1
\& $scatter_plot\->dataSets\->{\*(Aqdata\*(Aq}\->change_data($xs, $ys);
.Ve
.SS "Distribution"
.IX Subsection "Distribution"
Distributions are unordered collections of sample data. The typical use case
of a distribution is that you have a population of things and you want to
analyze their agregate properties. For example, you might be interested in
the distribution of tree heights at your Christmas Tree Farm, or the
distribution of your students' (or your classmates') test scores from the
mid-term. Common ways for visualizing distributions are to plot their
cumulative distribution functions or their histogram, but those are actually
classic pairwise data visualization approaches. That means that what we really
need are means for converting unordered sets of data into pairwise data.
Distributions, therefore, let you specify the means by which your unordered
data should be transformed into pairwise data, and the pairwise plot types to
visualize the resulting transformed data. In an object oriented sense, the
Distribution class is derived from the Pairwise class because a distribution
\&\fBis visualized\fR using pairwise plot types.
.PP
Note that shape of pluralized properties (i.e. \f(CW\*(C`colors\*(C'\fR) should
thread-match the shape of the data \fBexcluding\fR the data's first dimension.
That is, if I want to plot the cumulative distributions for three different
batches using three different line colors, my data would have shape (N, 3) and
my colors piddle would have shape (3).
.PP
PDL::Graphics::Prima's notion of distributions is not yet finalized and is
open to suggestion. If you find yourself using distribution plots regularly,
you should give me feedback on what works and what doesn't. Thanks!
.IP "ds::Dist \- short-name constructor" 4
.IX Item "ds::Dist - short-name constructor"
.Vb 1
\&    ds::Dist($data, option => value, ...)
.Ve
.Sp
The short-name constructor to create distribtions. The data can be either a
piddle of values or an array reference of values (which will be converted to
a piddle during initialization).
.Sp
In addition to the standard keys, there is also the \f(CW\*(C`binning\*(C'\fR key. The
\&\f(CW\*(C`binning\*(C'\fR key expects either a standard binning approach using one of the
pre-defined forms, or a subroutine reference that performs the binning
in a customized fashion. The binning types are all functions that expect
key/value pairs that include \f(CW\*(C`min\*(C'\fR and \f(CW\*(C`max\*(C'\fR for the lower and upper
threshold of the binning, \f(CW\*(C`drop_extremes\*(C'\fR to indicate if the data outside
the min/max range should be included in the first and last bins, and
\&\f(CW\*(C`normalize\*(C'\fR to indicate if the binning should be normalized to 1, for some
appropriate definition of normalization. Other keys may also be allowed.
.Sp
If you want to write a customized binning function, it should accept the
two arguments, the \f(CW\*(C`data\*(C'\fR to bin and the \f(CW\*(C`distribution\*(C'\fR object. It should
return a pair of piddles representing the x and y coordinates to plot. In
addition, if the binning routine knows how to calculate properties for
specific plot types, it can specify the plot type and any properties that it
would provide for that plot type.
.Sp
For example, if you write a binning routine that knows how to calculate
the bin boundaries for the Histogram plot type, your return statement could
look like this:
.Sp
.Vb 1
\& return ($x, $y, Histogram => { binEdges => $bounds } );
.Ve
.Sp
If your binning routine uses the number of points in a Symbols plot type to
represent something, it could specify those:
.Sp
.Vb 1
\& return ($x, $y, Symbols => { N_points => $n_points } );
.Ve
.Sp
If you have a means for calculating the error on your bins, you could
include the error bar data:
.Sp
.Vb 1
\& return ($x, $y, ErrorBars => { y_err => $count_err } );
.Ve
.Sp
These properties will be applied to the relevant plot types just before
drawing and autoscaling operations, and any dataset operation that makes
use of your supplied function should examine the additional parameters and
act accordingly.
.Sp
The standard binning types include:
.RS 4
.IP "bt::CDF" 4
.IX Item "bt::CDF"
Generates a cumulative distribution from the data. The default \f(CW\*(C`min\*(C'\fR is the
data's minimum, the default \f(CW\*(C`max\*(C'\fR is the data's maximum, the binning will not
\&\f(CW\*(C`drop_extremes\*(C'\fR by default (i.e. \f(CW\*(C`drop_extremes => 0\*(C'\fR) and the binning
normalizes the data (i.e. \f(CW\*(C`normalize => 1\*(C'\fR). You can also specify if you
want an increasing or decreasing representation by specifying a boolean value
for the \f(CW\*(C`increasing\*(C'\fR key (the default is increasing, i.e. true).
.Sp
In the context of the \s-1CDF,\s0 normalization refers to the curve runnning from
y = 0 to y = N \- 1 (not normalized) or from y = 0 to y = 1 (normalized).
Bear in mind that this interacts with your choice to drop the extremes or not.
.Sp
In producing the \s-1CDF,\s0 bad values are simply skipped.
.IP "bt::Linear" 4
.IX Item "bt::Linear"
Generates a histogram from the data with linear spacing. The default \f(CW\*(C`min\*(C'\fR is the
data's minimum, the default \f(CW\*(C`max\*(C'\fR is the data's maximum, the binning will
\&\f(CW\*(C`drop_extremes\*(C'\fR by default (i.e. \f(CW\*(C`drop_extremes => 1\*(C'\fR) and the binning
normalizes the data (i.e. \f(CW\*(C`normalize => 1\*(C'\fR). You can also specify the
number of bins with \f(CW\*(C`nbins\*(C'\fR. The default is 20. If you want empty bins to
be marked as bad, specify \f(CW\*(C`mark_empty_as => \*(Aqbad\*(Aq\*(C'\fR. The default is to
mark them as zero.
.Sp
In this case, normalization means that the \*(L"integral\*(R" of the histogram is
1, which means that the sum of the heights \fItimes the widths\fR is 1.
.IP "bt::Log" 4
.IX Item "bt::Log"
Generates a histogram from the data with logarithmic spacing. The default
\&\f(CW\*(C`min\*(C'\fR is the data's smallest positive value and the default max is the data's
maximum value. If none of the data is positive, the binning type croaks.
The binning will \f(CW\*(C`drop_extremes\*(C'\fR by default (i.e. \f(CW\*(C`drop_extremes => 1\*(C'\fR)
and the binning normalizes the data (i.e. \f(CW\*(C`normalize => 1\*(C'\fR). You can also
specify the number of bins with \f(CW\*(C`nbins\*(C'\fR. The default is 20. If you want empty bins to
be marked as bad, specify \f(CW\*(C`mark_empty_as => \*(Aqbad\*(Aq\*(C'\fR. The default is to
mark them as zero.
.Sp
As with linear binning, normalization means that the \*(L"integral\*(R" of the histogram is
1, which means that the sum of the heights \fItimes the widths\fR is 1.
.IP "bt::StrictLog" 4
.IX Item "bt::StrictLog"
Identical to bt::Log, except that it croaks if it encounters
\&\fBany\fR negative values. You can use this in place of bt::Log to
sanity check your data.
.RE
.RS 4
.RE
.IP "bt::NormFit" 4
.IX Item "bt::NormFit"
\&\*(L"Fits\*(R" the distribution between the specified min and max (defaults to the
data's min and max) to a normal distribution. This bin type does not pay
attention to the \f(CW\*(C`drop_extremes\*(C'\fR key, but it cares about the \f(CW\*(C`normalize\*(C'\fR
key. If unspecified (the default), the curve will be scaled so that the area
underneath it is the number of data points being fit. If normalized, the
curve will be scaled so that the area under the curve will be 1. You can
also specify the number of points to use in generating the curves by including
the \f(CW\*(C`N_points\*(C'\fR key/value pair.
.Sp
I am pondering allowing the curve's min/max to take the current axis bounds
min/max if the axes are not autoscaling. Thoughts appreciated.
.IP "get_data, get_xs, get_ys" 4
.IX Item "get_data, get_xs, get_ys"
Returns the binned data, just the x\-values, or just the y\-values. For all of
these, the binning function is applied to the current dataset. However, for
the x\- or y\-getters, the other piece of data is discarded.
.SS "Grid"
.IX Subsection "Grid"
Grids are collections of data that is regularly ordered in two dimensions. Put
differently, it is a structure in which the data is described by two indices.
The analogous mathematical structure is a matrix and the analogous visual is an
image. PDL::Graphics::Prima provides a few ways to visualize grids, as
discussed under \*(L"Grids\*(R" in PDL::Graphics::Prima::PlotType. The default plot type
is \f(CW\*(C`pgrid::Color\*(C'\fR.
.PP
This is the least well thought-out dataSet. As such, it may change in the
future. All such changes will, hopefully, be backwards compatible.
.PP
At the moment, there is only one way to visualize grid data: \f(CW\*(C`pseq::Matrix\*(C'\fR.
Although I can conceive of a contour plot, it has yet to be implemented. As
such, it is hard to specify the dimension requirements for dataset-wide
properties. There are a few dataset-wide properties discussed in the
constructor, however, so see them for some examples.
.IP "ds::Grid \- short-name constructor" 4
.IX Item "ds::Grid - short-name constructor"
.Vb 1
\&    ds::Grid($matrix, option => value, ...)
.Ve
.Sp
The short-name constructor to create grids. The data should be a piddle of
values or something which topdl can convert to a piddle (an array reference of
array references).
.Sp
The current cross-plot-type options include the bounds settings. You can either
specify a \f(CW\*(C`bounds\*(C'\fR key or one key from each column:
.Sp
.Vb 3
\& x_bounds   y_bounds
\& x_centers  y_centers
\& x_edges    y_edges
.Ve
.RS 4
.IP "bounds" 4
.IX Item "bounds"
The value associated with the \f(CW\*(C`bounds\*(C'\fR key is a four-element anonymous array:
.Sp
.Vb 1
\& bounds => [$left, $bottom, $right, $top]
.Ve
.Sp
The values can either be scalars or piddles that indicate the corners of the
grid plotting area. If the latter, it is possible to thread over the bounds by
having the shape of (say) \f(CW$left\fR thread-match the shape of your grid's data,
excluding the first two dimensions. That is, if your \f(CW$matrix\fR has
a shape of (20, 30, 4, 5), the piddle for \f(CW$left\fR can have shapes of (1), (4),
(4, 1), (1, 5), or (4, 5).
.Sp
At the moment, if you specify bounds, linear spacing from the min to the max is
used. In the future, a new key may be introduced to allow you to specify the
spacing as something besides linear.
.IP "x_bounds, y_bounds" 4
.IX Item "x_bounds, y_bounds"
The values associated with \f(CW\*(C`x_bounds\*(C'\fR and \f(CW\*(C`y_bounds\*(C'\fR are anonymous arrays with
two elements containing the same sorts of data as the \f(CW\*(C`bounds\*(C'\fR array.
.IP "x_centers, y_centers" 4
.IX Item "x_centers, y_centers"
The value associated with \f(CW\*(C`x_centers\*(C'\fR (or \f(CW\*(C`y_centers\*(C'\fR) should be a piddle with
increasing values of x (or y) that give the mid-points of the data. For example,
if we have a matrix with shape (3, 4), \f(CW\*(C`x_centers\*(C'\fR would have 3 elements and
\&\f(CW\*(C`y_centers\*(C'\fR would have 4 elements:
.Sp
.Vb 10
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& y3 | d03 | d13 | d23 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& y2 | d02 | d12 | d22 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& y1 | d01 | d11 | d21 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& y0 | d00 | d10 | d20 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&      x0    x1    x2
.Ve
.Sp
Some plot types may require the edges. In that case, if there is more than one
point, the plot guesses the scaling of the spacing between points (choosing
between logarithmic or linear) and appropriate bounds for the given scaling are
calculated using interpolation and extrapolation. The plot will croak if there
is only one point (in which case interpolation is not possible). If the spacing
for your grid is neither linear nor logarithmic, you should explicitly specify
the edges, as discussed next.
.Sp
At the moment, the guess work assumes that all the scalings for a given Grid
dataset are either linear or logarithmic, even though it's possible to mix
the scaling using threading. (It's hard to do that by accident, so if that last
bit seems confusing, then you probably don't need to worry about tripping on
it.) Also, I would like for the plot to croak if the scaling does not appear to
be either linear or logarithmic, but that is not yet implemented.
.IP "x_edges, y_edges" 4
.IX Item "x_edges, y_edges"
The value associated with \f(CW\*(C`x_edges\*(C'\fR (or \f(CW\*(C`y_edges\*(C'\fR) should be a piddle with
increasing values of x (or y) that give the boundary edges of data. For example,
if we have a matrix with shape (3, 4), \f(CW\*(C`x_edges\*(C'\fR would have 3 + 1 = 4 elements
and \f(CW\*(C`y_edges\*(C'\fR would have 4 + 1 = 5 elements:
.Sp
.Vb 10
\& y4 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    | d03 | d13 | d23 |
\& y3 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    | d02 | d12 | d22 |
\& y2 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    | d01 | d11 | d21 |
\& y1 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    | d00 | d10 | d20 |
\& y0 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    x0    x1    x2    x3
.Ve
.Sp
Some plot types may require the data centers. In that case, if there are only
two edges, a linear interpolation is used. If there are more than two points,
the plot will try to guess the spacing, choosing between linear and logarithmic,
and use the appropriate interpolation.
.Sp
The note above about regarding guess work for x_centers and y_centers applies
here, also.
.RE
.RS 4
.RE
.IP "expected_plot_class" 4
.IX Item "expected_plot_class"
Grids expect plot type objects that are derived from
\&\f(CW\*(C`PDL::Graphics::Prima::PlotType::Grid\*(C'\fR.
.IP "get_data" 4
.IX Item "get_data"
Returns the piddle containing the data.
.IP "change_data" 4
.IX Item "change_data"
Changes the data to the piddle passed in. For example,
.Sp
.Vb 1
\& $map_plot\->dataSets\->{\*(Aqintensity\*(Aq}\->change_data($new_intensity);
.Ve
.IP "guess_scaling_for" 4
.IX Item "guess_scaling_for"
Takes a piddle and tries to guess the scaling from the spacing. Returns a string
indicating the scaling, either \*(L"linear\*(R" or \*(L"log\*(R", as well as the spacing term.
.Sp
working here \- clarify that last bit with an example
.SS "Image"
.IX Subsection "Image"
Images are like Grids (they are derived from Grids, actually) but they have
a specified color format. Since they have a color format, this means that
they need to hold information for different aspects of each color, so they
typically have one more dimension than Grids. That is, where a grid might
have dimensions M x N, an rgb or hsv image would have dimensions 3 x M x N.
.PP
The default image format is rgb. Currently supported image formats are
rgb (red-green-blue), hsv (hugh-saturation-value), and prima (Prima's internal
color format, which is a packed form of rgb).
.PP
As Images are derived from Grids, any method you can call on a Grid you can
also call on an Image. Differences and details specific to Images include:
.IP "ds::Image \- short-name constructor" 4
.IX Item "ds::Image - short-name constructor"
.Vb 1
\&    ds::Image($image, option => value, ...)
.Ve
.Sp
Creates an Image dataset. A particularly important key is the \f(CW\*(C`color_format\*(C'\fR
key, which indicates the format of the \f(CW$image\fR piddle. When it comes to
drawing the image, the data will be converted to a set of Prima colors,
which means that the first dimension will be reduced away. Values associated
with keys should be thread-compatible with the dimensions starting from the
second dimension, so if your image has dims 3 x M x N, values associated
with your various keys should be thread-compatible with an M x N piddle.
.Sp
Note that color formats are case insensitive. At the moment there is no way
to add new color formats, but you should expect a color format \s-1API\s0 to come
at some point in the not-distant future. It will very likely make use of
PDL::Graphics::ColorSpace, so if you want your own special color format
to be used for Images, you should contribute to that project.
.IP "change_data" 4
.IX Item "change_data"
Sets the image to the new image data. Expects a piddle with the new data
and an optional format specification. If no specification is given, the
current format is used.
.SS "Func"
.IX Subsection "Func"
PDL::Graphics::Prima provides a special pair dataset that takes a function
reference instead of a set of data. The function should take a piddle of x\-values
as input and compute and return the y\-values. You can specify the number of data
points by supplying
.PP
.Vb 1
\& N_points => value
.Ve
.PP
in the list of key-value pairs that initialize the dataset. Most of the
functionality is inherited from \f(CW\*(C`PDL::Graphics::Prima::DataSet::Pair\*(C'\fR, but
there are a few exceptions.
.IP "ds::Func \- short-name constructor" 4
.IX Item "ds::Func - short-name constructor"
.Vb 1
\&    ds::Func($subroutine, option => value, ...)
.Ve
.Sp
The short-name constructor to create function datasets. The subroutine must be
a reference to a subroutine, or an anonymous sub. For example,
.Sp
.Vb 3
\& # Reference to a subroutine,
\& # PDL\*(Aqs exponential function:
\& ds::Func (\e&PDL::exp)
\& 
\& # Using an anonymous subroutine:
\& ds::Func ( sub {
\&     my $xs = shift;
\&     return $xs\->exp;
\& })
.Ve
.IP "change_data" 4
.IX Item "change_data"
Sets the function and/or the number of points to evaluate. The basic usage
looks like this:
.Sp
.Vb 1
\& $plot\->dataSets\->{\*(Aqcurve\*(Aq}\->change_data(\e&some_func, $N_points);
.Ve
.Sp
Either of the arguments can be undefined if you want to change only the
other. That means that you can change the function without changing the
number of evaluation points like this:
.Sp
.Vb 1
\& $plot\->dataSets\->{\*(Aqcurve\*(Aq}\->change_data(\e&some_func);
.Ve
.Sp
and you can change the number of evaluation points without changing the
function like this:
.Sp
.Vb 1
\& $plot\->dataSets\->{\*(Aqcurve\*(Aq}\->change_data(undef, $N_points);
.Ve
.IP "get_xs, get_ys" 4
.IX Item "get_xs, get_ys"
These functions override the default Pair behavior by generating the x\-data
and using that to compute the y\-data. The x\-data is uniformly sampled
according to the x\-axis scaling.
.IP "compute_collated_min_max_for" 4
.IX Item "compute_collated_min_max_for"
This function is supposed to provide information for autoscaling. This is a
sensible thing to do for the the y\-values of functions, but it makes no
situation with the x\-values since these are taken from the x\-axis min and
max already.
.Sp
This could be smarter, methinks, so please give me your ideas if you have
them. :\-)
.SS "Annotation"
.IX Subsection "Annotation"
PDL::Graphics::Prima provides a generic annotation dataset that is used for
adding drawn or textual annotations to your plots.
.IP "ds::Note \- short-name constructor for annotations" 4
.IX Item "ds::Note - short-name constructor for annotations"
.Vb 1
\&    ds::Note(plotType, plotType, ..., drawing => option, drawing => option)
.Ve
.Sp
The short-name constructor to create annotations. This expects a list of
annotation plot types fullowed by a list of general drawing options, such as
line width or color. For example,
.Sp
.Vb 12
\& ds::Note(
\&     pnote::Region(
\&         # args here
\&     ),
\&     pnote::Text(\*(Aqtext\*(Aq,
\&         # args here
\&     ),
\&     ... more note objects ...
\&     # Dataset drawing options
\&     color => cl::LightRed,
\&     ...
\& );
.Ve
.Sp
Unlike other dataset short-form constructors, you do not need to specify the
plotTypes key explicitly, though if you did it would do what you mean. That is,
the previous example would give identical results as this:
.Sp
.Vb 10
\& ds::Note(
\&     plotTypes => [
\&         pnote::Region(
\&             # args here
\&         ),
\&         pnote::Text(\*(Aqtext\*(Aq,
\&             # args here
\&         ),
\&         ... more note objects ...
\&     ],
\&     # Dataset drawing options
\&     color => cl::LightRed,
\&     ...
\& );
.Ve
.Sp
The former is simply offered as a convenience for this more long-winded form.
.SH "DataSet::Collection"
.IX Header "DataSet::Collection"
The dataset collection is the thing that actually holds the datasets in the
plot widget object. The Collection is a tied hash, so you access all of its
data members as if they were hash elements. However, it does some
double-checking for you behind the scenes to make sure that whenever you
add a dataset to the Collection, that you added a real DataSet object and
not some arbitrary thing.
.PP
working here \- this needs to be clarified
.SH "RESPONSIBILITIES"
.IX Header "RESPONSIBILITIES"
The datasets and the dataset collection have a number of responsibilities, and
a number of things for whch they are not responsible.
.PP
The dataset container is responsible for:
.IP "knowing the plot widget" 4
.IX Item "knowing the plot widget"
The container always maintains knowledge of the plot widget to which it belongs.
Put a bit differently, a dataset container cannot belong to multiple plot
widgets (at least, not at the moment).
.IP "informing datasets of their container and plot widget" 4
.IX Item "informing datasets of their container and plot widget"
When a dataset is added to a dataset collection, the collection is responsible
for informing the dataset of the plot object and the dataset collection to which
the dataset belongs.
.PP
Datasets themselves are responsible for:
.IP "knowing and managing the plotTypes" 4
.IX Item "knowing and managing the plotTypes"
The datasets are responsible for maintaining the list of plotTypes that are to
be applied to their data.
.IP "knowing per-dataset properties" 4
.IX Item "knowing per-dataset properties"
Drawing properties can be specified on a per-dataset scope. The dataset is
responsible for maintaining a list of these properties and providing them to
the plot types when they perform drawing operations.
.IP "knowing the dataset container and the plot widget" 4
.IX Item "knowing the dataset container and the plot widget"
All datasets know the dataset container and the plot widget to which they belong.
Although they could retrieve the widget through a method on the container, the
.IP "informing plotTyes' plot widget" 4
.IX Item "informing plotTyes' plot widget"
The plot types all know the widget (and dataset) to which they belong, and it is
the
.IP "managing the drawing operations of plotTypes" 4
.IX Item "managing the drawing operations of plotTypes"
Although datasets themselves do not need to draw anything, they do call the
drawing operations of the different plot types that they contain.
.IP "knowing and supplying the data" 4
.IX Item "knowing and supplying the data"
A key responsibility for the dataSets is holding the data that are drawn by the
plot types. Althrough the plot types may hold specialized data, the dataset
holds the actual data the underlies the plot types and provides a specific
interface for the plot types to access that data.
.PP
On the other hand, datasets are not responsible for knowing or doing any of the
following:
.IP "knowing axes" 4
.IX Item "knowing axes"
The plot object is responsible for knowing the x\- and y\-axis objects. However,
if the axis system is changed to allow for multiple x\- and y\-axes, then this
burden will shift to the dataset as it will need to know which axis to use when
performing data <\-> pixel conversions.
.SH "TODO"
.IX Header "TODO"
Add optional bounds to function-based DataSets.
.PP
Captitalization for plotType, etc.
.PP
Use \s-1PDL\s0 documentation conventions for signatures, ref, etc.
.PP
Additional datset, a two-tone grid. Imagine that you want to overlay the
population density of a country and the average rainfall (at the granularity
of counties, let's say). You could use the intensity of the red channel to
indicate population and the intensity of blue to indicate rainfall. Highly
populated areas with low rainfall would be bright red, while highly populated
areas with high rainfall would be purple, and low populated areas with high
rainfall would be blue. The color scale would be indicated
with a square with a color gradient (rather than a horizontal or vertical bar
with a color gradient, as in a normal ColorGrid). Anyway, this differs from
a normal grid dataset because it would require two datasets, one for each
tone.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Mertens (dcmertens.perl@gmail.com)
.SH "ADDITIONAL MODULES"
.IX Header "ADDITIONAL MODULES"
Here is the full list of modules in this distribution:
.IP "PDL::Graphics::Prima" 4
.IX Item "PDL::Graphics::Prima"
Defines the Plot widget for use in Prima applications
.IP "PDL::Graphics::Prima::Axis" 4
.IX Item "PDL::Graphics::Prima::Axis"
Specifies the behavior of axes (but not the scaling)
.IP "PDL::Graphics::Prima::DataSet" 4
.IX Item "PDL::Graphics::Prima::DataSet"
Specifies the behavior of DataSets
.IP "PDL::Graphics::Prima::Limits" 4
.IX Item "PDL::Graphics::Prima::Limits"
Defines the lm:: namespace
.IP "PDL::Graphics::Prima::Palette" 4
.IX Item "PDL::Graphics::Prima::Palette"
Specifies a collection of different color palettes
.IP "PDL::Graphics::Prima::PlotType" 4
.IX Item "PDL::Graphics::Prima::PlotType"
Defines the different ways to visualize your data
.IP "PDL::Graphics::Prima::ReadLine" 4
.IX Item "PDL::Graphics::Prima::ReadLine"
Encapsulates all interaction with the Term::ReadLine family of
modules.
.IP "PDL::Graphics::Prima::Scaling" 4
.IX Item "PDL::Graphics::Prima::Scaling"
Specifies different kinds of scaling, including linear and logarithmic
.IP "PDL::Graphics::Prima::Simple" 4
.IX Item "PDL::Graphics::Prima::Simple"
Defines a number of useful functions for generating simple and not-so-simple
plots
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Unless otherwise stated, all contributions in code and documentation are
copyright (c) their respective authors, all rights reserved.
.PP
Portions of this module's code are copyright (c) 2011 The Board of
Trustees at the University of Illinois.
.PP
Portions of this module's code are copyright (c) 2011\-2013 Northwestern
University.
.PP
Portions of this module's code are copyright (c) 2013\-2014 Dickinson
College.
.PP
This module's documentation is copyright (c) 2011\-2014 David Mertens.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1507:" 4
.IX Item "Around line 1507:"
You forgot a '=back' before '=head2'
