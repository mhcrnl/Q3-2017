.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::image-load 3"
.TH pod::Prima::image-load 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::image\-load \- Using image subsystem
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Details on image subsystem \- image loading, saving, and codec managements
.SH "Loading"
.IX Header "Loading"
.SS "Simple loading"
.IX Subsection "Simple loading"
Simplest case, loading a single image would look like:
.PP
.Vb 2
\&        my $x = Prima::Image\-> load( \*(Aqfilename.duf\*(Aq);
\&        die "$@" unless $x;
.Ve
.PP
Image functions can work being either invoked from package,
or from existing Prima::Image object, in latter case the caller 
object itself is changing. The code above could be also written as
.PP
.Vb 2
\&        my $x = Prima::Image\-> create;
\&        die "$@" unless $x\-> load( \*(Aqfilename.duf\*(Aq);
.Ve
.PP
In both cases \f(CW$x\fR contains image data upon success.
Error is returned into $@ variable ( see perldoc perlvar for more info).
.SS "Loading from stream"
.IX Subsection "Loading from stream"
\&\f(CW\*(C`Prima::Image\*(C'\fR can also load image by reading from a stream:
.PP
.Vb 4
\&        open FILE, \*(Aqa.jpeg\*(Aq or die "Cannot open:$!";
\&        binmode FILE;
\&        my $x = Prima::Image\-> load( \e*FILE);
\&        die "$@" unless $x;
.Ve
.SS "Multiframe loading"
.IX Subsection "Multiframe loading"
Multiframe load call can be also issued in two ways:
.PP
.Vb 2
\&        my @x = Prima::Image\-> load( \*(Aqfilename.duf\*(Aq, loadAll => 1);
\&        die "$@" unless $x[\-1];
\&
\&        my $x = Prima::Image\-> create;
\&        my @x = $x\-> load( \*(Aqfilename.duf\*(Aq, loadAll => 1);
\&        die "$@" unless $x[\-1];
.Ve
.PP
In second case, the content of the first frame comes to \f(CW$x\fR and \f(CW$x\fR[0].
Sufficient check for error is whether last item of a returned
array is defined. This check works also if an empty array is returned.
Only this last item can be an undefined value, others are guaranteed
to be valid objects.
.PP
Multiframe syntax is expressed in a set of extra hash keys.
These keys are:
.IP "loadAll" 4
.IX Item "loadAll"
Request for loading all frames that can be read from a file.
Example:
.Sp
.Vb 1
\&        loadAll => 1
.Ve
.IP "index" 4
.IX Item "index"
If present, returns a single frame with index given.
Example:
.Sp
.Vb 1
\&        index => 8
.Ve
.IP "map" 4
.IX Item "map"
Contains an anonymous array of frame indices to load. 
Valid indices are above zero, negative ones can't be counted in a way
perl array indices are. Example:
.Sp
.Vb 1
\&         map => [0, 10, 15..20]
.Ve
.SS "Querying extra information"
.IX Subsection "Querying extra information"
By default Prima loads image data and palette only. For any other information
that can be loaded, anonymous hash 'extras' can be defined. To notify a codec
that this extra information is desired, loadExtras boolean value is used.
Example:
.PP
.Vb 5
\&        my $x = Prima::Image\-> load( $f, loadExtras => 1);
\&        die "$@" unless $x;
\&        for ( keys %{$x\-> {extras}}) {
\&           print " $_ : $x\->{extras}\->{$_}\en";
\&        }
.Ve
.PP
The code above loads and prints extra information read from a file.
Typical output, for example, from a gif codec based on libungif would look
like:
.PP
.Vb 4
\&    codecID : 1
\&    transparentColorIndex : 1
\&    comment : created by GIMP
\&    frames : 18
.Ve
.PP
\&'codecID' is a Prima-defined extra field, which is an index of the codec
which have loaded the file. This field's value is useful for explicit 
indication of codec on the save request.
.PP
\&'frames' is also a Prima-defined extra field, with integer value set to
a number of frames in the image. It might be set to \-1,
signaling that codec is incapable of quick reading of the frame count.
If, however, it is necessary to get actual frame count, a 'wantFrames'
profile boolean value should be set to 1 \- then frames is guaranteed to
be set to a 0 or positive value, but the request may take longer time, especially
on a large file with sequential access. Real life example is a gif file
with more than thousand frames. 'wantFrames' is useful in null load requests.
.SS "Multiprofile loading requests"
.IX Subsection "Multiprofile loading requests"
The parameters that are accepted by load, are divided into several 
categories \- first, those that apply to all loading process and those
who apply only to a particular frame. Those who are defined by Prima, are
enumerated above \- loadExtras, loadAll etc. Only loadExtras, noImageData,
noIncomplete and iconUnmask are applicable to
a frame, other govern the loading process. A codec may as well define its own
parameters, however it is not possible to tell what parameter belongs to what
group \- this information is to be found in codec documentation;
.PP
The parameters that applicable to any frame, can be specified separately to
every desirable frame in single call. For that purpose, parameter 'profiles'
is defined. 'profiles' is expected to be an anonymous array of hashes, each
hash where corresponds to a request number. Example:
.PP
.Vb 4
\&        $x\-> load( $f, loadAll => 1, profiles => [
\&             {loadExtras => 0},
\&             {loadExtras => 1},
\&        ]);
.Ve
.PP
First hash there applies to frame index 0, second \- to frame index 1.
Note that in code
.PP
.Vb 6
\&        $x\-> load( $f, 
\&           map => [ 5, 10],
\&           profiles => [
\&             {loadExtras => 0},
\&             {loadExtras => 1},
\&        ]);
.Ve
.PP
first hash applies to frame index 5, and second \- to frame index 10.
.SS "Null load requests"
.IX Subsection "Null load requests"
If it is desired to peek into image, reading type and dimensions only, one
should set 'noImageData' boolean value to 1. Using 'noImageData', empty
objects with read type are returned, and with extras 'width' and 'height'
set to image dimensions. Example:
.PP
.Vb 4
\&        $x\-> load( $f, noImageData => 1);
\&        die "$@" unless $x;
\&        print $x\-> {extras}\-> {width} , \*(Aqx\*(Aq , $x\-> {extras}\-> {height}, \*(Aqx\*(Aq,
\&           $x\-> type & im::BPP, "\en";
.Ve
.PP
Some information about image can be loaded even without frame loading \- if the
codec provides such a functionality. This is the only request that cannot be issued
on a package:
.PP
.Vb 1
\&        $x\-> load( $f, map => [], loadExtras => 1);
.Ve
.PP
Since no frames are required to load, an empty array is returned 
upon success and an array with one undefined value on failure.
.SS "Using Prima::Image descendants"
.IX Subsection "Using Prima::Image descendants"
If Prima needs to create a storage object, it is by default
Prima::Image, or a class name of an caller object, or a package
the request was issued on. This behavior can be altered 
using parameter 'className', which defines the class to be used 
for the frame.
.PP
.Vb 8
\&        my @x = Prima::Image\-> load( $f,
\&            map => [ 1..3],
\&            className => \*(AqPrima::Icon\*(Aq, 
\&            profiles => [
\&                {},
\&                { className => \*(AqPrima::Image\*(Aq },
\&                {}
\&            ],
.Ve
.PP
In this example \f(CW@x\fR will be ( Icon, Image, Icon) upon success.
.PP
When loading to an Icon object, the default toolkit action is
to build the transparency mask based on image data. When it is
not the desired behavior, e.g., there is no explicit knowledge 
of image, but the image may or may not contain transparency 
information, \f(CW\*(C`iconUnmask\*(C'\fR boolean option can be used. When set
to a \f(CW\*(C`true\*(C'\fR value, and the object is \f(CW\*(C`Prima::Icon\*(C'\fR descendant,
\&\f(CW\*(C`Prima::Icon::autoMasking\*(C'\fR is set to \f(CW\*(C`am::None\*(C'\fR prior to the
file loading. By default this options is turned off.
.SS "Loading with progress indicator"
.IX Subsection "Loading with progress indicator"
Some codecs (\s-1PNG,TIFF,JPEG\s0) can notify the caller as they read image data.  For
this purpose, \f(CW\*(C`Prima::Image\*(C'\fR has two events, \f(CW\*(C`onHeaderReady\*(C'\fR and
\&\f(CW\*(C`onDataReady\*(C'\fR. If either (or both) are present on image object that is issuing
load call, and the codec supports progressive loading, these events are called.
\&\f(CW\*(C`onHeaderReady\*(C'\fR is called when image header data is acquired, and empty image
with the dimensions and pixel type is allocated. \f(CW\*(C`onDataReady\*(C'\fR is called
whenever a part of image is ready and is loaded in the memory of the object;
the position and dimensions of the loaded area is reported also. The format of
the events is:
.PP
.Vb 2
\&    onHeaderReady $OBJECT
\&    onDataReady   $OBJECT, $X, $Y, $WIDTH, $HEIGHT
.Ve
.PP
\&\f(CW\*(C`onHeaderReady\*(C'\fR is called only once, but \f(CW\*(C`onDataReady\*(C'\fR is called as soon as
new image data is available. To reduce frequency of these calls, that otherwise
would be issued on every scanline loaded, \f(CW\*(C`load\*(C'\fR has parameter \f(CW\*(C`eventDelay\*(C'\fR,
a number of seconds, which limits event rate. The default \f(CW\*(C`eventDelay\*(C'\fR is 0.1 .
.PP
The handling on \f(CW\*(C`onDataReady\*(C'\fR must be performed with care. First, the image 
must be accessed read-only, which means no transformations with image size and 
type are allowed. Currently there is no protection for such actions ( because
codec must perform these ), so a crash will most surely issue.
Second, loading and saving of images is not in general reentrant, and although
some codecs are reentrant, loading and saving images inside image events is
not recommended.
.PP
There are two techniques to display partial image as it loads. All of these
share overloading of \f(CW\*(C`onHeaderReady\*(C'\fR and \f(CW\*(C`onDataReady\*(C'\fR. The simpler is to
call \f(CW\*(C`put_image\*(C'\fR from inside \f(CW\*(C`onDataReady\*(C'\fR:
.PP
.Vb 5
\&        $i = Prima::Image\-> new(
\&                onDataReady => sub {
\&                        $progress_widget\-> put_image( 0, 0, $i);
\&                },
\&        );
.Ve
.PP
but that will most probably loads heavily underlying OS-dependent conversion of
image data to native display bitmap data. A more smarter, but more complex
solution is to copy loaded (and only loaded) bits to a preexisting device
bitmap:
.PP
.Vb 12
\&        $i = Prima::Image\-> new(
\&                onHeaderReady => sub {
\&                        $bitmap = Prima::DeviceBitmap\-> new(
\&                                width    => $i\-> width,
\&                                height   => $i\-> height,
\&                        ));
\&                },
\&                onDataReady => sub {
\&                        my ( $i, $x, $y, $w, $h) = @_;
\&                        $bitmap\-> put_image( $x, $y, $i\-> extract( $x, $y, $w, $h));
\&                },
\&        );
.Ve
.PP
The latter technique is used by \f(CW\*(C`Prima::ImageViewer\*(C'\fR when it is setup to monitor
image loading progress. See \*(L"watch_load_progress\*(R" in Prima::ImageViewer for details.
.SS "Truncated files"
.IX Subsection "Truncated files"
By default, codecs are not specified whether they would fail on premature end
of file or omit the error and return truncated image. \f(CW\*(C`noIncomplete\*(C'\fR boolean
flag tells that a codec must always fail if the image cannot be red in full. It
is off by default. If indeed the codec detected that the file was incomplete,
it sets \f(CW\*(C`truncated\*(C'\fR boolean flag in the \f(CW\*(C`extras\*(C'\fR profile, if \f(CW\*(C`loadExtras\*(C'\fR
was requested.
.SH "Saving"
.IX Header "Saving"
.SS "Simple saving"
.IX Subsection "Simple saving"
Typical saving code will be:
.PP
.Vb 1
\&   die "$@" unless $x\-> save( \*(Aqfilename.duf\*(Aq);
.Ve
.PP
Upon a single-frame invocation save returns 1 upon success an 0 on failure.
Save requests also can be performed with package syntax:
.PP
.Vb 2
\&   die "$@" unless Prima::Image\-> save( \*(Aqfilename.duf\*(Aq, 
\&       images => [ $x]);
.Ve
.SS "Saving to a stream"
.IX Subsection "Saving to a stream"
Saving to a stream requires explicit \f(CW\*(C`codecID\*(C'\fR to be supplied. When an image
is loaded with \f(CW\*(C`loadExtras\*(C'\fR, this field is always present on the image object,
and is an integer that selects image encoding format.
.PP
.Vb 5
\&   my @png_id = 
\&      map  { $_\-> {codecID} }
\&      grep { $_\-> {fileShortType} =~ /^png$/i } 
\&      @{ Prima::Image\-> codecs };
\&   die "No png codec installed" unless @png_id;
\&
\&   open FILE, "> a.png" or die "Cannot save:$!";
\&   binmode FILE;
\&   $image\-> save( \e*FILE, codecID => $png_id[0])
\&      or die "Cannot save:$@";
.Ve
.SS "Multiframe saving"
.IX Subsection "Multiframe saving"
In multiframe invocation save returns number of successfully saved frames.
File is erased though, if error occurred, even after some successfully 
written frames.
.PP
.Vb 2
\&    die "$@" if scalar(@images) > Prima::Image\-> save( $f, 
\&       images => \e@images);
.Ve
.SS "Saving extras information"
.IX Subsection "Saving extras information"
All information, that is found in object hash reference 'extras', is
assumed to be saved as an extra information. It is a codec's own business
how it reacts on invalid and/or inacceptable information \- but typical behavior is
that keys that were not recognized by the codec just get ignored, and invalid values
raise an error.
.PP
.Vb 2
\&       $x\-> {extras}\-> {comments} = \*(AqCreated by Prima\*(Aq;
\&       $x\-> save( $f);
.Ve
.SS "Selecting a codec"
.IX Subsection "Selecting a codec"
Extras field 'codecID', the same one that is defined after load requests,
selects explicitly a codec for an image to handle. If the codec
selected is incapable of saving an error is returned. Selecting a codec
is only possible with the object-driven syntax, and this information
is never extracted from objects but passed to 'images' array instead.
.PP
.Vb 2
\&       $x\-> {extras}\-> {codecID} = 1;
\&       $x\-> save( $f);
.Ve
.PP
Actual correspondence between codecs and their indices is described latter.
.PP
\&\s-1NB \-\s0 if codecID is not given, codec is selected by the file extension.
.SS "Type conversion"
.IX Subsection "Type conversion"
Codecs usually are incapable of saving images in all formats, so Prima
either converts an image to an appropriate format or signals an error.
This behavior is governed by profile key 'autoConvert', which is 1 by
default. 'autoConvert' can be present in image 'extras' structures.
With autoConvert set it is guaranteed that image will be saved, but original image
information may be lost. With autoConvert unset, no information will be lost,
but Prima may signal an error. Therefore general-purpose save routines should
be planned carefully. As an example the Prima::ImageDialog::SaveImageDialog
code might be useful.
.PP
When the conversion takes place, Image property 'conversion' is used
for selection of an error distribution algorithm, if down-sampling 
is required.
.SS "Appending frames to an existing file"
.IX Subsection "Appending frames to an existing file"
This functionality is under design, but the common outlines are already set.
Profile key 'append' ( 0 by default ) triggers this behavior \- if it is set,
then an append attempt is made.
.SH "Managing codecs"
.IX Header "Managing codecs"
Prima provides single function, Prima::Image\-> codecs, which returns an
anonymous array of hashes, where every hash entry corresponds to a 
registered codec. 'codecID' parameter on load and save requests is actually
an index in this array. Indexes for a codecs registered once never change,
so it is safe to manipulate these numbers within single program run.
.PP
Codec information that is contained in these hashes is divided into
following parameters:
.IP "codecID" 4
.IX Item "codecID"
Unique integer value for a codec, same as index of the codec entry in
results of \f(CW\*(C`Prima::Image\->codecs\*(C'\fR;
.IP "name" 4
.IX Item "name"
codec full name, string
.IP "vendor" 4
.IX Item "vendor"
codec vendor, string
.IP "versionMajor and versionMinor" 4
.IX Item "versionMajor and versionMinor"
usually underlying library versions, integers
.IP "fileExtensions" 4
.IX Item "fileExtensions"
array of strings, with file extensions that are typical to a codec.
example: ['tif', 'tiff']
.IP "fileType" 4
.IX Item "fileType"
Description of a type of a file, that codec is designed to work with.
String.
.IP "fileShortType" 4
.IX Item "fileShortType"
Short description of a type of a file, that codec is designed to work with.
( short means 3\-4 characters ). String.
.IP "featuresSupported" 4
.IX Item "featuresSupported"
Array of strings, with some features description that a codec supports \-
usually codecs implement only a part of file format specification, so it is
always interesting to know, what part it is.
.IP "module and package" 4
.IX Item "module and package"
Specify a perl module, usually inside Prima/Image directory into Prima distribution,
and a package inside the module. The package contains some specific functions
for work with codec-specific parameters. Current implementation defines
only ::\fIsave_dialog()\fR function, that returns a dialog that allows to change
these parameters. See Prima::ImageDialog::SaveImageDialog for details.
Strings, undefined if empty.
.IP "canLoad" 4
.IX Item "canLoad"
1 if a codec can load images, 0 if not
.IP "canLoadStream" 4
.IX Item "canLoadStream"
1 if a codec can load images from streams, 0 otherwise
.IP "canLoadMultiple" 4
.IX Item "canLoadMultiple"
1 if a codec can handle multiframe load requests and load frames with
index more than zero. 0 if not.
.IP "canSave" 4
.IX Item "canSave"
1 if a codec can save images, 0 if not.
.IP "canSaveStream" 4
.IX Item "canSaveStream"
1 if a codec can save images to streams, 0 otherwise
.IP "canSaveMultiple" 4
.IX Item "canSaveMultiple"
Set if a codec can save more that one frame
.IP "canAppend" 4
.IX Item "canAppend"
Set if a codec can append frames to an exising file
.IP "types" 4
.IX Item "types"
Array of integers \- each is a combination of im:: flags, an image type,
which a codec is capable of saving. First type in list is a default one;
if image type that to be saved is not in that list, the image will be 
converted to this default type.
.IP "loadInput" 4
.IX Item "loadInput"
Hash, where keys are those that are accepted by Prima::Image\-> load,
and values are default values for these keys.
.IP "loadOutput" 4
.IX Item "loadOutput"
Array of strings, each of those is a name of extra information entry 
in 'extras' hash.
.IP "saveInput" 4
.IX Item "saveInput"
Hash, where keys are those that are accepted by Prima::Image\-> save,
and values are default values for these keys.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Image, Prima::codecs
