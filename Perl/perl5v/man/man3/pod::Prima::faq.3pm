.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::faq 3"
.TH pod::Prima::faq 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::faq \- Frequently asked questions about Prima
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1FAQ\s0 covers various topics around Prima, such as distribution, compilation,
installation, and programming.
.SH "COMMON"
.IX Header "COMMON"
.SS "What is Prima?"
.IX Subsection "What is Prima?"
Prima is a general purpose extensible graphical user interface toolkit with a
rich set of standard widgets and an emphasis on 2D image processing tasks. A
Perl program using \s-1PRIMA\s0 looks and behaves identically on X, Win32.
.SS "Yeah, right. So what is Prima again?"
.IX Subsection "Yeah, right. So what is Prima again?"
Ok. A Yet Another Perl \s-1GUI.\s0
.SS "Why bother with the Yet Another thing, while there is Perl-Tk and plenty of others?"
.IX Subsection "Why bother with the Yet Another thing, while there is Perl-Tk and plenty of others?"
Prima was started on \s-1OS/2,\s0 where Tk didn't really run. We have had two options
\&\- either port Tk, or write something on our own, probably better than the
existing tools.  We believe that we've succeeded.
.PP
Interestingly enough, Prima still builds for \s-1OS/2 \s0(as of July 2012), but its support
was killed because noone needs it anyway.
.SS "Why Perl?"
.IX Subsection "Why Perl?"
Why not? Perl is great. The high-level \s-1GUI\s0 logic fits badly into C, \*(C+, or the
like, so a scripting language is probably the way to go here.
.SS "But I want to use Prima in another language."
.IX Subsection "But I want to use Prima in another language."
Unless your language has runtime binding with perl, you cannot.
.SS "Who wrote Prima?"
.IX Subsection "Who wrote Prima?"
Dmitry Karasik implemented the majority of the toolkit, after the original idea
by Anton Berezin. The latter and set of contributors helped the development of
the toolkit since then.
.SS "What is the copyright?"
.IX Subsection "What is the copyright?"
The copyright is a modified \s-1BSD\s0 license, where only two first paragraphs remain
out of the original four. The text of copyright is present is almost all files
of the toolkit.
.SS "I'd like to contribute."
.IX Subsection "I'd like to contribute."
You can do this is several ways. The project would probably best benefit from
the advocacy, because not many people use it. Of course, you can send in new
widgets, patches, suggestions, or even donations. Also, documentation is the
thing that needs a particular attention, since my native language is not
English, so if there are volunteers for polishing of the Prima docs, you are
very welcome.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
.SS "Where can I download Prima?"
.IX Subsection "Where can I download Prima?"
<http://www.prima.eu.org> contains links to source and binary download
resources, instructions on how to subscribe to the Prima mailing list,
documentation, and some other useful info.
.SS "What is better, source or binary?"
.IX Subsection "What is better, source or binary?"
Depends where your are and what are your goals. On unix, the best is to use the
source. On win32 the binaries probably are preferred. If you happen to
use cygwin you probably still better off using the source.
.SS "How to install binary distribution?"
.IX Subsection "How to install binary distribution?"
First, check if you've downloaded Prima binary for the correct version of Perl.
For win32 ActiveState builds, difference in the minor digits of the Perl
version shouldn't be a problem, for example, binary distribution for Perl build
#805 should work with Perl build #808, etc etc.
.PP
To install, unpack the archive and type 'perl ms_install.pl'.  The files will
be copied into the perl tree.
.SS "How to compile Prima from source?"
.IX Subsection "How to compile Prima from source?"
Type the following:
.PP
.Vb 3
\&   perl Makefile.PL
\&   make 
\&   make install
.Ve
.PP
If the 'perl Makefile.PL' fails complaining to strange errors, you can check
makefile.log to see if anything is wrong. A typical situation here is that
Makefile.PL may report that is cannot find Perl library, for example, where
there actually it invokes the compiler in a wrong way.
.PP
Note, that in order to get Prima working from sources, your system must contain
graphic libraries, such as libungif or ligjpeg, for Prima to load graphic
files.
.SS "What's about the graphic libraries?"
.IX Subsection "What's about the graphic libraries?"
To load and save images, Prima employs graphic libraries. Such as, to load \s-1GIF\s0
files, libungif library is used, etc. Makefile.PL finds available libraries and
links Prima against these. It is possible to compile Prima without any, but this
is not really useful.
.PP
On every supported platform Prima can make use of the following graphic
libraries:
.PP
.Vb 6
\&   libX11   \- XBM bitmaps
\&   libXpm   \- Xpm pixmaps
\&   libjpeg  \- JPEG images
\&   libungif \- GIF images
\&   libpng   \- PNG images
\&   libtiff  \- tiff images
.Ve
.PP
Strawberry perl and Cygwin come with most of them, so on these installations Prima just
compiles without any throuble. For other perl builds, use one of \f(CW\*(C`Prima::codecs::\*(C'\fR 
modules that contains the needed include and lib files. If you're installing Prima
through \s-1CPAN,\s0 that gets done authomatically.
.SS "img/codec_XXX.c compile error"
.IX Subsection "img/codec_XXX.c compile error"
\&\f(CW\*(C`img/codec_XXX.c\*(C'\fR files are C sources for support of the graphic libraries. In
case a particular codec does not compile, the ultimate fix is to remove the
file and re-run Makefile.PL . This way, the problem can be avoided easily,
although at cost of a lacking support for a graphic format.
.SS "How'd I check what libraries are compiled in?"
.IX Subsection "How'd I check what libraries are compiled in?"
.Vb 1
\&   perl \-MPrima \-e \*(Aqprint map { $_\->{name}.qq(\en) } @{Prima::Image\->codecs};\*(Aq
.Ve
.SS "I have a graphic library installed, but Makefile.PL doesn't find it"
.IX Subsection "I have a graphic library installed, but Makefile.PL doesn't find it"
The library is probably located in a weird directory so Makefile.PL must be
told to use it by adding LIBPATH+=/some/weird/lib, and possibly
INCPATH+=/some/weird/include in the command line. Check makefile.log created by
Makefile.PL for the actual errors reported when it tries to use the
library.
.SS "Compile error"
.IX Subsection "Compile error"
There are various reasons why a compilation may fail. The best would be
to copy the output together with outputs of env and perl \-V and send these into
the Prima mailing list.
.SS "Prima doesn't run"
.IX Subsection "Prima doesn't run"
Again, there are reasons for Prima to fail during the start.
.PP
First, check whether all main files are installed correctly. \fIPrima.pm\fR must
be in your perl directory, and Prima library file ( \fIPrima.a\fR or \fIPrima.so\fR for
unix, \fIPrima.dll\fR for win32 ) is copied in the
correct location in the perl tree.
.PP
Second, try to run 'perl \-MPrima \-e 1' . If Prima.pm is not found, the error
message would something like
.PP
.Vb 1
\&  Can\*(Aqt locate Prima.pm in @INC
.Ve
.PP
If Prima library or one of the libraries it depends on cannot be found, perl
Dynaloader would complain. On win32 this usually happen when
some dll files Prima needs are not found. If this is the case, try
to copy these files into your \s-1PATH,\s0 for example in C:/WINNT .
.SS "Prima doesn't get installed using ppm (ActiveState)"
.IX Subsection "Prima doesn't get installed using ppm (ActiveState)"
Prima uses a non-conventional build process, which is not picked up by
automated ActiveState ppm builder. So if you run \*(L"ppm install Prima\*(R" and
it succeeds but installs nothing, try this:
.PP
.Vb 1
\&  ppm install \-\-force http://cpan.uwinnipeg.ca/PPMPackages/10xx/Prima.ppd
.Ve
.PP
(Justin Allegakoen and Randy Kobes:thanks!)
.SS "Prima error: Can't open display"
.IX Subsection "Prima error: Can't open display"
This error happens when you've compiled Prima for X11, and no connection to X11
display can be established. Check your \s-1DISPLAY\s0 environment variable, or use
\&\-\-display parameter when running Prima. If you do not want Prima to connect to
the display, for example, to use it inside of a \s-1CGI\s0 script, either use \-\-no\-x11
parameter or include \f(CW\*(C`use Prima::noX11\*(C'\fR statement in your program.
.SS "X11: my fonts are bad!"
.IX Subsection "X11: my fonts are bad!"
Check whether you have Xft and fontconfig installed. Prima benefits greatly from
having been compiled with Xft/fontconfig. Read more in Prima::X11 .
.SS "Where are the docs installed?"
.IX Subsection "Where are the docs installed?"
Prima documentation comes in .pm and .pod files. These, when installed,
are copied under perl tree, and under man tree in unix. So, 
\&'perldoc Prima' should be sufficient to invoke the main page
of the Prima documentation. Other pages can be invoked as 'perldoc Prima::Buttons',
say, or, for the graphical pod reader, 'podview Prima::Buttons'. podview
is the Prima doc viewer, which is also capable of displaying any \s-1POD\s0 page.
.PP
There is also a pdf file on the Prima web site www.prima.eu.org, which contains
the same set of documentation but composed as a single book. Its sources are
in utils/makedoc directory, somewhat rudimentary and require an installation
of latex and dvips to produce one of tex, dvi, ps, or pdf targets.
.SS "I've found a bug!"
.IX Subsection "I've found a bug!"
Send the bug report into the mailing list or to \s-1CPAN RT.\s0
.SH "PROGRAMMING"
.IX Header "PROGRAMMING"
.SS "How can I use .fm files of the Visual Builder inside my program?"
.IX Subsection "How can I use .fm files of the Visual Builder inside my program?"
podview Prima::VB::VBLoader
.SS "I want to use Prima inside \s-1CGI\s0 for loading and converting images only, without X11 display."
.IX Subsection "I want to use Prima inside CGI for loading and converting images only, without X11 display."
.Vb 3
\&   use Prima::noX11; # this prevents Prima from connecting to X11 display
\&   use Prima;
\&   my $i = Prima::Image\-> load( ... )
.Ve
.PP
Note that drawing on images will be severly limited \- only pixel and put_image methods would work.
.SS "How would I change several properties with a single call?"
.IX Subsection "How would I change several properties with a single call?"
.Vb 5
\&   $widget\-> set(
\&      property1 => $value1,
\&      property2 => $value2,
\&      ...
\&   );
.Ve
.SS "I want Prima::Edit to have feature \s-1XXX\s0"
.IX Subsection "I want Prima::Edit to have feature XXX"
If the feature is not governed by none of the \f(CW\*(C`Prima::Edit\*(C'\fR properties,
you've to overload \f(CW\*(C`::on_paint\*(C'\fR. It is not that hard as you might think.
.PP
If the feature is generic enough, you can send a patch in the list.
.SS "Tk ( Wx, Qt, whatever ) has a feature Prima doesn't."
.IX Subsection "Tk ( Wx, Qt, whatever ) has a feature Prima doesn't."
Well, I'd probably love to see the feature in Prima as well, but I don't
have a time to write it myself. Send in a patch, and I promise I'll check it out.
.SS "I wrote a program and it looks ugly with another font size"
.IX Subsection "I wrote a program and it looks ugly with another font size"
This would most certainly happen when you rely on your own screen properties.
There are several ways to avoid this problem.
.PP
First, if one programs a window where there are many widgets independent of each
other size, one actually can supply coordinates for these widgets as they are 
positioned on a screen. Don't forget to set \f(CW\*(C`designScale\*(C'\fR
property of the parent window, which contains dimensions of the font used to design the
window. One can get these by executing
.PP
.Vb 1
\&    perl \-MPrima \-MPrima::Application \-le \*(Aq$_=$::application\->font; print $_\->width, q( ), $_\->height\*(Aq;
.Ve
.PP
This way, the window and the widgets would get resized automatically under another font.
.PP
Second, in case the widget layout is not that independent, one can position the
widgets relatively to each other by explicitly calculating widget extension. For
example, an \f(CW\*(C`InputLine\*(C'\fR would have height relative to the font, and to have a
widget placed exactly say 2 pixels above the input line, code something like
.PP
.Vb 2
\&    my $input = $owner\-> insert( InputLine, ... );
\&    my $widget = $owner\-> insert( Widget, bottom => $input\-> top + 2 );
.Ve
.PP
Of course one can change the font as well, but it is a bad idea since users
would get annoyed by this.
.PP
Third, one can use geometry managers, similar to the ones in Tk. See
Prima::Widget::pack and Prima::Widget::place.
.PP
Finally, check the widget layouts with Prima::Stress written specifically for this
purpose:
.PP
.Vb 1
\&    perl \-MPrima::Stress myprogram
.Ve
.SS "How would I write a widget class myself?"
.IX Subsection "How would I write a widget class myself?"
There are lots and lots of examples of this. Find a widget class similar to
what you are about to write, and follow the idea. There are, though, some non-evident
moments worth to enumerate.
.IP "\(bu" 4
Test your widget class with different default settings, such as colors, fonts,
parent sizes, widget properties such as buffered and visible.
.IP "\(bu" 4
Try to avoid special properties for \f(CW\*(C`create\*(C'\fR, where for example a particular property
must always be supplied, or never supplied, or a particular combination of properties is
expected. See if the \s-1DWIM\s0 principle can be applied instead.
.IP "\(bu" 4
Do not be afraid to define and re-define notification types. These have large number
of options, to be programmed once and then used as a \s-1DWIM\s0 helper. Consider for which
notifications user callback routines ( onXxxx ) would be best to be called first, or
last, whether a notification should be of multiple or single callback type.
.Sp
If there is a functionality better off performed by the user-level code, consider
creating an individual notification for this purpose.
.IP "\(bu" 4
Repaint only the changed areas, not the whole widget.
.Sp
If your widget has scrollable areas, use \f(CW\*(C`scroll\*(C'\fR method.
.Sp
Inside \f(CW\*(C`on_paint\*(C'\fR check whether the whole or only a part of the widget is
about to be repainted. Simple optimizations here increase the speed.
.Sp
Avoid using pre-cooked data in \f(CW\*(C`on_paint\*(C'\fR, such as when for example only a
particular part of a widget was invalidated, and this fact is stored in an
internal variable. This is because when the actual \f(CW\*(C`on_paint\*(C'\fR call is
executed, the invalid area may be larger than was invalidated by the class
actions. If you must though, compare values of \f(CW\*(C`clipRect\*(C'\fR property to see
whether the invalid area is indeed the same as it is expected.
.Sp
Remember, that inside on_paint all coordinates are inclusive-inclusive, 
and outside inclusive-exclusive.
.Sp
Note, that \f(CW\*(C`buffered\*(C'\fR property does not guarantee that the widget
output would be actually buffered.
.IP "\(bu" 4
Write some documentation and example of use.
.SS "How would I add my widget class to the \s-1VB\s0 palette?"
.IX Subsection "How would I add my widget class to the VB palette?"
Check Prima/VB/examples/Widgety.pm . This file, if loaded through
\&'Add widget' command in \s-1VB,\s0 adds example widget class and example 
\&\s-1VB\s0 property into the \s-1VB\s0 palette and Object Inspector.
.SS "How would I use unicode/UTF8 in Prima?"
.IX Subsection "How would I use unicode/UTF8 in Prima?"
Basically,
.PP
.Vb 1
\&   $::application\-> wantUnicodeInput(1)
.Ve
.PP
is enough to tell Prima to provide input in Unicode/UTF8. Note, that if the
data received in that fashion are to be put through file I/O, the \f(CW\*(Aqutf8\*(Aq\fR \s-1IO\s0
layer must be selected ( see open ).
.PP
Prima can input and output \s-1UTF8\s0 text if the underlying system capabilities
support that ( check Prima::Application::get_system_value, \f(CW\*(C`sv::CanUTF8_Input\*(C'\fR
and \f(CW\*(C`sv::CanUTF8_Output\*(C'\fR ).  Displaying \s-1UTF8\s0 text is unproblematic, because Perl
scalars can be unambiguously told whether the text they contain is in \s-1UTF8\s0 or
not. The text that comes from the user input
\&\- keyboard and clipboard \- can be treated and reported to Prima
either as \s-1UTF8\s0 or plain text, depending on
\&\f(CW\*(C`Prima::Application::wantUnicodeInput\*(C'\fR property.
.PP
The keyboard input is also easy, because a character key event comes with the character
code, not the character itself, and conversion between these is done via
standard perl's \f(CW\*(C`chr\*(C'\fR and \f(CW\*(C`ord\*(C'\fR.  The clipboard input is more complicated,
because the clipboard may contain both \s-1UTF8\s0 and plain text data at once, and it
must be decided by the programmer explicitly which one is desired.  See more in
\&\*(L"Unicode\*(R" in Prima::Clipboard.
.SS "Is there a way to display \s-1POD\s0 text that comes with my program / package ?"
.IX Subsection "Is there a way to display POD text that comes with my program / package ?"
.Vb 2
\&   $::application\-> open_help( $0 );
\&   $::application\-> open_help( \*(AqMy::Package/BUGS\*(Aq );
.Ve
.SS "How to implement parallel processing?"
.IX Subsection "How to implement parallel processing?"
Prima doesn't work if called from more than one thread, since Perl scalars
cannot be shared between threads automatically, but only if explicitly told,
by using thread::shared. Prima does work in multithread environments though,
but only given it runs within a dedicated thread. It is important not to
call Prima methods from any other thread, because scalars that may be created
inside these calls will be unavailable to the Prima core, which would result
in strange errors.
.PP
It is possible to run things in parallel by calling the event processing
by hands: instead of entering the main loop with
.PP
.Vb 1
\&   run Prima;
.Ve
.PP
one can write
.PP
.Vb 4
\&   while ( 1) {
\&      ... do some calculations .. 
\&      $::application\->yield;
\&   }
.Ve
.PP
That'll give Prima a chance to handle accumulated events, but that technique is
only viable if calculations can be quantized into relatively short time frames.
.PP
The generic solution would be harder to implement and debug, but it scales
well. The idea is to fork a process, and communicate with it via its stdin
and/or stdout ( see perlipc how to do that), and use Prima::File to
asyncronously read data passed through a pipe or a socket.
.PP
Note: Win32 runtime library does not support asynchronous pipes, only asyncronous sockets.
Cygwin does support both asyncronous pipes and sockets.
.SS "How do I use Prima with AnyEvent ?"
.IX Subsection "How do I use Prima with AnyEvent ?"
Prima works well with AnyEvent but there are some minor differences in using
Prima. AnyEvent is a generic event processing library that supports various
underlying event loop implementations such as \s-1EV\s0, Event, \s-1POE\s0 etc.
Prima internally uses its own event loop to perform its event handling and
AnyEvent can support that by automatically selecting \s-1POE\s0 to be the
internal implementation when Prima is loaded.  However, you may use AnyEvent
with any other internal event loop implementation such as \s-1EV\s0 along with Prima
with varying results depending on the event library used. There are a few points
to note:
.IP "\(bu" 4
Prima has to be loaded before AnyEvent.
.IP "\(bu" 4
If you want to use Prima's internal event loop system you have to install
POE::Loop::Prima and include it in your code before Prima is loaded like
below:
        use \s-1POE \s0'Loop::Prima';
        use Prima qw/Application/;
        use AnyEvent;
.IP "\(bu" 4
You can call \f(CW\*(C`AnyEvent::detect\*(C'\fR to check if the implementation is
\&\f(CW\*(AqAnyEvent::Impl::POE\*(Aq\fR if you want to use Prima's event loop or it should be
the event loop implementation you expect such as \f(CW\*(AqAnyEvent::Impl::EV\*(Aq\fR;
.IP "\(bu" 4
If you use POE::Loop::Prima then you can continue to call \f(CW\*(C`run Prima\*(C'\fR and
should not call AnyEvent's condition variable \f(CW\*(C`recv\*(C'\fR function.
.IP "\(bu" 4
If you want to use another event library implementation of AnyEvent, you have
to not call \f(CW\*(C`run Prima\*(C'\fR but instead call AnyEvent's condition variable
\&\f(CW\*(C`recv\*(C'\fR function.
.IP "\(bu" 4
You have to use \f(CW\*(C`$::application\->yield\*(C'\fR in an \f(CW\*(C`AnyEvent\->timer\*(C'\fR object to
allow for the Prima \s-1UI\s0 to update periodically, if you're not using
POE::Loop::Prima.
.PP
See full example in \fIexamples/socket_anyevent.pl\fR and
\&\fIexamples/socket_anyevent_poe.pl\fR.
.SS "How do I post an asynchronous message?"
.IX Subsection "How do I post an asynchronous message?"
\&\f(CW\*(C`Prima::Component::post_message\*(C'\fR method posts a message through the system event dispatcher
and returns immediately; when the message is arrived, \f(CW\*(C`onPostMessage\*(C'\fR notification is triggered:
.PP
.Vb 5
\&   use Prima qw(Application);
\&   my $w = Prima::MainWindow\-> create( onPostMessage => sub { shift; print "@_\en" });
\&   $w\-> post_message(1,2);
\&   print "3 4 ";
\&   run Prima;
\&
\&   output: 3 4 1 2
.Ve
.PP
This technique is fine when all calls to the \f(CW\*(C`post_message\*(C'\fR on the object are
controlled.  To multiplex callbacks one can use one of the two scalars passed
to \f(CW\*(C`post_message\*(C'\fR as callback identification. This is done by
\&\*(L"post\*(R" in Prima::Utils, that internally intercepts \f(CW$::application\fR's
\&\f(CW\*(C`PostMessage\*(C'\fR and provides the procedural interface to the same function:
.PP
.Vb 2
\&   use Prima qw(Application);
\&   use Prima::Utils qw(post);
\&
\&   post( sub { print "@_\en" }, \*(Aqa\*(Aq);
\&   print "b";
\&   run Prima;
\&
\&   output: ba
.Ve
.SS "Now to address widgets inside TabbedNotebook / TabbedScrollNotebook ?"
.IX Subsection "Now to address widgets inside TabbedNotebook / TabbedScrollNotebook ?"
The tabbed notebooks work as parent widgets for \f(CW\*(C`Prima::Notebook\*(C'\fR, that
doesn't have any interface elements on its own, and provides only page flipping
function. The sub-widgets, therefore, are to be addressed as \f(CW\*(C`$TabbedNotebook\-> Notebook\-> MyButton\*(C'\fR.
.SS "How to compile a Prima-based module using \s-1XS\s0?"
.IX Subsection "How to compile a Prima-based module using XS?"
Take a look at \s-1IPA\s0, Prima::OpenGL, Prima::Image::Magick, PDL::PrimaImage,
and PDL::Drawing::Prima . These modules compile against Prima dynamic module,
start from there. Note \- it's important to include \s-1PRIMA_VERSION_BOOTCHECK\s0 in the \*(L"\s-1BOOT:\*(R"\s0
section, to avoid binary incompatibilites, if there should be any.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima
