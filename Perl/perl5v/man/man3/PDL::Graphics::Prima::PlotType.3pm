.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDL::Graphics::Prima::PlotType 3"
.TH PDL::Graphics::Prima::PlotType 3 "2015-11-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Graphics::Prima::PlotType \- a collection of plot types
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use PDL;
\& use PDL::Graphics::Prima::Simple \-sequential;
\& my $x = sequence(100)/10;
\& my $y = sin($x);
\& 
\& # A lines+diamonds plot
\& plot(
\&     \-data => ds::Pair(
\&         $x,
\&         $y,
\&         plotTypes => [
\&             ppair::Lines,
\&             ppair::Diamonds,
\&         ],
\&     ),
\& );
\& 
\& # Dandelions:
\& $x = random(10);
\& $y = random(10) + 0.5;
\& plot(
\&     \-data => ds::Pair(
\&         $x,
\&         $y,
\&         plotTypes => [
\&             ppair::Spikes(colors => cl::Green, lineWidths => 2),
\&             ppair::Asterisks(N_points => 11, colors => cl::White),
\&         ],
\&     ),
\&     backColor => cl::LightBlue,
\&     color => cl::White,
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a number of basic plot types that you can use in a
PDL::Graphics::Prima plot. As far as PDL::Graphics::Prima is concerned, there
are different kinds of data that you might want to visualize, each with their
own distinct plot types. The three kinds of basic data sets, as described in
PDL::Graphics::Prima::DataSet, are Sets, Pairs, and Grids. Here, I will
discuss the different plot types that you can apply to each of these sorts of
data.
.PP
Just as you can specify properties for \f(CW\*(C`DataSet\*(C'\fRs, you can also specify properties
for individual <PlotType>s. \s-1XXX\s0 working here \- discuss PlotType-wide properties
(singular) and threaded (plural) properties, and ensure that they are handled
as documented.
.PP
.Vb 2
\& # Specify the color for each blob:
\& ppair::Blobs(colors => $my_colors)
\& 
\& # Specify different line widths for each column in the histogram:
\& ppair::Histogram(lineWidths => $the_widths)
.Ve
.SS "Pairs"
.IX Subsection "Pairs"
Many plots are based on plotting x/y pairs
.PP
working here
.PP
of data or lines, or perhaps shaded
areas. If you think of your data as a function of a single variable, like a
time series, you will likely use these plot types to visualize your data.
.IP "ppair::Lines" 4
.IX Item "ppair::Lines"
.Vb 1
\& ppair::Lines( [thread_like => STRING,] options )
.Ve
.Sp
Draws the x/y data as lines, connecting each pair of points with a line
segment. The behavior of the line drawing depends on what kind of threading
you want. You can specify that the threading behave like lines:
.Sp
.Vb 1
\& ppair::Lines(thread_like => \*(Aqlines\*(Aq, ...)
.Ve
.Sp
which is the default, or like points:
.Sp
.Vb 1
\& ppair::Lines(thread_like => \*(Aqpoints\*(Aq, ...)
.Ve
.Sp
Threading like lines does not play well with the many point-based plotTypes.
For all of those plotTypes, you can specify one property per point (like
\&\f(CW\*(C`colors\*(C'\fR and \f(CW\*(C`lineWidths\*(C'\fR), but doing so could lead to thread index
mismatch and an error in \f(CW\*(C`collate_min_max_wrt_many\*(C'\fR:
.Sp
.Vb 1
\& Index mismatch in collate_min_max_wrt_many ...
.Ve
.Sp
So, if you want a line with continually changing thicknesses, or continually
changing colors, you should specify that it thread like \f(CW\*(C`points\*(C'\fR.
.Sp
However, threading like points has one major drawback, which is that it does
not properly handle line styles. For example, if you wanted a dashed curve,
you would specify
.Sp
.Vb 1
\& ppair::Lines(..., linePattern => lp::Dash)
.Ve
.Sp
When you thread like points, each line segment is treated as a seperate line.
That mis-applies your dashing style. For large datasets (more than a million
points), another problem with point-like threading is that it uses more
memory and \s-1CPU\s0 to perform the drawing.
.IP "ppair::Trendlines" 4
.IX Item "ppair::Trendlines"
.Vb 2
\& ppair::Trendlines( [thread_like => STRING,] [weights => PDL,]
\&                 [along_dim => INTEGER,] options )
.Ve
.Sp
Draws linear fits to the x/y data as lines. This is a descendent of
\&\f(CW\*(C`ppair::Lines\*(C'\fR, so you can specify the style of threading you want employed.
You can also specify the weights that you want used for your fitting. The
default is equal weights.
.Sp
If you are using multidimensional data, the fit is performed along the first
dimension by default. However, if you need to perform the fit along some
other dimension, you can specify that with the \f(CW\*(C`along_dim\*(C'\fR key.
.IP "ppair::Spikes" 4
.IX Item "ppair::Spikes"
.Vb 1
\& ppair::Spikes( [x_baseline | y_baseline => PDL], options )
.Ve
.Sp
Draws x/y data as a collection of vertical or horizontal lines. In the default
behavior, for each (x, y) data point, it draws a line from (x, 0) to (x, y). You
can change the baseline by specifying either the \f(CW\*(C`y_baseline\*(C'\fR or \f(CW\*(C`x_baseline\*(C'\fR
key. For example, if you specify \f(CW\*(C`y_baseline => 5\*(C'\fR, this will draw lines
starting from (x, 5) instead of (x, 0). Specifying \f(CW\*(C`x_baseline => \-2\*(C'\fR will
lead to horizontal lines instead of vertical lines, drawn from (\-2, y) to
(x, y). Finally, if you specify the undefined value, as
\&\f(CW\*(C`x_baseline => undef\*(C'\fR or \f(CW\*(C`x_baseline => undef\*(C'\fR, the baseline will be
taken as the minimum of the dataset's x or y data, respectively.
.IP "ppair::Blobs" 4
.IX Item "ppair::Blobs"
.Vb 2
\& ppair::Blobs( [radius => PDL], [xRadius => PDL],
\&            [yRadius => PDL], options )
.Ve
.Sp
Lets you draw filled ellipses with per-point x\- and y\- pixel radii. If you
specify the key \f(CW\*(C`radius\*(C'\fR, it draws filled circles with the given radius. The
more specific keys \f(CW\*(C`xRadius\*(C'\fR and \f(CW\*(C`yRadius\*(C'\fR override the \f(CW\*(C`radius\*(C'\fR key.
.IP "ppair::Symbols" 4
.IX Item "ppair::Symbols"
.Vb 3
\& ppair::Symbols( [size => PDL], [filled => PDL::Byte],
\&              [N_points => PDL::Byte], [orientation => PDL],
\&              [skip => PDL::Byte], options )
.Ve
.Sp
Lets you draw various geometric symbols, mostly based on regular polygons.
This function inspired the creation of \*(L"pdl_symbols\*(R" in PDL::Drawing::Prima,
so you should acquaint yourself with that function's terminology if you
want to understand the meaning of the options here. There are also a number
of derived Symbol plot types, as discussed below.
.Sp
For each of your symbols, you can specify the size (radius), number of
points, orientation, skip, and whether or not you want the symbol filled.
These are the allowed arguments:
.RS 4
.IP "size" 4
.IX Item "size"
The symbols are drawn with a fixed size in pixels. This size is the radius
of a circle that would inscribe the symbol. The default size is 5 pixels.
.IP "filled" 4
.IX Item "filled"
You can draw filled symbols or open symbols. Filled symbols do not have
a border. You can specify a per-symbol value of 0 or 1, or you can specify
a plotType-wide value of 0, 1, 'yes', or 'no'. The default setting is
unfilled. Note that the filling takes winding number into account, so for
example, a five-sided star (skip=2) will have a hollow center. This, perhaps,
should be changed. I'm still debating about that.
.IP "N_points" 4
.IX Item "N_points"
The number of points in your symbol. Values of zero and one are interpreted
as circles; values of 2 are interpreted as line segments; values of three or
more are interpreted as regular polygons with the specified number of
points. The number of points is an integer and must be less than 256. The
default value is 5.
.IP "orientation" 4
.IX Item "orientation"
The angle in degrees. An orientation of zero points to the right, and the
angle increases in a counterclockwise fashion. You can also use the following
descriptive (case insensitive) strings:
.Sp
.Vb 4
\& up    \- 90 degrees
\& left  \- 180 degrees
\& down  \- 270 degrees
\& right \- 0 degrees, or 360 degrees
.Ve
.Sp
If the orientation is not specified, the polygon will be drawn 'right'.
This means that 4gons are drawn as diamonds, not squares, and triangels will
look tilted. (But see \*(L"Triangles\*(R" and \*(L"Squares\*(R".)
.IP "skip" 4
.IX Item "skip"
The default skip is 1 and leads to normal regular polygons, like a pentagon.
However, what if you want to draw a five-pointed star instead of a pentagon?
In that case, you would specify a skip of 2. This means \fIdraw a shape
connecting every \f(BIother\fI point\fR. Higher values of skip are allowed, though
I am not sure how useful they would be.
.RE
.RS 4
.Sp
In addition, there are many nicely named derivatives of ppair::Symbols. These
give descriptive names to many common symbols and include:
.IP "ppair::Sticks" 4
.IX Item "ppair::Sticks"
.Vb 1
\& ppair::Sticks( [size => PDL], [orientation => PDL], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Sticks\*(C'\fR is a wrapper around the Symbols plotType that draws 2\-point polygons,
that is, sticks. You can specify the orientation and the size; you can also specify
N_points and filled, but those will be ignored.
.IP "ppair::Triangles" 4
.IX Item "ppair::Triangles"
.Vb 2
\& ppair::Triangles( [size => PDL], [filled => PDL::Byte],
\&                [orientation => PDL], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Triangles\*(C'\fR is a wrapper around the Symbols plotType that draws 3\-point regular
polygons. It takes the same options as Symbols, except that if you specify
N_points, it will be overridden by the value 3. Also, the default orientation
which you \fBcan\fR override, is 'up'.
.IP "ppair::Squares" 4
.IX Item "ppair::Squares"
.Vb 1
\& ppair::Squares( [size => PDL], [filled => PDL::Byte], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Squares\*(C'\fR is a wrapper around Symbols that draws 4\-point regular polygon with an
orientation that makes it look like a square (instead of a diamond). You can
specify vales for N_points and orientation, but they will be ignored.
.IP "ppair::Diamonds" 4
.IX Item "ppair::Diamonds"
.Vb 1
\& ppair::Diamonds( [size => PDL], [filled => PDL::Byte], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Diamonds\*(C'\fR is just like Squares, but rotated by 45
degrees. Again, you can specify N_points and orientation, but those will be
ignored.
.IP "ppair::Stars" 4
.IX Item "ppair::Stars"
.Vb 2
\& ppair::Stars( [size => PDL], [N_points => PDL::Byte],
\&            [orientation => PDL], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Stars\*(C'\fR creates open or filled star shapes. These only look right when
you have five or more \f(CW\*(C`N_points\*(C'\fR, though it will plot something with four
and fewer. The default orientation is 'up' but that can be overridden. The
\&\f(CW\*(C`skip\*(C'\fR of two, however, cannot be overridden. You can also specify the fill
state and the orientation, in addition to all the other Drawable parameters,
of course.
.IP "ppair::Asterisks" 4
.IX Item "ppair::Asterisks"
.Vb 2
\& ppair::Asterisks( [size => PDL], [N_points => PDL::Byte],
\&                [orientation => PDL], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Asterisks\*(C'\fR creates N\-sided asterisks. It does this by forcing a skip
of zero that cannot be overridden. As with Stars, the default orientation is
\&'up' but that can be overridden. You can also specify the fill state, but
that will not be used.
.IP "ppair::Xs" 4
.IX Item "ppair::Xs"
.Vb 1
\& ppair::Xs( [size => PDL], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Xs\*(C'\fR creates \f(CW\*(C`x\*(C'\fR shaped symbols. This sets all the Symbol arguments
except the size, so although you can specify them, they will be ignored.
.IP "ppair::Crosses" 4
.IX Item "ppair::Crosses"
.Vb 1
\& ppair::Crosses( [size => PDL], options )
.Ve
.Sp
\&\f(CW\*(C`ppair::Crosses\*(C'\fR creates cross-shaped symbols, i.e. a \f(CW\*(C`+\*(C'\fR shape. As with Xs,
you are free to set the size, but all other Symbol options are set for you and
will be ignored if you specify them.
.RE
.RS 4
.RE
.IP "ppair::Histogram" 4
.IX Item "ppair::Histogram"
.Vb 2
\& ppair::Histogram( [binEdges => PDL], [baseline => SCALAR],
\&                [topPadding => SCALAR], options )
.Ve
.Sp
Draws a histogram. The bin-centers that are approximated from the x\-values
and the bin heights are set as the data's y\-values. Both positive and
negative y\-values are allowed. The border of the histogram bars are drawn
using the applicable \f(CW\*(C`color\*(C'\fR and the histograms are filled with the
applicable \f(CW\*(C`backColor\*(C'\fR.
.Sp
Histogram computes the inter-point bin edges as the mid-point between each
(sequential) pair of x\-values. For the first and last bins, the outer edge
is the same distance from the center as the corresponding inner edge. If all
of your bins have the same width, this will give you exactly what you mean.
If your bins do not have identical widths, the center of the bin is
guaranteed to fall somewhere within the bin boundaries, but it won't be in
the \*(L"center\*(R". For greater control of where the bin boundaries are placed,
you should specify the binEdges key:
.Sp
.Vb 1
\& ppair::Histogram(binEdges => $bin_edges)
.Ve
.Sp
Note that binEdges should have one more element compared with your y\-data,
that is, if you have 20 heights, you'll need 21 binEdges. Unfortunately,
specifying bin edges in this way does not work very well with having a
function-based dataset.
.Sp
Options for this plotType include:
.RS 4
.IP "baseline" 4
.IX Item "baseline"
The histogram is plotted as a series of rectangles. The height of the bottom
of these rectangles is zero, but you can set a different heigh using this
key.
.IP "binEdges" 4
.IX Item "binEdges"
Sets the location of the bin edges; useful if your histogram does not have
identical spacing.
.IP "topPadding" 4
.IX Item "topPadding"
Histograms whose tallest column runs to the top of the graph are very
confusing. This plotType includes a little bit of padding to ensure that
the top of the highest histogram is plotted below the top axis when you use
autoscaling. The same logic is applied to negative columns if you have any.
.RE
.RS 4
.Sp
The histogram plotType works decently well, but it needs improvement. Don't
be surprised if this plotType changes in the near future. Potential areas
for improvement might be the inclusion of a Scaling property as well as
filled/unfilled specifications (as in Symbols).
.RE
.IP "ppair::ErrorBars" 4
.IX Item "ppair::ErrorBars"
.Vb 5
\& ppair::ErrorBars( [x_err => PDL], [y_err => PDL]
\&                  [x_left_err => PDL], [x_right_err => PDL],
\&                  [y_upper_err => PDL], [y_lower_err => PDL],
\&                  [x_err_width => PDL], [y_err_width => PDL],
\&                  [err_width => PDL], options );
.Ve
.Sp
You create an error bars plotType objet with \f(CW\*(C`ppair::ErrorBars\*(C'\fR:
.Sp
You must specify at least one sort of error bar to plot, though you can mix and
match as you wish. Each error specification must be a piddle or something that
can be converted to a piddle:
.Sp
.Vb 6
\& x_err       \- symmetric x error bars
\& y_err       \- symmetric y error bars
\& x_left_err  \- left x error bars
\& x_right_err \- right x error bars
\& y_upper_err \- upper y error bars
\& y_lower_err \- lower y error bars
.Ve
.Sp
Note that the more specific error bars will override the less specific ones,
so if you provide \f(CW\*(C`x_err\*(C'\fR and \f(CW\*(C`x_left_err\*(C'\fR, the left error bars override the
basic ones.
.Sp
You can also specify the width of the error bars in pixels:
.Sp
.Vb 3
\& err_width   \- width of both error caps
\& x_err_width \- width of x\-error caps
\& y_err_width \- width of y\-error caps
.Ve
.Sp
Again, the more specific widths override the less specific ones.
.SS "Grid-based plot types"
.IX Subsection "Grid-based plot types"
Other plots focus on using color or grayscale to visualize data that is a
function of two variables. If you need to visualize the elements of a matrix,
you will use these plot types. If would like to
visualize an image and have already computed the \s-1RGB, HSV,\s0 or similar values,
you should use pimage::Basic instead.
.IP "pgrid::Matrix" 4
.IX Item "pgrid::Matrix"
.Vb 1
\& pgrid::Matrix( [palette => PDL::Graphics::Prima::Palette], options )
.Ve
.Sp
This plot type lets you specify colors or values on a grid to visualize
rasterized contour plots (as opposed to line contour plots).
The default palette is a grayscale one but you can specify whichever
palette you like. See PDL::Graphics::Prima::Palette. If would like to
visualize an image and have already computed the \s-1RGB, HSV,\s0 or similar values,
you should use pimage::Basic instead.
.Sp
The x\- and y\-bounds of your Grid are taken from the dataset x\- and y\-bounds,
so look into PDL::Graphics::Prima::DataSet for details.
.Sp
working here \- expand, give an example
.SS "Image-based Plot Types"
.IX Subsection "Image-based Plot Types"
While Grid-based plots focus on imaging data with a specified palette,
Image-based plots focus on plotting data that has already been converted to
a color representation. At the moment, there is only one plot type for
images (and there likely will remain only one plot type unless a stroke of
brilliance hits me). As it is automatically used as the default plot type by
\&\*(L"PDL::Graphics::Prima::DataSet/ds::Image\*(R" in ds::Image, and as it does not
have any configuration that cannot be specified in the data set, you
probably can ignore this.
.IP "pimage::Basic" 4
.IX Item "pimage::Basic"
The most basic image plot type simply draws the imge with the palette
provided by the plot type
.Sp
.Vb 1
\& pimage::Basic()
.Ve
.SS "Annotation Plot Types"
.IX Subsection "Annotation Plot Types"
Annotation plot types have a number of distinct features compared with other
plot types. They do not have any standard data or function arguments. They
tend to provide features that are decorative or annotative. Many of them
support relative positioning as well. However, none of these are requirements
for annotation plot types and they are the general catch-all plot type class
for plot types that do not have a sensibly related dataset.
.PP
Since Annotation plot types do not presume any form of the data's structure,
if you are considering creating a new plot type and cannot figure out which
basic plot type to use, the Annotation base class may be the right fit.
.PP
As a base class, \f(CW\*(C`PDL::Graphics::Prima::PlotType::Annotation\*(C'\fR provides the
following methods that may be useful for your derived classes:
.IP "parse_position" 4
.IX Item "parse_position"
This method standardizes and typo-checks position specifications. The
specification can be either a string or an anonymous hash; the return value
is an anonymous hash. If you pass in a malformed spec, the method croaks. You
call it like any other method:
.Sp
.Vb 1
\& $hash = $note_obj\->parse_position($spec);
.Ve
.Sp
A position specification is a powerful and flexible means for specifying a
location on a plot widget as a combination of data values, pixel offsets,
multiples of the current width of the letter \f(CW\*(C`M\*(C'\fR, and a percentage of the
current plot portion of the widget. I think best in terms of examples, so here
are a couple that hopefully illustrate how this works.
.Sp
If passed as a y\-specification, i.e. top or bottom specification, this will
pick a location that is one M\-width below the upper axis. If passed as an
x\-specification, this will pick a location that is one M\-width to the left
of the right axis.
.Sp
.Vb 6
\& # input
\& $spec_string = \*(Aq100% \- 1em\*(Aq;
\& # output
\& $spec_hash = {
\&     pct => 100, em => 1
\& };
.Ve
.Sp
Here's another one. As a y\-specification, this will give a location that is
five pixels below the y\-value of 12. As an x\-specification, this will give a
location that is five pixels to the left of the x\-value of 12.
.Sp
.Vb 6
\& # input 
\& $spec_string = \*(Aq12 \- 5px\*(Aq;
\& # output
\& $spec_hash = {
\&     raw => 12, px => \-5,
\& };
.Ve
.Sp
Allowed postfixes in the spec string are nothing for raw data values, \f(CW\*(C`%\*(C'\fR
for plot window percentages, \f(CW\*(C`em\*(C'\fR for M\-widths, and \f(CW\*(C`px\*(C'\fR for pixel widths.
The corresponding names in the output hash are \f(CW\*(C`raw\*(C'\fR, \f(CW\*(C`pct\*(C'\fR, \f(CW\*(C`em\*(C'\fR, and
\&\f(CW\*(C`px\*(C'\fR, respectively. You can use normal floating-point number notation for
the values. When you use a specification string, the values associated with
each key in the returned hash will be Perl scalars.
.Sp
As I already mentioned, this method accepts either a string or a hash and
most of what I have documented has focused on the string parsing. If
passed a hash, it simply verifies that the keys in the hash are only the
above four values. It does not verify the values asssociated with the hash.
This lack of data verification is why I discribe it above as a method to
\&\*(L"typo-check\*(R" a position specification. If you create a specification hash
that includes \f(CW\*(C`pc\*(C'\fR instead of \f(CW\*(C`px\*(C'\fR, this will catch it for you.
.Sp
Why not verify? Your method that ultimately uses the results of the parsed
position may be flexible enough to use complex data types, such as piddles
or other objects, and I do not want to overly restrict the utility of this
method. This can be used to great effect with \*(L"pnote::Region\*(R", for example,
in which you can specify many region highlights with a single set of piddles.
The drawing commands automatically thread over those piddle values. For this
reason, \f(CW\*(C`parse_position\*(C'\fR assumes that if you specified your position by
hand with a hash rather than with a specification string, you know what
you are doing.
.Sp
One final note: if the specification string includes weird or bad values, it
returns a hash with the \*(L"bad\*(R" key set to true, i.e. \f(CW\*(C`{bad =\*(C'\fR 1}>, and nothing
else. This is interpreted by \f(CW\*(C`compute_position\*(C'\fR as a bad value. Strings that
will trip bad value handling include \*(L"bad\*(R", \*(L"nan\*(R", and \*(L"inf\*(R". Presently, a
warning is issued every time such a value is encountered; the issuance of the
warning may become a configurable option some day.
.Sp
To translate the resulting hash into a pixel position on the plot widget,
use \f(CW\*(C`compute_position\*(C'\fR.
.IP "em_width" 4
.IX Item "em_width"
This method takes the current axis and obtains the width of the letter \f(CW\*(C`M\*(C'\fR
in pixels. You call it like so:
.Sp
.Vb 1
\& $em_width = $note_obj\->em_width($y_axis);
.Ve
.Sp
Note: you can obtain the x\- or y\-axis object calling the \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR
methods, respectively, of the plot widget.
.IP "compute_position" 4
.IX Item "compute_position"
This method expects a position hash, an axis, and a drawing ratio (which is
always supplied as the last argument to \f(CW\*(C`draw\*(C'\fR; if you're not sure what to
do, use a value of 1) and computes a pixel offset for the position. The
position hash must have a percentage or a raw data value or the method
croaks. The returned value is a pixel position that corresponds to the
desired location on the plot widget and which can be fed directly into
Prima's drawing operations. If any of the values in the position hash are
piddles, the result will be a piddle of positions that can be sent to the
drawing operations provided by PDL::Drawing::Prima.
.Sp
This value has special handling for bad values. If the bad key is set in the
position hash, a piddle with a lone bad value is returned.
.Sp
This method expects a position hash of the form built (or verified) by
\&\f(CW\*(C`parse_position\*(C'\fR.
.PP
There are a number of annotation plot-types:
.IP "pnote::Region" 4
.IX Item "pnote::Region"
.Vb 5
\& pnote::Region( [left   => position\-spec],
\&                [right  => position\-spec],
\&                [bottom => position\-spec],
\&                [top    => position\-spec],
\&                options )
.Ve
.Sp
Draws a shaded region, or if any of your position specs
include piddles it draws a set of shaded regions in one PDL-threaded drawing
operation.
.Sp
This is useful if you want to highlight certain portions of your
figure with a rectangular highlight (or is it a backlight?). Each Region
annotation has a position specification for the left, bottom, right, and top
edges. The defaults for the left and bottom are the specification string 
\&\f(CW\*(Aq0%\*(Aq\fR and the defaults for the right and top are the specification string
\&\f(CW\*(Aq100%\*(Aq\fR.
.Sp
For more on position specifications, see the discussion of \f(CW\*(C`parse_position\*(C'\fR
under \*(L"Annotation Plot Types\*(R".
.IP "pnote::Box" 4
.IX Item "pnote::Box"
.Vb 5
\& pnote::Box( [left   => position\-spec],
\&             [right  => position\-spec],
\&             [bottom => position\-spec],
\&             [top    => position\-spec],
\&             options )
.Ve
.Sp
Draws an outlied box, or if any of your position specs
include piddles it draws a set of outlined boxes in one PDL-threaded drawing
operation.
.Sp
This is the outline equivalent of pnote::Region; see those docs for details.
.Sp
For more on position specifications, see the discussion of \f(CW\*(C`parse_position\*(C'\fR
under \*(L"Annotation Plot Types\*(R".
.IP "pnote::Line" 4
.IX Item "pnote::Line"
.Vb 5
\& pnote::Line( [x1 => position\-spec],
\&              [y1 => position\-spec],
\&              [x2 => position\-spec],
\&              [y2 => position\-spec],
\&              options )
.Ve
.Sp
Draws a line from (x1, y1) to (x2, y2). If any of the position specs involve
piddles, it will draw a set of lines in one PDL-threaded drawing operation.
.Sp
The default value for x1 and y1 is \f(CW\*(Aq0%\*(Aq\fR and the default value for x2 and y2
is \f(CW\*(Aq100%\*(Aq\fR.
.Sp
For more on position specifications, see the discussion of \f(CW\*(C`parse_position\*(C'\fR
under \*(L"Annotation Plot Types\*(R".
.IP "pnote::Text" 4
.IX Item "pnote::Text"
.Vb 5
\& pnote::Text( text\-string,
\&              [x        => position\-spec],
\&              [y        => position\-spec],
\&              [clipRect => clip\-spec],
\&              options )
.Ve
.Sp
Adds a text annotation to your plot. The x\- and y\-position specifications
default to the string \f(CW\*(Aq50%\*(Aq\fR, i.e. right in the middle of the plot. This
may not be terribly useful, but hey, it's a default, right? The default
\&\f(CW\*(C`clipRect\*(C'\fR specification is the string \f(CW\*(Aqnormal\*(Aq\fR, which means that the
drawing will be clipped like any other plot type to the \*(L"plot window\*(R", the
region within the axes. You can also specify the string \f(CW\*(Aqcanvas\*(Aq\fR, which
expands the clip region to the entire canvas, or pass a four-element array
suitable for a call to the Prima \f(CW\*(C`clipRect\*(C'\fR method. This added flexibility
lets you to add notations anywhere on the figure, not just in the plotting
region.
.Sp
For more on position specifications, see the discussion of \f(CW\*(C`parse_position\*(C'\fR
under \*(L"Annotation Plot Types\*(R".
.SS "Creating new plot types"
.IX Subsection "Creating new plot types"
If the supplied plot types do not match your needs, you can always make a new
one: all of the code for all of these plot types is written in Perl, so it isn't
too difficult. This section describes how to create custom plot types for your
own needs.
.PP
To write your own plot type, you must create a class that is derived from
\&\f(CW\*(C`PDL::Graphics::Prima::PlotType\*(C'\fR. (To make the discussion a bit more concrete,
I am going to use the ficticious FooBars plotType, which I suppose would plot
some fancy error bars.) Such a derived class would probably start out with these
lines of code:
.PP
.Vb 2
\& package PDL::Graphics::Prima::PlotType::Pair::FooBars;
\& use base \*(AqPDL::Graphics::Prima::PlotType::Pair\*(Aq;
.Ve
.PP
You must then write a custom \f(CW\*(C`draw\*(C'\fR function, and you can optionally overload
the following functions: \f(CW\*(C`xmin\*(C'\fR, \f(CW\*(C`xmax\*(C'\fR, \f(CW\*(C`ymin\*(C'\fR, \f(CW\*(C`ymax\*(C'\fR, \f(CW\*(C`initialize\*(C'\fR.
.PP
You should also install a constructor under \f(CW\*(C`ppair::FooBars\*(C'\fR that looks like
this:
.PP
.Vb 3
\& sub ppair::FooBars {
\&     PDL::Graphics::Prima::PlotType::Pair::FooBars\->new(@_);
\& }
.Ve
.PP
That uses the inherited \f(CW\*(C`PDL::Graphics::Prima::PlotType::new\*(C'\fR function, which
will eventually call your class's \f(CW\*(C`initialize\*(C'\fR function. If your initializer
expects custom arguments, you should overload the \f(CW\*(C`initialize\*(C'\fR function like
so:
.PP
.Vb 3
\& # still in the PDL::Graphics::Prima::PlotType::Pair::FooBars package
\& sub initialize {
\&     my $self = shift;
\&     
\&     # You could pull items out of @args at this point if you
\&     # want. To call the superclass initialization do this:
\&     $self\->SUPER::initialize(@_);
\&     
\&     # Here\*(Aqs some custom args processing. If the user did
\&     # not specify a curviness, default to 4:
\&     $self\->{curviness} ||= 4;
\&     
\&     # Could also check that the supplied values make sense:
\&     croak(\*(AqCurviness must be a positive integer\*(Aq)
\&         unless $self\->{curviness} =~ /^\ed+$/
\&           and $self\->{curviness} > 0;
\& }
.Ve
.PP
You could shove all of that construction functionality into \f(CW\*(C`ppair::FooBars\*(C'\fR, but
then other classes would not be able to derive functionality from your 
undoubtedly elegant class without resorting to rather inelegant code.
.PP
Which brings me to writing plotTypes that are derived from other plotTypes.
That is allowed, of course, in which case you can override whichever class
functions you want. At that point, you are doing normal Perl \s-1OO\s0 programming,
so it's as easy (and/or annoying) as that.
.SS "compute_collated_min_max_for"
.IX Subsection "compute_collated_min_max_for"
This plotType function is called when the graph needs to determine automatic
minima and maxima. It is hard to explain and will require some attention in
the future to flesh out its documentation. My apologies for now.
.PP
This function is called with three arguments and should always return
two piddles. The return values should be of the sort described in
PDL::Drawing::Prima::collate_min_max_wrt_many. The three arguments are:
.IP "plotType object (or class name)" 4
.IX Item "plotType object (or class name)"
This is whatever you created with your constructor; if you're following the
example above, that would be an instance of the plotType. This passes in
whatever the dataset was given for the plotType.
.IP "axis_name" 4
.IX Item "axis_name"
The axis for which we need to know the min and the max
.IP "pixel_extent" 4
.IX Item "pixel_extent"
The width into which the
.PP
If you cannot determine an extremum, or do not want to determine an extremum,
you can return two piddles of size \f(CW$pixel_extent\fR filled with bad values.
.SS "generate_properties"
.IX Subsection "generate_properties"
This method accumulates all the properties from the plotType object together
with those from the dataset into a single hash that you can submit to one of the
PDL-based Prima drawing methods or (if you are using a
normal Prima::Drawable graphics primitive
and expect that all of the properties will be singular) the set method discussed
in Prima::Object.
.PP
I use this function both in the implementations of the \f(CW\*(C`draw\*(C'\fR and 
\&\f(CW\*(C`collate_min_max_wrt_many\*(C'\fR methods, and I have never encountered a reason to
override it.
.SS "widget"
.IX Subsection "widget"
Returns the widget that owns the dataType which, in turn, called this drawing
operation.
.SS "dataset"
.IX Subsection "dataset"
Returns the dataSet that owns this plotType.
.SS "get_data"
.IX Subsection "get_data"
Shorthand: Returns the result of calling the dataset's get_data function.
.SS "draw"
.IX Subsection "draw"
Needs explanation and examples. This function will be called whenever the
plot widget needs to redraw your plotType (window resizes, zooms, etc). It is
a simple method call, and is called with the plotType object as the first
argument, the canvas upon which to draw as the second argument (typically the
widget, but sometimes not), and the canvas ratio if the canvas's size is not
the same as the widget's size.
.PP
Now, something that I \fIalways\fR forget to do is to convert the data values to
pixel values. You do that with the widget's x\- and y\-axis objects with code like
.PP
.Vb 1
\& my $x_to_plot = $self\->widget\->x\->reals_to_pixels($xs, $ratio)
.Ve
.PP
If it seems like your new plot type is not plotting anything, be sure that you
have properly converted the points you are trying to plot.
.SH "CallBack"
.IX Header "CallBack"
This class lets you supply your own callback for drawing routines. In time,
it may also allow you to supply your own callback for autoscaling, but that's
not supported at the moment. This may seem overly high-level, but
it's mostly here so that you can implement custom drawing routines, implement
user-level tweaks to existing classes, and toy around with new plot types
without having to write a full-blown plot class.
.SS "New Drawing Techniques"
.IX Subsection "New Drawing Techniques"
If you like the way that a class operates but want to use your own drawing
routines, you can specify a base class and a drawing callback like so:
.PP
.Vb 4
\& my $smiley_plot_type = pt::CallBack(
\&        base_class => \*(AqPDL::Graphics::Prima::PlotType::Pair::Blobs\*(Aq,
\&        draw => sub {
\&                my ($self, $canvas, $ratio) = @_;
\&                
\&                # Retrieve the data from the dataset:
\&                my ($xs, $ys) = $self\->dataset\->get_data_as_pixels($ratio);
\&                
\&                # Draw the smileys:
\&                $canvas\->pdl_ellipses($xs, $ys, 20, 20);        # face
\&                $canvas\->pdl_fill_ellipses($xs \- 5, $ys + 4, 2, 2);     # left eye
\&                $canvas\->pdl_fill_ellipses($xs + 5, $ys + 4, 2, 2); # right eye
\&                $canvas\->pdl_arcs($xs, $ys, 10, 10, 200, 340); # smiling mouth
\&        },
\&        radius => 10,   # be sure to coordinate with pdl_ellipses, above
\& );
.Ve
.PP
This will use the Blobs methods for determining xmin, xmax, ymin, and ymax, but
use this custom method for drawing smileys.
.SH "TODO"
.IX Header "TODO"
I have lots of things that need to happen to improve this component of the
library.
.IP "Consistencies" 4
.IX Item "Consistencies"
Are string-properties \s-1OK,\s0 or should they be constants? (threadlike, for example)
Should properties be threadable?
.IP "Documentation on Combining" 4
.IX Item "Documentation on Combining"
I need to explain how to use multiple plotTypes together in the \s-1DESCRIPTION.
\&\s0(For now, the best discussion is in PDL::Graphics::Prima::Simple, in case
you're looking.)
.IP "New Plot Types" 4
.IX Item "New Plot Types"
There are many, many plot types that are not yet supported, but should
be. Sequential plot-types that come to mind include:
.RS 4
.IP "arrows" 4
.IX Item "arrows"
Draw flow-fields with arrows of various sizes and orientations.
Args: orientation, style => head, tail (ORable?), filled, length
.IP "error-bands" 4
.IX Item "error-bands"
I would really like to be able to draw error-bands around a best-fit function.
.IP "box-and-whisker" 4
.IX Item "box-and-whisker"
Box-and-whisker plots should be easy enough, a simple extension of error bars.
.RE
.RS 4
.Sp
Set plot-types that come to mind include many fitting types, such as:
.Sp
.Vb 6
\& gauss\-cdf\-fit     gauss\-pdf\-fit
\& lorentz\-cdf\-fit   lorentz\-pdf\-fit
\& p\-law\-cdf\-fit     p\-law\-pdf\-fit
\& log\-norm\-cdf\-fit  log\-norm\-pdf\-fit
\& exp\-cdf\-fit       exp\-pdf\-fit
\& beta\-cdf\-fit      beta\-pdf\-fit
.Ve
.Sp
Surely there are others. In addition:
.IP "PairSet" 4
.IX Item "PairSet"
A plot type that bins Pair data in x/y bins and plots a grayscale. This
would be useful for visualizing huge quantities of x/y data, when plotting
with points would fail due to too many in the same place.
.RE
.RS 4
.RE
.IP "simpler image support" 4
.IX Item "simpler image support"
pgrid::Color, while immensely flexible, is very slow. Prima has hooks for adding
images to a Drawable object, but they have not yet been incorporated into
PDL::Drawing::Prima. Once that happens, fast and scalable image support will
be possible.
.IP "consistent interface for caching" 4
.IX Item "consistent interface for caching"
Many of these plottypes could speed up bounds calculations by caching certain
results. I need to implement a generic interface for caching, and cache clearing.
.IP "Add support for 3d Plots" 4
.IX Item "Add support for 3d Plots"
Dmitry has written a proof-of-concept widget that uses openGL and it should
be possible to make many of these plotTypes work with 3d data just as well
as with 2d data.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Mertens (dcmertens.perl@gmail.com)
.SH "ADDITIONAL MODULES"
.IX Header "ADDITIONAL MODULES"
Here is the full list of modules in this distribution:
.IP "PDL::Graphics::Prima" 4
.IX Item "PDL::Graphics::Prima"
Defines the Plot widget for use in Prima applications
.IP "PDL::Graphics::Prima::Axis" 4
.IX Item "PDL::Graphics::Prima::Axis"
Specifies the behavior of axes (but not the scaling)
.IP "PDL::Graphics::Prima::DataSet" 4
.IX Item "PDL::Graphics::Prima::DataSet"
Specifies the behavior of DataSets
.IP "PDL::Graphics::Prima::Limits" 4
.IX Item "PDL::Graphics::Prima::Limits"
Defines the lm:: namespace
.IP "PDL::Graphics::Prima::Palette" 4
.IX Item "PDL::Graphics::Prima::Palette"
Specifies a collection of different color palettes
.IP "PDL::Graphics::Prima::PlotType" 4
.IX Item "PDL::Graphics::Prima::PlotType"
Defines the different ways to visualize your data
.IP "PDL::Graphics::Prima::ReadLine" 4
.IX Item "PDL::Graphics::Prima::ReadLine"
Encapsulates all interaction with the Term::ReadLine family of
modules.
.IP "PDL::Graphics::Prima::Scaling" 4
.IX Item "PDL::Graphics::Prima::Scaling"
Specifies different kinds of scaling, including linear and logarithmic
.IP "PDL::Graphics::Prima::Simple" 4
.IX Item "PDL::Graphics::Prima::Simple"
Defines a number of useful functions for generating simple and not-so-simple
plots
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Unless otherwise stated, all contributions in code and documentation are
copyright (c) their respective authors, all rights reserved.
.PP
Portions of this module's code are copyright (c) 2011 The Board of
Trustees at the University of Illinois.
.PP
Portions of this module's code are copyright (c) 2011\-2013 Northwestern
University.
.PP
Portions of this module's code are copyright (c) 2013\-2014 Dickinson
College.
.PP
This module's documentation is copyright (c) 2011\-2014 David Mertens.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1678:" 4
.IX Item "Around line 1678:"
\&'=item' outside of any '=over'
.IP "Around line 1720:" 4
.IX Item "Around line 1720:"
You forgot a '=back' before '=head2'
.IP "Around line 1945:" 4
.IX Item "Around line 1945:"
\&'=item' outside of any '=over'
