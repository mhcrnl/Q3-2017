.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDL::Drawing::Prima::Utils 3"
.TH PDL::Drawing::Prima::Utils 3 "2015-11-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Drawing::Prima::Utils \- A handful of useful utilities.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions provide a number of utilities that do not depend on the Prima
toolkit but which are useful for Prima/PDL interaction. The first set of
functions assist in converting colors from one format to another. The second set
of functions are important for the auto-scaling calculations in
PDL::Graphics::Prima. Strictly speaking, they should probably be defined
somewhere in that module, but they reside here at the moment.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "color_to_rgb"
.IX Subsection "color_to_rgb"
.Vb 1
\&  Signature: (int color(); int [o] rgb(n=3))
.Ve
.PP
Converts a Prima color value to \s-1RGB\s0 representation
.PP
If the input piddle has dimension (m, n, ...), the output piddle has
dimensions (3, m, n, ...). The first element represents the red value, the
second the green value, and the third the blue value. The resulting piddle is
suitable for use in \f(CW\*(C`rgb_to_color\*(C'\fR or \f(CW\*(C`rgb_to_hsv\*(C'\fR.
.PP
The code for this routine is based on \f(CW\*(C`value2rgb\*(C'\fR from Prima::colorDialog.
.PP
If \f(CW\*(C`color_to_rgb\*(C'\fR encounters a bad value in the input, the output piddle will
be marked as bad and the associated rgb values will all be marked with the bad
value.
.SS "rgb_to_color"
.IX Subsection "rgb_to_color"
.Vb 1
\&  Signature: (int rgb(n=3); int [o] color())
.Ve
.PP
Converts an \s-1RGB\s0 color to a Prima color value
.PP
Red, green, and blue values must fall between 0 and 255. Any values outside
those boundaries will be truncated to the nearest boundary before computing the
color.
.PP
The \s-1RGB\s0 values must be in the first dimension. In other words, the size of the
first dimension must be three, so if the input piddle has dimensions (3, m, n,
\&...), the output piddle will have dimension (m, n, ...). The resulting piddle is
suitable for use when specifying colors to drawing primitives.
.PP
The code for this routine is based on \f(CW\*(C`rgb2value\*(C'\fR from Prima::colorDialog.
.PP
If \f(CW\*(C`rgb_to_color\*(C'\fR encounters a bad value in any of the red, green, or blue
values of the input, the output piddle will be marked as bad and the associated
color values will all be marked as bad.
.SS "hsv_to_rgb"
.IX Subsection "hsv_to_rgb"
.Vb 1
\&  Signature: (float+ hsv(n=3); int [o]rgb(m=3))
.Ve
.PP
Converts an \s-1HSV\s0 color triple to an \s-1RGB\s0 color triple
.PP
\&\s-1HSV\s0 stands for hue-saturation-value and is nicely represented by a cirle in a
color palette. In this representation, the numbers representing saturation and
value must be between 0 and 1; anything less than zero or greater than 1 will be
truncated to the closest limit. The hue must be a value between 0 and 360, and
again it will be truncated to the corresponding limit if that is not the case.
For more information about \s-1HSV,\s0 see <http://en.wikipedia.org/wiki/HSL_and_HSV>.
.PP
Note that Prima's \f(CW\*(C`hsv2rgb\*(C'\fR function, upon which this was based, had a special
notation for a hue of \-1, which always corresponded to a saturation of 0. Since
a saturation of 0 means 'use greyscale', this function does not make any special
use of that notation.
.PP
The first dimension of the piddles holding the hsv and rgb values must be size
3, i.e. the dimensions must look like (3, m, n, ...). The resulting piddle is
suitable for input into rgb_to_color as well as manual manipulation.
.PP
The code for this routine is based on \f(CW\*(C`hsv2rgb\*(C'\fR from Prima::colorDialog.
.PP
If \f(CW\*(C`hsv_to_rgb\*(C'\fR encounters a bad value in any of the hue, saturation, or value
quantities, the output piddle will be marked as bad and the associated rgb
color values will all be marked as bad.
.SS "rgb_to_hsv"
.IX Subsection "rgb_to_hsv"
.Vb 1
\&  Signature: (int rgb(n=3); float+ [o]hsv(m=3))
.Ve
.PP
Converts an \s-1RGB\s0 color triple to an \s-1HSV\s0 color triple
.PP
\&\s-1HSV\s0 stands for hue-saturation-value and is nicely represented by a cirle in a
color palette. In this representation, the numbers representing saturation and
value will run between 0 and 1. The hue will be a value between 0 and 360.
For more information about \s-1HSV,\s0 see <http://en.wikipedia.org/wiki/HSL_and_HSV>.
.PP
Note that Prima's \f(CW\*(C`rgb2hsv\*(C'\fR function, upon which this was based, returned a
special value if r == g == b. In that case, it returned a hue of \-1 and a
saturation of zero. In the rgb color is a greyscale and the value is based
simply on that. This function does not make use of that special hue value; it
simply returns a hue value of 0.
.PP
The first dimension of the piddles holding the hsv and rgb values must be size
3, i.e. the dimensions must look like (3, m, n, ...). The resulting piddle is
suitable for manual manipulation and input into hsv_to_rgb.
.PP
The code for this routine is based on \f(CW\*(C`rgb2hsv\*(C'\fR from Prima::colorDialog.
.PP
If \f(CW\*(C`rgb_to_hsv\*(C'\fR encounters a bad value in any of the red, green, or blue values
the output piddle will be marked as bad and the associated hsv values will all
be marked as bad.
.SS "minmaxforpair"
.IX Subsection "minmaxforpair"
.Vb 1
\&  Signature: (x(n); y(n); [o] min_x(); [o] min_y(); [o] max_x(); [o] max_y())
.Ve
.PP
Returns the min/max values for the pairs of coordinates x and y.
.PP
This function is only really useful in one very specific context: when the
number of dimensions for x and y do not agree, and when you have bad data in
x, y, or both.
.PP
Suppose that you know that x and y are good. Then you could get the min/max
data using the \f(CW\*(C`minmax\*(C'\fR function:
.PP
.Vb 2
\& my ($xmin, $xmax) = $x\->minmax;
\& my ($ymin, $ymax) = $y\->minmax;
.Ve
.PP
On the other hand, if you have data but you know that the dimensions of x and
y match, you could modify the above like so:
.PP
.Vb 2
\& my ($xmin, $xmax) = $x\->where($x\->isgood & $y\->isgood)\->minmax;
\& my ($ymin, $ymax) = $y\->where($x\->isgood & $y\->isgood)\->minmax;
.Ve
.PP
However, what if you have only one-dimensional x\-data but two-dimensional
y\-data? For example, you want to plot mutliple y datasets against the same
x\-coordinates. In that case, if some of the x\-data is bad, you could probably
hack something, but if some of the y\-data is bad you you will have a hard time
picking out the good pairs, and getting the min/max from them. That is the
purpose of this function.
.PP
Output is set bad if no pair of x/y data is good.
.SS "collate_min_max_wrt_many"
.IX Subsection "collate_min_max_wrt_many"
.Vb 1
\&  Signature: (min_check(Q); int min_index(Q); max_check(Q); int max_index(Q); extra0(Q); extra1(Q); extra2(Q); extra3(Q); extra4(Q); extra5(Q); extra6(Q); extra7(Q); extra8(Q); extra9(Q); extra10(Q); extra11(Q); extra12(Q); extra13(Q); extra14(Q); extra15(Q); extra16(Q); extra17(Q); extra18(Q); extra19(Q); [o] min(N); [o] max(N); int N_extras)
.Ve
.PP
collate_min_max_wrt_many processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "collate_min_max_wrt_many"
.IX Subsection "collate_min_max_wrt_many"
.Vb 5
\&  Signature: ($min(N_pixels), $max(N_pixels))
\&               = collate_min_max_wrt_many(
\&                   $min_to_collate(M); $min_index(M);
\&                   $max_to_collate(M); $max_index(M);
\&                   N_pixels; $p1(M); $p2(M); ...);
.Ve
.PP
Collates the min/max two piddles according to their supplied indices.
.PP
This function pretty much only makes sense in the context of
PDL::Graphics::Prima and it's auto-scaling calculations. Here's how it
works.
.PP
Suppose you're drawing a collection of colored blobs. Your blobs have
various radii and you want to know the min and the max x\-positions, collated
for each radius. In other words, for all the blobs with radius 1, give me
the min and the max; for all the blobs with radius 2, give me the min and
the max; etc. However, you are not going to draw the blobs that have a 
badvalue for a the y position or the color\-\-\-badvalues for any of these mean
\&\*(L"skip me\*(R". You only want to know the minima and maxima for the blobs that
you intend to draw. Also, let's assume that the widget onto which you intend
to draw is 500 pixels wide.
.PP
For that situation, you would call collate_min_max_wrt_many like so:
.PP
.Vb 2
\& my ($min, $max) = PDL::collate_min_max_wrt_many($x, $xRadii, $x, $xRadii
\&                                  , 500, $y, $yRadii, $colors);
.Ve
.PP
The arguments are interpreted as follows. The first two piddles are the
values and the indices of the data from which we wish to draw the minima.
Here we want to find the smallest value of x, collated according to the
specified pixel radii. The next two piddles are the values and indices of
the data from which we wish to draw the maxima. The fifth argument, a scalar
number, indicates the maximum collation bin.
.PP
The remainder of the arguments are values against which we want to check
for bad values. For example, suppose the first (x, y) pair is (2, inf). This
point will not be drawn, because infinity cannot be drawn, so I will not
want to collate that x\-value of 2, regardless of the xRadius with which it
corresponds. So, each value of x is included in the min/max collation only
if all the other piddles have good values at the same index.
.PP
This function threads over as many as 20 extra piddles, checking each
of them to see if they have bad values, inf, or nan. The limit to 20 piddles
is a hard but arbitrary limit. It could be increased if the need arose, but
the function would need to be recompiled.
.PP
This function is explicitly meant to handle bad values. The output piddles
will have bad values for any index that was not represented in the
calculation. If any of the supplied piddles have bad values, the
corresponding position will not be analyzed.
.SS "trim_collated_min"
.IX Subsection "trim_collated_min"
.Vb 1
\&  Signature: (minima(m, a=3); int [o] min_mask(m))
.Ve
.PP
Returns a mask to trim a collated list of minima so that the resulting
(masked off) entries are in strictly decreasing order with increasing index.
.PP
working here \- this needs documentation
.PP
trim_collated_min does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "trim_collated_max"
.IX Subsection "trim_collated_max"
.Vb 1
\&  Signature: (maxima(n, a=3); int [o] max_mask(n))
.Ve
.PP
Returns a mask to trim a collated list so that the resulting (masked off)
entries are in strictly decreasing extremeness with increasing index.
.PP
working here \- this needs documentation
.PP
trim_collated_max does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
