.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Prima::RubberBand 3"
.TH Prima::RubberBand 3 "2015-09-13" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::RubberBand \- draw rubberbands
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The motivation for this module was that I was tired to see corrupted screens on
Windows 7 when dragging rubberbands in Prima code. Even though \s-1MS\s0 somewhere
warned of not doing any specific hacks to circumvent the bug, I decided to give
it a go anyway.
.PP
This module thus is a \f(CW\*(C`Prima::Widget/rect_focus\*(C'\fR with a safeguard. The only
thing it can do is to draw a static rubberband \- but also remember the last
coordinates drawn, so cleaning comes for free.
.PP
The idea is that a rubberband object is meant to be a short-lived one: as soon
as it get instantiatet it draws itself on the screen. When it is destroyed, the
rubberband is erased too.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use strict;
\&        use Prima qw(Application RubberBand);
\&        
\&        sub xordraw
\&        {
\&                my ($self, @new_rect) = @_;
\&                $::application\-> rubberband( @new_rect ?
\&                        ( rect => \e@new_rect ) :
\&                        ( destroy => 1 )
\&                );
\&        }
\&        
\&        Prima::MainWindow\-> create(
\&                onMouseDown => sub {
\&                        my ( $self, $btn, $mod, $x, $y) = @_;
\&                        $self\-> {anchor} = [$self\-> client_to_screen( $x, $y)];
\&                        xordraw( $self, @{$self\-> {anchor}}, $self\-> client_to_screen( $x, $y));
\&                        $self\-> capture(1);
\&                },
\&                onMouseMove => sub {
\&                        my ( $self, $mod, $x, $y) = @_;
\&                        xordraw( $self, @{$self\-> {anchor}}, $self\-> client_to_screen( $x, $y)) if $self\-> {anchor};
\&                },
\&                onMouseUp => sub {
\&                        my ( $self, $btn, $mod, $x, $y) = @_;
\&                        xordraw if delete $self\-> {anchor};
\&                        $self\-> capture(0);
\&                },
\&        );
\&        
\&        run Prima;
.Ve
.SH "API"
.IX Header "API"
.ie n .IP "new %properties" 4
.el .IP "new \f(CW%properties\fR" 4
.IX Item "new %properties"
Creates a new RubberBand instance. See description of properties below.
.SS "Properties"
.IX Subsection "Properties"
.IP "breadth \s-1INTEGER\s0 = 1" 4
.IX Item "breadth INTEGER = 1"
Defines rubberband breadth, in pixels.
.ie n .IP "canvas = $::application" 4
.el .IP "canvas = \f(CW$::application\fR" 4
.IX Item "canvas = $::application"
Sets the painting surface, and also the widget (it must be a widget) used for drawing.
.IP "clipRect X1, Y1, X2, Y2" 4
.IX Item "clipRect X1, Y1, X2, Y2"
Defines the clipping rectangle, in inclusive-inclusive coordinates. If set to [\-1,\-1,\-1,\-1],
means no clipping is done.
.IP "mode \s-1STRING\s0 = 'auto'" 4
.IX Item "mode STRING = 'auto'"
The module implements two techniques, standard classic 'xor' (using .rect_focus method) 
and a conservative method that uses widgets instead of drawing on a canvas ('full').
The 'auto' mode checks the system and selects the appropriate mode.
.Sp
Allowed modes: auto, xor, full
.IP "rect X1, Y1, X2, Y2" 4
.IX Item "rect X1, Y1, X2, Y2"
Defines the band geometry, in inclusive-inclusive coordinates. The band is drawn so that its body
is always inside these coordinates, no matter what breadth is.
.SS "Methods"
.IX Subsection "Methods"
.IP "hide" 4
.IX Item "hide"
Hides the band, if drawn
.IP "has_clip_rect" 4
.IX Item "has_clip_rect"
Cheks whether clipRect contains an actual clippring rectange or it is empty.
.ie n .IP "set %profile" 4
.el .IP "set \f(CW%profile\fR" 4
.IX Item "set %profile"
Applies all properties
.IP "left, right, top, bottom, width, height, origin, size" 4
.IX Item "left, right, top, bottom, width, height, origin, size"
Same shortcuts as in \f(CW\*(C`Prima::Widget\*(C'\fR, but read-only.
.IP "show" 4
.IX Item "show"
Show the band, if invisible
.SH "Prima::Widget interface"
.IX Header "Prima::Widget interface"
The module adds a single method to \f(CW\*(C`Prima::Widget\*(C'\fR namespace, \f(CW\*(C`rubberband\*(C'\fR
(see example of use in the synopsis).
.IP "rubberband(%profile)" 4
.IX Item "rubberband(%profile)"
Instantiates a \f(CW\*(C`Prima::RubberBand\*(C'\fR with \f(CW%profile\fR, also sets \f(CW\*(C`canvas\*(C'\fR to \f(CW$self\fR
unless \f(CW\*(C`canvas\*(C'\fR is set explicitly.
.IP "\fIrubberband()\fR" 4
.IX Item "rubberband()"
Returns the existing \f(CW\*(C`Prima::RubberBand\*(C'\fR object
.IP "rubberband(destroy => 1)" 4
.IX Item "rubberband(destroy => 1)"
Destroys the existing \f(CW\*(C`Prima::RubberBand\*(C'\fR object
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"rect_focus\*(R" in Prima::Widget, \*(L"grip.pl\*(R" in examples
.SS "Windows 7 Aero mode"
.IX Subsection "Windows 7 Aero mode"
Quote from <http://blogs.msdn.com/b/greg_schechter/archive/2006/05/02/588934.aspx> :
.PP
\&\*(L"One particularly dangerous practice is writing to the screen, either through
the use of GetDC(\s-1NULL\s0) and writing to that, or attempting to do \s-1XOR\s0 rubber-band
lines, etc  ...  Since the \s-1UCE\s0 doesn't know about it, it may get cleared in the
next frame refresh, or it may persist for a very long time, depending on what
else needs to be updated on the screen.  (We really don't allow direct writing
to the primary anyhow, for that very reason... if you try to access the
DirectDraw primary, for instance, the \s-1DWM\s0 will turn off until the accessing
application exits)\*(R"
.PP
This quote seems to explain the effect why screen sometimes gets badly
corrupted when using a normal xor rubberband. \s-1UCE \s0( Update Compatibility
Evaluator ?? ) seems to be hacky enough to recognize some situations, but not
all.  It seems that depending on which widget received mouse button just before
initialting rubberband drawing matters somehow. Anyway, the module tries to
see if we're under Windows 7 aero, and if so, turns the 'full' mode on.
