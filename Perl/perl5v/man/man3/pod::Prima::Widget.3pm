.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::Widget 3"
.TH pod::Prima::Widget 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::Widget \- window management
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&   # create a widget
\&   my $widget = Prima::Widget\-> new(
\&       size    => [ 200, 200],
\&       color   => cl::Green,
\&       visible => 0,
\&       onPaint => sub {
\&          my ($self,$canvas) = @_;
\&          $canvas\-> clear;
\&          $canvas\-> text_out( "Hello world!", 10, 10);
\&       },
\&   );
\&
\&   # manipulate the widget
\&   $widget\-> origin( 10, 10);
\&   $widget\-> show;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Prima::Widget is a descendant of Prima::Component,
a class, especially crafted to reflect and govern
properties of a system-dependent window, such as its
position, hierarchy, outlook etc. Prima::Widget 
is mapped into the screen space as a rectangular area,
with distinct boundaries, pointer and sometimes
cursor, and a user-selectable input focus.
.SH "USAGE"
.IX Header "USAGE"
Prima::Widget class and its descendants are
used widely throughout the toolkit, and, indeed
provide almost all its user interaction and input-output. 
The notification system, explained
in Prima::Object, is employed in Prima::Widget
heavily, providing the programmer with unified
access to the system-generated events, that occur
when the user moves windows, clicks the mouse,
types the keyboard, etc. Descendants of Prima::Widget
use the internal, the direct method of overriding the notifications,
whereas end programs tend to use the toolkit widgets
equipped with anonymous subroutines ( see Prima::Object
for the details).
.PP
The class functionality is much more extensive
comparing to the other built-in classes, and therefore
the explanations are grouped in several topics.
.SH "Creation and destruction"
.IX Header "Creation and destruction"
The widget creation syntax is the same as for the other Prima objects:
.PP
.Vb 6
\&   Prima::Widget\-> create(
\&      name => \*(AqWidget\*(Aq,
\&      size => [ 20, 10],
\&      onMouseClick => sub { print "click\en"; },
\&      owner => $owner,
\&   );
.Ve
.PP
In the real life, a widget must be almost always
explicitly told about its owner. The owner object 
is either a Prima::Widget descendant, in which case
the widget is drawn inside its inferior, or the
application object, and in the latter case a widget
becomes top-level. This is the reason why the \f(CW\*(C`insert\*(C'\fR
syntax is much more often used, as it is more illustrative
and is more convenient for creating several widgets
in one call ( see Prima::Object ).
.PP
.Vb 5
\&   $owner\-> insert( \*(AqPrima::Widget\*(Aq,
\&      name => \*(AqWidget\*(Aq,
\&      size => [ 20, 10],
\&      onMouseClick => sub { print "click\en"; },
\&   );
.Ve
.PP
These two examples produce identical results.
.PP
As a descendant of Prima::Component, Prima::Widget
sends \f(CW\*(C`Create\*(C'\fR notification when created ( more precisely,
after its init stage is finished. See Prima::Object for
details). This notification is called and processed within
\&\f(CW\*(C`create()\*(C'\fR call. In addition, another notification \f(CW\*(C`Setup\*(C'\fR
is sent after the widget is created. This message is
\&\fIposted\fR, so it is called within \f(CW\*(C`create()\*(C'\fR but processed
in the application event loop. This means that the execution
time of \f(CW\*(C`Setup\*(C'\fR is uncertain, as it is with all posted messages; its delivery time
is system-dependent, so its use must be considered with care.
.PP
After a widget is created, it is usually asked to render its content,
provided that the widget is visible. This request is delivered by 
means of \f(CW\*(C`Paint\*(C'\fR notification.
.PP
When the life time of a widget is over, its method \f(CW\*(C`destroy()\*(C'\fR is called,
often implicitly. If a widget gets destroyed because its owner also
does, it is guaranteed that the children widgets will be destroyed first,
and the owner afterwards. In such situation, widget can operate with 
a limited functionality both on itself and its owners ( see 
Prima::Object, \fBCreation\fR section ).
.SH "Graphic content"
.IX Header "Graphic content"
A widget can use two different ways for representing its
graphic content to the user. The first method is 
event-driven, when the \f(CW\*(C`Paint\*(C'\fR notification arrives, 
notifying the widget that it must re-paint itself.
The second is the 'direct' method, when the widget generates
graphic output unconditionally.
.SS "Event-driven rendering"
.IX Subsection "Event-driven rendering"
A notification responsible for widget repainting is \f(CW\*(C`Paint\*(C'\fR.
It provides a single ( besides the widget itself )
parameter, an object, where the drawing is performed. In an
event-driven call, it is always equals to the widget. However, if
a custom mechanism should be used that directly calls, for example,
.PP
.Vb 1
\&   $widget\-> notify(\*(AqPaint\*(Aq, $some_other_widget);
.Ve
.PP
for whatever purpose, it is recommended ( not required, though ),
to use this parameter, not the widget itself for painting and drawing
calls.
.PP
The example of \f(CW\*(C`Paint\*(C'\fR callback is quite simple:
.PP
.Vb 12
\&   Prima::Widget\-> create(
\&       ...
\&       onPaint => sub {
\&          my ( $self, $canvas) = @_;
\&          $canvas\-> clear;
\&          $canvas\-> text_out("Clicked $self\->{clicked} times", 10, 10);
\&       },
\&       onMouseClick => sub {
\&          $_[0]\-> {clicked}++;
\&          $_[0]\-> repaint;
\&       }, 
\&   );
.Ve
.PP
The example uses several important features 
of the event-driven mechanism. First, no \f(CW\*(C`begin_paint()\*(C'\fR/\f(CW\*(C`end_paint()\*(C'\fR
brackets are used within the callback. These are called implicitly.
Second, when the custom refresh of the widget's graphic content is needed, 
no code like \f(CW\*(C`notify(q(Paint))\*(C'\fR is used \- \f(CW\*(C`repaint()\*(C'\fR method is used instead. 
It must be noted, that the actual execution of \f(CW\*(C`Paint\*(C'\fR callbacks 
might or might not occur inside the \f(CW\*(C`repaint()\*(C'\fR call. This behavior is governed by
the \f(CW\*(C`::syncPaint\*(C'\fR property.
\&\f(CW\*(C`repaint()\*(C'\fR marks the whole widget's area to be refreshed, or \fIinvalidates\fR
the area. For the finer gradation of the area that should be repainted,
\&\f(CW\*(C`invalidate_rect()\*(C'\fR and \f(CW\*(C`validate_rect()\*(C'\fR pair of functions is used. Thus,
.PP
.Vb 1
\&  $x\-> repaint()
.Ve
.PP
code is a mere alias to
.PP
.Vb 1
\&  $x\-> invalidate_rect( 0, 0, $x\-> size);
.Ve
.PP
call. It must be realized, that the area, passed to \f(CW\*(C`invalidate_rect()\*(C'\fR
only in its ideal ( but a quite often ) execution case will be pertained as a 
clipping rectangle when a widget executes its \f(CW\*(C`Paint\*(C'\fR notification.
The user and system interactions can result in exposition of other
parts of a widget ( like, moving windows over a widget ), and the
resulting clipping rectangle can be different from the one that was
passed to \f(CW\*(C`invalidate_rect()\*(C'\fR. Moreover, the clipping rectangle can become
empty as the result of these influences, and the notification will not
be called at all.
.PP
Invalid rectangle is presented differently inside and outside
the drawing mode. The first, returned by \f(CW\*(C`::clipRect\*(C'\fR, employs
inclusive-inclusive coordinates, whereas \f(CW\*(C`invalidate_rect()\*(C'\fR, \f(CW\*(C`validate_rect()\*(C'\fR
and \f(CW\*(C`get_invalid_rect()\*(C'\fR \- inclusive-exclusive coordinates. The ideal case
exemplifies the above said:
.PP
.Vb 7
\&   $x\-> onPaint( sub { 
\&      my @c = $_[0]\-> clipRect; 
\&      print "clip rect:@c\en"; 
\&   });
\&   $x\-> invalidate_rect( 10, 10, 20, 20);
\&   ...
\&   clip rect: 10 10 19 19
.Ve
.PP
As noted above, \f(CW\*(C`::clipRect\*(C'\fR property is set to
the clipping rectangle of the widget area that is needed to be refreshed,
and an event handler code can take advantage of this information,
increasing the efficiency of the painting procedure.
.PP
Further assignments of \f(CW\*(C`::clipRect\*(C'\fR property do not
make possible over-painting on the screen area that lies outside
the original clipping region. This is also valid for all paint
operations, however since the original clipping rectangle is
the full area of a canvas, this rule is implicit and unnecessary, because
whatever large the clipping rectangle is, drawing and painting
cannot be performed outside the physical boundaries of the canvas.
.SS "Direct rendering"
.IX Subsection "Direct rendering"
The direct rendering, contrary to the event-driven,
is initiated by the program, not by the system. If a programmer
wishes to paint over a widget immediately, then 
\&\f(CW\*(C`begin_paint()\*(C'\fR is called, and, if successful, the part 
of the screen occupied by the widget is accessible to the drawing
and painting routines.
.PP
This method is useful, for example, for graphic demonstration 
programs, that draw continuously without any input.
Another field is the screen drawing, which is performed
with Prima::Application class, that does not have \f(CW\*(C`Paint\*(C'\fR
notification. Application's graphic canvas represents the whole screen,
allowing over-drawing the graphic content of other programs.
.PP
The event-driven rendering method adds 
implicit \f(CW\*(C`begin_paint()\*(C'\fR/\f(CW\*(C`end_paint()\*(C'\fR brackets ( plus some 
system-dependent actions ) and is a convenience
version of the direct rendering. Sometimes, however, the 
changes needed to be made to a widget's graphic context are
so insignificant, so the direct rendering method is preferable, 
because of the cleaner and terser code. As an example might serve
a simple progress bar, that draws a simple colored bar.
The event-driven code would be 
( in short, omitting many details ) as such:
.PP
.Vb 10
\&   $bar = Widget\-> create(
\&     width => 100,
\&     onPaint => sub {
\&        my ( $self, $canvas) = @_;
\&        $canvas\-> color( cl::Blue);
\&        $canvas\-> bar( 0, 0, $self\-> {progress}, $self\-> height);
\&        $canvas\-> color( cl::Back);
\&        $canvas\-> bar( $self\-> {progress}, 0, $self\-> size);
\&     },
\&   );
\&   ...
\&   $bar\-> {progress} += 10;
\&   $bar\-> repaint;
\&   # or, more efficiently, ( but clumsier )
\&   # $bar\-> invalidate_rect( $bar\->{progress}\-10, 0, 
\&   #                 $bar\->{progress}, $bar\-> height);
.Ve
.PP
And the direct driven:
.PP
.Vb 7
\&   $bar = Widget\-> create( width => 100 );
\&   ...
\&   $bar\-> begin_paint;
\&   $bar\-> color( cl::Blue);
\&   $bar\-> bar( $progress, 0, $progress + 10, $bar\-> height);
\&   $bar\-> end_paint;
\&   $progress += 10;
.Ve
.PP
The pros and contras are obvious: the event-driven rendered widget
correctly represents the status after an eventual repaint,
for example when the user sweeps a window over the progress bar
widget. The direct method cannot be that smart, but if the
status bar is an insignificant part of the program, the trade-off
of the functionality in favor to the code simplicity might be preferred.
.PP
Both methods can be effectively disabled using the paint locking
mechanism. The \f(CW\*(C`lock()\*(C'\fR and \f(CW\*(C`unlock()\*(C'\fR methods can be called several times,
stacking the requests. This feature is useful because many
properties implicitly call \f(CW\*(C`repaint()\*(C'\fR, and if several of these properties
activate in a row, the unnecessary redrawing of the widget can be avoided.
The drawback is that the last \f(CW\*(C`unlock()\*(C'\fR call triggers \f(CW\*(C`repaint()\*(C'\fR unconditionally.
.SH "Geometry"
.IX Header "Geometry"
.SS "Basic properties"
.IX Subsection "Basic properties"
A widget always has its position and size determined, even if
it is not visible on the screen. Prima::Widget provides several
properties with overlapping functionality, that govern the geometry 
of a widget. The base properties are \f(CW\*(C`::origin\*(C'\fR and \f(CW\*(C`::size\*(C'\fR,
and the derived are \f(CW\*(C`::left\*(C'\fR, \f(CW\*(C`::bottom\*(C'\fR, \f(CW\*(C`::right\*(C'\fR, \f(CW\*(C`::top\*(C'\fR,
\&\f(CW\*(C`::width\*(C'\fR, \f(CW\*(C`::height\*(C'\fR and \f(CW\*(C`::rect\*(C'\fR. \f(CW\*(C`::origin\*(C'\fR and \f(CW\*(C`::size\*(C'\fR
operate with two integers, \f(CW\*(C`::rect\*(C'\fR with four, others with one
integer value.
.PP
As the Prima toolkit coordinate space begins in the lower bottom
corner, the combination of \f(CW\*(C`::left\*(C'\fR and \f(CW\*(C`::bottom\*(C'\fR is same
as \f(CW\*(C`::origin\*(C'\fR, and combination of \f(CW\*(C`::left\*(C'\fR, \f(CW\*(C`::bottom\*(C'\fR, \f(CW\*(C`::right\*(C'\fR and
\&\f(CW\*(C`::top\*(C'\fR \- same as \f(CW\*(C`::rect\*(C'\fR.
.PP
When a widget is moved or resized, correspondingly two notifications
occur: \f(CW\*(C`Move\*(C'\fR and \f(CW\*(C`Size\*(C'\fR. The parameters to both are old and new
position and size. The notifications occur irrespectable to whether the
geometry change was issued by the program itself or by the user.
.SS "Implicit size regulations"
.IX Subsection "Implicit size regulations"
Concerning the size of a widget, two additional two-integer 
properties exist, \f(CW\*(C`::sizeMin\*(C'\fR and \f(CW\*(C`::sizeMax\*(C'\fR, that constrain the
extension of a widget in their boundaries. The direct call that
assigns values to the size properties that lie outside 
\&\f(CW\*(C`::sizeMin\*(C'\fR and \f(CW\*(C`::sizeMax\*(C'\fR boundaries, will fail \- the widget 
extension will be adjusted to the boundary values, not to the
specified ones.
.PP
Change to widget's position and size can occur not only by an explicit
call to one of the geometry properties. The toolkit contains 
implicit rules, that can move and resize a widget corresponding to
the flags, given to the \f(CW\*(C`::growMode\*(C'\fR property. The exact meaning 
of the \f(CW\*(C`gm::XXX\*(C'\fR flags is not given here ( see description to 
\&\f(CW\*(C`::growMode\*(C'\fR in \s-1API\s0 section ), but in short, it is possible with 
simple means to maintain widget's size and position regarding its
owner, when the latter is resized. By default, and the default behavior
corresponds to \f(CW\*(C`::growMode\*(C'\fR 0, widget does not change neither its size
nor position when its owner is resized. It stays always in 'the left
bottom corner'. When, for example, a widget is expected to stay
in 'the right bottom corner', or 'the left top corner', the
\&\f(CW\*(C`gm::GrowLoX\*(C'\fR and \f(CW\*(C`gm::GrowLoY\*(C'\fR values must be used, correspondingly. 
When a widget is expected to cover, for example, its owner's 
lower part and change its width in accord with the owner's, 
( a horizontal scroll bar in an editor window is the example),
the \f(CW\*(C`gm::GrowHiX\*(C'\fR value must be used.
.PP
When this implicit size change does occur, the \f(CW\*(C`::sizeMin\*(C'\fR 
and \f(CW\*(C`::sizeMax\*(C'\fR do take their part as well \- they still do not allow
the widget's size excess their boundaries. However, this 
algorithm derives a problem, that is illustrated by the following 
setup. Imagine a widget with size-dependent \f(CW\*(C`::growMode\*(C'\fR ( with
\&\f(CW\*(C`gm::GrowHiX\*(C'\fR or \f(CW\*(C`gm::GrowHiY\*(C'\fR bits set ) that must maintain certain relation between
the owner's size and its own. If the implicit size change would
be dependent on the actual widget size, derived as a result from the previous
implicit size action, then its size (and probably position) will be incorrect
after an attempt is made to change the widget's size to values outside
the size boundaries.
.PP
Example: child widget has width 100, growMode set to \f(CW\*(C`gm::GrowHiX\*(C'\fR
and sizeMin set to (95, 95). Its owner has width 200. 
If the owner widget changes gradually its width from 200 to 190
and then back, the following width table emerges:
.PP
.Vb 6
\&                    Owner        Child  
\&  Initial state      200           100
\&  Shrink             195   \-5       95
\&  Shrink             190   \-5       95 \- as it can not be less than 95.
\&  Grow               195   +5      100
\&  Grow               200   +5      105
.Ve
.PP
That effect would exist if the differential-size algorithm would
be implemented, \- the owner changes width by 5, and the child does the same.
The situation is fixed by introducing the \fIvirtual size\fR term.
The \f(CW\*(C`::size\*(C'\fR property is derived from virtual size, and as
\&\f(CW\*(C`::size\*(C'\fR cannot exceed the size boundaries, virtual size can.
It can even accept the negative values. With this intermediate stage
added, the correct picture occurs:
.PP
.Vb 7
\&                    Owner        Child\*(Aqs       Child\*(Aqs
\&                                 virtual width  width
\&  Initial state      200           100           100     
\&  Shrink             195   \-5       95            95
\&  Shrink             190   \-5       90            95
\&  Grow               195   +5       95            95
\&  Grow               200   +5      100           100
.Ve
.PP
Strictly speaking, the \fIvirtual size\fR must be declared a read-only property,
but currently it is implemented as a \f(CW\*(C`get_virtual_size()\*(C'\fR function,
and it is planned to fix this discrepancy between the document
and the implementation in favor of the property syntax.
.SS "Geometry managers"
.IX Subsection "Geometry managers"
The concept of geometry managers is imported from Tk, which in turn
is a port of Tcl-Tk. The idea behind it is that a widget size and
position is governed by one of the managers, which operate depending 
on the specific options given to the widget. The selection is operated
by \f(CW\*(C`::geometry\*(C'\fR property, and is one of \f(CW\*(C`gt::XXX\*(C'\fR constants. The native
( and the default ) geometry manager is the described above grow-mode 
algorithm ( \f(CW\*(C`gt::GrowMode\*(C'\fR ). The currently implemented Tk managers are
packer ( \f(CW\*(C`gt::Pack\*(C'\fR ) and placer ( \f(CW\*(C`gt::Place\*(C'\fR). Each has its own set of
options and methods, and their manuals are provided separately in
Prima::Widget::pack and Prima::Widget::place ( the manpages are also imported from Tk ).
.PP
Another concept that comes along with geometry managers is the 'geometry request size'.
It is realized as a two-integer property \f(CW\*(C`::geomSize\*(C'\fR, which reflects the size
selected by some intrinsic widget knowledge, and the idea is that \f(CW\*(C`::geomSize\*(C'\fR it
is merely a request to a geometry manager, whereas the latter changes \f(CW\*(C`::size\*(C'\fR 
accordingly. For example, a button might set its 'intrinsic' width in accord with
the width of text string displayed in it. If the default width for such a button is not overridden,
it is assigned with such a width. By default, under \f(CW\*(C`gt::GrowMode\*(C'\fR geometry manager,
setting \f(CW\*(C`::geomSize\*(C'\fR ( and its two semi-alias properties \f(CW\*(C`::geomWidth\*(C'\fR and \f(CW\*(C`::geomHeight\*(C'\fR ) 
also changes the actual widget size.Moreover, when the size is passed to the Widget 
initialization code, \f(CW\*(C`::size\*(C'\fR properties are used to initialize \f(CW\*(C`::geomSize\*(C'\fR. Such design
minimizes the confusion between the two properties, and also minimizes the direct usage
of \f(CW\*(C`::geomSize\*(C'\fR, limiting it for selecting advisory size in widget internal code.
.PP
The geometry request size is useless under \f(CW\*(C`gt::GrowMode\*(C'\fR geometry 
manager, but Tk managers use it extensively.
.SS "Relative coordinates"
.IX Subsection "Relative coordinates"
Another geometry issue, or rather a programming technique
must be mentioned \- the \fIrelative coordinates\fR. It is
the well-known problem, when a dialog window, developed
with one font looks garbled on another system with another 
font. The relative coordinates solve the problem; the solution
provides the \f(CW\*(C`::designScale\*(C'\fR two-integer property, the
width and height of the font, that was used when the dialog
window was designed. With this property supplied, the position
and size supplied when a widget is actually created, are transformed in
proportion between the designed and the actual font metrics.
.PP
The relative coordinates can be used only when passing the
geometry properties values, and only before the creation stage,
before a widget is created, because the scaling calculations 
perform in Prima::Widget::\f(CW\*(C`profile_check_in()\*(C'\fR method.
.PP
In order to employ the relative coordinates scheme, the owner
( or the \fIdialog\fR ) widget must set its \f(CW\*(C`::designScale\*(C'\fR
to the font metrics and \f(CW\*(C`::scaleChildren\*(C'\fR property to 1.
Widgets, created with owner that meets these requirements,
participate in the relative coordinates scheme. If
a widget must be excluded from the relative geometry applications,
either the owner's property \f(CW\*(C`::scaleChildren\*(C'\fR must be set to 0,
or the widget's \f(CW\*(C`::designScale\*(C'\fR must be set to \f(CW\*(C`undef\*(C'\fR.
As the default \f(CW\*(C`::designScale\*(C'\fR value is \f(CW\*(C`undef\*(C'\fR, no default implicit
relative geometry schemes are applied.
.PP
The \f(CW\*(C`::designScale\*(C'\fR property is auto-inherited;
its value is copied to the children widgets, unless
the explicit \f(CW\*(C`::designScale\*(C'\fR was given during the widget's
creation. This is used when such a child widget serves as an owner
for some other grand-children widgets; the inheritance scheme 
allows the grand\- ( grand\- etc ) children to participate in
the relative geometry scheme.
.PP
Note: it is advised to test such applications with the Prima::Stress
module, which assigns a random font as the default, so the testing
phase does not involve tweaking of the system settings.
.SH "Z\-order"
.IX Header "Z-order"
In case when two widgets overlap, one of these is drawn
in full, whereas the another only partly. Prima::Widget
provides management of the \fIZ\-axis\fR ordering, but since
Z\-ordering paradigm can hardly be fit into the 
properties scheme, the toolkit uses methods instead.
.PP
A widget can use four query methods: \f(CW\*(C`first()\*(C'\fR, \f(CW\*(C`last()\*(C'\fR, \f(CW\*(C`next()\*(C'\fR, 
and \f(CW\*(C`prev()\*(C'\fR. These return, correspondingly, the first and the last
widgets in Z\-order stack, and the direct neighbors of a widget
( \f(CW$widget\fR\-> next\-> prev always equals to the \f(CW$widget\fR itself, given
that \f(CW$widget\fR\-> next exists ).
.PP
The last widget is the topmost one, the one that is drawn fully.
The first is the most obscured one, given that all the widgets
overlap.
.PP
Z\-order can also be changed at runtime ( but not during widget's 
creation). There are three methods: \f(CW\*(C`bring_to_front()\*(C'\fR, that sets the
widget last in the order, making it topmost, \f(CW\*(C`send_to_back()\*(C'\fR, that
does the reverse, and \f(CW\*(C`insert_behind()\*(C'\fR, that sets a widget behind
the another widget, passed as an argument.
.PP
Changes to Z\-order trigger \f(CW\*(C`ZOrderChanged\*(C'\fR notification.
.SH "Parent-child relationship"
.IX Header "Parent-child relationship"
By default, if a widget is a child to a widget
or window, it maintains two features: it is clipped by its
owner's boundaries and is moved together as the owner widget moves.
It is said also that a \fIchild\fR is inferior to its \fIparent\fR. However,
a widget without a parent still does have a valid owner.
Instead of implementing \fIparent\fR property, the \f(CW\*(C`::clipOwner\*(C'\fR
property was devised. It is 1 by default, and if it is 1, then
owner of a widget is its parent, at the same time. However, when it is 0, many 
things change. The widget is neither clipped nor moved together
with its parent. The widget become parentless, or, more strictly
speaking, the screen becomes its parent. Moreover, 
the widget's origin offset is calculated then not from the owner's 
coordinates but from the screen, and mouse events in the 
widget do not transgress implicitly to the owner's top-level window
eventual decorations.
.PP
The same results are produced if a widget is inserted in 
the application object, which does not have screen visualization.
A widget that belongs to the application object, can not reset its \f(CW\*(C`::clipOwner\*(C'\fR
value to 1.
.PP
The \f(CW\*(C`::clipOwner\*(C'\fR property opens a possibility for the toolkit widgets
to live inside other programs' windows. If the \f(CW\*(C`::parentHandle\*(C'\fR is
changed from its default \f(CW\*(C`undef\*(C'\fR value to a valid system window handle, 
the widget becomes child to this window, which can belong to any application
residing on the same display. This option is dangerous, however:
normally widgets never get destroyed by no reason. A top-level window
is never destroyed before its \f(CW\*(C`Close\*(C'\fR notification grants the destruction.
The case with \f(CW\*(C`::parentHandle\*(C'\fR is special, because a widget, inserted into an alien application,
must be prepared to be destroyed at any moment. It is recommended to
use prior knowledge about such the application, and, even better, use
one or another inter-process communication scheme to interact with it.
.PP
A widget does not need to undertake anything special to become an 'owner'.
Any widget, that was set in \f(CW\*(C`::owner\*(C'\fR property on any other widget,
becomes owner automatically. Its \f(CW\*(C`get_widgets()\*(C'\fR method returns non-empty
widget list. \f(CW\*(C`get_widgets()\*(C'\fR serves same purpose as Prima::Component::\f(CW\*(C`get_components()\*(C'\fR,
but returns only Prima::Widget descendants.
.PP
A widget can change its owner at any moment. The \f(CW\*(C`::owner\*(C'\fR property is both
readable and writable, and if a widget is visible during the owner change, it
is immediately appeared under different coordinates and different 
clipping condition after the property change, given that 
its \f(CW\*(C`::clipOwner\*(C'\fR is set to 1.
.SH "Visibility"
.IX Header "Visibility"
A widget is visible by default. Visible means that
it is shown on the screen if it is not shadowed by
other widgets or windows. The visibility
is governed by the \f(CW\*(C`::visible\*(C'\fR property, and its
two convenience aliases, \f(CW\*(C`show()\*(C'\fR and \f(CW\*(C`hide()\*(C'\fR.
.PP
When a widget is invisible, its geometry is not discarded;
the widget pertains its position and size, and is subject to
all previously discussed implicit sizing issues. When change
to \f(CW\*(C`::visible\*(C'\fR property is made, the screen is not updated 
immediately, but in the next event loop invocation, because uncovering of
the underlying area of a hidden widget, and repainting of a new-shown widget
both depend onto the event-driven rendering functionality. If the graphic
content must be updated, \f(CW\*(C`update_view()\*(C'\fR must be called, but
there's a problem. It is obvious that if a widget is shown,
the only content to be updated is its own. When a widget
becomes hidden, it may uncover more than one widget, depending on 
the geometry, so it is unclear what widgets must be updated.
For the practical reasons, it is enough to get one event loop
passed, by calling \f(CW\*(C`yield()\*(C'\fR method of the \f(CW$::application\fR object. 
The other notifications may pass here as well, however.
.PP
There are other kinds of visibility. A widget might be visible,
but one of its owners might not. Or, a widget and its owners
might be visible, but they might be over-shadowed by the other
windows. These conditions are returned by \f(CW\*(C`showing()\*(C'\fR and \f(CW\*(C`exposed()\*(C'\fR
functions. These return boolean values corresponding to the 
condition described. So, if a widget is 'exposed', it is
\&'showing' and 'visible'; \f(CW\*(C`exposed()\*(C'\fR returns always 0 if a widget
is either not 'showing' or not 'visible'. If a widget is 'showing',
then it is always 'visible'. \f(CW\*(C`showing()\*(C'\fR returns always 0 if a widget is
invisible.
.PP
Visibility changes trigger \f(CW\*(C`Hide\*(C'\fR and \f(CW\*(C`Show\*(C'\fR notifications.
.SH "Focus"
.IX Header "Focus"
One of the key points of any \s-1GUI\s0 is that only one window at a time
can possess a \fIfocus\fR. The widget is \fIfocused\fR, if the user's keyboard
input is directed to it. The toolkit adds another layer in the focusing
scheme, as often window managers do, highlighting the decorations of
a top-level window over a window with the input focus.
.PP
Prima::Widget property \f(CW\*(C`::focused\*(C'\fR governs the focused state of a
widget. It is sometimes too powerful to be used. Its more often
substitutes, \f(CW\*(C`::selected\*(C'\fR and \f(CW\*(C`::current\*(C'\fR properties provide
more respect to widget hierarchy.
.PP
\&\f(CW\*(C`::selected\*(C'\fR property sets focus to a widget if it
is allowed to be focused, by the usage
of the \f(CW\*(C`::selectable\*(C'\fR property. With this granted, the focus
is passed to the widget or to the one of its ( grand\-) children.
So to say, when 'selecting' a window with a text field by clicking
on a window, one does not expect the window to be focused, but the text
field. To achieve this goal and reduce unnecessary coding, the 
\&\f(CW\*(C`::current\*(C'\fR property is introduced. With all equal conditions,
a widget that is 'current' gets precedence in getting selected
over widgets that are not 'current'.
.PP
De-selecting, in its turn, leaves the system in such a state when no window
has input focus. There are two convenience shortcuts
\&\f(CW\*(C`select()\*(C'\fR and \f(CW\*(C`deselect()\*(C'\fR defined, aliased to \fIselected\fR\|(1) and \fIselected\fR\|(0),
correspondingly.
.PP
As within the \s-1GUI\s0 space, there can be only one 'focused' widget,
so within the single widget space, there can be only one 'current' widget.
A widget can be marked as a current by calling \f(CW\*(C`::current\*(C'\fR 
( or, identically, \f(CW\*(C`::currentWidget\*(C'\fR on the owner widget ).
The reassignments are performed automatically when a widget is focused.
The reverse is also true: if a widget
is explicitly marked as 'current', and belongs to the widget tree with the
focus in one of its widgets, then the focus passed to the 'current' widget,
or down to hierarchy if it is not selectable.
.PP
These relations between current widget pointer and focus allow the toolkit
easily implement the focusing hierarchy. The focused widget is
always on the top of the chain of its owner widgets, each of
whose is a 'current' widget. If, for example, a window that 
contains a widget that contains a focused button,
become un-focused, and then user selects the window again,
then the button will become focused automatically.
.PP
Changes to focus produce \f(CW\*(C`Enter\*(C'\fR and \f(CW\*(C`Leave\*(C'\fR notifications.
.PP
Below discussed mouse\- and keyboard\- driven focusing schemes.
Note that all of these work via \f(CW\*(C`::selected\*(C'\fR, and do not 
focus the widgets with \f(CW\*(C`::selectable\*(C'\fR property set to 0.
.SS "Mouse-aided focusing"
.IX Subsection "Mouse-aided focusing"
Typically, when the user clicks the left mouse button 
on a widget, the latter becomes focused.
One can note that not all widgets become focused after
the mouse click \- scroll bars are the examples. Another kind
of behavior is the described above window with the text field \-
clicking mouse on a window focuses a text field.
.PP
Prima::Widget has the \f(CW\*(C`::selectingButtons\*(C'\fR property, a combination
of mb::XXX ( mouse buttons ) flags. If the bits corresponding to the 
buttons are set, then click of this button will automatically 
call \f(CW::selected(1)\fR ( not \f(CW::focused(1)\fR ).
.PP
Another boolean property, \f(CW\*(C`::firstClick\*(C'\fR determines the behavior 
when the mouse button action is up to focus a widget, but the widget's 
top-level window is not active. The default value of \f(CW\*(C`::firstClick\*(C'\fR is 1, 
but if set otherwise, the user
must click twice to a widget to get it focused. The property 
does not influence anything if the top-level window was already active
when the click event occured.
.PP
Due to some vendor-specific \s-1GUI\s0 designs, it is hardly possibly to force selection
of one top-level window when the click was on the another.
The window manager or the \s-1OS\s0 can interfere, although this does not always
happen, and produce different results on different platforms. Since
the primary goal of the toolkit is portability, such functionality
must be considered with care.
Moreover, when the user selects a window by clicking not on the 
toolkit-created widgets, but on the top-level window decorations,
it is not possible to discern the case from any other kind of focusing.
.SS "Keyboard focusing"
.IX Subsection "Keyboard focusing"
The native way to navigate between the toolkit widgets are 
tab\- and arrow\- navigation. The tab ( and its reverse, shift-tab )
key combinations circulate the focus between the widgets in same 
top-level group ( but not inside the same owner widget group ). The arrow keys,
if the focused widget is not interested in these keystrokes, move
the focus in the specified direction, if it is possible. The methods that
provide the navigations are available and called \f(CW\*(C`next_tab()\*(C'\fR and 
\&\f(CW\*(C`next_positional()\*(C'\fR, correspondingly ( see \s-1API\s0 for the details).
.PP
When \f(CW\*(C`next_positional()\*(C'\fR operates with the geometry of the widgets,
\&\f(CW\*(C`next_tab()\*(C'\fR uses the \f(CW\*(C`::tabStop\*(C'\fR and \f(CW\*(C`::tabOrder\*(C'\fR properties.
\&\f(CW\*(C`::tabStop\*(C'\fR, the boolean property, set to 1 by default, tells
if a widget is willing to participate in tab-aided focus
circulation. If it doesn't, \f(CW\*(C`next_tab()\*(C'\fR never uses it in its iterations.
\&\f(CW\*(C`::tabOrder\*(C'\fR value is an integer, unique within the sibling widgets 
( sharing same owner ) list, and is used as simple tag when the next
tab-focus candidate is picked up. The default \f(CW\*(C`::tabOrder\*(C'\fR value is \-1,
which changes automatically after widget creation to a unique value.
.SH "User input"
.IX Header "User input"
The toolkit responds to the two basic means of the user input \- 
the keyboard and the mouse. Below described three aspects of
the input handling \- the event-driven, the polling and
the simulated input issues. The event-driven
input is the more or less natural way of communicating with the user,
so when the user presses the key or moves the mouse, a system
event occurs and triggers the notification in one or more
widgets. Polling methods provide the immediate state of
the input devices; the polling is rarely employed, primarily 
because of its limited usability, and because the information
it provides is passed to the notification callbacks anyway. 
The simulated input is little more than \f(CW\*(C`notify()\*(C'\fR call with 
specifically crafted parameters. It interacts with the system,
so the emulation can gain the higher level of similarity 
to the user actions. The simulated input functions allow
the notifications to be called right away, or \fIpost\fR it,
delaying the notification until the next event loop invocation.
.SS "Keyboard"
.IX Subsection "Keyboard"
.IP "Event-driven" 4
.IX Item "Event-driven"
Keyboard input generates several notifications, where the most important are \f(CW\*(C`KeyDown\*(C'\fR
and \f(CW\*(C`KeyUp\*(C'\fR. Both have almost the same list of parameters ( see \s-1API \s0),
that contain the key code, its modifiers ( if any ) that were pressed and
an eventual character code. The algorithms that extract the meaning
of the key, for example, discretion between character and
functional keys etc are not described here. The reader is advised
to look at Prima::KeySelector module, which provides convenience 
functions for keyboard input values transformations, and to the
Prima::Edit and Prima::InputLine modules, the classes that
use extensively the keyboard input. But in short,
the key code is one of the \f(CW\*(C`kb::XXX\*(C'\fR ( like, kb::F10, kb::Esc ) constants, 
and the modifier value is a combination of the \f(CW\*(C`km::XXX\*(C'\fR ( km::Ctrl, km::Shift) 
constants. The notable exception is kb::None value, which
hints that the character code is of value. Some other \f(CW\*(C`kb::XXX\*(C'\fR\-marked keys
have the character code as well, and it is up to a programmer how to
treat these combinations. It is advised, however, to look at the key
code first, and then to the character code.
.Sp
\&\f(CW\*(C`KeyDown\*(C'\fR event has also the \fIrepeat\fR integer parameter, that
shows the repetitive count how many times the key was pressed.
Usually it is 1, but if a widget was not able to get its portion
of events between the key presses, its value can be higher.
If a code doesn't check for this parameter, some keyboard input
may be lost. If the code will be too much complicated by
introducing the repeat-value, one may consider setting the \f(CW\*(C`::briefKeys\*(C'\fR
property to 0. \f(CW\*(C`::briefKeys\*(C'\fR, the boolean property, is 1 by default.
If set to 0, it guarantees that the repeat value will always be 1,
but with the price of certain under-optimization. If the core \f(CW\*(C`KeyDown\*(C'\fR processing
code sees repeat value greater than 1, it simply calls the notification again.
.Sp
Along with these two notifications, the \f(CW\*(C`TranslateAccel\*(C'\fR event 
is generated after \f(CW\*(C`KeyDown\*(C'\fR, if the focused widget is not interested
in the key event. Its usage covers the needs of the other widgets
that are willing to read the user input, even being out of focus.
A notable example can be a button with a hot key, that reacts on
the key press when the focus is elsewhere within its top-level window. 
\&\f(CW\*(C`TranslateAccel\*(C'\fR has same parameters as \f(CW\*(C`KeyDown\*(C'\fR, except the \s-1REPEAT\s0 parameter.
.Sp
Such out-of-focus input is also used with built-in menu keys translations.
If a descendant of Prima::AbstractMenu is in the reach of the widget tree
hierarchy, then it is checked whether it contains some hot keys that match
the user input. See Prima::Menu for the details. In particular,
Prima::Widget has \f(CW\*(C`::accelTable\*(C'\fR property, a mere slot for an object
that contains a table of hot keys mappings to custom subroutines.
.IP "Polling" 4
.IX Item "Polling"
The polling function for the keyboard is limited to the modifier
keys only. \f(CW\*(C`get_shift_state()\*(C'\fR method returns the press state
of the modifier keys, a combination of \f(CW\*(C`km::XXX\*(C'\fR constants.
.IP "Simulated input" 4
.IX Item "Simulated input"
There are two methods, corresponding to the major notifications \-
\&\f(CW\*(C`key_up()\*(C'\fR and \f(CW\*(C`key_down()\*(C'\fR, that accept the same parameters as 
the \f(CW\*(C`KeyUp\*(C'\fR and \f(CW\*(C`KeyDown\*(C'\fR notifications do, plus the \s-1POST\s0
boolean flag. See \*(L"\s-1API\*(R"\s0 for details.
.Sp
These methods are convenience wrappers for \f(CW\*(C`key_event()\*(C'\fR 
method, which is never used directly.
.SS "Mouse"
.IX Subsection "Mouse"
.IP "Event-driven" 4
.IX Item "Event-driven"
Mouse notifications are send in response when the user
moves the mouse, or presses and releases mouse buttons.
The notifications are logically grouped in two sets, the first contains
\&\f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR, and \f(CW\*(C`MouseWheel\*(C'\fR, and the second \- 
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, end \f(CW\*(C`MouseLeave\*(C'\fR.
.Sp
The first set deals with button actions. Pressing, de-pressing, clicking
( and double-clicking ), the turn of mouse wheel correspond to the four
notifications. The notifications are sent together with the mouse pointer coordinates,
the button that was touched, and the eventual modifier keys that were pressed.
In addition, \f(CW\*(C`MouseClick\*(C'\fR provides the boolean flag if the click was single or double,
and \f(CW\*(C`MouseWheel\*(C'\fR the wheel turn amount. These notifications occur
when the mouse event occurs within the geometrical bounds of a widget,
with one notable exception, when a widget is in \fIcapture\fR mode.
If the \f(CW\*(C`::capture\*(C'\fR is set to 1, then these events are sent to the widget even
if the mouse pointer is outside, and not sent to the widgets and windows
that reside under the pointer.
.Sp
The second set deals with the pointer movements. When the pointer passes over
a widget, it receives first \f(CW\*(C`MouseEnter\*(C'\fR, then series of \f(CW\*(C`MouseMove\*(C'\fR,
and finally \f(CW\*(C`MouseLeave\*(C'\fR. \f(CW\*(C`MouseMove\*(C'\fR and \f(CW\*(C`MouseEnter\*(C'\fR notifications provide
X,Y\-coordinates and modificator keys; \f(CW\*(C`MouseLeave\*(C'\fR passes no parameters.
.IP "Polling" 4
.IX Item "Polling"
The mouse input polling procedures are \f(CW\*(C`get_mouse_state()\*(C'\fR method,
that returns combination of \f(CW\*(C`mb::XXX\*(C'\fR constants, and the \f(CW\*(C`::pointerPos\*(C'\fR 
two-integer property that reports the current position of the mouse pointer.
.IP "Simulated input" 4
.IX Item "Simulated input"
There are five methods, corresponding to the mouse events \- 
\&\f(CW\*(C`mouse_up()\*(C'\fR, \f(CW\*(C`mouse_down()\*(C'\fR, \f(CW\*(C`mouse_click()\*(C'\fR, \f(CW\*(C`mouse_wheel()\*(C'\fR and \f(CW\*(C`mouse_move()\*(C'\fR,
that accept the same parameters as their event counterparts do,
plus the \s-1POST\s0 boolean flag. See \*(L"\s-1API\*(R"\s0 for details.
.Sp
These methods are convenience wrappers for \f(CW\*(C`mouse_event()\*(C'\fR 
method, which is never used directly.
.SH "Color schemes"
.IX Header "Color schemes"
Prima::Drawable deals only with such color values, that
can be unambiguously decomposed to their red, green and blue components.
Prima::Widget extends the range of the values acceptable by
its color properties, introducing the color schemes. 
The color can be set indirectly, without prior knowledge
of what is its \s-1RGB\s0 value. There are several
constants defined in \f(CW\*(C`cl::\*(C'\fR name space, that correspond to the 
default values of different color properties of a widget.
.PP
Prima::Widget revises the usage of \f(CW\*(C`::color\*(C'\fR and \f(CW\*(C`::backColor\*(C'\fR,
the properties inherited from Prima::Drawable. Their values
are widget's 'foreground' and 'background' colors,
in addition to their function as template values. Moreover, their dynamic change
induces the repainting of a widget, and they can be inherited
from the owner. The inheritance is governed by properties
\&\f(CW\*(C`::ownerColor\*(C'\fR and \f(CW\*(C`::ownerBackColor\*(C'\fR. While these are true,
changes to owner \f(CW\*(C`::color\*(C'\fR or \f(CW\*(C`::backColor\*(C'\fR copied automatically
to a widget. Once the widget's \f(CW\*(C`::color\*(C'\fR or \f(CW\*(C`::backColor\*(C'\fR are
explicitly set, the owner link breaks automatically by setting \f(CW\*(C`::ownerColor\*(C'\fR or 
\&\f(CW\*(C`::ownerBackColor\*(C'\fR to 0.
.PP
In addition to these two color properties, Prima::Widget 
introduces six others.
These are \f(CW\*(C`::disabledColor\*(C'\fR, \f(CW\*(C`::disabledBackColor\*(C'\fR,
\&\f(CW\*(C`::hiliteColor\*(C'\fR, \f(CW\*(C`::hiliteBackColor\*(C'\fR, \f(CW\*(C`::light3DColor\*(C'\fR, and
\&\f(CW\*(C`::dark3DColor\*(C'\fR.  The 'disabled' color pair contains the values
that are expected to be used as foreground and background when 
a widget is in the disabled state 
( see \s-1API, \s0\f(CW\*(C`::enabled\*(C'\fR property ). The 'hilite' values
serve as the colors for representation of selection inside
a widget. Selection may be of any kind, and some widgets do
not provide any. But for those that do, the 'hilite' color values
provide distinct alternative colors. Examples are selections
in the text widgets, or in the list boxes. The last pair, 
\&\f(CW\*(C`::light3DColor\*(C'\fR and \f(CW\*(C`::dark3DColor\*(C'\fR is used for drawing 
3D\-looking outlines of a widget. The purpose of all these properties
is the adequate usage of the color settings, selected by the user using 
system-specific tools, so the program written with the toolkit
would look not such different, and more or less conformant to the
user's color preferences.
.PP
The additional \f(CW\*(C`cl::\*(C'\fR constants, mentioned above, represent these 
eight color properties. These named correspondingly, cl::NormalText,
cl::Normal, cl::HiliteText, cl::Hilite, cl::DisabledText, cl::Disabled,
cl::Light3DColor and cl::Dark3DColor. cl::NormalText is alias to cl::Fore,
and cl::Normal \- to cl::Back. Another constant set, \f(CW\*(C`ci::\*(C'\fR
can be used with the \f(CW\*(C`::colorIndex\*(C'\fR
property, a multiplexer for all eight color properties. \f(CW\*(C`ci::\*(C'\fR constants
mimic their non-RGB \f(CW\*(C`cl::\*(C'\fR counterparts, so the call
\&\f(CW\*(C`hiliteBackColor(cl::Red)\*(C'\fR is equal to \f(CW\*(C`colorIndex(ci::Hilite, cl::Red)\*(C'\fR.
.PP
Mapping from these constants to the \s-1RGB\s0 color representation
is used with \f(CW\*(C`map_color()\*(C'\fR method. These \f(CW\*(C`cl::\*(C'\fR constants alone 
are sufficient for acquiring the default values, but the toolkit provides wider
functionality than this. The \f(CW\*(C`cl::\*(C'\fR constants can be combined with
the \f(CW\*(C`wc::\*(C'\fR constants, that represent standard widget class.
The widget class is implicitly used when single \f(CW\*(C`cl::\*(C'\fR constant is used;
its value is read from the \f(CW\*(C`::widgetClass\*(C'\fR property, unless 
one of \f(CW\*(C`wc::\*(C'\fR constants is combined with the non-RGB \f(CW\*(C`cl::\*(C'\fR value. \f(CW\*(C`wc::\*(C'\fR
constants are described in \*(L"\s-1API\*(R"\s0; their usage can make
call of, for example, \f(CW\*(C`backColor( cl::Back)\*(C'\fR on a button and on
an input line result in different colors, because the \f(CW\*(C`cl::Back\*(C'\fR
is translated in the first case into \f(CW\*(C`cl::Back|wc::Button\*(C'\fR, and
in another \- \f(CW\*(C`cl::Back|wc::InputLine\*(C'\fR.
.PP
Dynamic change of the color properties result in the
\&\f(CW\*(C`ColorChanged\*(C'\fR notification.
.SH "Fonts"
.IX Header "Fonts"
Prima::Widget does not change the handling of fonts \- the 
font selection inside and outside \f(CW\*(C`begin_paint()\*(C'\fR/\f(CW\*(C`end_paint()\*(C'\fR
is not different at all. A matter of difference is how
does Prima::Widget select the default font.
.PP
First, if the \f(CW\*(C`::ownerFont\*(C'\fR property is set to 1, 
then font of the owner is copied to the widget, and
is maintained all the time while the property is true.
If it is not, the default font values read from the system.
.PP
The default font metrics for a widget returned by \f(CW\*(C`get_default_font()\*(C'\fR
method, that often deals with system-dependent and user-selected
preferences ( see \*(L"Additional resources\*(R" ). Because a widget can host
an eventual Prima::Popup object, it contains
\&\f(CW\*(C`get_default_popup_font()\*(C'\fR method, that returns the default font
for the popup objects. The dynamic popup font settings governed,
naturally, by the \f(CW\*(C`::popupFont\*(C'\fR property. Prima::Window extends the
functionality to \f(CW\*(C`get_default_menu_font()\*(C'\fR and the \f(CW\*(C`::menuFont\*(C'\fR property.
.PP
Dynamic change of the font property results in the
\&\f(CW\*(C`FontChanged\*(C'\fR notification.
.SH "Additional resources"
.IX Header "Additional resources"
The resources, operated via Prima::Widget class but not that
strictly bound to the widget concept, are gathered in this
section. The section includes overview of pointer, cursor, 
hint, menu objects and user-specified resources.
.SS "Pointer"
.IX Subsection "Pointer"
The mouse pointer is the shared resource, that can change its 
visual representation when it hovers over different kinds of widgets.
It is usually a good practice for a text field, for example, set the
pointer icon to a jagged vertical line, or indicate a moving window
with a cross-arrowed pointer.
.PP
A widget can select either one of the predefined system pointers,
mapped by the \f(CW\*(C`cr::XXX\*(C'\fR constant set, or supply its own pointer icon
of an arbitrary size and color depth.
.PP
\&\s-1NB:\s0 Not all systems allow the colored pointer icons. System value
under sv::ColorPointer index containing a boolean value, whether the colored
icons are allowed or not.
.PP
In general, the \f(CW\*(C`::pointer\*(C'\fR property is enough for these actions.
It discerns whether it has an icon or a constant passed, and 
sets the appropriate properties. These properties are also
accessible separately, although their usage is not encouraged, primarily
because of the tangled relationship between them. These properties are:
\&\f(CW\*(C`::pointerType\*(C'\fR, \f(CW\*(C`::pointerIcon\*(C'\fR, and \f(CW\*(C`::pointerHotSpot\*(C'\fR. See their
details in the \*(L"\s-1API\*(R"\s0 sections.
.PP
Another property, which is present only in Prima::Application name space
is called \f(CW\*(C`::pointerVisible\*(C'\fR, and governs the visibility of the pointer \-
but for all widget instances at once.
.SS "Cursor"
.IX Subsection "Cursor"
The cursor is a blinking rectangular area, indicating the 
availability of the input focus in a widget. There can
be only one active cursor per a \s-1GUI\s0
space, or none at all. Prima::Widget provides several
cursor properties: \f(CW\*(C`::cursorVisible\*(C'\fR, \f(CW\*(C`::cursorPos\*(C'\fR, and
\&\f(CW\*(C`::cursorSize\*(C'\fR. There are also two methods, \f(CW\*(C`show_cursor()\*(C'\fR
and \f(CW\*(C`hide_cursor()\*(C'\fR, which are not the convenience shortcuts
but the functions accounting the cursor hide count. If \f(CW\*(C`hide_cursor()\*(C'\fR
was called three times, then \f(CW\*(C`show_cursor()\*(C'\fR must be called three times 
as well for the cursor to become visible.
.SS "Hint"
.IX Subsection "Hint"
\&\f(CW\*(C`::hint\*(C'\fR is a text string, that usually describes the widget's purpose
to the user in a brief manner. If the mouse pointer is hovered over the
widget longer than some timeout ( see Prima::Application::hintPause ),
then a label appears with the hint text, until the pointer is drawn away.
The hint behavior is governed by Prima::Application, but a widget
can do two additional things about hint: it can enable and disable 
it by calling \f(CW\*(C`::showHint\*(C'\fR property, and it can inherit the owner's
\&\f(CW\*(C`::hint\*(C'\fR and \f(CW\*(C`::showHint\*(C'\fR properties using \f(CW\*(C`::ownerHint\*(C'\fR
and \f(CW\*(C`::ownerShowHint\*(C'\fR properties. If, for example, \f(CW\*(C`::ownerHint\*(C'\fR 
is set to 1, then \f(CW\*(C`::hint\*(C'\fR value is automatically copied from the 
widget's owner, when it changes. If, however, the widget's \f(CW\*(C`::hint\*(C'\fR
or \f(CW\*(C`::showHint\*(C'\fR are explicitly set, the owner link breaks automatically by setting
\&\f(CW\*(C`::ownerHint\*(C'\fR or \f(CW\*(C`::ownerShowHint\*(C'\fR to 0.
.PP
The widget can also operate the \f(CW\*(C`::hintVisible\*(C'\fR property,
that shows or hides the hint label immediately, if the mouse pointer
is inside the widget's boundaries.
.SS "Menu objects"
.IX Subsection "Menu objects"
The default functionality of Prima::Widget coexists with two kinds of the Prima::AbstractMenu
descendants \- Prima::AccelTable and Prima::Popup ( Prima::Window
is also equipped with Prima::Menu reference). The \f(CW\*(C`::items\*(C'\fR property of these objects
are accessible through \f(CW\*(C`::accelItems\*(C'\fR and \f(CW\*(C`::popupItems\*(C'\fR, whereas
the objects themselves \- through \f(CW\*(C`::accelTable\*(C'\fR and \f(CW\*(C`::popup\*(C'\fR, 
correspondingly. As mentioned in \*(L"User input\*(R", 
these objects hook the user keyboard input and call the programmer-defined 
callback subroutine if the key stroke
equals to one of their table values. As for \f(CW\*(C`::accelTable\*(C'\fR, its 
function ends here. \f(CW\*(C`::popup\*(C'\fR provides access to a context pop-up menu,
which can be invoked by either right-clicking or pressing a
system-dependent key combination. As a little customization,
the \f(CW\*(C`::popupColorIndex\*(C'\fR and \f(CW\*(C`::popupFont\*(C'\fR properties are introduced.
( \f(CW\*(C`::popupColorIndex\*(C'\fR is multiplexed to \f(CW\*(C`::popupColor\*(C'\fR, 
\&\f(CW\*(C`::popupHiliteColor\*(C'\fR, \f(CW\*(C`::popupHiliteBackColor\*(C'\fR, etc etc
properties exactly like the \f(CW\*(C`::colorIndex\*(C'\fR property ).
.PP
The font and color of a menu object might not always be writable (Win32).
.PP
The Prima::Window class provides equivalent methods for the menu bar, introducing
\&\f(CW\*(C`::menu\*(C'\fR, \f(CW\*(C`::menuItems\*(C'\fR, \f(CW\*(C`::menuColorIndex\*(C'\fR ( with multiplexing ) and
\&\f(CW\*(C`::menuFont\*(C'\fR properties.
.SS "User-specified resources"
.IX Subsection "User-specified resources"
It is considered a good idea to incorporate the user 
preferences into the toolkit look-and-feel. Prima::Widget
relies to the system-specific code that tries to map these
preferences as close as possible to the toolkit paradigm.
.PP
Unix version employs \s-1XRDB \s0( X resource database ), which is the
natural way for the user to tell the preferences with fine
granularity. Win32 reads the setting that the user has to
set interactively, using system tools. Nevertheless, the toolkit
can not emulate all user settings that are available on the supported
platforms; it rather takes a 'least common denominator', which is
colors and fonts. \f(CW\*(C`fetch_resource()\*(C'\fR method is capable of returning
any of such settings, provided it's format is font, color or a string. 
The method is rarely called directly.
.PP
The appealing idea of making every widget property adjustable via
the user-specified resources is not implemented in full.
It can be accomplished up to a certain degree using \f(CW\*(C`fetch_resource()\*(C'\fR
existing functionality, but it is believed that calling up the method
for the every property for the every widget created is prohibitively 
expensive.
.SH "API"
.IX Header "API"
.SS "Properties"
.IX Subsection "Properties"
.IP "accelItems [ \s-1ITEM_LIST \s0]" 4
.IX Item "accelItems [ ITEM_LIST ]"
Manages items of a Prima::AccelTable object associated with a widget.
The \s-1ITEM_LIST\s0 format is same as \f(CW\*(C`Prima::AbstractMenu::items\*(C'\fR
and is described in Prima::Menu.
.Sp
See also: \f(CW\*(C`accelTable\*(C'\fR
.IP "accelTable \s-1OBJECT\s0" 4
.IX Item "accelTable OBJECT"
Manages a Prima::AccelTable object associated with a widget. 
The sole purpose of the accelTable object is to provide
convenience mapping of key combinations to anonymous subroutines.
Instead of writing an interface specifically for Prima::Widget,
the existing interface of Prima::AbstractMenu was taken.
.Sp
The accelTable object can be destroyed safely; its cancellation
can be done either via \f(CW\*(C`accelTable(undef)\*(C'\fR or \f(CW\*(C`destroy()\*(C'\fR call.
.Sp
Default value: undef
.Sp
See also: \f(CW\*(C`accelItems\*(C'\fR
.IP "autoEnableChildren \s-1BOOLEAN\s0" 4
.IX Item "autoEnableChildren BOOLEAN"
If \s-1TRUE,\s0 all immediate children widgets maintain the same
\&\f(CW\*(C`enabled\*(C'\fR state as the widget. This property is useful for
the group-like widgets ( ComboBox, SpinEdit etc ), that employ their
children for visual representation.
.Sp
Default value: 0
.IP "backColor \s-1COLOR\s0" 4
.IX Item "backColor COLOR"
In widget paint state, reflects background color in the graphic context.
In widget normal state, manages the basic background color.
If changed, initiates \f(CW\*(C`ColorChanged\*(C'\fR notification and repaints the widget.
.Sp
See also: \f(CW\*(C`color\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "bottom \s-1INTEGER\s0" 4
.IX Item "bottom INTEGER"
Maintains the lower boundary of a widget. If changed,
does not affect the widget height; but does so, if called
in \f(CW\*(C`set()\*(C'\fR together with \f(CW\*(C`::top\*(C'\fR.
.Sp
See also: \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`right\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`rect\*(C'\fR,
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR
.IP "briefKeys \s-1BOOLEAN\s0" 4
.IX Item "briefKeys BOOLEAN"
If 1, contracts the repetitive key press events into one
notification, increasing \s-1REPEAT\s0 parameter of \f(CW\*(C`KeyDown\*(C'\fR 
callbacks. If 0, \s-1REPEAT\s0 parameter is always 1.
.Sp
Default value: 1
.Sp
See also: \f(CW\*(C`KeyDown\*(C'\fR
.IP "buffered \s-1BOOLEAN\s0" 4
.IX Item "buffered BOOLEAN"
If 1, a widget \f(CW\*(C`Paint\*(C'\fR callback draws not on the screen, but
on the off-screen memory instead. The memory content is copied
to the screen then. Used when complex drawing methods are used, 
or if output smoothness is desired.
.Sp
This behavior can not be always granted, however. If there is not
enough memory, then widget draws in the usual manner.
.Sp
Default value: 0
.Sp
See also: \f(CW\*(C`Paint\*(C'\fR
.IP "capture \s-1BOOLEAN, CLIP_OBJECT\s0 = undef" 4
.IX Item "capture BOOLEAN, CLIP_OBJECT = undef"
Manipulates capturing of the mouse events. If 1,
the mouse events are not passed to the widget the mouse pointer
is over, but are redirected to the caller widget. The call for capture
might not be always granted due the race conditions 
between programs.
.Sp
If \s-1CLIP_OBJECT\s0 widget is defined in set-mode call, 
the pointer movements are confined to \s-1CLIP_OBJECT\s0 inferior.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR.
.IP "centered \s-1BOOLEAN\s0" 4
.IX Item "centered BOOLEAN"
A write-only property. Once set, widget is centered by X and Y
axis relative to its owner.
.Sp
See also: \f(CW\*(C`x_centered\*(C'\fR, \f(CW\*(C`y_centered\*(C'\fR, \f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`Move\*(C'\fR.
.IP "clipOwner \s-1BOOLEAN\s0" 4
.IX Item "clipOwner BOOLEAN"
If 1, a widget is clipped by its owner boundaries. 
It is the default and expected behavior. If clipOwner is 0,
a widget behaves differently: it does not clipped
by the owner, it is not moved together with the parent, 
the origin offset is calculated not from the owner's coordinates but
from the screen, and mouse events in a widget do not transgress
to the top-level window decorations. In short, it itself becomes 
a top-level window, that, contrary
to the one created from Prima::Window class, does not have
any interference with system-dependent window stacking and positioning 
( and any other ) policy, and is not ornamented by the window manager
decorations.
.Sp
Default value: 1
.Sp
See \*(L"Parent-child relationship\*(R"
.Sp
See also: \f(CW\*(C`Prima::Object\*(C'\fR owner section, \f(CW\*(C`parentHandle\*(C'\fR
.IP "color \s-1COLOR\s0" 4
.IX Item "color COLOR"
In widget paint state, reflects foreground color in the graphic context.
In widget normal state, manages the basic foreground color.
If changed, initiates \f(CW\*(C`ColorChanged\*(C'\fR notification and repaints the widget.
.Sp
See also: \f(CW\*(C`backColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "colorIndex \s-1INDEX, COLOR\s0" 4
.IX Item "colorIndex INDEX, COLOR"
Manages the basic color properties indirectly, 
by accessing via \f(CW\*(C`ci::XXX\*(C'\fR constant. Is a complete alias
for \f(CW\*(C`::color\*(C'\fR, \f(CW\*(C`::backColor\*(C'\fR, \f(CW\*(C`::hiliteColor\*(C'\fR, \f(CW\*(C`::hiliteBackColor\*(C'\fR,
\&\f(CW\*(C`::disabledColor\*(C'\fR, \f(CW\*(C`::disabledBackColor\*(C'\fR, \f(CW\*(C`::light3DColor\*(C'\fR, and
\&\f(CW\*(C`::dark3DColor\*(C'\fR properties. The \f(CW\*(C`ci::XXX\*(C'\fR constants are:
.Sp
.Vb 8
\&   ci::NormalText or ci::Fore 
\&   ci::Normal or ci::Back
\&   ci::HiliteText
\&   ci::Hilite
\&   ci::DisabledText
\&   ci::Disabled
\&   ci::Light3DColor
\&   ci::Dark3DColor
.Ve
.Sp
The non-RGB \f(CW\*(C`cl::\*(C'\fR constants, specific to the Prima::Widget color usage are
identical to their \f(CW\*(C`ci::\*(C'\fR counterparts:
.Sp
.Vb 8
\&   cl::NormalText or cl::Fore 
\&   cl::Normal or cl::Back
\&   cl::HiliteText
\&   cl::Hilite
\&   cl::DisabledText
\&   cl::Disabled
\&   cl::Light3DColor
\&   cl::Dark3DColor
.Ve
.Sp
See also: \f(CW\*(C`color\*(C'\fR, \f(CW\*(C`backColor\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "current \s-1BOOLEAN\s0" 4
.IX Item "current BOOLEAN"
If 1, a widget (or one of its children) is marked as the one to 
be focused ( or selected) when the owner widget receives \f(CW\*(C`select()\*(C'\fR call.
Within children widgets, only one or none at all can be marked as a current.
.Sp
See also: \f(CW\*(C`currentWidget\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`selectedWidget\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "currentWidget \s-1OBJECT\s0" 4
.IX Item "currentWidget OBJECT"
Points to a children widget, that is to 
be focused ( or selected) when the owner widget receives \f(CW\*(C`select()\*(C'\fR call.
.Sp
See also: \f(CW\*(C`current\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`selectedWidget\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "cursorPos X_OFFSET Y_OFFSET" 4
.IX Item "cursorPos X_OFFSET Y_OFFSET"
Specifies the lower left corner of the cursor
.Sp
See also: \f(CW\*(C`cursorSize\*(C'\fR, \f(CW\*(C`cursorVisible\*(C'\fR
.IP "cursorSize \s-1WIDTH HEIGHT\s0" 4
.IX Item "cursorSize WIDTH HEIGHT"
Specifies width and height of the cursor
.Sp
See also: \f(CW\*(C`cursorPos\*(C'\fR, \f(CW\*(C`cursorVisible\*(C'\fR
.IP "cursorVisible \s-1BOOLEAN\s0" 4
.IX Item "cursorVisible BOOLEAN"
Specifies cursor visibility flag. Default value is 0.
.Sp
See also: \f(CW\*(C`cursorSize\*(C'\fR, \f(CW\*(C`cursorPos\*(C'\fR
.IP "dark3DColor \s-1COLOR\s0" 4
.IX Item "dark3DColor COLOR"
The color used to draw dark shades.
.Sp
See also: \f(CW\*(C`light3DColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "designScale X_SCALE Y_SCALE" 4
.IX Item "designScale X_SCALE Y_SCALE"
The width and height of a font, that was used when
a widget ( usually  a dialog or a grouping 
widget ) was designed.
.Sp
See also: \f(CW\*(C`scaleChildren\*(C'\fR, \f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR, \f(CW\*(C`size\*(C'\fR, \f(CW\*(C`font\*(C'\fR
.IP "disabledBackColor \s-1COLOR\s0" 4
.IX Item "disabledBackColor COLOR"
The color used to substitute \f(CW\*(C`::backColor\*(C'\fR when a widget 
is in its disabled state.
.Sp
See also: \f(CW\*(C`disabledColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "disabledColor \s-1COLOR\s0" 4
.IX Item "disabledColor COLOR"
The color used to substitute \f(CW\*(C`::color\*(C'\fR when a widget 
is in its disabled state.
.Sp
See also: \f(CW\*(C`disabledBackColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "enabled \s-1BOOLEAN\s0" 4
.IX Item "enabled BOOLEAN"
Specifies if a widget can accept focus, keyboard and mouse events.
Default value is 1, however, being 'enabled' does not automatically
allow the widget become focused. Only the reverse is true \- 
if enabled is 0, focusing can never happen.
.Sp
See also: \f(CW\*(C`responsive\*(C'\fR, \f(CW\*(C`visible\*(C'\fR, \f(CW\*(C`Enable\*(C'\fR, \f(CW\*(C`Disable\*(C'\fR
.ie n .IP "font %FONT" 4
.el .IP "font \f(CW%FONT\fR" 4
.IX Item "font %FONT"
Manages font context. Same syntax as in Prima::Drawable.
If changed, initiates \f(CW\*(C`FontChanged\*(C'\fR notification and repaints the widget.
.Sp
See also: \f(CW\*(C`designScale\*(C'\fR, \f(CW\*(C`FontChanged\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "geometry \s-1INTEGER\s0" 4
.IX Item "geometry INTEGER"
Selects one of the available geometry managers. The corresponding
integer constants are:
.Sp
.Vb 3
\&   gt::GrowMode, gt::Default \- the default grow\-mode algorithm
\&   gt::Pack                  \- Tk packer
\&   gt::Place                 \- Tk placer
.Ve
.Sp
See \f(CW\*(C`growMode\*(C'\fR, Prima::Widget::pack, Prima::Widget::place.
.IP "growMode \s-1MODE\s0" 4
.IX Item "growMode MODE"
Specifies widget behavior, when its owner is resized or moved.
\&\s-1MODE\s0 can be 0 ( default ) or a combination of the following constants:
.RS 4
.IP "Basic constants" 4
.IX Item "Basic constants"
.Vb 10
\& gm::GrowLoX      widget\*(Aqs left side is kept in constant 
\&                  distance from owner\*(Aqs right side
\& gm::GrowLoY      widget\*(Aqs bottom side is kept in constant 
\&                  distance from owner\*(Aqs top side 
\& gm::GrowHiX      widget\*(Aqs right side is kept in constant 
\&                  distance from owner\*(Aqs right side  
\& gm::GrowHiY      widget\*(Aqs top side is kept in constant 
\&                  distance from owner\*(Aqs top side  
\& gm::XCenter      widget is kept in center on its owner\*(Aqs
\&                  horizontal axis
\& gm::YCenter      widget is kept in center on its owner\*(Aqs
\&                  vertical axis 
\& gm::DontCare     widgets origin is maintained constant relative 
\&                  to the screen
.Ve
.IP "Derived or aliased constants" 4
.IX Item "Derived or aliased constants"
.Vb 6
\& gm::GrowAll      gm::GrowLoX|gm::GrowLoY|gm::GrowHiX|gm::GrowHiY 
\& gm::Center       gm::XCenter|gm::YCenter
\& gm::Client       gm::GrowHiX|gm::GrowHiY
\& gm::Right        gm::GrowLoX|gm::GrowHiY 
\& gm::Left         gm::GrowHiY 
\& gm::Floor        gm::GrowHiX
.Ve
.RE
.RS 4
.Sp
See also: \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`origin\*(C'\fR
.RE
.IP "firstClick \s-1BOOLEAN\s0" 4
.IX Item "firstClick BOOLEAN"
If 0, a widget bypasses first mouse click on it,
if the top-level window it belongs to was not activated, so
selecting such a widget it takes two mouse clicks.
.Sp
Default value is 1
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`focused\*(C'\fR, \f(CW\*(C`selectingButtons\*(C'\fR
.IP "focused \s-1BOOLEAN\s0" 4
.IX Item "focused BOOLEAN"
Specifies whether a widget possesses the input focus or not.
Disregards \f(CW\*(C`::selectable\*(C'\fR property on set-call.
.Sp
See also: \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`selectedWidget\*(C'\fR, \f(CW\*(C`KeyDown\*(C'\fR
.IP "geomWidth, geomHeight, geomSize" 4
.IX Item "geomWidth, geomHeight, geomSize"
Three properties that select geometry request size. Writing
and reading to \f(CW\*(C`::geomWidth\*(C'\fR and \f(CW\*(C`::geomHeight\*(C'\fR is equivalent to
\&\f(CW\*(C`::geomSize\*(C'\fR. The properies are run-time only, and behave differently
under different circumstances:
.RS 4
.IP "\(bu" 4
As the properties are run-time only, they can not be set in the profile,
and their initial value is fetched from \f(CW\*(C`::size\*(C'\fR property. Thus, setting the
explicit size is aditionally sets the advised size in case the widget is
to be used with the Tk geometry managers.
.IP "\(bu" 4
Setting the properties under the \f(CW\*(C`gt::GrowMode\*(C'\fR geometry manager also
sets the corresponding \f(CW\*(C`::width\*(C'\fR, \f(CW\*(C`::height\*(C'\fR, or \f(CW\*(C`::size\*(C'\fR. When the properties
are read, though, the real size properties are not read; the values are kept separately.
.IP "\(bu" 4
Setting the properties under Tk geometry managers cause widgets size and position changed 
according to the geometry manager policy.
.RE
.RS 4
.RE
.IP "height" 4
.IX Item "height"
Maintains the height of a widget.
.Sp
See also: \f(CW\*(C`width\*(C'\fR, 
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`get_virtual_size\*(C'\fR, 
\&\f(CW\*(C`sizeMax\*(C'\fR, \f(CW\*(C`sizeMin\*(C'\fR
.IP "helpContext \s-1STRING\s0" 4
.IX Item "helpContext STRING"
A string that binds a widget, a logical part 
it plays with the application and an interactive 
help topic. \s-1STRING\s0 format is defined as \s-1POD\s0 link
( see perlpod ) \- \*(L"manpage/section\*(R", 
where 'manpage' is the file with \s-1POD\s0 content and 'section'
is the topic inside the manpage.
.Sp
See also: \f(CW\*(C`help\*(C'\fR
.IP "hiliteBackColor \s-1COLOR\s0" 4
.IX Item "hiliteBackColor COLOR"
The color used to draw alternate background areas
with high contrast.
.Sp
See also: \f(CW\*(C`hiliteColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "hiliteColor \s-1COLOR\s0" 4
.IX Item "hiliteColor COLOR"
The color used to draw alternate foreground areas
with high contrast.
.Sp
See also: \f(CW\*(C`hiliteBackColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "hint \s-1TEXT\s0" 4
.IX Item "hint TEXT"
A text, shown under mouse pointer if it is hovered over
a widget longer than \f(CW\*(C`Prima::Application::hintPause\*(C'\fR timeout. The text shows
only if the \f(CW\*(C`::showHint\*(C'\fR is 1.
.Sp
See also: \f(CW\*(C`hintVisible\*(C'\fR, \f(CW\*(C`showHint\*(C'\fR, \f(CW\*(C`ownerHint\*(C'\fR, \f(CW\*(C`ownerShowHint\*(C'\fR
.IP "hintVisible \s-1BOOLEAN\s0" 4
.IX Item "hintVisible BOOLEAN"
If called in get-form, returns whether the hint label is shown
or not. If in set-form, immediately turns on or off the hint label,
disregarding the timeouts. It does regard the mouse pointer location,
however, and does not turn on the hint label if the pointer is away.
.Sp
See also: \f(CW\*(C`hint\*(C'\fR, \f(CW\*(C`showHint\*(C'\fR, \f(CW\*(C`ownerHint\*(C'\fR, \f(CW\*(C`ownerShowHint\*(C'\fR
.IP "left \s-1INTEGER\s0" 4
.IX Item "left INTEGER"
Maintains the left boundary of a widget. If changed,
does not affect the widget width; but does so, if called
in \f(CW\*(C`set()\*(C'\fR together with \f(CW\*(C`::right\*(C'\fR.
.Sp
See also: \f(CW\*(C`bottom\*(C'\fR, \f(CW\*(C`right\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`rect\*(C'\fR,
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR
.IP "light3DColor \s-1COLOR\s0" 4
.IX Item "light3DColor COLOR"
The color used to draw light shades.
.Sp
See also: \f(CW\*(C`dark3DColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "ownerBackColor \s-1BOOLEAN\s0" 4
.IX Item "ownerBackColor BOOLEAN"
If 1, the background color is synchronized with the owner's.
Automatically set to 0 if \f(CW\*(C`::backColor\*(C'\fR property is explicitly set.
.Sp
See also: \f(CW\*(C`ownerColor\*(C'\fR, \f(CW\*(C`backColor\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR
.IP "ownerColor \s-1BOOLEAN\s0" 4
.IX Item "ownerColor BOOLEAN"
If 1, the foreground color is synchronized with the owner's.
Automatically set to 0 if \f(CW\*(C`::color\*(C'\fR property is explicitly set.
.Sp
See also: \f(CW\*(C`ownerBackColor\*(C'\fR, \f(CW\*(C`color\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR
.IP "ownerFont \s-1BOOLEAN\s0" 4
.IX Item "ownerFont BOOLEAN"
If 1, the font is synchronized with the owner's.
Automatically set to 0 if \f(CW\*(C`::font\*(C'\fR property is explicitly set.
.Sp
See also: \f(CW\*(C`font\*(C'\fR, \f(CW\*(C`FontChanged\*(C'\fR
.IP "ownerHint \s-1BOOLEAN\s0" 4
.IX Item "ownerHint BOOLEAN"
If 1, the hint is synchronized with the owner's.
Automatically set to 0 if \f(CW\*(C`::hint\*(C'\fR property is explicitly set.
.Sp
See also: \f(CW\*(C`hint\*(C'\fR, \f(CW\*(C`showHint\*(C'\fR, \f(CW\*(C`hintVisible\*(C'\fR, \f(CW\*(C`ownerShowHint\*(C'\fR
.IP "ownerShowHint \s-1BOOLEAN\s0" 4
.IX Item "ownerShowHint BOOLEAN"
If 1, the show hint flag is synchronized with the owner's.
Automatically set to 0 if \f(CW\*(C`::showHint\*(C'\fR property is explicitly set.
.Sp
See also: \f(CW\*(C`hint\*(C'\fR, \f(CW\*(C`showHint\*(C'\fR, \f(CW\*(C`hintVisible\*(C'\fR, \f(CW\*(C`ownerHint\*(C'\fR
.IP "ownerPalette \s-1BOOLEAN\s0" 4
.IX Item "ownerPalette BOOLEAN"
If 1, the palette array is synchronized with the owner's.
Automatically set to 0 if \f(CW\*(C`::palette\*(C'\fR property is explicitly set.
.Sp
See also: \f(CW\*(C`palette\*(C'\fR
.IP "origin X Y" 4
.IX Item "origin X Y"
Maintains the left and bottom boundaries of a widget relative
to its owner ( or to the screen if \f(CW\*(C`::clipOwner\*(C'\fR is set to 0 ).
.Sp
See also: \f(CW\*(C`bottom\*(C'\fR, \f(CW\*(C`right\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`rect\*(C'\fR,
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR
.ie n .IP "packInfo %OPTIONS" 4
.el .IP "packInfo \f(CW%OPTIONS\fR" 4
.IX Item "packInfo %OPTIONS"
See Prima::Widget::pack
.ie n .IP "palette [ @PALETTE ]" 4
.el .IP "palette [ \f(CW@PALETTE\fR ]" 4
.IX Item "palette [ @PALETTE ]"
Specifies array of colors, that are desired to be present
into the system palette, as close to the \s-1PALETTE\s0 as possible.
This property works only if the graphic device allows palette
operations. See \*(L"palette\*(R" in Prima::Drawable.
.Sp
See also: \f(CW\*(C`ownerPalette\*(C'\fR
.IP "parentHandle \s-1SYSTEM_WINDOW\s0" 4
.IX Item "parentHandle SYSTEM_WINDOW"
If \s-1SYSTEM_WINDOW\s0 is a valid system-dependent window handle,
then a widget becomes the child of the window specified,
given the widget's \f(CW\*(C`::clipOwner\*(C'\fR is 0.
The parent window can belong to another application.
.Sp
Default value is undef.
.Sp
See also: \f(CW\*(C`clipOwner\*(C'\fR
.ie n .IP "placeInfo %OPTIONS" 4
.el .IP "placeInfo \f(CW%OPTIONS\fR" 4
.IX Item "placeInfo %OPTIONS"
See Prima::Widget::place
.IP "pointer cr::XXX or \s-1ICON\s0" 4
.IX Item "pointer cr::XXX or ICON"
Specifies the pointer icon; discerns between
\&\f(CW\*(C`cr::XXX\*(C'\fR constants and an icon. If an icon
contains a hash variable \f(CW\*(C`_\|_pointerHotSpot\*(C'\fR 
with an array of two integers, these integers
will be treated as the pointer hot spot. In 
get-mode call, this variable is automatically assigned
to an icon, if the result is an icon object.
.Sp
See also: \f(CW\*(C`pointerHotSpot\*(C'\fR, \f(CW\*(C`pointerIcon\*(C'\fR, \f(CW\*(C`pointerType\*(C'\fR
.IP "pointerHotSpot X_OFFSET Y_OFFSET" 4
.IX Item "pointerHotSpot X_OFFSET Y_OFFSET"
Specifies the hot spot coordinates of a pointer icon, associated 
with a widget.
.Sp
See also: \f(CW\*(C`pointer\*(C'\fR, \f(CW\*(C`pointerIcon\*(C'\fR, \f(CW\*(C`pointerType\*(C'\fR
.IP "pointerIcon \s-1ICON\s0" 4
.IX Item "pointerIcon ICON"
Specifies the pointer icon, associated with a widget.
.Sp
See also: \f(CW\*(C`pointerHotSpot\*(C'\fR, \f(CW\*(C`pointer\*(C'\fR, \f(CW\*(C`pointerType\*(C'\fR
.IP "pointerPos X_OFFSET Y_OFFSET" 4
.IX Item "pointerPos X_OFFSET Y_OFFSET"
Specifies the mouse pointer coordinates relative to widget's
coordinates.
.Sp
See also: \f(CW\*(C`get_mouse_state\*(C'\fR, \f(CW\*(C`screen_to_client\*(C'\fR, \f(CW\*(C`client_to_screen\*(C'\fR
.IP "pointerType \s-1TYPE\s0" 4
.IX Item "pointerType TYPE"
Specifies the type of the pointer, associated with the widget.
\&\s-1TYPE\s0 can accept one constant of \f(CW\*(C`cr::XXX\*(C'\fR set:
.Sp
.Vb 10
\&   cr::Default                 same pointer type as owner\*(Aqs
\&   cr::Arrow                   arrow pointer
\&   cr::Text                    text entry cursor\-like pointer
\&   cr::Wait                    hourglass
\&   cr::Size                    general size action pointer
\&   cr::Move                    general move action pointer 
\&   cr::SizeWest, cr::SizeW     right\-move action pointer
\&   cr::SizeEast, cr::SizeE     left\-move action pointer 
\&   cr::SizeWE                  general horizontal\-move action pointer 
\&   cr::SizeNorth, cr::SizeN    up\-move action pointer 
\&   cr::SizeSouth, cr::SizeS    down\-move action pointer 
\&   cr::SizeNS                  general vertical\-move action pointer 
\&   cr::SizeNW                  up\-right move action pointer
\&   cr::SizeSE                  down\-left move action pointer
\&   cr::SizeNE                  up\-left move action pointer
\&   cr::SizeSW                  down\-right move action pointer
\&   cr::Invalid                 invalid action pointer
\&   cr::User                    user\-defined icon
.Ve
.Sp
All constants except \f(CW\*(C`cr::User\*(C'\fR and \f(CW\*(C`cr::Default\*(C'\fR present a system-defined 
pointers, their icons and hot spot offsets. \f(CW\*(C`cr::User\*(C'\fR is a sign that
an icon object was specified explicitly via \f(CW\*(C`::pointerIcon\*(C'\fR property. 
\&\f(CW\*(C`cr::Default\*(C'\fR is a way to tell that a widget inherits its owner pointer type,
no matter is it a system-defined pointer or a custom icon.
.Sp
See also: \f(CW\*(C`pointerHotSpot\*(C'\fR, \f(CW\*(C`pointerIcon\*(C'\fR, \f(CW\*(C`pointer\*(C'\fR
.IP "popup \s-1OBJECT\s0" 4
.IX Item "popup OBJECT"
Manages a Prima::Popup object associated with a widget. 
The purpose of the popup object is to show a context menu
when the user right-clicks or selects the corresponding keyboard
combination. Prima::Widget can host many children objects,
Prima::Popup as well. But only the one that is set in
\&\f(CW\*(C`::popup\*(C'\fR property will be activated automatically.
.Sp
The popup object can be destroyed safely; its cancellation
can be done either via \f(CW\*(C`popup(undef)\*(C'\fR or \f(CW\*(C`destroy()\*(C'\fR call.
.Sp
See also: \f(CW\*(C`Prima::Menu\*(C'\fR, \f(CW\*(C`Popup\*(C'\fR, \f(CW\*(C`Menu\*(C'\fR, 
\&\f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR
.IP "popupColorIndex \s-1INDEX, COLOR\s0" 4
.IX Item "popupColorIndex INDEX, COLOR"
Maintains eight color properties of a pop-up context menu,
associated with a widget. \s-1INDEX\s0 must be one of \f(CW\*(C`ci::XXX\*(C'\fR constants
( see \f(CW\*(C`::colorIndex\*(C'\fR property ).
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupColor \s-1COLOR\s0" 4
.IX Item "popupColor COLOR"
Basic foreground in a popup context menu color.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupBackColor \s-1COLOR\s0" 4
.IX Item "popupBackColor COLOR"
Basic background in a popup context menu color.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupDark3DColor \s-1COLOR\s0" 4
.IX Item "popupDark3DColor COLOR"
Color for drawing dark shadings in a popup context menu.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupDisabledColor \s-1COLOR\s0" 4
.IX Item "popupDisabledColor COLOR"
Foreground color for disabled items in a popup context menu.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupDisabledBackColor \s-1COLOR\s0" 4
.IX Item "popupDisabledBackColor COLOR"
Background color for disabled items in a popup context menu.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.ie n .IP "popupFont %FONT" 4
.el .IP "popupFont \f(CW%FONT\fR" 4
.IX Item "popupFont %FONT"
Maintains the font of a pop-up context menu, associated with a widget.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupHiliteColor \s-1COLOR\s0" 4
.IX Item "popupHiliteColor COLOR"
Foreground color for selected items in a popup context menu.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupHiliteBackColor \s-1COLOR\s0" 4
.IX Item "popupHiliteBackColor COLOR"
Background color for selected items in a popup context menu.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "popupItems [ \s-1ITEM_LIST \s0]" 4
.IX Item "popupItems [ ITEM_LIST ]"
Manages items of a Prima::Popup object associated with a widget.
The \s-1ITEM_LIST\s0 format is same as \f(CW\*(C`Prima::AbstractMenu::items\*(C'\fR
and is described in Prima::Menu.
.Sp
See also: \f(CW\*(C`popup\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR
.IP "popupLight3DColor \s-1COLOR\s0" 4
.IX Item "popupLight3DColor COLOR"
Color for drawing light shadings in a popup context menu.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR, \f(CW\*(C`popupColorIndex\*(C'\fR, \f(CW\*(C`popupFont\*(C'\fR, \f(CW\*(C`popup\*(C'\fR
.IP "rect X_LEFT_OFFSET Y_BOTTOM_OFFSET X_RIGHT_OFFSET Y_TOP_OFFSET" 4
.IX Item "rect X_LEFT_OFFSET Y_BOTTOM_OFFSET X_RIGHT_OFFSET Y_TOP_OFFSET"
Maintains the rectangular boundaries of a widget relative
to its owner ( or to the screen if \f(CW\*(C`::clipOwner\*(C'\fR is set to 0 ).
.Sp
See also: \f(CW\*(C`bottom\*(C'\fR, \f(CW\*(C`right\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, 
\&\f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR, \f(CW\*(C`size\*(C'\fR
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`get_virtual_size\*(C'\fR, 
\&\f(CW\*(C`sizeMax\*(C'\fR, \f(CW\*(C`sizeMin\*(C'\fR
.IP "right \s-1INTEGER\s0" 4
.IX Item "right INTEGER"
Maintains the right boundary of a widget. If changed,
does not affect the widget width; but does so, if called
in \f(CW\*(C`set()\*(C'\fR together with \f(CW\*(C`::left\*(C'\fR.
.Sp
See also: \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`bottom\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`rect\*(C'\fR,
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR
.IP "scaleChildren \s-1BOOLEAN\s0" 4
.IX Item "scaleChildren BOOLEAN"
If a widget has \f(CW\*(C`::scaleChildren\*(C'\fR set to 1, then the newly-created 
children widgets inserted in it will be scaled corresponding to the
owner's \f(CW\*(C`::designScale\*(C'\fR, given that widget's \f(CW\*(C`::designScale\*(C'\fR is not \f(CW\*(C`undef\*(C'\fR
and the owner's is not [0,0].
.Sp
Default is 1.
.Sp
See also: \f(CW\*(C`designScale\*(C'\fR
.IP "selectable \s-1BOOLEAN\s0" 4
.IX Item "selectable BOOLEAN"
If 1, a widget can be granted focus implicitly, or by means of
the user actions. \f(CW\*(C`select()\*(C'\fR regards this property, and does not
focus a widget that has \f(CW\*(C`::selectable\*(C'\fR set to 0.
.Sp
Default value is 0
.Sp
See also: \f(CW\*(C`current\*(C'\fR, \f(CW\*(C`currentWidget\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`selectedWidget\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "selected \s-1BOOLEAN\s0" 4
.IX Item "selected BOOLEAN"
If called in get-mode, returns whether a widget or
one of its (grand\-) children is focused. If in set-mode,
either simply turns the system with no-focus state ( if 0 ),
or sends input focus to itself or one of the widgets tracked down by
\&\f(CW\*(C`::currentWidget\*(C'\fR chain.
.Sp
See also: \f(CW\*(C`current\*(C'\fR, \f(CW\*(C`currentWidget\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selectedWidget\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "selectedWidget \s-1OBJECT\s0" 4
.IX Item "selectedWidget OBJECT"
Points to a child widget, that has property \f(CW\*(C`::selected\*(C'\fR set to 1.
.Sp
See also: \f(CW\*(C`current\*(C'\fR, \f(CW\*(C`currentWidget\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "selectingButtons \s-1FLAGS\s0" 4
.IX Item "selectingButtons FLAGS"
\&\s-1FLAGS\s0 is a combination of \f(CW\*(C`mb::XXX\*(C'\fR ( mouse button ) flags.
If a widget receives a click with a mouse button, that has
the corresponding bit set in \f(CW\*(C`::selectingButtons\*(C'\fR, then
\&\f(CW\*(C`select()\*(C'\fR is called.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`firstClick\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "shape \s-1IMAGE\s0" 4
.IX Item "shape IMAGE"
Maintains the non-rectangular shape of a widget.
\&\s-1IMAGE\s0 is monochrome Prima::Image, with 0 bits treated 
as transparent pixels, and 1 bits as opaque pixels.
.Sp
Successive only if \f(CW\*(C`sv::ShapeExtension\*(C'\fR value is true.
.IP "showHint \s-1BOOLEAN\s0" 4
.IX Item "showHint BOOLEAN"
If 1, the toolkit is allowed to show the hint label over 
a widget. If 0, the display of the hint is forbidden. The \f(CW\*(C`::hint\*(C'\fR
property must contain non-empty string as well, if
the hint label must be shown.
.Sp
Default value is 1.
.Sp
See also: \f(CW\*(C`hint\*(C'\fR, \f(CW\*(C`ownerShowHint\*(C'\fR, \f(CW\*(C`hintVisible\*(C'\fR, \f(CW\*(C`ownerHint\*(C'\fR
.IP "size \s-1WIDTH HEIGHT\s0" 4
.IX Item "size WIDTH HEIGHT"
Maintains the width and height of a widget.
.Sp
See also: \f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`get_virtual_size\*(C'\fR, 
\&\f(CW\*(C`sizeMax\*(C'\fR, \f(CW\*(C`sizeMin\*(C'\fR
.IP "sizeMax \s-1WIDTH HEIGHT\s0" 4
.IX Item "sizeMax WIDTH HEIGHT"
Specifies the maximal size for a widget that it is allowed to accept.
.Sp
See also: \f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR, \f(CW\*(C`size\*(C'\fR
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`get_virtual_size\*(C'\fR, 
\&\f(CW\*(C`sizeMin\*(C'\fR
.IP "sizeMin \s-1WIDTH HEIGHT\s0" 4
.IX Item "sizeMin WIDTH HEIGHT"
Specifies the minimal size for a widget that it is allowed to accept.
.Sp
See also: \f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR, \f(CW\*(C`size\*(C'\fR
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`get_virtual_size\*(C'\fR, 
\&\f(CW\*(C`sizeMax\*(C'\fR
.IP "syncPaint \s-1BOOLEAN\s0" 4
.IX Item "syncPaint BOOLEAN"
If 0, the \f(CW\*(C`Paint\*(C'\fR request notifications are stacked
until the event loop is called. If 1, every time the widget
surface gets invalidated, the \f(CW\*(C`Paint\*(C'\fR notification is called.
.Sp
Default value is 0.
.Sp
See also: \f(CW\*(C`invalidate_rect\*(C'\fR, \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`validate_rect\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR
.IP "tabOrder \s-1INTEGER\s0" 4
.IX Item "tabOrder INTEGER"
Maintains the order in which tab\- and shift\-tab\- key navigation
algorithms select the sibling widgets. \s-1INTEGER\s0 is unique among
the sibling widgets. In set mode, if \s-1INTEGER\s0 value is already taken,
the occupier is assigned another unique value, but without destruction
of a queue \- widgets with ::tabOrder greater than of the widget,
receive their new values too. Special value \-1 is accepted as 'the end of list'
indicator; the negative value is never returned.
.Sp
See also: \f(CW\*(C`tabStop\*(C'\fR, \f(CW\*(C`next_tab\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "tabStop \s-1BOOLEAN\s0" 4
.IX Item "tabStop BOOLEAN"
Specifies whether a widget is interested in tab\- and shift\-tab\- key
navigation or not.
.Sp
Default value is 1.
.Sp
See also: \f(CW\*(C`tabOrder\*(C'\fR, \f(CW\*(C`next_tab\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`focused\*(C'\fR
.IP "text \s-1TEXT\s0" 4
.IX Item "text TEXT"
A text string for generic purpose. Many Prima::Widget
descendants use this property heavily \- buttons, labels,
input lines etc, but Prima::Widget itself does not.
.IP "top \s-1INTEGER\s0" 4
.IX Item "top INTEGER"
Maintains the upper boundary of a widget. If changed,
does not affect the widget height; but does so, if called
in \f(CW\*(C`set()\*(C'\fR together with \f(CW\*(C`::bottom\*(C'\fR.
.Sp
See also: \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`right\*(C'\fR, \f(CW\*(C`bottom\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`rect\*(C'\fR,
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR
.IP "transparent \s-1BOOLEAN\s0" 4
.IX Item "transparent BOOLEAN"
Specifies whether the background of a widget before
it starts painting is of any importance. If 1, a widget
can gain certain transparency look if it
does not clear the background during \f(CW\*(C`Paint\*(C'\fR event.
.Sp
Default value is 0
.Sp
See also: \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`buffered\*(C'\fR.
.IP "visible \s-1BOOLEAN\s0" 4
.IX Item "visible BOOLEAN"
Specifies whether a widget is visible or not.
See \*(L"Visibility\*(R".
.Sp
See also: \f(CW\*(C`Show\*(C'\fR, \f(CW\*(C`Hide\*(C'\fR, \f(CW\*(C`showing\*(C'\fR, \f(CW\*(C`exposed\*(C'\fR
.IP "widgetClass \s-1CLASS\s0" 4
.IX Item "widgetClass CLASS"
Maintains the integer value, designating the color
class that is defined by the system and is associated with Prima::Widget
eight basic color properties. \s-1CLASS\s0 can be one of 
\&\f(CW\*(C`wc::XXX\*(C'\fR constants:
.Sp
.Vb 10
\&   wc::Undef
\&   wc::Button
\&   wc::CheckBox
\&   wc::Combo
\&   wc::Dialog
\&   wc::Edit
\&   wc::InputLine
\&   wc::Label
\&   wc::ListBox
\&   wc::Menu
\&   wc::Popup
\&   wc::Radio
\&   wc::ScrollBar
\&   wc::Slider
\&   wc::Widget or wc::Custom
\&   wc::Window
\&   wc::Application
.Ve
.Sp
These constants are not associated with the toolkit classes;
any class can use any of these constants in \f(CW\*(C`::widgetClass\*(C'\fR.
.Sp
See also: \f(CW\*(C`map_color\*(C'\fR, \f(CW\*(C`colorIndex\*(C'\fR
.ie n .IP "widgets @WIDGETS" 4
.el .IP "widgets \f(CW@WIDGETS\fR" 4
.IX Item "widgets @WIDGETS"
In get-mode, returns list of immediate children widgets (identical
to \f(CW\*(C`get_widgets\*(C'\fR). In set-mode accepts set of widget profiles, as \f(CW\*(C`insert\*(C'\fR does,
as a list or an array. This way it is possible to create widget hierarchy in
a single call.
.IP "width \s-1WIDTH\s0" 4
.IX Item "width WIDTH"
Maintains the width of a widget.
.Sp
See also: \f(CW\*(C`height\*(C'\fR
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`get_virtual_size\*(C'\fR, 
\&\f(CW\*(C`sizeMax\*(C'\fR, \f(CW\*(C`sizeMin\*(C'\fR
.IP "x_centered \s-1BOOLEAN\s0" 4
.IX Item "x_centered BOOLEAN"
A write-only property. Once set, widget is centered by the horizontal
axis relative to its owner.
.Sp
See also: \f(CW\*(C`centered\*(C'\fR, \f(CW\*(C`y_centered\*(C'\fR, \f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`Move\*(C'\fR.
.IP "y_centered \s-1BOOLEAN\s0" 4
.IX Item "y_centered BOOLEAN"
A write-only property. Once set, widget is centered by the vertical
axis relative to its owner.
.Sp
See also: \f(CW\*(C`x_centered\*(C'\fR, \f(CW\*(C`centered\*(C'\fR, \f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`Move\*(C'\fR.
.SS "Methods"
.IX Subsection "Methods"
.IP "bring_to_front" 4
.IX Item "bring_to_front"
Sends a widget on top of all other siblings widgets
.Sp
See also: \f(CW\*(C`insert_behind\*(C'\fR, \f(CW\*(C`send_to_back\*(C'\fR, \f(CW\*(C`ZOrderChanged\*(C'\fR
,\f(CW\*(C`first\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`prev\*(C'\fR, \f(CW\*(C`last\*(C'\fR
.IP "can_close" 4
.IX Item "can_close"
Sends \f(CW\*(C`Close\*(C'\fR message, and returns its boolean exit state.
.Sp
See also: \f(CW\*(C`Close\*(C'\fR, \f(CW\*(C`close\*(C'\fR
.ie n .IP "client_to_screen @OFFSETS" 4
.el .IP "client_to_screen \f(CW@OFFSETS\fR" 4
.IX Item "client_to_screen @OFFSETS"
Maps array of X and Y integer offsets from widget to screen coordinates.
Returns the mapped \s-1OFFSETS.\s0
.Sp
See also: \f(CW\*(C`screen_to_client\*(C'\fR, \f(CW\*(C`clipOwner\*(C'\fR
.IP "close" 4
.IX Item "close"
Calls \f(CW\*(C`can_close()\*(C'\fR, and if successful, destroys a widget.
Returns the \f(CW\*(C`can_close()\*(C'\fR result.
.Sp
See also: \f(CW\*(C`can_close\*(C'\fR, \f(CW\*(C`Close\*(C'\fR
.IP "defocus" 4
.IX Item "defocus"
Alias for \f(CWfocused(0)\fR call
.Sp
See also: \f(CW\*(C`focus\*(C'\fR, \f(CW\*(C`focused\*(C'\fR, \f(CW\*(C`Enter\*(C'\fR, \f(CW\*(C`Leave\*(C'\fR
.IP "deselect" 4
.IX Item "deselect"
Alias for \f(CWselected(0)\fR call
.Sp
See also: \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`Enter\*(C'\fR, \f(CW\*(C`Leave\*(C'\fR
.IP "exposed" 4
.IX Item "exposed"
Returns a boolean value, indicating whether a widget 
is at least partly visible on the screen.
Never returns 1 if a widget has \f(CW\*(C`::visible\*(C'\fR set to 0.
.Sp
See also: \f(CW\*(C`visible\*(C'\fR, \f(CW\*(C`showing\*(C'\fR, \f(CW\*(C`Show\*(C'\fR, \f(CW\*(C`Hide\*(C'\fR
.IP "fetch_resource \s-1CLASS_NAME, NAME, CLASS_RESOURCE, RESOURCE, OWNER, RESOURCE_TYPE\s0 = fr::String" 4
.IX Item "fetch_resource CLASS_NAME, NAME, CLASS_RESOURCE, RESOURCE, OWNER, RESOURCE_TYPE = fr::String"
Returns a system-defined scalar of resource, defined by the widget hierarchy,
its class, name and owner. \s-1RESOURCE_TYPE\s0 can be one of type qualificators:
.Sp
.Vb 3
\&   fr::Color  \- color resource
\&   fr::Font   \- font resource
\&   fs::String \- text string resource
.Ve
.Sp
Such a number of the parameters is used because the method 
can be called before a widget is created.
\&\s-1CLASS_NAME\s0 is widget class string, \s-1NAME\s0 is widget name.
\&\s-1CLASS_RESOURCE\s0 is class of resource, and \s-1RESOURCE\s0 is the resource name.
.Sp
For example, resources 'color' and 'disabledColor' belong to the
resource class 'Foreground'.
.IP "first" 4
.IX Item "first"
Returns the first ( from bottom ) sibling widget in Z\-order.
.Sp
See also: \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`prev\*(C'\fR
.IP "focus" 4
.IX Item "focus"
Alias for \f(CWfocused(1)\fR call
.Sp
See also: \f(CW\*(C`defocus\*(C'\fR, \f(CW\*(C`focused\*(C'\fR, \f(CW\*(C`Enter\*(C'\fR, \f(CW\*(C`Leave\*(C'\fR
.IP "hide" 4
.IX Item "hide"
Sets widget \f(CW\*(C`::visible\*(C'\fR to 0.
.Sp
See also: \f(CW\*(C`hide\*(C'\fR, \f(CW\*(C`visible\*(C'\fR, \f(CW\*(C`Show\*(C'\fR, \f(CW\*(C`Hide\*(C'\fR, \f(CW\*(C`showing\*(C'\fR, \f(CW\*(C`exposed\*(C'\fR
.IP "hide_cursor" 4
.IX Item "hide_cursor"
Hides the cursor. As many times \f(CW\*(C`hide_cursor()\*(C'\fR was called,
as many time its counterpart \f(CW\*(C`show_cursor()\*(C'\fR must be called
to reach the cursor's initial state.
.Sp
See also: \f(CW\*(C`show_cursor\*(C'\fR, \f(CW\*(C`cursorVisible\*(C'\fR
.IP "help" 4
.IX Item "help"
Starts an interactive help viewer
opened on \f(CW\*(C`::helpContext\*(C'\fR string value.
.Sp
The string value is combined
from the widget's owner \f(CW\*(C`::helpContext\*(C'\fR strings
if the latter is empty or begins with a slash.
A special meaning is assigned to an empty string \*(L" \*(R" \-
the \fIhelp()\fR call fails when such value is found to be
the section component.  This feature can be useful when a window or a dialog
presents a standalone functionality in a separate module,
and the documentation is related more to the module than
to an embedding program. In such case, the grouping widget
holds \f(CW\*(C`::helpContext\*(C'\fR as a pod manpage name with a trailing
slash, and its children widgets are assigned \f(CW\*(C`::helpContext\*(C'\fR
to the topics without the manpage but the leading slash instead.
If the grouping widget has an empty string \*(L" \*(R" as \f(CW\*(C`::helpContext\*(C'\fR
then the help is forced to be unavailable for all the children
widgets.
.Sp
See also: \f(CW\*(C`helpContext\*(C'\fR
.ie n .IP "insert \s-1CLASS,\s0 %PROFILE [[ \s-1CLASS,\s0 %PROFILE], ... ]" 4
.el .IP "insert \s-1CLASS,\s0 \f(CW%PROFILE\fR [[ \s-1CLASS,\s0 \f(CW%PROFILE\fR], ... ]" 4
.IX Item "insert CLASS, %PROFILE [[ CLASS, %PROFILE], ... ]"
Creates one or more widgets with \f(CW\*(C`owner\*(C'\fR property set to the 
caller widget, and returns the list of references to the newly 
created widgets.
.Sp
Has two calling formats:
.RS 4
.IP "Single widget" 4
.IX Item "Single widget"
.Vb 4
\&  $parent\-> insert( \*(AqChild::Class\*(Aq,
\&     name => \*(Aqchild\*(Aq,
\&     ....
\&  );
.Ve
.IP "Multiple widgets" 4
.IX Item "Multiple widgets"
.Vb 12
\&  $parent\-> insert( 
\&    [
\&       \*(AqChild::Class1\*(Aq,
\&          name => \*(Aqchild1\*(Aq,
\&          ....
\&    ],
\&    [
\&       \*(AqChild::Class2\*(Aq,
\&          name => \*(Aqchild2\*(Aq,
\&          ....
\&    ],
\&  );
.Ve
.RE
.RS 4
.RE
.IP "insert_behind \s-1OBJECT\s0" 4
.IX Item "insert_behind OBJECT"
Sends a widget behind the \s-1OBJECT\s0 on Z\-axis, given that
the \s-1OBJECT\s0 is a sibling to the widget.
.Sp
See also: \f(CW\*(C`bring_to_front\*(C'\fR, \f(CW\*(C`send_to_back\*(C'\fR, \f(CW\*(C`ZOrderChanged\*(C'\fR 
,\f(CW\*(C`first\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`prev\*(C'\fR, \f(CW\*(C`last\*(C'\fR
.IP "invalidate_rect X_LEFT_OFFSET Y_BOTTOM_OFFSET X_RIGHT_OFFSET Y_TOP_OFFSET" 4
.IX Item "invalidate_rect X_LEFT_OFFSET Y_BOTTOM_OFFSET X_RIGHT_OFFSET Y_TOP_OFFSET"
Marks the rectangular area of a widget as 'invalid', 
so re-painting of the area happens. See \*(L"Graphic content\*(R".
.Sp
See also: \f(CW\*(C`validate_rect\*(C'\fR, \f(CW\*(C`get_invalid_rect\*(C'\fR, \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`syncPaint\*(C'\fR, \f(CW\*(C`update_view\*(C'\fR
.IP "key_down \s-1CODE, KEY\s0 = kb::NoKey, \s-1MOD\s0 = 0, \s-1REPEAT\s0 = 1, \s-1POST\s0 = 0" 4
.IX Item "key_down CODE, KEY = kb::NoKey, MOD = 0, REPEAT = 1, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`KeyDown\*(C'\fR event 
to the system. \s-1CODE, KEY, MOD\s0 and \s-1REPEAT\s0 are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`key_up\*(C'\fR, \f(CW\*(C`key_event\*(C'\fR, \f(CW\*(C`KeyDown\*(C'\fR
.IP "key_event \s-1COMMAND, CODE, KEY\s0 = kb::NoKey, \s-1MOD\s0 = 0, \s-1REPEAT\s0 = 1, \s-1POST\s0 = 0" 4
.IX Item "key_event COMMAND, CODE, KEY = kb::NoKey, MOD = 0, REPEAT = 1, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated keyboard event 
to the system. \s-1CODE, KEY, MOD\s0 and \s-1REPEAT\s0 are the parameters
to be passed to an eventual \f(CW\*(C`KeyDown\*(C'\fR or \f(CW\*(C`KeyUp\*(C'\fR notifications.
\&\s-1COMMAND\s0 is allowed to be either \f(CW\*(C`cm::KeyDown\*(C'\fR or \f(CW\*(C`cm::KeyUp\*(C'\fR.
.Sp
See also: \f(CW\*(C`key_down\*(C'\fR, \f(CW\*(C`key_up\*(C'\fR, \f(CW\*(C`KeyDown\*(C'\fR, \f(CW\*(C`KeyUp\*(C'\fR
.IP "key_up \s-1CODE, KEY\s0 = kb::NoKey, \s-1MOD\s0 = 0, \s-1POST\s0 = 0" 4
.IX Item "key_up CODE, KEY = kb::NoKey, MOD = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`KeyUp\*(C'\fR event 
to the system. \s-1CODE, KEY\s0 and \s-1MOD\s0 are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`key_down\*(C'\fR, \f(CW\*(C`key_event\*(C'\fR, \f(CW\*(C`KeyUp\*(C'\fR
.IP "last" 4
.IX Item "last"
Returns the last ( the topmost ) sibling widget in Z\-order.
.Sp
See also: \f(CW\*(C`first\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`prev\*(C'\fR
.IP "lock" 4
.IX Item "lock"
Turns off the ability of a widget to re-paint itself.
As many times \f(CW\*(C`lock()\*(C'\fR was called, as may times its counterpart,
\&\f(CW\*(C`unlock()\*(C'\fR must be called to enable re-painting again.
Returns a boolean success flag.
.Sp
See also: \f(CW\*(C`unlock\*(C'\fR, \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`get_locked\*(C'\fR
.IP "map_color \s-1COLOR\s0" 4
.IX Item "map_color COLOR"
Transforms \f(CW\*(C`cl::XXX\*(C'\fR and \f(CW\*(C`ci::XXX\*(C'\fR combinations into \s-1RGB\s0
color representation and returns the result. If \s-1COLOR\s0 is already 
in \s-1RGB\s0 format, no changes are made.
.Sp
See also: \f(CW\*(C`colorIndex\*(C'\fR
.IP "mouse_click \s-1BUTTON\s0 = mb::Left, \s-1MOD\s0 = 0, X = 0, Y = 0, \s-1DBL_CLICK\s0 = 0, \s-1POST\s0 = 0" 4
.IX Item "mouse_click BUTTON = mb::Left, MOD = 0, X = 0, Y = 0, DBL_CLICK = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`MouseClick\*(C'\fR event 
to the system. \s-1BUTTON, MOD, X, Y,\s0 and \s-1DBL_CLICK\s0 are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "mouse_down \s-1BUTTON\s0 = mb::Left, \s-1MOD\s0 = 0, X = 0, Y = 0, \s-1POST\s0 = 0" 4
.IX Item "mouse_down BUTTON = mb::Left, MOD = 0, X = 0, Y = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`MouseDown\*(C'\fR event 
to the system. \s-1BUTTON, MOD, X,\s0 and Y are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "mouse_enter \s-1MOD\s0 = 0, X = 0, Y = 0, \s-1POST\s0 = 0" 4
.IX Item "mouse_enter MOD = 0, X = 0, Y = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`MouseEnter\*(C'\fR event 
to the system. \s-1MOD, X,\s0 and Y are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "mouse_event \s-1COMMAND\s0 = cm::MouseDown, \s-1BUTTON\s0 = mb::Left, \s-1MOD\s0 = 0, X = 0, Y = 0, \s-1DBL_CLICK\s0 = 0, \s-1POST\s0 = 0" 4
.IX Item "mouse_event COMMAND = cm::MouseDown, BUTTON = mb::Left, MOD = 0, X = 0, Y = 0, DBL_CLICK = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated mouse event 
to the system. \s-1BUTTON, MOD, X, Y\s0 and \s-1DBL_CLICK\s0 are the parameters
to be passed to an eventual mouse notifications.
\&\s-1COMMAND\s0 is allowed to be one of \f(CW\*(C`cm::MouseDown\*(C'\fR, \f(CW\*(C`cm::MouseUp\*(C'\fR,
\&\f(CW\*(C`cm::MouseWheel\*(C'\fR, \f(CW\*(C`cm::MouseClick\*(C'\fR, \f(CW\*(C`cm::MouseMove\*(C'\fR, \f(CW\*(C`cm::MouseEnter\*(C'\fR,
\&\f(CW\*(C`cm::MouseLeave\*(C'\fR constants.
.Sp
See also: \f(CW\*(C`mouse_down\*(C'\fR, \f(CW\*(C`mouse_up\*(C'\fR, \f(CW\*(C`mouse_wheel\*(C'\fR, \f(CW\*(C`mouse_click\*(C'\fR,
\&\f(CW\*(C`mouse_move\*(C'\fR, \f(CW\*(C`mouse_enter\*(C'\fR, \f(CW\*(C`mouse_leave\*(C'\fR, 
\&\f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "mouse_leave" 4
.IX Item "mouse_leave"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`MouseLeave\*(C'\fR event 
to the system.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "mouse_move \s-1MOD\s0 = 0, X = 0, Y = 0, \s-1POST\s0 = 0" 4
.IX Item "mouse_move MOD = 0, X = 0, Y = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`MouseMove\*(C'\fR event 
to the system. \s-1MOD, X,\s0 and Y are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "mouse_up \s-1BUTTON\s0 = mb::Left, \s-1MOD\s0 = 0, X = 0, Y = 0, \s-1POST\s0 = 0" 4
.IX Item "mouse_up BUTTON = mb::Left, MOD = 0, X = 0, Y = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`MouseUp\*(C'\fR event 
to the system. \s-1BUTTON, MOD, X,\s0 and Y are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "mouse_wheel \s-1MOD\s0 = 0, X = 0, Y = 0, \s-1INCR\s0 = 0, \s-1POST\s0 = 0" 4
.IX Item "mouse_wheel MOD = 0, X = 0, Y = 0, INCR = 0, POST = 0"
The method sends or posts ( \s-1POST\s0 flag ) simulated \f(CW\*(C`MouseUp\*(C'\fR event 
to the system. \s-1MOD, X, Y\s0 and \s-1INCR\s0 are the parameters
to be passed to the notification callbacks.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "next" 4
.IX Item "next"
Returns the neighbor sibling widget, next ( above ) in Z\-order.
If none found, undef is returned.
.Sp
See also: \f(CW\*(C`first\*(C'\fR, \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`prev\*(C'\fR
.IP "next_tab \s-1FORWARD\s0 = 1" 4
.IX Item "next_tab FORWARD = 1"
Returns the next widget in the sorted by \f(CW\*(C`::tabOrder\*(C'\fR list
of sibling widgets. \s-1FORWARD\s0 is a boolean lookup direction flag. 
If none found, the first ( or the last, depending on \s-1FORWARD\s0 flag )
widget is returned. Only widgets with \f(CW\*(C`::tabStop\*(C'\fR set to 1 participate.
.Sp
Also used by the internal keyboard navigation code.
.Sp
See also: \f(CW\*(C`next_positional\*(C'\fR, \f(CW\*(C`tabOrder\*(C'\fR, \f(CW\*(C`tabStop\*(C'\fR, \f(CW\*(C`selectable\*(C'\fR
.IP "next_positional \s-1DELTA_X DELTA_Y\s0" 4
.IX Item "next_positional DELTA_X DELTA_Y"
Returns a sibling, (grand\-)child of a sibling or (grand\-)child widget,
that matched best the direction specified by \s-1DELTA_X\s0 and \s-1DELTA_Y.\s0
At one time, only one of these parameters can be zero; another
parameter must be either 1 or \-1.
.Sp
Also used by the internal keyboard navigation code.
.Sp
See also: \f(CW\*(C`next_tab\*(C'\fR, \f(CW\*(C`origin\*(C'\fR
.IP "pack, packForget, packSlaves" 4
.IX Item "pack, packForget, packSlaves"
See Prima::Widget::pack
.IP "place, placeForget, placeSlaves" 4
.IX Item "place, placeForget, placeSlaves"
See Prima::Widget::place
.IP "prev" 4
.IX Item "prev"
Returns the neighbor sibling widget, previous ( below ) in Z\-order.
If none found, undef is returned.
.Sp
See also: \f(CW\*(C`first\*(C'\fR, \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR
.IP "repaint" 4
.IX Item "repaint"
Marks the whole widget area as 'invalid', 
so re-painting of the area happens. See \*(L"Graphic content\*(R".
.Sp
See also: \f(CW\*(C`validate_rect\*(C'\fR, \f(CW\*(C`get_invalid_rect\*(C'\fR, \f(CW\*(C`invalidate_rect\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR, 
\&\f(CW\*(C`update_view\*(C'\fR, \f(CW\*(C`syncPaint\*(C'\fR
.ie n .IP "rect_bevel $CANVAS, @RECT, %OPTIONS" 4
.el .IP "rect_bevel \f(CW$CANVAS\fR, \f(CW@RECT\fR, \f(CW%OPTIONS\fR" 4
.IX Item "rect_bevel $CANVAS, @RECT, %OPTIONS"
Draws a rectangular area, similar to produced by \f(CW\*(C`rect3d\*(C'\fR over \f(CW@RECT\fR
that is 4\-integer coordinates of the area, but implicitly using widget's \f(CW\*(C`light3DColor\*(C'\fR
and \f(CW\*(C`dark3DColor\*(C'\fR properties' values. The following options are
recognized:
.RS 4
.IP "fill \s-1COLOR\s0" 4
.IX Item "fill COLOR"
If set, the area is filled with \s-1COLOR,\s0 ortherwise is left intact.
.IP "width \s-1INTEGER\s0" 4
.IX Item "width INTEGER"
Width of the border in pixels
.IP "concave \s-1BOOLEAN\s0" 4
.IX Item "concave BOOLEAN"
If 1, draw a concave area, bulged otherwise
.RE
.RS 4
.RE
.IP "responsive" 4
.IX Item "responsive"
Returns a boolean flag, indicating whether a widget and its owners
have all \f(CW\*(C`::enabled\*(C'\fR 1 or not. Useful for fast check if
a widget should respond to the user actions.
.Sp
See also: \f(CW\*(C`enabled\*(C'\fR
.ie n .IP "screen_to_client @OFFSETS" 4
.el .IP "screen_to_client \f(CW@OFFSETS\fR" 4
.IX Item "screen_to_client @OFFSETS"
Maps array of X and Y integer offsets from screen to widget coordinates.
Returns the mapped \s-1OFFSETS.\s0
.Sp
See also: \f(CW\*(C`client_to_screen\*(C'\fR
.ie n .IP "scroll \s-1DELTA_X DELTA_Y\s0 %OPTIONS" 4
.el .IP "scroll \s-1DELTA_X DELTA_Y\s0 \f(CW%OPTIONS\fR" 4
.IX Item "scroll DELTA_X DELTA_Y %OPTIONS"
Scrolls the graphic context area by \s-1DELTA_X\s0 and \s-1DELTA_Y\s0 pixels.
\&\s-1OPTIONS\s0 is hash, that contains optional parameters to the scrolling
procedure:
.RS 4
.IP "clipRect [X1, Y1, X2, Y2]" 4
.IX Item "clipRect [X1, Y1, X2, Y2]"
The clipping area is confined by X1, Y1, X2, Y2 rectangular area.
If not specified, the clipping area covers the whole widget.
Only the bits, covered by clipRect are affected.
Bits scrolled from the outside of the rectangle to the inside 
are painted; bits scrolled from the inside of the rectangle to 
the outside are not painted.
.IP "confineRect [X1, Y1, X2, Y2]" 4
.IX Item "confineRect [X1, Y1, X2, Y2]"
The scrolling area is confined by X1, Y1, X2, Y2 rectangular area.
If not specified, the scrolling area covers the whole widget.
.IP "withChildren \s-1BOOLEAN\s0" 4
.IX Item "withChildren BOOLEAN"
If 1, the scrolling performs with the eventual children widgets
change their positions to \s-1DELTA_X\s0 and \s-1DELTA_Y\s0 as well.
.RE
.RS 4
.Sp
Cannot be used inside paint state.
.Sp
See also: \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`get_invalid_rect\*(C'\fR
.RE
.IP "select" 4
.IX Item "select"
Alias for \f(CWselected(1)\fR call
.Sp
See also: \f(CW\*(C`deselect\*(C'\fR, \f(CW\*(C`selected\*(C'\fR, \f(CW\*(C`Enter\*(C'\fR, \f(CW\*(C`Leave\*(C'\fR
.IP "send_to_back" 4
.IX Item "send_to_back"
Sends a widget at bottom of all other siblings widgets
.Sp
See also: \f(CW\*(C`insert_behind\*(C'\fR, \f(CW\*(C`bring_to_front\*(C'\fR, \f(CW\*(C`ZOrderChanged\*(C'\fR 
,\f(CW\*(C`first\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`prev\*(C'\fR, \f(CW\*(C`last\*(C'\fR
.IP "show" 4
.IX Item "show"
Sets widget \f(CW\*(C`::visible\*(C'\fR to 1.
.Sp
See also: \f(CW\*(C`hide\*(C'\fR, \f(CW\*(C`visible\*(C'\fR, \f(CW\*(C`Show\*(C'\fR, \f(CW\*(C`Hide\*(C'\fR, \f(CW\*(C`showing\*(C'\fR, \f(CW\*(C`exposed\*(C'\fR
.IP "show_cursor" 4
.IX Item "show_cursor"
Shows the cursor. As many times \f(CW\*(C`hide_cursor()\*(C'\fR was called,
as many time its counterpart \f(CW\*(C`show_cursor()\*(C'\fR must be called
to reach the cursor's initial state.
.Sp
See also: \f(CW\*(C`hide_cursor\*(C'\fR, \f(CW\*(C`cursorVisible\*(C'\fR
.IP "showing" 4
.IX Item "showing"
Returns a boolean value, indicating whether the widget and its owners
have all \f(CW\*(C`::visible\*(C'\fR 1 or not.
.IP "unlock" 4
.IX Item "unlock"
Turns on the ability of a widget to re-paint itself.
As many times \f(CW\*(C`lock()\*(C'\fR was called, as may times its counterpart,
\&\f(CW\*(C`unlock()\*(C'\fR must be called to enable re-painting again.
When last \f(CW\*(C`unlock()\*(C'\fR is called, an implicit \f(CW\*(C`repaint()\*(C'\fR call is 
made.  Returns a boolean success flag.
.Sp
See also: \f(CW\*(C`lock\*(C'\fR, \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`get_locked\*(C'\fR
.IP "update_view" 4
.IX Item "update_view"
If any parts of a widget were marked as 'invalid' by
either \f(CW\*(C`invalidate_rect()\*(C'\fR or \f(CW\*(C`repaint()\*(C'\fR calls or the 
exposure caused by window movements ( or any other),
then \f(CW\*(C`Paint\*(C'\fR notification is immediately called.
If no parts are invalid, no action is performed.
If a widget has \f(CW\*(C`::syncPaint\*(C'\fR set to 1, 
\&\f(CW\*(C`update_view()\*(C'\fR is always a no-operation call.
.Sp
See also: \f(CW\*(C`invalidate_rect\*(C'\fR, \f(CW\*(C`get_invalid_rect\*(C'\fR, \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`syncPaint\*(C'\fR, \f(CW\*(C`update_view\*(C'\fR
.IP "validate_rect X_LEFT_OFFSET Y_BOTTOM_OFFSET X_RIGHT_OFFSET Y_TOP_OFFSET" 4
.IX Item "validate_rect X_LEFT_OFFSET Y_BOTTOM_OFFSET X_RIGHT_OFFSET Y_TOP_OFFSET"
Reverses the effect of \f(CW\*(C`invalidate_rect()\*(C'\fR, restoring the original, 'valid'
state of widget area covered by the rectangular area passed. If a widget
with previously invalid areas was wholly validated by this method, no \f(CW\*(C`Paint\*(C'\fR
notifications occur.
.Sp
See also: \f(CW\*(C`invalidate_rect\*(C'\fR, \f(CW\*(C`get_invalid_rect\*(C'\fR, \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`syncPaint\*(C'\fR, \f(CW\*(C`update_view\*(C'\fR
.SS "Get-methods"
.IX Subsection "Get-methods"
.IP "get_default_font" 4
.IX Item "get_default_font"
Returns the default font for a Prima::Widget class.
.Sp
See also: \f(CW\*(C`font\*(C'\fR
.IP "get_default_popup_font" 4
.IX Item "get_default_popup_font"
Returns the default font for a Prima::Popup class.
.Sp
See also: \f(CW\*(C`font\*(C'\fR
.IP "get_invalid_rect" 4
.IX Item "get_invalid_rect"
Returns the result of successive calls \f(CW\*(C`invalidate_rect()\*(C'\fR,
\&\f(CW\*(C`validate_rect()\*(C'\fR and \f(CW\*(C`repaint()\*(C'\fR, as a rectangular area   
( four integers ) that cover all invalid regions in a widget.
If none found, (0,0,0,0) is returned.
.Sp
See also: \f(CW\*(C`validate_rect\*(C'\fR, \f(CW\*(C`invalidate_rect\*(C'\fR, \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`Paint\*(C'\fR, \f(CW\*(C`syncPaint\*(C'\fR, \f(CW\*(C`update_view\*(C'\fR
.IP "get_handle" 4
.IX Item "get_handle"
Returns a system handle for a widget
.Sp
See also: \f(CW\*(C`get_parent_handle\*(C'\fR, \f(CW\*(C`Window::get_client_handle\*(C'\fR
.IP "get_locked" 4
.IX Item "get_locked"
Returns 1 if a widget is in \f(CW\*(C`lock()\*(C'\fR \- initiated repaint-blocked state.
.Sp
See also: \f(CW\*(C`lock\*(C'\fR, \f(CW\*(C`unlock\*(C'\fR
.IP "get_mouse_state" 4
.IX Item "get_mouse_state"
Returns a combination of \f(CW\*(C`mb::XXX\*(C'\fR constants, reflecting the currently
pressed mouse buttons.
.Sp
See also: \f(CW\*(C`pointerPos\*(C'\fR, \f(CW\*(C`get_shift_state\*(C'\fR
.IP "get_parent" 4
.IX Item "get_parent"
Returns the owner widget that clips the widget boundaries, or application
object if a widget is top-level.
.Sp
See also: \f(CW\*(C`clipOwner\*(C'\fR
.IP "get_parent_handle" 4
.IX Item "get_parent_handle"
Returns a system handle for a parent of a widget, a window that
belongs to another program. Returns 0 if the widget's owner and parent
are in the same application and process space.
.Sp
See also: \f(CW\*(C`get_handle\*(C'\fR, \f(CW\*(C`clipOwner\*(C'\fR
.IP "get_pointer_size" 4
.IX Item "get_pointer_size"
Returns two integers, width and height of a icon,
that the system accepts as valid for a pointer.
If the icon is supplied that is more or less than these values,
it is truncated or padded with transparency bits, but is not stretched.
Can be called with class syntax.
.IP "get_shift_state" 4
.IX Item "get_shift_state"
Returns a combination of \f(CW\*(C`km::XXX\*(C'\fR constants, reflecting the currently
pressed keyboard modificator buttons.
.Sp
See also: \f(CW\*(C`get_shift_state\*(C'\fR
.IP "get_virtual_size" 4
.IX Item "get_virtual_size"
Returns virtual width and height of a widget. 
See \*(L"Geometry\*(R", Implicit size regulations.
.Sp
See also: \f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR, \f(CW\*(C`size\*(C'\fR
\&\f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`sizeMax\*(C'\fR, \f(CW\*(C`sizeMin\*(C'\fR
.IP "get_widgets" 4
.IX Item "get_widgets"
Returns list of children widgets.
.SS "Events"
.IX Subsection "Events"
.IP "Change" 4
.IX Item "Change"
Generic notification, used for Prima::Widget descendants;
Prima::Widget itself neither calls not uses the event.
Designed to be called when an arbitrary major state of 
a widget is changed.
.IP "Click" 4
.IX Item "Click"
Generic notification, used for Prima::Widget descendants;
Prima::Widget itself neither calls not uses the event.
Designed to be called when an arbitrary major action
for a widget is called.
.IP "Close" 4
.IX Item "Close"
Triggered by \f(CW\*(C`can_close()\*(C'\fR and \f(CW\*(C`close()\*(C'\fR functions. 
If the event flag is cleared during execution,
these functions fail.
.Sp
See also: \f(CW\*(C`close\*(C'\fR, \f(CW\*(C`can_close\*(C'\fR
.IP "ColorChanged \s-1INDEX\s0" 4
.IX Item "ColorChanged INDEX"
Called when one of widget's color properties
is changed, either by direct property change
or by the system. \s-1INDEX\s0 is one of \f(CW\*(C`ci::XXX\*(C'\fR
constants.
.Sp
See also: \f(CW\*(C`colorIndex\*(C'\fR
.IP "Disable" 4
.IX Item "Disable"
Triggered by a successive \f(CWenabled(0)\fR call
.Sp
See also: \f(CW\*(C`Enable\*(C'\fR, \f(CW\*(C`enabled\*(C'\fR, \f(CW\*(C`responsive\*(C'\fR
.IP "DragDrop X Y" 4
.IX Item "DragDrop X Y"
\&\fIDesign in progress\fR. Supposed to be triggered
when a drag-and-drop session started by the widget.
X and Y are mouse pointer coordinates on
the session start.
.Sp
See also: \f(CW\*(C`DragOver\*(C'\fR, \f(CW\*(C`EndDrag\*(C'\fR
.IP "DragOver X Y \s-1STATE\s0" 4
.IX Item "DragOver X Y STATE"
\&\fIDesign in progress\fR. Supposed to be called
when a mouse pointer is passed over a widget
during a drag-and-drop session.
X and Y are mouse pointer coordinates, identical
to \f(CW\*(C`MouseMove\*(C'\fR X Y parameters. \s-1STATE\s0 value
is undefined.
.Sp
See also: \f(CW\*(C`DragDrop\*(C'\fR, \f(CW\*(C`EndDrag\*(C'\fR
.IP "Enable" 4
.IX Item "Enable"
Triggered by a successive \f(CWenabled(1)\fR call
.Sp
See also: \f(CW\*(C`Disable\*(C'\fR, \f(CW\*(C`enabled\*(C'\fR, \f(CW\*(C`responsive\*(C'\fR
.IP "EndDrag X Y" 4
.IX Item "EndDrag X Y"
\&\fIDesign in progress\fR. Supposed to be called
when a drag-and-drop session is finished successfully
over a widget. X and Y are mouse pointer coordinates
on the session end.
.Sp
See also: \f(CW\*(C`DragDrop\*(C'\fR, \f(CW\*(C`DragOver\*(C'\fR
.IP "Enter" 4
.IX Item "Enter"
Called when a widget receives the input focus.
.Sp
See also: \f(CW\*(C`Leave\*(C'\fR, \f(CW\*(C`focused\*(C'\fR, \f(CW\*(C`selected\*(C'\fR
.IP "FontChanged" 4
.IX Item "FontChanged"
Called when a widget font is changed either 
by direct property change or by the system.
.Sp
See also: \f(CW\*(C`font\*(C'\fR, \f(CW\*(C`ColorChanged\*(C'\fR
.IP "Hide" 4
.IX Item "Hide"
Triggered by a successive \f(CWvisible(0)\fR call
.Sp
See also: \f(CW\*(C`Show\*(C'\fR, \f(CW\*(C`visible\*(C'\fR, \f(CW\*(C`showing\*(C'\fR, \f(CW\*(C`exposed\*(C'\fR
.IP "Hint \s-1SHOW_FLAG\s0" 4
.IX Item "Hint SHOW_FLAG"
Called when the hint label is about to show or hide,
depending on \s-1SHOW_FLAG.\s0 The hint show or hide action
fails, if the event flag is cleared during execution.
.Sp
See also: \f(CW\*(C`showHint\*(C'\fR, \f(CW\*(C`ownerShowHint\*(C'\fR, \f(CW\*(C`hintVisible\*(C'\fR, \f(CW\*(C`ownerHint\*(C'\fR
.IP "KeyDown \s-1CODE, KEY, MOD, REPEAT\s0" 4
.IX Item "KeyDown CODE, KEY, MOD, REPEAT"
Sent to the focused widget when the user presses a key.
\&\s-1CODE\s0 contains an eventual character code, \s-1KEY\s0 is one of \f(CW\*(C`kb::XXX\*(C'\fR
constants, \s-1MOD\s0 is a combination of the modificator keys
pressed when the event occurred ( \f(CW\*(C`km::XXX\*(C'\fR ). \s-1REPEAT\s0
is how many times the key was pressed; usually it is 1.
( see \f(CW\*(C`::briefKeys\*(C'\fR ).
.Sp
The valid \f(CW\*(C`km::\*(C'\fR constants are:
.Sp
.Vb 6
\&   km::Shift
\&   km::Ctrl
\&   km::Alt
\&   km::KeyPad
\&   km::DeadKey
\&   km::Unicode
.Ve
.Sp
The valid \f(CW\*(C`kb::\*(C'\fR constants are grouped in several sets.
Some codes are aliased, like, \f(CW\*(C`kb::PgDn\*(C'\fR and \f(CW\*(C`kb::PageDown\*(C'\fR.
.RS 4
.IP "Modificator keys" 4
.IX Item "Modificator keys"
.Vb 4
\&   kb::ShiftL   kb::ShiftR   kb::CtrlL      kb::CtrlR
\&   kb::AltL     kb::AltR     kb::MetaL      kb::MetaR
\&   kb::SuperL   kb::SuperR   kb::HyperL     kb::HyperR
\&   kb::CapsLock kb::NumLock  kb::ScrollLock kb::ShiftLock
.Ve
.IP "Keys with character code defined" 4
.IX Item "Keys with character code defined"
.Vb 2
\&   kb::Backspace  kb::Tab    kb::Linefeed   kb::Enter
\&   kb::Return     kb::Escape kb::Esc        kb::Space
.Ve
.IP "Function keys" 4
.IX Item "Function keys"
.Vb 3
\&   kb::F1 .. kb::F30
\&   kb::L1 .. kb::L10
\&   kb::R1 .. kb::R10
.Ve
.IP "Other" 4
.IX Item "Other"
.Vb 8
\&   kb::Clear    kb::Pause   kb::SysRq  kb::SysReq
\&   kb::Delete   kb::Home    kb::Left   kb::Up
\&   kb::Right    kb::Down    kb::PgUp   kb::Prior
\&   kb::PageUp   kb::PgDn    kb::Next   kb::PageDown
\&   kb::End      kb::Begin   kb::Select kb::Print
\&   kb::PrintScr kb::Execute kb::Insert kb::Undo
\&   kb::Redo     kb::Menu    kb::Find   kb::Cancel
\&   kb::Help     kb::Break   kb::BackTab
.Ve
.RE
.RS 4
.Sp
See also: \f(CW\*(C`KeyUp\*(C'\fR, \f(CW\*(C`briefKeys\*(C'\fR, \f(CW\*(C`key_down\*(C'\fR, \f(CW\*(C`help\*(C'\fR, \f(CW\*(C`popup\*(C'\fR,
\&\f(CW\*(C`tabOrder\*(C'\fR, \f(CW\*(C`tabStop\*(C'\fR, \f(CW\*(C`accelTable\*(C'\fR
.RE
.IP "KeyUp \s-1CODE, KEY, MOD\s0" 4
.IX Item "KeyUp CODE, KEY, MOD"
Sent to the focused widget when the user releases a key.
\&\s-1CODE\s0 contains an eventual character code, \s-1KEY\s0 is one of \f(CW\*(C`kb::XXX\*(C'\fR
constants, \s-1MOD\s0 is a combination of the modificator keys
pressed when the event occurred ( \f(CW\*(C`km::XXX\*(C'\fR ).
.Sp
See also: \f(CW\*(C`KeyDown\*(C'\fR, \f(CW\*(C`key_up\*(C'\fR
.IP "Leave" 4
.IX Item "Leave"
Called when the input focus is removed from a widget
.Sp
See also: \f(CW\*(C`Enter\*(C'\fR, \f(CW\*(C`focused\*(C'\fR, \f(CW\*(C`selected\*(C'\fR
.IP "Menu \s-1MENU VAR_NAME\s0" 4
.IX Item "Menu MENU VAR_NAME"
Called before the user-navigated menu ( pop-up
or pull-down ) is about to show another level of 
submenu on the screen. \s-1MENU\s0 is Prima::AbstractMenu
descendant, that children to a widget, and \s-1VAR_NAME\s0
is the name of the menu item that is about to be shown.
.Sp
Used for making changes in the menu structures dynamically.
.Sp
See also: \f(CW\*(C`popupItems\*(C'\fR
.IP "MouseClick \s-1BUTTON, MOD, X, Y, DOUBLE_CLICK\s0" 4
.IX Item "MouseClick BUTTON, MOD, X, Y, DOUBLE_CLICK"
Called when a mouse click ( button is pressed, and then 
released within system-defined interval of time ) is
happened in the widget area. \s-1BUTTON\s0 is one of \f(CW\*(C`mb::XXX\*(C'\fR
constants, \s-1MOD\s0 is a combination of \f(CW\*(C`km::XXX\*(C'\fR constants,
reflecting pressed modificator keys during the event,
X and Y are the mouse pointer coordinates. \s-1DOUBLE_CLICK\s0
is a boolean flag, set to 1 if it was a double click,
0 if a single.
.Sp
\&\f(CW\*(C`mb::XXX\*(C'\fR constants are:
.Sp
.Vb 8
\&   mb::b1 or mb::Left
\&   mb::b2 or mb::Middle
\&   mb::b3 or mb::Right
\&   mb::b4
\&   mb::b5
\&   mb::b6
\&   mb::b7
\&   mb::b8
.Ve
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "MouseDown \s-1BUTTON, MOD, X, Y\s0" 4
.IX Item "MouseDown BUTTON, MOD, X, Y"
Occurs when the user presses mouse button on a widget.
\&\s-1BUTTON\s0 is one of \f(CW\*(C`mb::XXX\*(C'\fR constants, \s-1MOD\s0 is a combination of 
\&\f(CW\*(C`km::XXX\*(C'\fR constants, reflecting the pressed modificator keys during the event,
X and Y are the mouse pointer coordinates.
.Sp
See also: \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "MouseEnter \s-1MOD, X, Y\s0" 4
.IX Item "MouseEnter MOD, X, Y"
Occurs when the mouse pointer is entered the area occupied by a widget
( without mouse button pressed ).
\&\s-1MOD\s0 is a combination of  \f(CW\*(C`km::XXX\*(C'\fR constants, reflecting 
the pressed modificator keys during the event,
X and Y are the mouse pointer coordinates.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "MouseLeave" 4
.IX Item "MouseLeave"
Occurs when the mouse pointer is driven off the area 
occupied by a widget ( without mouse button pressed ).
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR
.IP "MouseMove \s-1MOD, X, Y\s0" 4
.IX Item "MouseMove MOD, X, Y"
Occurs when the mouse pointer is transported over a widget.
\&\s-1MOD\s0 is a combination of  \f(CW\*(C`km::XXX\*(C'\fR constants, reflecting 
the pressed modificator keys during the event,
X and Y are the mouse pointer coordinates.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR,
\&\f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "MouseUp \s-1BUTTON, MOD, X, Y\s0" 4
.IX Item "MouseUp BUTTON, MOD, X, Y"
Occurs when the user depresses mouse button on a widget.
\&\s-1BUTTON\s0 is one of \f(CW\*(C`mb::XXX\*(C'\fR constants, \s-1MOD\s0 is a combination of 
\&\f(CW\*(C`km::XXX\*(C'\fR constants, reflecting the pressed modificator keys during the event,
X and Y are the mouse pointer coordinates.
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR, \f(CW\*(C`MouseWheel\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "MouseWheel \s-1MOD, X, Y, INCR\s0" 4
.IX Item "MouseWheel MOD, X, Y, INCR"
Occurs when the user rotates mouse wheel on a widget.  \s-1MOD\s0 is a combination of
\&\f(CW\*(C`km::XXX\*(C'\fR constants, reflecting the pressed modificator keys during the event,
\&\s-1INCR\s0 is the wheel movement, scaled by 120.  +120 is a step upwards, or \-120
downwards.  For wheels which are discrete button clicks \s-1INCR\s0 is +/\-120 but
other devices may give other amounts.  A widget should scroll by \s-1INCR/120\s0 many
units, or partial unit, for whatever its unit of movement might be, such as
lines of text, slider ticks, etc.
.Sp
A widget might like to vary its unit move according to the \s-1MOD\s0 keys.  For
example \f(CW\*(C`Prima::SpinEdit\*(C'\fR has a \f(CW\*(C`step\*(C'\fR and \f(CW\*(C`pageStep\*(C'\fR and moves by
\&\f(CW\*(C`pageStep\*(C'\fR when \f(CW\*(C`km::Ctrl\*(C'\fR is held down (see Prima::Sliders).
.Sp
See also: \f(CW\*(C`MouseDown\*(C'\fR, \f(CW\*(C`MouseUp\*(C'\fR, \f(CW\*(C`MouseClick\*(C'\fR,
\&\f(CW\*(C`MouseMove\*(C'\fR, \f(CW\*(C`MouseEnter\*(C'\fR, \f(CW\*(C`MouseLeave\*(C'\fR
.IP "Move \s-1OLD_X, OLD_Y, NEW_X, NEW_Y\s0" 4
.IX Item "Move OLD_X, OLD_Y, NEW_X, NEW_Y"
Triggered when widget changes its position relative to 
its parent, either by Prima::Widget methods or by the user.
\&\s-1OLD_X\s0 and \s-1OLD_Y\s0 are the old coordinates of
a widget, \s-1NEW_X\s0 and \s-1NEW_Y\s0 are the new ones.
.Sp
See also: \f(CW\*(C`Size\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`growMode\*(C'\fR, \f(CW\*(C`centered\*(C'\fR, \f(CW\*(C`clipOwner\*(C'\fR
.IP "Paint \s-1CANVAS\s0" 4
.IX Item "Paint CANVAS"
Caused when the system calls for the refresh of a graphic
context, associated with a widget. \s-1CANVAS\s0 is the widget itself,
however its usage instead of widget is recommended ( see
\&\*(L"Graphic content\*(R" ).
.Sp
See also: \f(CW\*(C`repaint\*(C'\fR, \f(CW\*(C`syncPaint\*(C'\fR, \f(CW\*(C`get_invalid_rect\*(C'\fR, \f(CW\*(C`scroll\*(C'\fR,
\&\f(CW\*(C`colorIndex\*(C'\fR, \f(CW\*(C`font\*(C'\fR
.IP "Popup \s-1BY_MOUSE, X, Y\s0" 4
.IX Item "Popup BY_MOUSE, X, Y"
Called by the system when the user presses a key or mouse
combination defined for a context pop-up menu execution.
By default executes the associated Prima::Popup object,
if it is present. If the event flag is cleared during the 
execution of callbacks, the pop-up menu is not shown.
.Sp
See also: \f(CW\*(C`popup\*(C'\fR
.IP "Setup" 4
.IX Item "Setup"
This message is posted right after \f(CW\*(C`Create\*(C'\fR notification,
and comes first from the event loop. Prima::Widget does not
use it.
.IP "Show" 4
.IX Item "Show"
Triggered by a successive \f(CWvisible(1)\fR call
.Sp
See also: \f(CW\*(C`Show\*(C'\fR, \f(CW\*(C`visible\*(C'\fR, \f(CW\*(C`showing\*(C'\fR, \f(CW\*(C`exposed\*(C'\fR
.IP "Size \s-1OLD_WIDTH, OLD_HEIGHT, NEW_WIDTH, NEW_HEIGHT\s0" 4
.IX Item "Size OLD_WIDTH, OLD_HEIGHT, NEW_WIDTH, NEW_HEIGHT"
Triggered when widget changes its size, 
either by Prima::Widget methods or by the user.
\&\s-1OLD_WIDTH\s0 and \s-1OLD_HEIGHT\s0 are the old extensions of
a widget, \s-1NEW_WIDTH\s0 and \s-1NEW_HEIGHT\s0 are the new ones.
.Sp
See also: \f(CW\*(C`Move\*(C'\fR, \f(CW\*(C`origin\*(C'\fR, \f(CW\*(C`size\*(C'\fR, \f(CW\*(C`growMode\*(C'\fR, 
\&\f(CW\*(C`sizeMax\*(C'\fR, \f(CW\*(C`sizeMin\*(C'\fR, \f(CW\*(C`rect\*(C'\fR, \f(CW\*(C`clipOwner\*(C'\fR
.IP "TranslateAccel \s-1CODE, KEY, MOD\s0" 4
.IX Item "TranslateAccel CODE, KEY, MOD"
A distributed \f(CW\*(C`KeyDown\*(C'\fR event. Traverses all the object
tree that the widget which received original \f(CW\*(C`KeyDown\*(C'\fR event 
belongs to. Once the event flag is cleared, the iteration stops.
.Sp
Used for tracking keyboard events by out-of-focus widgets.
.Sp
See also: \f(CW\*(C`KeyDown\*(C'\fR
.IP "ZOrderChanged" 4
.IX Item "ZOrderChanged"
Triggered when a widget changes its stacking order, or Z\-order
among its siblings, either by Prima::Widget methods or by the user.
.Sp
See also: \f(CW\*(C`bring_to_front\*(C'\fR, \f(CW\*(C`insert_behind\*(C'\fR, \f(CW\*(C`send_to_back\*(C'\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Object, Prima::Drawable.
