.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::Widget::pack 3"
.TH pod::Prima::Widget::pack 3 "2015-09-13" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::Widget::pack \- Geometry manager that packs around edges of cavity
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  $widget\-> pack( args);
\&
\&  $widget\-> packInfo( args);
\&  $widget\-> geometry( gt::Pack);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBpack\fR method is used to communicate with the packer,
a geometry manager that arranges the children of a owner by
packing them in order around the edges of the owner.
.PP
In this port of \fBTk::pack\fR it is normal to pack widgets one-at-a-time
using the widget object to be packed to invoke a method call.
This is a slight distortion of the original Tcl-Tk interface (which
can handle lists of windows to one pack method call) but Tk reports
that it has proven effective in practice.
.PP
The \fBpack\fR method can have any of several forms, depending
on \fIOption\fR:
.ie n .IP "pack %OPTIONS" 4
.el .IP "pack \f(CW%OPTIONS\fR" 4
.IX Item "pack %OPTIONS"
The options consist of pairs of arguments that specify how
to manage the slave.
See \*(L"The packer algorithm\*(R" below for details on how the options
are used by the packer.
The following options are supported:
.RS 4
.ie n .IP "\fBafter\fR => \fI\fI$other\fI\fR" 8
.el .IP "\fBafter\fR => \fI\f(CI$other\fI\fR" 8
.IX Item "after => $other"
\&\fI\f(CI$other\fI\fR must be another window.
Use its master as the master for the slave, and insert
the slave just after \fI\f(CI$other\fI\fR in the packing order.
.IP "\fBanchor\fR => \fIanchor\fR" 8
.IX Item "anchor => anchor"
\&\fIAnchor\fR must be a valid anchor position such as \fBn\fR
or \fBsw\fR; it specifies where to position each slave in its
parcel.
Defaults to \fBcenter\fR.
.ie n .IP "\fBbefore\fR => \fI\fI$other\fI\fR" 8
.el .IP "\fBbefore\fR => \fI\f(CI$other\fI\fR" 8
.IX Item "before => $other"
\&\fI\f(CI$other\fI\fR must be another window.
Use its master as the master for the slave, and insert
the slave just before \fI\f(CI$other\fI\fR in the packing order.
.IP "\fBexpand\fR => \fIboolean\fR" 8
.IX Item "expand => boolean"
Specifies whether the slave should be expanded to consume
extra space in their master.
\&\fIBoolean\fR may have any proper boolean value, such as \fB1\fR
or \fBno\fR.
Defaults to 0.
.IP "\fBfill\fR => \fIstyle\fR" 8
.IX Item "fill => style"
If a slave's parcel is larger than its requested dimensions, this
option may be used to stretch the slave.
\&\fIStyle\fR must have one of the following values:
.RS 8
.IP "\fBnone\fR" 12
.IX Item "none"
Give the slave its requested dimensions plus any internal padding
requested with \fB\-ipadx\fR or \fB\-ipady\fR.  This is the default.
.IP "\fBx\fR" 12
.IX Item "x"
Stretch the slave horizontally to fill the entire width of its
parcel (except leave external padding as specified by \fB\-padx\fR).
.IP "\fBy\fR" 12
.IX Item "y"
Stretch the slave vertically to fill the entire height of its
parcel (except leave external padding as specified by \fB\-pady\fR).
.IP "\fBboth\fR" 12
.IX Item "both"
Stretch the slave both horizontally and vertically.
.RE
.RS 8
.RE
.ie n .IP "\fBin\fR => \fI\fI$master\fI\fR" 8
.el .IP "\fBin\fR => \fI\f(CI$master\fI\fR" 8
.IX Item "in => $master"
Insert the slave(s) at the end of the packing order for the master
window given by \fI\f(CI$master\fI\fR. Currently, only the immediate owner
can be accepted as master.
.IP "\fBipad\fR => \fIamount\fR" 8
.IX Item "ipad => amount"
\&\fIAmount\fR specifies how much both horizontal and vertical internal padding to
leave on each side of the slave(s).
\&\fIAmount\fR must be a valid screen distance, such as \fB2\fR or \fB.5c\fR.
It defaults to 0.
.IP "\fBipadx\fR => \fIamount\fR" 8
.IX Item "ipadx => amount"
\&\fIAmount\fR specifies how much horizontal internal padding to
leave on each side of the slave(s).
\&\fIAmount\fR must be a valid screen distance, such as \fB2\fR or \fB.5c\fR.
It defaults to 0.
.IP "\fBipady\fR => \fIamount\fR" 8
.IX Item "ipady => amount"
\&\fIAmount\fR specifies how much vertical internal padding to
leave on each side of the slave(s).
\&\fIAmount\fR  defaults to 0.
.IP "\fBpad\fR => \fIamount\fR" 8
.IX Item "pad => amount"
\&\fIAmount\fR specifies how much horizontal and vertical external padding to
leave on each side of the slave(s).
\&\fIAmount\fR defaults to 0.
.IP "\fBpadx\fR => \fIamount\fR" 8
.IX Item "padx => amount"
\&\fIAmount\fR specifies how much horizontal external padding to
leave on each side of the slave(s).
\&\fIAmount\fR defaults to 0.
.IP "\fBpady\fR => \fIamount\fR" 8
.IX Item "pady => amount"
\&\fIAmount\fR specifies how much vertical external padding to
leave on each side of the slave(s).
\&\fIAmount\fR defaults to 0.
.IP "\fBside\fR => \fIside\fR" 8
.IX Item "side => side"
Specifies which side of the master the slave(s) will be packed against.
Must be \fBleft\fR, \fBright\fR, \fBtop\fR, or \fBbottom\fR.
Defaults to \fBtop\fR.
.RE
.RS 4
.RE
.PP
If no \fBin\fR, \fBafter\fR or \fBbefore\fR option is specified
then slave will be inserted at the end of the packing list
for its owner unless it is already managed by the packer (in which
case it will be left where it is).
If one of these options is specified then slave will be
inserted at the specified point.
If the slave are already managed by the geometry manager
then any unspecified options for them retain their previous values rather
than receiving default values.
.IP "packForget" 4
.IX Item "packForget"
Removes \fIslave\fR from the packing order for its
master and unmaps its window.
The slave will no longer be managed by the packer.
.ie n .IP "packInfo [ %OPTIONS ]" 4
.el .IP "packInfo [ \f(CW%OPTIONS\fR ]" 4
.IX Item "packInfo [ %OPTIONS ]"
In get-mode, returns a list whose elements are the current configuration state of
the slave given by \fI\f(CI$slave\fI\fR.
The first two elements of the list are ``\fBin\fR=>\fI\f(CI$master\fI\fR'' where
\&\fI\f(CI$master\fI\fR is the slave's master.
.Sp
In set-mode, sets all \fBpack\fR parameters, but does not set
widget geometry property to \f(CW\*(C`gt::Pack\*(C'\fR.
.IP "packPropagate \s-1BOOLEAN\s0" 4
.IX Item "packPropagate BOOLEAN"
If \fIboolean\fR has a true boolean value 
then propagation is enabled for \fI\f(CI$master\fI\fR,
(see \*(L"Geometry propagation\*(R" below).
If \fIboolean\fR has a false boolean value then propagation is
disabled for \fI\f(CI$master\fI\fR.
If \fIboolean\fR is omitted then the method returns \fB0\fR or
\&\fB1\fR to indicate whether propagation is currently enabled
for \fI\f(CI$master\fI\fR.
.Sp
Propagation is enabled by default.
.IP "packSlaves" 4
.IX Item "packSlaves"
Returns a list of all of the slaves in the packing order for \fI\f(CI$master\fI\fR.
The order of the slaves in the list is the same as their order in
the packing order.
If \fI\f(CI$master\fI\fR has no slaves then an empty list/string is returned in
array/scalar context, respectively
.SH "The packer algorithm"
.IX Header "The packer algorithm"
For each master the packer maintains an ordered list of slaves
called the \fIpacking list\fR.
The \fBin\fR, \fBafter\fR, and \fBbefore\fR configuration
options are used to specify the master for each slave and the slave's
position in the packing list.
If none of these options is given for a slave then the slave
is added to the end of the packing list for its owner.
.PP
The packer arranges the slaves for a master by scanning the
packing list in order.
At the time it processes each slave, a rectangular area within
the master is still unallocated.
This area is called the \fIcavity\fR;  for the first slave it
is the entire area of the master.
.PP
For each slave the packer carries out the following steps:
.IP "\(bu" 4
The packer allocates a rectangular \fIparcel\fR for the slave
along the side of the cavity given by the slave's \fBside\fR option.
If the side is top or bottom then the width of the parcel is
the width of the cavity and its height is the requested height
of the slave plus the \fBipady\fR and \fBpady\fR options.
For the left or right side the height of the parcel is
the height of the cavity and the width is the requested width
of the slave plus the \fBipadx\fR and \fBpadx\fR options.
The parcel may be enlarged further because of the \fBexpand\fR
option (see \*(L"Expansion\*(R" below)
.IP "\(bu" 4
The packer chooses the dimensions of the slave.
The width will normally be the slave's requested width plus
twice its \fBipadx\fR option and the height will normally be
the slave's requested height plus twice its \fBipady\fR
option.
However, if the \fBfill\fR option is \fBx\fR or \fBboth\fR
then the width of the slave is expanded to fill the width of the parcel,
minus twice the \fBpadx\fR option.
If the \fBfill\fR option is \fBy\fR or \fBboth\fR
then the height of the slave is expanded to fill the width of the parcel,
minus twice the \fBpady\fR option.
.IP "\(bu" 4
The packer positions the slave over its parcel.
If the slave is smaller than the parcel then the \fB\-anchor\fR
option determines where in the parcel the slave will be placed.
If \fBpadx\fR or \fBpady\fR is non-zero, then the given
amount of external padding will always be left between the
slave and the edges of the parcel.
.Sp
Once a given slave has been packed, the area of its parcel
is subtracted from the cavity, leaving a smaller rectangular
cavity for the next slave.
If a slave doesn't use all of its parcel, the unused space
in the parcel will not be used by subsequent slaves.
If the cavity should become too small to meet the needs of
a slave then the slave will be given whatever space is
left in the cavity.
If the cavity shrinks to zero size, then all remaining slaves
on the packing list will be unmapped from the screen until
the master window becomes large enough to hold them again.
.SH "Expansion"
.IX Header "Expansion"
If a master window is so large that there will be extra space
left over after all of its slaves have been packed, then the
extra space is distributed uniformly among all of the slaves
for which the \fBexpand\fR option is set.
Extra horizontal space is distributed among the expandable
slaves whose \fBside\fR is \fBleft\fR or \fBright\fR,
and extra vertical space is distributed among the expandable
slaves whose \fBside\fR is \fBtop\fR or \fBbottom\fR.
.SH "Geometry propagation"
.IX Header "Geometry propagation"
The packer normally computes how large a master must be to
just exactly meet the needs of its slaves, and it sets the
requested width and height of the master to these dimensions.
This causes geometry information to propagate up through a
window hierarchy to a top-level window so that the entire
sub-tree sizes itself to fit the needs of the leaf windows.
However, the \fBgeometryPropagate\fR method may be used to
turn off propagation for one or more masters.
If propagation is disabled then the packer will not set
the requested width and height of the packer.
This may be useful if, for example, you wish for a master
window to have a fixed size that you specify.
.SH "Restrictions on master windows"
.IX Header "Restrictions on master windows"
The master for each slave must not be a child of the slave,
and must not be present in any other list of slaves that
directly or indirectly refers to the slave.
.SH "Packing order"
.IX Header "Packing order"
If the master for a slave is not its owner then you must make sure
that the slave is higher in the stacking order than the master.
Otherwise the master will obscure the slave and it will appear as
if the slave hasn't been packed correctly.
The easiest way to make sure the slave is higher than the master is
to create the master window first:  the most recently created window
will be highest in the stacking order.
Or, you can use the \fBbring_to_front\fR and \fBsend_to_back\fR methods to change
the stacking order of either the master or the slave.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Widget
.PP
Tk::pack
Tk::place
