.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::Widget::place 3"
.TH pod::Prima::Widget::place 3 "2011-05-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::Widget::place \- Geometry manager for fixed or rubber\-sheet placement
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   $widget\->place(option=>value?, option=>value, ...)
\&
\&   $widget\->placeForget;
\&
\&   $widget\->placeInfo(option=>value?, option=>value, ...);
\&   $widget\->geometry( gt::Place);
\&
\&   $master\->placeSlaves
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The placer is a geometry manager from Tk.
It provides simple fixed placement of windows, where you specify
the exact size and location of one window, called the \fIslave\fR,
within another window, called the \fI\f(CI$master\fI\fR.
The placer also provides rubber-sheet placement, where you specify the
size and location of the slave in terms of the dimensions of
the master, so that the slave changes size and location
in response to changes in the size of the master.
Lastly, the placer allows you to mix these styles of placement so
that, for example, the slave has a fixed width and height but is
centered inside the master.
.ie n .IP "place %OPTIONS" 4
.el .IP "place \f(CW%OPTIONS\fR" 4
.IX Item "place %OPTIONS"
The \fBplace\fR method arranges for the placer
to manage the geometry of \fI\f(CI$slave\fI\fR.
The remaining arguments consist of one or more \fIoption\fR=>\fIvalue\fR
pairs that specify the way in which \fI\f(CI$slave\fI\fR's
geometry is managed.
If the placer is already managing \fI\f(CI$slave\fI\fR, then the
\&\fIoption\fR=>\fIvalue\fR pairs modify the configuration for \fI\f(CI$slave\fI\fR.
The \fBplace\fR method returns an empty string as result.
The following \fIoption\fR=>\fIvalue\fR pairs are supported:
.RS 4
.ie n .IP "\fBin\fR => \fI\fI$master\fI\fR" 8
.el .IP "\fBin\fR => \fI\f(CI$master\fI\fR" 8
.IX Item "in => $master"
\&\fI\f(CI$master\fI\fR is the reference to the window relative
to which \fI\f(CI$slave\fI\fR is to be placed. 
\&\fI\f(CI$master\fI\fR must neither be \fI\f(CI$slave\fI\fR's child nor be present
in a slaves list that directly or indirectly refers to the \fI\f(CI$slave\fI\fR.
.Sp
If this option isn't specified then the master defaults to
\&\fI\f(CI$slave\fI\fR's owner.
.IP "\fBx\fR => \fIlocation\fR" 8
.IX Item "x => location"
\&\fILocation\fR specifies the x\-coordinate within the master window
of the anchor point for \fI\f(CI$slave\fI\fR widget.
.IP "\fBrelx\fR => \fIlocation\fR" 8
.IX Item "relx => location"
\&\fILocation\fR specifies the x\-coordinate within the master window
of the anchor point for \fI\f(CI$slave\fI\fR widget.
In this case the location is specified in a relative fashion
as a floating-point number:  0.0 corresponds to the left edge
of the master and 1.0 corresponds to the right edge of the master.
\&\fILocation\fR need not be in the range 0.0\-1.0.
If both \fBx\fR and \fBrelx\fR are specified for a slave
then their values are summed.  For example, "\fBrelx\fR=>0.5, \fBx\fR=\-2"
positions the left edge of the slave 2 pixels to the left of the
center of its master.
.IP "\fBy\fR => \fIlocation\fR" 8
.IX Item "y => location"
\&\fILocation\fR specifies the y\-coordinate within the master window
of the anchor point for \fI\f(CI$slave\fI\fR widget.
.IP "\fBrely\fR => \fIlocation\fR" 8
.IX Item "rely => location"
\&\fILocation\fR specifies the y\-coordinate within the master window
of the anchor point for \fI\f(CI$slave\fI\fR widget.
In this case the value is specified in a relative fashion
as a floating-point number:  0.0 corresponds to the top edge
of the master and 1.0 corresponds to the bottom edge of the master.
\&\fILocation\fR need not be in the range 0.0\-1.0.
If both \fBy\fR and \fBrely\fR are specified for a slave
then their values are summed.  For example, \fBrely\fR=>0.5, \fBx\fR=>3
positions the top edge of the slave 3 pixels below the
center of its master.
.IP "\fBanchor\fR => \fIwhere\fR" 8
.IX Item "anchor => where"
\&\fIWhere\fR specifies which point of \fI\f(CI$slave\fI\fR is to be positioned
at the (x,y) location selected by the \fBx\fR, \fBy\fR,
\&\fBrelx\fR, and \fBrely\fR options.
Thus if \fIwhere\fR is \fBse\fR then the lower-right corner of
\&\fI\f(CI$slave\fI\fR's border will appear at the given (x,y) location
in the master.
The anchor position defaults to \fBnw\fR.
.IP "\fBwidth\fR => \fIsize\fR" 8
.IX Item "width => size"
\&\fISize\fR specifies the width for \fI\f(CI$slave\fI\fR.
If \fIsize\fR is an empty string, or if no \fBwidth\fR
or \fBrelwidth\fR option is specified, then the width requested
internally by the window will be used.
.IP "\fBrelwidth\fR => \fIsize\fR" 8
.IX Item "relwidth => size"
\&\fISize\fR specifies the width for \fI\f(CI$slave\fI\fR.
In this case the width is specified as a floating-point number
relative to the width of the master: 0.5 means \fI\f(CI$slave\fI\fR will
be half as wide as the master, 1.0 means \fI\f(CI$slave\fI\fR will have
the same width as the master, and so on.
If both \fBwidth\fR and \fBrelwidth\fR are specified for a slave,
their values are summed.  For example, \fBrelwidth\fR=>1.0, \fBwidth\fR=>5
makes the slave 5 pixels wider than the master.
.IP "\fBheight\fR => \fIsize\fR" 8
.IX Item "height => size"
\&\fISize\fR specifies the height for \fI\f(CI$slave\fI\fR.
If \fIsize\fR is an empty string, or if no \fBheight\fR or
\&\fBrelheight\fR option is specified, then the height requested
internally by the window will be used.
.IP "\fBrelheight\fR => \fIsize\fR" 8
.IX Item "relheight => size"
\&\fISize\fR specifies the height for \fI\f(CI$slave\fI\fR.
In this case the height is specified as a floating-point number
relative to the height of the master: 0.5 means \fI\f(CI$slave\fI\fR will
be half as high as the master, 1.0 means \fI\f(CI$slave\fI\fR will have
the same height as the master, and so on.
If both \fBheight\fR and \fBrelheight\fR are specified for a slave,
their values are summed.  For example, \fBrelheight\fR=>1.0, \fBheight\fR=>\-2
makes the slave 2 pixels shorter than the master.
.RE
.RS 4
.RE
.IP "placeSlaves" 4
.IX Item "placeSlaves"
The \fBplaceSlaves\fR method returns a list of all the slave
windows for which \fI\f(CI$master\fI\fR is the master.
If there are no slaves for \fI\f(CI$master\fI\fR then an empty list is
returned.
.IP "placeForget" 4
.IX Item "placeForget"
The \fBplaceForget\fR method causes the placer to stop managing
the geometry of \fI\f(CI$slave\fI\fR.  
If \fI\f(CI$slave\fI\fR isn't currently managed by the placer then the
method call has no effect.
.ie n .IP "placeInfo %OPTIONS" 4
.el .IP "placeInfo \f(CW%OPTIONS\fR" 4
.IX Item "placeInfo %OPTIONS"
In get-mode the \fBplaceInfo\fR method returns a list giving the current
configuration of \fI\f(CI$slave\fI\fR.
The list consists of \fIoption\fR=>\fIvalue\fR pairs in exactly the
same form as might be specified to the \fBplace\fR
method. 
If the configuration of a window has been retrieved with
\&\fBplaceInfo\fR, that configuration can be restored later by
first using \fBplaceInfo\fR in set-mode and setting \fBgeometry\fR
to \f(CW\*(C`gt::Place\*(C'\fR, which is equivalent to a direct call to \fBplace\fR.
.SH "Fine points"
.IX Header "Fine points"
It is not necessary for the master window to be the owner
of the slave window.
This feature is useful in at least two situations.
First, for complex window layouts it means you can create a
hierarchy of subwindows whose only purpose
is to assist in the layout of the owner.
The ``\fIreal children\fR'' of the owner (i.e. the windows that
are significant for the application's user interface) can be
children of the owner yet be placed inside the windows
of the geometry-management hierarchy.
This means that the path names of the ``\fIreal children\fR''
don't reflect the geometry-management hierarchy and users
can specify options for the real children
without being aware of the structure of the geometry-management
hierarchy.
.PP
A second reason for having a master different than the slave's
owner is to tie two siblings together.
For example, the placer can be used to force a window always to
be positioned centered just below one of its
siblings by specifying the configuration
.PP
\&\ \ \ \ \fBin\fR=>\fI\f(CI$sibling\fI\fR, \fBrelx\fR=>0.5, \fBrely\fR=>1.0,
\&\fBanchor\fR=>'n'
.PP
Whenever the \fI\f(CI$sibling\fI\fR widget is repositioned in the future, the slave
will be repositioned as well.
.PP
Unlike the other geometry managers (such as the packer)
the placer does not make any attempt to manipulate the geometry of
the master windows or the owners of slave windows (i.e. it doesn't
set their requested sizes).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Widget
.PP
Tk::place
Tk::pack
