.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::Window 3"
.TH pod::Prima::Window 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::Window \- top\-level window management
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Prima;
\&   use Prima::Application;
\&
\&   # this window, when closed, terminated the application
\&   my $main = Prima::MainWindow\-> new( text => \*(AqHello world\*(Aq );
\&
\&   # this is a modal window
\&   my $dialog = Prima::Dialog\->create( size => [ 100, 100 ]);
\&   my $result = $dialog\-> execute;
\&   $dialog\-> destroy;
\&
\&   run Prima;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Prima::Window is a descendant of Prima::Widget class.
It deals with top-level windows, the windows that
are specially treated by the system. Its major
difference from Prima::Widget is that instances of
Prima::Window can only be inferior by the
screen, not the other windows, and that the system or window manager add
decorations to these \- usually menus, buttons and title 
bars. Prima::Window provides methods that communicate
with the system and hint these decorations.
.SH "USAGE"
.IX Header "USAGE"
A typical program communicates with the user with aid
of widgets, collected upon one or more top-level windows.
Prima::Widget already has all functionality required for
these child-parent operations, so Prima::Window is not
special in respect of widget grouping and relationship.
Its usage therefore is straightforward:
.PP
.Vb 4
\&   my $w = Prima::Window\-> create( 
\&       size => [300,300],
\&       text => \*(AqStartup window\*(Aq,
\&   );
.Ve
.PP
There are more about Prima::Window in areas, that it is
specifically designed to \- the system window management and
the dialog execution.
.SS "System window management"
.IX Subsection "System window management"
As noted before, top-level windows are special for the system,
not only in their 'look', but also in 'feel': the system adds
specific functions to the windows, aiding the user to navigate through
the desktop. The system ofter dictates the size and position for
windows, and some times these rules are hard or even impossible to 
circumvent. This document will be long if it would venture to describe the features
of different window management systems, and the task would be 
never accomplished \- brand new window managers emerge every month,
and the old change their behavior in an unpredictable way. The only
golden rule is to never rely on the behavior of one window manager,
and test programs with at least two.
.PP
The Prima toolkit provides simple access to buttons, title bar
and borders of a window. Buttons and title bar are managed by
the \f(CW\*(C`::borderIcons\*(C'\fR property, and borders by the \f(CW\*(C`::borderStyle\*(C'\fR 
property. These operate with set of predefined constants, \f(CW\*(C`bi::XXX\*(C'\fR
and \f(CW\*(C`bs::XXX\*(C'\fR, correspondingly. The button constants can be combined with
each other, but not all combinations may be granted by the system.
The same is valid also for the border constant, except that they can
not be combined \- the value of \f(CW\*(C`::borderStyle\*(C'\fR is one of the integer constants.
.PP
There are other hints that the toolkit can set for a window manager.
The system can be supplied with an icon that a window is bound to; the icon
dimensions are much different, and although can be requested via
\&\f(CW\*(C`sv::XIcon\*(C'\fR and \f(CW\*(C`sv::YIcon\*(C'\fR system values, the \f(CW\*(C`::icon\*(C'\fR property
scales the image automatically to the closest system-recognizable
dimension. The window icon is not shown by the toolkit, it is usually
resides in the window decorations and sometimes on a task bar, along
with the window's name. The system can be hinted to not reflect the window
on the task bar, by setting the \f(CW\*(C`::taskListed\*(C'\fR property to 0.
.PP
Another issue is the window positioning. Usually, if no explicit
position was given, the window is positioned automatically
by the system. The same is valid for the size.  But some window
managers bend it to the extreme \- for example, default \s-1CDE\s0
setup force the user to set newly created windows' positions explicitly.
However, there is at least one point of certainty.
Typically, when the initial size and/or position of a top-level window 
are expected to be set by the system, the \f(CW\*(C`::originDontCare\*(C'\fR and
\&\f(CW\*(C`::sizeDontCare\*(C'\fR properties can be set to 1 during window creation.
If these set, the system is asked to size/position a window regarding
its own windowing policy. The reverse is not always true, unfortunately.
Either if these properties set to 0, or explicit size or positions are given,
the system is hinted to use these values instead, but this does not
always happen. Actually, this behavior is expected by the user and often does
not get even noticed as something special. Therefore it is a good practice to test
a top-level windowing code with several window managers.
.PP
There are different policies about window positioning and sizing; 
some window managers behave best when the position is given to the window
with the system-dependent decorations. It is hardly can be called a good
policy, since it is not possible to calculate the derived window coordinates
with certainty. This problem results in that it is impossible to
be sure about window position and size before these are set explicitly.
The only, not much efficient help the toolkit can provide is the property
pair \f(CW\*(C`::frameOrigin\*(C'\fR and \f(CW\*(C`::frameSize\*(C'\fR, which along with \f(CW\*(C`::origin\*(C'\fR
and \f(CW\*(C`::size\*(C'\fR reflect the position and size of a window, but taking into
account the system-dependent decorations.
.SS "Dialog execution"
.IX Subsection "Dialog execution"
Method of Prima::Window, \f(CW\*(C`execute()\*(C'\fR brings a window
in a modal state on top of other toolkit windows, and
returns after the window is dismissed in one or another way.
This method is special as it is an implicit event loop,
similar to
.PP
.Vb 1
\&  run Prima;
.Ve
.PP
code. The event flow is not disrupted, but the windows and
widgets that do not belong to the currently executed, the
\&'modal' window group can not be activated. There can be many
modal windows on top of each other, but only one is accessible.
As an example a message box can be depicted, a window that prevents
the user to work with the application windows until dismissed.
There can be other message boxes on top of each other, preventing
the windows below from operation as well.
This scheme is called the 'exclusive' modality.
.PP
The toolkit also provides the shared modality scheme, where
there can be several stacks of modal windows, not interfering
with each other. Each window stack is distinct and contains its own windows.
An example analogy is when several independent applications run with 
modal message boxes being activated. This scheme, however, can not be achieved
with single \fIexecute()\fR\-like call without creating interlocking
conditions. The shared model call, \f(CW\*(C`execute_shared()\*(C'\fR,
inserts the window into the shared modal stack, activates the window and returns immediately.
.PP
The both kinds of modal windows can coexist, but the exclusive
windows prevents the shared from operation; while there are
exclusive windows, the shared have same rights as the usual windows.
.PP
The stacking order for these two models is slightly different.  A window after
\&\fIexecute()\fR call is set on top of the last exclusive modal window, or, in other
words, is added to the exclusive window stack. There can be only one exclusive
window stack, but many shared window stacks; a window after \fIexecute_shared()\fR
call is added to a shared window stack, to the one the window's owner belongs
to. The shared window stacks are rooted in so-called modal horizons, windows
with boolean property \f(CW\*(C`::modalHorizon\*(C'\fR set to \f(CW\*(C`true\*(C'\fR. The default horizon is
\&\f(CW\*(C`::application\*(C'\fR.
.PP
A window in modal state can return to the normal (non-modal) state by calling
\&\f(CW\*(C`end_modal()\*(C'\fR method. The window is then hidden and disabled, and the windows
below are accessible to the user. If the window was in the exclusive modal
state, the \fIexecute()\fR call is finished and returns the exit code, the value of
\&\f(CW\*(C`::modalResult\*(C'\fR property. There two shortuct methods that end modal state,
setting \f(CW\*(C`::modalResult\*(C'\fR to the basic 'ok' and 'not ok' code, correspondingly
\&\f(CW\*(C`ok()\*(C'\fR and \f(CW\*(C`cancel()\*(C'\fR methods. Behavior of \f(CW\*(C`cancel()\*(C'\fR is identical to when
the user closes the modal window by clicking the system close button, pressing
Escape key, or otherwise cancelling the dialog execution. \f(CW\*(C`ok()\*(C'\fR sets
\&\f(CW\*(C`::modalResult\*(C'\fR to \f(CW\*(C`mb::OK\*(C'\fR, \f(CW\*(C`cancel()\*(C'\fR to \f(CW\*(C`mb::Cancel\*(C'\fR, correspondingly.
There are more \f(CW\*(C`mb::XXX\*(C'\fR constants, but these have no special meaning, any
integer value can be passed. For example, \f(CW\*(C`Prima::MsgBox::message\*(C'\fR method uses
these constants so the message window can return up to four different \f(CW\*(C`mb\*(C'\fR
codes.
.SS "Menu"
.IX Subsection "Menu"
A top-level window can be equipped with a menu bar. Its outlook
is system-dependent, but can be controlled by the toolkit up to
a certain level. The \f(CW\*(C`::menuItems\*(C'\fR property, that manages the menu items
of a \f(CW\*(C`::menu\*(C'\fR object of Prima::Menu class, arrange the layout
of the menu. The syntax of the items-derived properties is described in
Prima::Menu, but it must be reiterated that menu items contain only
hints, not requests for their exact representation. The same is valid for
the color and font properties, \f(CW\*(C`::menuColorIndex\*(C'\fR and \f(CW\*(C`::menuFont\*(C'\fR.
.PP
Only one menu at a time can be displayed in a top-level window, although
a window can be an owner for many menu objects. The key property is
\&\f(CW\*(C`Prima::Menu::selected\*(C'\fR \- if a menu object is selected on a widget
or a window object, it refers to the default menu actions, which, in
case of Prima::Window is being displayed as menu bar.
.PP
\&\s-1NB: A\s0 window can be an owner for several menu objects and still do not
have a menu bar displayed, if no menu objects are marked as selected.
.SS "Prima::Dialog"
.IX Subsection "Prima::Dialog"
Prima::Dialog, a descendant from Prima::Window, introduces no
new functionality. It has its default values adjusted so
the colors use more appropriate system colors, and hints
the system that the outlook of a window is to be different,
to resemble the system dialogs on systems where such are
provided.
.SS "Prima::MainWindow"
.IX Subsection "Prima::MainWindow"
The class is a simple descendant of Prima::Window, which overloads
\&\f(CW\*(C`on_destroy\*(C'\fR notification and calls \f(CW\*(C`$application\->close\*(C'\fR inside it. The
purpose of declaration of a separate class for such a trifle difference is that
many programs are designed under a paradigm where these is a main window, which
is most 'important' to the user. As such the construct is used more often than
any other, it is considered an optimization to write
.PP
.Vb 1
\&   Prima::MainWindow\-> create( ... )
.Ve
.PP
rather than
.PP
.Vb 4
\&   Prima::Window\-> create( ..., 
\&      mainWindow => 1,
\&      onDestroy  => sub { $::application\-> close }
\&   )
.Ve
.PP
, although these lines are equivalent.
.PP
Also, the \f(CW$::main_window\fR is pointed to a newly created main window.
.PP
See also \f(CW\*(C`mainWindow\*(C'\fR.
.SH "API"
.IX Header "API"
.SS "Properties"
.IX Subsection "Properties"
.IP "borderIcons \s-1INTEGER \s0" 4
.IX Item "borderIcons INTEGER "
Hints the system about window's decorations, by
selecting the combination of \f(CW\*(C`bi::XXX\*(C'\fR constants.
The constants are:
.Sp
.Vb 6
\&   bi::SystemMenu  \- system menu button and/or close button 
\&                     ( usually with icon ) is shown
\&   bi::Minimize    \- minimize button 
\&   bi::Maximize    \- maximize ( and eventual restore )
\&   bi::TitleBar    \- window title 
\&   bi::All         \- all of the above
.Ve
.Sp
Not all systems respect these hints, and many systems
provide more navigating decoration controls than these.
.IP "borderStyle \s-1STYLE  \s0" 4
.IX Item "borderStyle STYLE "
Hints the system about window's border style, by selecting
one of \f(CW\*(C`bs::XXX\*(C'\fR constants. The constants are:
.Sp
.Vb 4
\&   bs::None      \- no border
\&   bs::Single    \- thin border
\&   bs::Dialog    \- thick border
\&   bs::Sizeable  \- thick border with interactive resize capabilities
.Ve
.Sp
\&\f(CW\*(C`bs::Sizeable\*(C'\fR is an unique window mode. If selected, the user
can resize the window, not only by dragging the window borders with
the mouse but by other system-dependent means. The other border styles
disallow interactive resizing.
.Sp
Not all systems recognize all these hints, although many recognize
interactive resizing flag.
.IP "frameHeight \s-1HEIGHT\s0" 4
.IX Item "frameHeight HEIGHT"
Maintains the height of a window, including 
the window decorations.
.IP "frameOrigin X_OFFSET, Y_OFFSET" 4
.IX Item "frameOrigin X_OFFSET, Y_OFFSET"
Maintains the left X and bottom Y boundaries of a window's
decorations relative to the screen.
.IP "frameSize \s-1WIDTH, HEIGHT\s0" 4
.IX Item "frameSize WIDTH, HEIGHT"
Maintains the width and height of a window, including 
the window decorations.
.IP "frameWidth \s-1WIDTH\s0" 4
.IX Item "frameWidth WIDTH"
Maintains the width of a window, including 
the window decorations.
.IP "icon \s-1OBJECT\s0" 4
.IX Item "icon OBJECT"
Hints the system about an icon, associated with a window.
If \s-1OBJECT\s0 is \f(CW\*(C`undef\*(C'\fR, the system-default icon is assumed.
.Sp
See also: \f(CW\*(C`ownerIcon\*(C'\fR
.IP "mainWindow \s-1BOOLEAN\s0" 4
.IX Item "mainWindow BOOLEAN"
Tells the system that the window is the main window for the application.  When
dialogs and modal windows are not anchored to any specific window, the main
window is used. In this context, anchoring means that if, for example, a window
spawns a dialog, and then is minimized or obscured, and then the user clicks on
either window, both can be brought forward (also in correct Z\-order) by the system
window manager.
.IP "menu \s-1OBJECT\s0" 4
.IX Item "menu OBJECT"
Manages a Prima::Menu object associated with a window. 
Prima::Window can host many Prima::Menu objects,
but only the one that is set in
\&\f(CW\*(C`::menu\*(C'\fR property will be seen as a menu bar.
.Sp
See also: \f(CW\*(C`Prima::Menu\*(C'\fR, \f(CW\*(C`menuItems\*(C'\fR
.IP "menuColorIndex \s-1INDEX, COLOR\s0" 4
.IX Item "menuColorIndex INDEX, COLOR"
Maintains eight color properties of a menu,
associated with a window. \s-1INDEX\s0 must be one of \f(CW\*(C`ci::XXX\*(C'\fR constants
( see Prima::Widget, \fIcolorIndex\fR section ).
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuColor \s-1COLOR\s0" 4
.IX Item "menuColor COLOR"
Basic foreground menu color.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuBackColor \s-1COLOR\s0" 4
.IX Item "menuBackColor COLOR"
Basic background menu color.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuDark3DColor \s-1COLOR\s0" 4
.IX Item "menuDark3DColor COLOR"
Color for drawing dark shadings in menus.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuDisabledColor \s-1COLOR\s0" 4
.IX Item "menuDisabledColor COLOR"
Foreground color for disabled items in menus.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuDisabledBackColor \s-1COLOR\s0" 4
.IX Item "menuDisabledBackColor COLOR"
Background color for disabled items in menus.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.ie n .IP "menuFont %FONT" 4
.el .IP "menuFont \f(CW%FONT\fR" 4
.IX Item "menuFont %FONT"
Maintains the font of a menu, associated with a window.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuHiliteColor \s-1COLOR\s0" 4
.IX Item "menuHiliteColor COLOR"
Foreground color for selected items in menus.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuHiliteBackColor \s-1COLOR\s0" 4
.IX Item "menuHiliteBackColor COLOR"
Background color for selected items in menus.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "menuItems [ \s-1ITEM_LIST \s0]" 4
.IX Item "menuItems [ ITEM_LIST ]"
Manages items of a Prima::Menu object associated with a window.
The \s-1ITEM_LIST\s0 format is same as \f(CW\*(C`Prima::AbstractMenu::items\*(C'\fR
and is described in Prima::Menu.
.Sp
See also: \f(CW\*(C`menu\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR
.IP "menuLight3DColor \s-1COLOR\s0" 4
.IX Item "menuLight3DColor COLOR"
Color for drawing light shadings in menus.
.Sp
See also: \f(CW\*(C`menuItems\*(C'\fR, \f(CW\*(C`menuColorIndex\*(C'\fR, \f(CW\*(C`menuFont\*(C'\fR, \f(CW\*(C`menu\*(C'\fR
.IP "modalHorizon \s-1BOOLEAN\s0" 4
.IX Item "modalHorizon BOOLEAN"
Reflects if a window serves as root to the shared modal window stack.  A window
with \f(CW\*(C`::modalHorizon\*(C'\fR set to 1 in shared modal state groups its children
windows in a window stack, separate from other shared modal stacks. The
\&\f(CW\*(C`::modalHorizon\*(C'\fR is therefore useful only when several shared modal window
stacks are needed.
.Sp
The property also serves as an additional grouping factor for widgets and
windows. For example, default keyboard navigation by tab and arrow keys is
limited to the windows and widgets of a single window stack.
.IP "modalResult \s-1INTEGER\s0" 4
.IX Item "modalResult INTEGER"
Maintains a custom integer value, returned by \f(CW\*(C`execute()\*(C'\fR.
Historically it is one of \f(CW\*(C`mb::XXX\*(C'\fR constants, but any 
integer value can be used. The most useful \f(CW\*(C`mb::\*(C'\fR constants are:
.Sp
.Vb 8
\&   mb::OK, mb::Ok
\&   mb::Cancel
\&   mb::Yes
\&   mb::No
\&   mb::Abort
\&   mb::Retry
\&   mb::Ignore
\&   mb::Help
.Ve
.Sp
\&\s-1NB:\s0 These constants are defined so they can be bitwise-or'ed,
and \fIPrima::MsgBox\fR package uses this feature, where one
of its functions parameters is a combination of \f(CW\*(C`mb::\*(C'\fR constants.
.IP "onTop \s-1BOOLEAN\s0" 4
.IX Item "onTop BOOLEAN"
If set, the window is hinted to stay on top of all other windows.
.Sp
Default value: 0
.IP "ownerIcon \s-1BOOLEAN\s0" 4
.IX Item "ownerIcon BOOLEAN"
If 1, the icon is synchronized with the owner's.
Automatically set to 0 if \f(CW\*(C`::icon\*(C'\fR property is explicitly set.
Default value is 1, so assigning an icon to \f(CW$::application\fR
spawns the icon to all windows.
.IP "taskListed \s-1BOOLEAN\s0" 4
.IX Item "taskListed BOOLEAN"
If set to 0, hints the system against
reflecting existence of a window into a system task bar, 
or a top-level window list, or otherwise lower the window's
value before the other windows. If 1, does not hint anything.
.Sp
Default value: 1
.IP "windowState \s-1STATE\s0" 4
.IX Item "windowState STATE"
A three-state property, that governs the state of a window.
\&\s-1STATE\s0 can be one of three \f(CW\*(C`ws::XXX\*(C'\fR constants:
.Sp
.Vb 3
\&   ws::Normal
\&   ws::Minimized
\&   ws::Maximized
.Ve
.Sp
There can be more or less, or other window states 
provided by the system, but these three were chosen as
a 'least common denominator'.  The property can be changed
either by explicit set-mode call or by the user. In either case,
a \f(CW\*(C`WindowState\*(C'\fR notification is triggered.
.Sp
The property has three convenience wrappers: \f(CW\*(C`maximize()\*(C'\fR,
\&\f(CW\*(C`minimize()\*(C'\fR and \f(CW\*(C`restore()\*(C'\fR.
.Sp
See also: \f(CW\*(C`WindowState\*(C'\fR
.SS "Methods"
.IX Subsection "Methods"
.IP "cancel" 4
.IX Item "cancel"
A standard method to dismiss a modal window with \f(CW\*(C`mb::Cancel\*(C'\fR
result. The effect of calling this method is equal to when
the user selects a 'close window' action with system-provided
menu, button or other tool.
.Sp
See also: \f(CW\*(C`ok\*(C'\fR, \f(CW\*(C`modalResult\*(C'\fR, \f(CW\*(C`execute\*(C'\fR, \f(CW\*(C`execute_shared\*(C'\fR
.IP "end_modal" 4
.IX Item "end_modal"
If a window is in modal state, the \f(CW\*(C`EndModal\*(C'\fR
notification is activated.
Then the window is returned from the modal state, 
gets hidden and disabled.
If the window was on top in the exclusive modal state,
the last called \f(CW\*(C`execute()\*(C'\fR function finishes.
If the window was not on top in the exclusive modal state, 
the corresponding \f(CW\*(C`execute()\*(C'\fR function finishes after
all subsequent \fIexecute()\fR calls are finished.
.IP "execute \s-1INSERT_BEFORE\s0 = undef" 4
.IX Item "execute INSERT_BEFORE = undef"
A window is turned to the exclusive modal state
and is put on top of non-modal and shared-modal windows.
By default, if \s-1INSERT_BEFORE\s0 object is undef, the window
is also put on top of other exclusive-modal windows;
if \s-1INSERT_BEFORE\s0 is one of the exclusive-modal windows
the window is placed in queue before the \s-1INSERT_BEFORE\s0 window.
The window is showed and enabled, if necessary, and
\&\f(CW\*(C`Execute\*(C'\fR notification is triggered.
.Sp
The function is returned when a window is dismissed,
or if the system-dependent 'exit'\-event is triggered by the
user ( the latter case falls through all \fIexecute()\fR calls
and terminates \f(CW\*(C`run Prima;\*(C'\fR call, exiting gracefully).
.IP "execute_shared \s-1INSERT_BEFORE\s0 = undef" 4
.IX Item "execute_shared INSERT_BEFORE = undef"
A window is turned to the shared modal state
and is put on top of non-modal windows in the stack
of its \f(CW\*(C`::modalHorizon\*(C'\fR. A window with \f(CW\*(C`::modalHorizon\*(C'\fR
set to 1 starts its own stack, independent of all other
window stacks.
.Sp
By default, if \s-1INSERT_BEFORE\s0 object is undef, the window
is also put on top of other shared-modal windows in its stack.
If \s-1INSERT_BEFORE\s0 is one of the shared-modal windows in its stack,
the window is placed in queue before the \s-1INSERT_BEFORE\s0 window.
.Sp
The window is showed and enabled, if necessary, and
\&\f(CW\*(C`Execute\*(C'\fR notification is triggered.
.Sp
The function is returned immediately.
.IP "get_client_handle" 4
.IX Item "get_client_handle"
Returns a system handle for a system window that is inserted in top-level windows and
covers all of its area. Is different from \f(CW\*(C`Window::get_handle\*(C'\fR in that it returns the
system handle of the top-level window itself. In other terms, window returned by
this function is a child of the window returned by \f(CW\*(C`Window::get_handle\*(C'\fR.
.Sp
See also: \f(CW\*(C`get_handle\*(C'\fR
.IP "get_default_menu_font" 4
.IX Item "get_default_menu_font"
Returns the default font for a Prima::Menu class.
.IP "get_modal" 4
.IX Item "get_modal"
Returns one of three constants, reflecting the modal
state of a window:
.Sp
.Vb 3
\&   mt::None
\&   mt::Shared
\&   mt::Exclusive
.Ve
.Sp
Value of \f(CW\*(C`mt::None\*(C'\fR is 0, so result of \fIget_modal()\fR can be 
also treated as a boolean value, if only the fact of modality
is needed to check.
.IP "get_modal_window \s-1MODALITY_TYPE\s0 = mt::Exclusive, \s-1NEXT\s0 = 1" 4
.IX Item "get_modal_window MODALITY_TYPE = mt::Exclusive, NEXT = 1"
Returns a modal window, that is next to the given window in the
modality chain. \s-1MODALITY_TYPE\s0 selects the chain, and can be either
\&\f(CW\*(C`mt::Exclusive\*(C'\fR or \f(CW\*(C`mt::Shared\*(C'\fR. \s-1NEXT\s0 is a boolean flag, selecting
the lookup direction; if it is 1, the 'upper' window is returned,
if 0, the 'lower' one ( in a simple case when window A is made modal
(executed) after modal window B, the A window is the 'upper' one ).
.Sp
If a window has no immediate modal relations,  \f(CW\*(C`undef\*(C'\fR is returned.
.IP "maximize" 4
.IX Item "maximize"
Maximizes window. A shortcut for \f(CW\*(C`windowState(ws::Maximized)\*(C'\fR.
.IP "minimize" 4
.IX Item "minimize"
Minimizes window. A shortcut for \f(CW\*(C`windowState(ws::Minimized)\*(C'\fR.
.IP "ok" 4
.IX Item "ok"
A standard method to dismiss a modal window with \f(CW\*(C`mb::OK\*(C'\fR
result. Typically the effect of calling this method is equal to when
the user presses the enter key of a modal window, signaling that
the default action is to be taken.
.Sp
See also: \f(CW\*(C`cancel\*(C'\fR, \f(CW\*(C`modalResult\*(C'\fR, \f(CW\*(C`execute\*(C'\fR, \f(CW\*(C`execute_shared\*(C'\fR
.IP "restore" 4
.IX Item "restore"
Restores window to normal state from
minimized or maximized state. A shortcut for \f(CW\*(C`windowState(ws::Normal)\*(C'\fR.
.SS "Events"
.IX Subsection "Events"
.IP "Activate" 4
.IX Item "Activate"
Triggered when a window is activated by the user.
Activation mark is usually resides on a window that
contains keyboard focus, and is usually reflected by
highlighted system decorations.
.Sp
The toolkit does not provide standalone activation
functions; \f(CW\*(C`select()\*(C'\fR call is used instead.
.IP "Deactivate" 4
.IX Item "Deactivate"
Triggered when a window is deactivated by the user.
Window is usually marked inactive, when it contains
no keyboard focus.
.Sp
The toolkit does not provide standalone de-activation
functions; \f(CW\*(C`deselect()\*(C'\fR call is used instead.
.IP "EndModal" 4
.IX Item "EndModal"
Called before a window leaves modal state.
.IP "Execute" 4
.IX Item "Execute"
Called after a window enters modal state.
.IP "WindowState \s-1STATE\s0" 4
.IX Item "WindowState STATE"
Triggered when window state is changed, either by
an explicit \f(CW\*(C`windowState()\*(C'\fR call, or by the user.
\&\s-1STATE\s0 is the new window state, one of three \f(CW\*(C`ws::XXX\*(C'\fR
constants.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Object, Prima::Drawable,
Prima::Widget.
