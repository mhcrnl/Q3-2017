.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Prima::Docks 3"
.TH Prima::Docks 3 "2015-08-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::Docks \- dockable widgets
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module contains a set of classes and an implementation of dockable widgets
interface. The interface assumes two parties, the dockable widget
and the dock widget; the generic methods for the dock widget class are contained in
\&\f(CW\*(C`Prima::AbstractDocker::Interface\*(C'\fR package.
.SH "USAGE"
.IX Header "USAGE"
A dockable widget is required to take particular steps before 
it can dock to a dock widget. It needs to talk to the dock and
find out if it is allowed to land, or if the dock contains lower-level dock widgets
that might suit better for docking. If there's more than one dock
widget in the program, the dockable widget can select between the targets; this is 
especially actual when a dockable widget is dragged by mouse and
the arbitration is performed on geometrical distance basis.
.PP
The interface implies that there exists at least one tree-like hierarchy of dock widgets,
linked up to a root dock widget. The hierarchy is not required to follow
parent-child relationships, although this is the default behavior.
All dockable widgets are expected to know explicitly what hierarchy tree they
wish to dock to. \f(CW\*(C`Prima::InternalDockerShuttle\*(C'\fR introduces \f(CW\*(C`dockingRoot\*(C'\fR property
for this purpose.
.PP
The conversation between parties starts when a dockable widget
calls \f(CW\*(C`open_session\*(C'\fR method of the dock. The dockable widget passes
set of parameters signaling if the widget is ready to change its size
in case the dock widget requires so, and how. \f(CW\*(C`open_session\*(C'\fR method can either refuse
or accept the widget.
In case of the positive answer from \f(CW\*(C`open_session\*(C'\fR, the dockable widget
calls \f(CW\*(C`query\*(C'\fR method, which either returns a new rectangle, or another dock widget.
In the latter case, the caller can enumerate all available dock widgets by
repetitive calls to \f(CW\*(C`next_docker\*(C'\fR method. The session is closed by \f(CW\*(C`close_session\*(C'\fR
call; after that, the widget is allowed to dock by setting its \f(CW\*(C`owner\*(C'\fR
to the dock widget, the \f(CW\*(C`rect\*(C'\fR property to the negotiated position and size, and 
calling \f(CW\*(C`dock\*(C'\fR method.
.PP
\&\f(CW\*(C`open_session\*(C'\fR/\f(CW\*(C`close_session\*(C'\fR brackets are used to cache all necessary 
calculations once, making \f(CW\*(C`query\*(C'\fR call as light as possible. This design allows
a dockable widget, when dragged, repeatedly ask all reachable docks in an 
optimized way. The docking sessions are kept open until the drag 
session is finished.
.PP
The conversation can be schematized in the following code:
.PP
.Vb 10
\&        my $dock = $self\-> dockingRoot;
\&        my $session_id = $dock\-> open_session({ self => $self });
\&        return unless $session_id;
\&        my @result = $dock\-> query( $session_id, $self\-> rect );
\&        if ( 4 == scalar @result) {       # new rectangle is returned
\&                if ( ..... is new rectangle acceptable ? ... ) {
\&                        $dock\-> close_session( $session_id);
\&                        $dock\-> dock( $self);
\&                        return;
\&                }
\&        } elsif ( 1 == scalar @result) {  # another dock returned
\&                my $next = $result[0];
\&                while ( $next) {
\&                        if ( ... is new docker acceptable? ....) {
\&                                $dock\-> close_session( $session_id);
\&                                $next\-> dock( $self);
\&                                return;
\&                        }
\&                        $next = $dock\-> next_docker( $session_id, $self\-> origin );
\&                }
\&        }
\&        $dock\-> close_session( $session_id);
.Ve
.PP
Since even the simplified code is quite cumbersome, direct calls to
\&\f(CW\*(C`open_session\*(C'\fR are rare. Instead, \f(CW\*(C`Prima::InternalDockerShuttle\*(C'\fR
implements \f(CW\*(C`find_docking\*(C'\fR method which performs the arbitration automatically
and returns the appropriate dock widget.
.PP
\&\f(CW\*(C`Prima::InternalDockerShuttle\*(C'\fR is a class that implements dockable
widget functionality. It also employs a top-level window-like wrapper widget
for the dockable widget when it is not docked. 
By default, \f(CW\*(C`Prima::ExternalDockerShuttle\*(C'\fR is used as the wrapper widget class.
.PP
It is not required, however, to use neither \f(CW\*(C`Prima::InternalDockerShuttle\*(C'\fR
nor \f(CW\*(C`Prima::AbstractDocker::Interface\*(C'\fR to implement a dockable widget;
the only requirements to one is to respect \f(CW\*(C`open_session\*(C'\fR/\f(CW\*(C`close_session\*(C'\fR
protocol.
.PP
\&\f(CW\*(C`Prima::InternalDockerShuttle\*(C'\fR initiates a class hierarchy of dockable widgets.
Its descendants are \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR and, in turn, \f(CW\*(C`Prima::SingleLinearWidgetDocker\*(C'\fR.
\&\f(CW\*(C`Prima::SimpleWidgetDocker\*(C'\fR and \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR, derived from 
\&\f(CW\*(C`Prima::AbstractDocker::Interface\*(C'\fR, begin hierarchy of dock widgets.
The full hierarchy is as follows:
.PP
.Vb 5
\&        Prima::AbstractDocker::Interface
\&                Prima::SimpleWidgetDocker
\&                Prima::ClientWidgetDocker
\&                Prima::LinearWidgetDocker 
\&                Prima::FourPartDocker
\&
\&        Prima::InternalDockerShuttle 
\&                Prima::LinearDockerShuttle 
\&                Prima::SingleLinearWidgetDocker 
\&
\&        Prima::ExternalDockerShuttle
.Ve
.PP
All docker widget classes are derived from \f(CW\*(C`Prima::AbstractDocker::Interface\*(C'\fR.
Depending on the specialization, they employ more or less sophisticated schemes
for arranging dockable widgets inside. The most complicated scheme is implemented
in \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR; it does not allow children overlapping and is
able to rearrange with children and resize itself when a widget is docked or undocked.
.PP
The package provides only basic functionality. Module \f(CW\*(C`Prima::DockManager\*(C'\fR
provides common dockable controls, \- toolbars, panels, speed buttons etc.
based on \f(CW\*(C`Prima::Docks\*(C'\fR module. See Prima::DockManager.
.SH "Prima::AbstractDocker::Interface"
.IX Header "Prima::AbstractDocker::Interface"
Implements generic functionality of a docket widget. The class is
not derived from \f(CW\*(C`Prima::Widget\*(C'\fR; is used as a secondary ascendant class
for dock widget classes.
.SS "Properties"
.IX Subsection "Properties"
Since the class is not \f(CW\*(C`Prima::Object\*(C'\fR descendant, it provides
only run-time implementation of its properties. It is up to the
descendant object whether the properties are recognized on the creation stage
or not.
.IP "fingerprint \s-1INTEGER\s0" 4
.IX Item "fingerprint INTEGER"
A custom bit mask, to be used by docking widgets to reject inappropriate
dock widgets on early stage. The \f(CW\*(C`fingerprint\*(C'\fR property is not part
of the protocol, and is not required to be present in a dockable widget implementation.
.Sp
Default value: \f(CW0x0000FFFF\fR
.IP "dockup \s-1DOCK_WIDGET\s0" 4
.IX Item "dockup DOCK_WIDGET"
Selects the upper link in dock widgets hierarchy tree. The upper
link is required to be a dock widget, but is not required to be
a direct or an indirect parent. In this case, however, the maintenance
of the link must be implemented separately, for example:
.Sp
.Vb 1
\&        $self\-> dockup( $upper_dock_not_parent );
\&
\&        $upper_dock_not_parent\-> add_notification( \*(AqDestroy\*(Aq, sub {
\&                return unless $_[0] == $self\-> dockup;
\&                undef $self\-> {dockup_event_id};
\&                $self\-> dockup( undef );
\&        }, $self);
\&
\&        $self\-> {destroy_id} = $self\-> add_notification( \*(AqDestroy\*(Aq, sub { 
\&                $self\-> dockup( undef );
\&        } unless $self\-> {destroy_id};
.Ve
.SS "Methods"
.IX Subsection "Methods"
.IP "add_subdocker \s-1SUBDOCK\s0" 4
.IX Item "add_subdocker SUBDOCK"
Appends \s-1SUBDOCK\s0 to the list of lower-level docker widgets. The items of the list are
returned by \f(CW\*(C`next_docker\*(C'\fR method.
.IP "check_session \s-1SESSION\s0" 4
.IX Item "check_session SESSION"
Debugging procedure; checks \s-1SESSION\s0 hash, warns if its members are
invalid or incomplete. Returns 1 if no fatal errors were encountered;
0 otherwise.
.IP "close_session \s-1SESSION\s0" 4
.IX Item "close_session SESSION"
Closes docking \s-1SESSION\s0 and frees the associated resources.
.IP "dock \s-1WIDGET\s0" 4
.IX Item "dock WIDGET"
Called after \s-1WIDGET\s0 is successfully finished negotiation with
the dock widget and changed its \f(CW\*(C`owner\*(C'\fR property. The method
adapts the dock widget layout and lists \s-1WIDGET\s0 into list of
docked widgets. The method does not change \f(CW\*(C`owner\*(C'\fR property of \s-1WIDGET.\s0
.Sp
The method must not be called directly.
.ie n .IP "dock_bunch @WIDGETS" 4
.el .IP "dock_bunch \f(CW@WIDGETS\fR" 4
.IX Item "dock_bunch @WIDGETS"
Effectively docks set of \s-1WIDGETS\s0 by updating internal structures
and calling \f(CW\*(C`rearrange\*(C'\fR.
.IP "docklings" 4
.IX Item "docklings"
Returns array of docked widgets.
.IP "next_docker \s-1SESSION,\s0 [ X, Y ]" 4
.IX Item "next_docker SESSION, [ X, Y ]"
Enumerates lower-level docker widgets within \s-1SESSION\s0; returns 
one docker widget at a time. After the last widget returns
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
The enumeration pointer is reset by \f(CW\*(C`query\*(C'\fR call.
.Sp
X and Y are coordinates of the point of interest.
.IP "open_session \s-1PROFILE\s0" 4
.IX Item "open_session PROFILE"
Opens docking session with parameters stored in \s-1PROFILE\s0
and returns session \s-1ID\s0 scalar in case of success, or \f(CW\*(C`undef\*(C'\fR otherwise.
The following keys must be set in \s-1PROFILE:\s0
.RS 4
.IP "position \s-1ARRAY\s0" 4
.IX Item "position ARRAY"
Contains two integer coordinates of the desired position of 
a widget in (X,Y) format in screen coordinate system.
.IP "self \s-1WIDGET\s0" 4
.IX Item "self WIDGET"
Widget that is about to dock.
.IP "sizeable \s-1ARRAY\s0" 4
.IX Item "sizeable ARRAY"
Contains two boolean flags, representing if the widget can be resized
to an arbitrary size, horizontally and vertically. The arbitrary resize
option used as last resort if \f(CW\*(C`sizes\*(C'\fR key does not contain the desired
size.
.IP "sizeMin \s-1ARRAY\s0" 4
.IX Item "sizeMin ARRAY"
Two integers; minimal size that the widget can accept.
.IP "sizes \s-1ARRAY\s0" 4
.IX Item "sizes ARRAY"
Contains arrays of points in (X,Y) format; each point represents an
acceptable size of the widget. If \f(CW\*(C`sizeable\*(C'\fR flags are set to 0,
and none of \f(CW\*(C`sizes\*(C'\fR can be accepted by the dock widget, \f(CW\*(C`open_session\*(C'\fR
fails.
.RE
.RS 4
.RE
.IP "query \s-1SESSION\s0 [ X1, Y1, X2, Y2 ]" 4
.IX Item "query SESSION [ X1, Y1, X2, Y2 ]"
Checks if a dockable widget can be landed into the dock. 
If it can, returns a rectangle that the widget must be set to.
If coordinates ( X1 .. Y2 ) are specified, returns the 
rectangle closest to these. If \f(CW\*(C`sizes\*(C'\fR or \f(CW\*(C`sizeable\*(C'\fR
keys of \f(CW\*(C`open_session\*(C'\fR profile were set, the returned size 
might be different from the current docking widget size.
.Sp
Once the caller finds the result appropriate, it is allowed to change
its owner to the dock; after that, it must change its origin and size correspondingly 
to the result, and then call \f(CW\*(C`dock\*(C'\fR.
.Sp
If the dock cannot accept the widget, but contains lower-lever
dock widgets, returns the first lower-lever widget. The caller
can use subsequent calls to \f(CW\*(C`next_docker\*(C'\fR to enumerate all
lower-level dock widgets. A call to \f(CW\*(C`query\*(C'\fR 
resets the internal enumeration pointer.
.Sp
If the widget cannot be landed, an empty array is returned.
.IP "rearrange" 4
.IX Item "rearrange"
Effectively re-docks all the docked widgets. The effect is
as same as of
.Sp
.Vb 1
\&        $self\-> redock_widget($_) for $self\-> docklings;
.Ve
.Sp
but usually \f(CW\*(C`rearrange\*(C'\fR is faster.
.IP "redock_widget \s-1WIDGET\s0" 4
.IX Item "redock_widget WIDGET"
Effectively re-docks the docked \s-1WIDGET.\s0 If \s-1WIDGET\s0 has \f(CW\*(C`redock\*(C'\fR
method in its namespace, it is called instead.
.IP "remove_subdocker \s-1SUBDOCK\s0" 4
.IX Item "remove_subdocker SUBDOCK"
Removes \s-1SUBDOCK\s0 from the list of lower-level docker widgets.
See also add_subdocker.
.IP "replace \s-1FROM, TO\s0" 4
.IX Item "replace FROM, TO"
Assigns widget \s-1TO\s0 same owner and rectangle as \s-1FROM.\s0 The \s-1FROM\s0 widget
must be a docked widget.
.IP "undock \s-1WIDGET\s0" 4
.IX Item "undock WIDGET"
Removes \s-1WIDGET\s0 from list of docked widgets. The layout of the dock widget
can be changed after execution of this method. The method does not
change \f(CW\*(C`owner\*(C'\fR property of \s-1WIDGET.\s0
.Sp
The method must not be called directly.
.SH "Prima::SimpleWidgetDocker"
.IX Header "Prima::SimpleWidgetDocker"
A simple dock widget; accepts any widget that geometrically fits into.
Allows overlapping of the docked widgets.
.SH "Prima::ClientWidgetDocker"
.IX Header "Prima::ClientWidgetDocker"
A simple dock widget; accepts any widget that can be fit to cover all
dock's interior.
.SH "Prima::LinearWidgetDocker"
.IX Header "Prima::LinearWidgetDocker"
A toolbar-like docking widget class. The implementation does
not allow tiling, and can reshape the dock widget and rearrange
the docked widgets if necessary.
.PP
\&\f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR is orientation-dependent; its main axis,
governed by \f(CW\*(C`vertical\*(C'\fR property, is used to align docked widgets in
\&'lines', which in turn are aligned by the opposite axis ( 'major' and 'minor' terms
are used in the code for the axes ).
.SS "Properties"
.IX Subsection "Properties"
.IP "growable \s-1INTEGER\s0" 4
.IX Item "growable INTEGER"
A combination of \f(CW\*(C`grow::XXX\*(C'\fR constants, that describes how
the dock widget can be resized. The constants are divided in two
sets, direct and indirect, or, \f(CW\*(C`vertical\*(C'\fR property independent and
dependent.
.Sp
The first set contains explicitly named constants:
.Sp
.Vb 4
\&        grow::Left       grow::ForwardLeft       grow::BackLeft
\&        grow::Down       grow::ForwardDown       grow::BackDown
\&        grow::Right      grow::ForwardRight      grow::BackRight
\&        grow::Up         grow::ForwardUp         grow::BackUp
.Ve
.Sp
that select if the widget can be grown to the direction shown.
These do not change meaning when \f(CW\*(C`vertical\*(C'\fR changes, though they do
change the dock widget behavior. The second set does not affect
dock widget behavior when \f(CW\*(C`vertical\*(C'\fR changes, however the names
are not that illustrative:
.Sp
.Vb 4
\&        grow::MajorLess  grow::ForwardMajorLess  grow::BackMajorLess
\&        grow::MajorMore  grow::ForwardMajorMore  grow::BackMajorMore
\&        grow::MinorLess  grow::ForwardMinorLess  grow::BackMinorLess
\&        grow::MinorMore  grow::ForwardMinorMore  grow::BackMinorMore
.Ve
.Sp
\&\f(CW\*(C`Forward\*(C'\fR and \f(CW\*(C`Back\*(C'\fR prefixes select if the dock widget can be 
respectively expanded or shrunk in the given direction. \f(CW\*(C`Less\*(C'\fR and
\&\f(CW\*(C`More\*(C'\fR are equivalent to \f(CW\*(C`Left\*(C'\fR and \f(CW\*(C`Right\*(C'\fR when \f(CW\*(C`vertical\*(C'\fR is 0,
and to \f(CW\*(C`Up\*(C'\fR and \f(CW\*(C`Down\*(C'\fR otherwise.
.Sp
The use of constants from the second set is preferred.
.Sp
Default value: 0
.IP "hasPocket \s-1BOOLEAN\s0" 4
.IX Item "hasPocket BOOLEAN"
A boolean flag, affects the possibility of a docked widget to reside
outside the dock widget inferior. If 1, a docked wigdet is allowed
to stay docked ( or dock into a position ) further on the major axis
( to the right when \f(CW\*(C`vertical\*(C'\fR is 0, up otherwise ), as if there's
a 'pocket'. If 0, a widget is neither allowed to dock outside the
inferior, nor is allowed to stay docked ( and is undocked automatically )
when the dock widget shrinks so that the docked widget cannot stay in
the dock boundaries.
.Sp
Default value: 1
.IP "vertical \s-1BOOLEAN\s0" 4
.IX Item "vertical BOOLEAN"
Selects the major axis of the dock widget. If 1, it is vertical,
horizontal otherwise.
.Sp
Default value: 0
.SS "Events"
.IX Subsection "Events"
.IP "Dock" 4
.IX Item "Dock"
Called when \f(CW\*(C`dock\*(C'\fR is successfully finished.
.IP "DockError \s-1WIDGET\s0" 4
.IX Item "DockError WIDGET"
Called when \f(CW\*(C`dock\*(C'\fR is unsuccessfully finished. This only 
happens if \s-1WIDGET\s0 does not follow the docking protocol, and inserts
itself into a non-approved area.
.IP "Undock" 4
.IX Item "Undock"
Called when \f(CW\*(C`undock\*(C'\fR is finished.
.SH "Prima::SingleLinearWidgetDocker"
.IX Header "Prima::SingleLinearWidgetDocker"
Descendant of \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR. In addition
to the constraints, introduced by the ascendant class,
\&\f(CW\*(C`Prima::SingleLinearWidgetDocker\*(C'\fR allows only one line ( or row,
depending on \f(CW\*(C`vertical\*(C'\fR property value ) of docked widgets.
.SH "Prima::FourPartDocker"
.IX Header "Prima::FourPartDocker"
Implementation of a docking widget, with its four sides
acting as 'rubber' docking areas.
.SS "Properties"
.IX Subsection "Properties"
.IP "indents \s-1ARRAY\s0" 4
.IX Item "indents ARRAY"
Contains four integers, specifying the breadth of offset for
each side. The first integer is width of the left side, the second \- height
of the bottom side, the third \- width of the right side, the fourth \- height
of the top side.
.IP "dockerClassLeft \s-1STRING\s0" 4
.IX Item "dockerClassLeft STRING"
Assigns class of left-side dock window.
.Sp
Default value: \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR.
Create-only property.
.IP "dockerClassRight \s-1STRING\s0" 4
.IX Item "dockerClassRight STRING"
Assigns class of right-side dock window.
.Sp
Default value: \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR.
Create-only property.
.IP "dockerClassTop \s-1STRING\s0" 4
.IX Item "dockerClassTop STRING"
Assigns class of top-side dock window.
.Sp
Default value: \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR.
Create-only property.
.IP "dockerClassBottom \s-1STRING\s0" 4
.IX Item "dockerClassBottom STRING"
Assigns class of bottom-side dock window.
.Sp
Default value: \f(CW\*(C`Prima::LinearWidgetDocker\*(C'\fR.
Create-only property.
.IP "dockerClassClient \s-1STRING\s0" 4
.IX Item "dockerClassClient STRING"
Assigns class of center dock window.
.Sp
Default value: \f(CW\*(C`Prima::ClientWidgetDocker\*(C'\fR.
Create-only property.
.IP "dockerProfileLeft \s-1HASH\s0" 4
.IX Item "dockerProfileLeft HASH"
Assigns hash of properties, passed to the left-side dock widget during the creation.
.Sp
Create-only property.
.IP "dockerProfileRight \s-1HASH\s0" 4
.IX Item "dockerProfileRight HASH"
Assigns hash of properties, passed to the right-side dock widget during the creation.
.Sp
Create-only property.
.IP "dockerProfileTop \s-1HASH\s0" 4
.IX Item "dockerProfileTop HASH"
Assigns hash of properties, passed to the top-side dock widget during the creation.
.Sp
Create-only property.
.IP "dockerProfileBottom \s-1HASH\s0" 4
.IX Item "dockerProfileBottom HASH"
Assigns hash of properties, passed to the bottom-side dock widget during the creation.
.Sp
Create-only property.
.IP "dockerProfileClient \s-1HASH\s0" 4
.IX Item "dockerProfileClient HASH"
Assigns hash of properties, passed to the center dock widget during the creation.
.Sp
Create-only property.
.IP "dockerDelegationsLeft \s-1ARRAY\s0" 4
.IX Item "dockerDelegationsLeft ARRAY"
Assigns the left-side dock list of delegated notifications.
.Sp
Create-only property.
.IP "dockerDelegationsRight \s-1ARRAY\s0" 4
.IX Item "dockerDelegationsRight ARRAY"
Assigns the right-side dock list of delegated notifications.
.Sp
Create-only property.
.IP "dockerDelegationsTop \s-1ARRAY\s0" 4
.IX Item "dockerDelegationsTop ARRAY"
Assigns the top-side dock list of delegated notifications.
.Sp
Create-only property.
.IP "dockerDelegationsBottom \s-1ARRAY\s0" 4
.IX Item "dockerDelegationsBottom ARRAY"
Assigns the bottom-side dock list of delegated notifications.
.Sp
Create-only property.
.IP "dockerDelegationsClient \s-1ARRAY\s0" 4
.IX Item "dockerDelegationsClient ARRAY"
Assigns the center dock list of delegated notifications.
.Sp
Create-only property.
.IP "dockerCommonProfile \s-1HASH\s0" 4
.IX Item "dockerCommonProfile HASH"
Assigns hash of properties, passed to all five dock widgets during the creation.
.Sp
Create-only property.
.SH "Prima::InternalDockerShuttle"
.IX Header "Prima::InternalDockerShuttle"
The class provides a container, or a 'shuttle', for a client widget, while is docked to 
an \f(CW\*(C`Prima::AbstractDocker::Interface\*(C'\fR descendant instance. The functionality includes 
communicating with dock widgets, the user interface for dragging and interactive dock selection,
and a client widget container for non-docked state. The latter is implemented by
reparenting of the client widget to an external shuttle widget, selected by \f(CW\*(C`externalDockerClass\*(C'\fR
property. Both user interfaces for the docked and the non-docked shuttle states are minimal.
.PP
The class implements dockable widget functionality, served by \f(CW\*(C`Prima::AbstractDocker::Interface\*(C'\fR,
while itself it is derived from \f(CW\*(C`Prima::Widget\*(C'\fR only.
.PP
See also: \*(L"Prima::ExternalDockerShuttle\*(R".
.SS "Properties"
.IX Subsection "Properties"
.IP "client \s-1WIDGET\s0" 4
.IX Item "client WIDGET"
Provides access to the client widget, which always resides either in 
the internal or the external shuttle. By default there is no client,
and any widget capable of changing its parent can be set as one.
After a widget is assigned as a client, its \f(CW\*(C`owner\*(C'\fR and \f(CW\*(C`clipOwner\*(C'\fR
properties must not be used.
.Sp
Run-time only property.
.IP "dock \s-1WIDGET\s0" 4
.IX Item "dock WIDGET"
Selects the dock widget that the shuttle is landed on. If \f(CW\*(C`undef\*(C'\fR,
the shuttle is in the non-docked state.
.Sp
Default value: \f(CW\*(C`undef\*(C'\fR
.IP "dockingRoot \s-1WIDGET\s0" 4
.IX Item "dockingRoot WIDGET"
Selects the root of dock widgets hierarchy. 
If \f(CW\*(C`undef\*(C'\fR, the shuttle can only exist in the non-docked state.
.Sp
Default value: \f(CW\*(C`undef\*(C'\fR
.Sp
See \*(L"\s-1USAGE\*(R"\s0 for reference.
.IP "externalDockerClass \s-1STRING\s0" 4
.IX Item "externalDockerClass STRING"
Assigns class of external shuttle widget.
.Sp
Default value: \f(CW\*(C`Prima::ExternalDockerShuttle\*(C'\fR
.IP "externalDockerModule \s-1STRING\s0" 4
.IX Item "externalDockerModule STRING"
Assigns module that contains the external shuttle widget class.
.Sp
Default value: \f(CW\*(C`Prima::MDI\*(C'\fR ( \f(CW\*(C`Prima::ExternalDockerShuttle\*(C'\fR is derived from \f(CW\*(C`Prima::MDI\*(C'\fR ).
.IP "externalDockerProfile \s-1HASH\s0" 4
.IX Item "externalDockerProfile HASH"
Assigns hash of properties, passed to the external shuttle widget during the creation.
.IP "fingerprint \s-1INTEGER\s0" 4
.IX Item "fingerprint INTEGER"
A custom bit mask, used to reject inappropriate dock widgets on early stage.
.Sp
Default value: \f(CW0x0000FFFF\fR
.IP "indents \s-1ARRAY\s0" 4
.IX Item "indents ARRAY"
Contains four integers, specifying the breadth of offset in pixels for each 
widget side in the docked state.
.Sp
Default value: \f(CW\*(C`5,5,5,5\*(C'\fR.
.IP "snapDistance \s-1INTEGER\s0" 4
.IX Item "snapDistance INTEGER"
A maximum offset, in pixels, between the actual shuttle coordinates and the coordinates
proposed by the dock widget, where the shuttle is allowed to land.
In other words, it is the distance between the dock and the shuttle when the latter
\&'snaps' to the dock during the dragging session.
.Sp
Default value: 10
.IP "x_sizeable \s-1BOOLEAN\s0" 4
.IX Item "x_sizeable BOOLEAN"
Selects whether the shuttle can change its width in case the dock widget suggests so.
.Sp
Default value: 0
.IP "y_sizeable \s-1BOOLEAN\s0" 4
.IX Item "y_sizeable BOOLEAN"
Selects whether the shuttle can change its height in case the dock widget suggests so.
.Sp
Default value: 0
.SS "Methods"
.IX Subsection "Methods"
.IP "client2frame X1, Y1, X2, Y2" 4
.IX Item "client2frame X1, Y1, X2, Y2"
Returns a rectangle that the shuttle would occupy if
its client rectangle is assigned to X1, Y1, X2, Y2 
rectangle.
.IP "dock_back" 4
.IX Item "dock_back"
Docks to the recent dock widget, if it is still available.
.IP "drag \s-1STATE, RECT, ANCHOR_X, ANCHOR_Y\s0" 4
.IX Item "drag STATE, RECT, ANCHOR_X, ANCHOR_Y"
Initiates or aborts the dragging session, depending on \s-1STATE\s0 boolean
flag.
.Sp
If it is 1, \s-1RECT\s0 is an array with the coordinates of the shuttle rectangle
before the drag has started; \s-1ANCHOR_X\s0 and \s-1ANCHOR_Y\s0 are coordinates of the 
aperture point where the mouse event occurred that has initiated the drag.
Depending on how the drag session ended, the shuttle can be relocated to
another dock, undocked, or left intact. Also, \f(CW\*(C`Dock\*(C'\fR, \f(CW\*(C`Undock\*(C'\fR, or
\&\f(CW\*(C`FailDock\*(C'\fR notifications can be triggered.
.Sp
If \s-1STATE\s0 is 0, \s-1RECT, ANCHOR_X \s0,and \s-1ANCHOR_Y\s0 parameters are not used.
.IP "find_docking \s-1DOCK,\s0 [ \s-1POSITION \s0]" 4
.IX Item "find_docking DOCK, [ POSITION ]"
Opens a session with \s-1DOCK,\s0 unless it is already opened,
and negotiates about the possibility of landing (
at particular \s-1POSITION,\s0 if this parameter is present ).
.Sp
\&\f(CW\*(C`find_docking\*(C'\fR caches the dock widget sessions, and provides a
possibility to select different parameters passed to \f(CW\*(C`open_session\*(C'\fR
for different dock widgets. To achieve this, \f(CW\*(C`GetCaps\*(C'\fR request
notification is triggered, which fills the parameters. The default
action sets \f(CW\*(C`sizeable\*(C'\fR options according to \f(CW\*(C`x_sizeable\*(C'\fR
and \f(CW\*(C`y_sizeable\*(C'\fR properties.
.Sp
In case an appropriate landing area is found, \f(CW\*(C`Landing\*(C'\fR
notification is triggered with the proposed dock widget
and the target rectangle. The area can be rejected on this stage
if \f(CW\*(C`Landing\*(C'\fR returns negative answer.
.Sp
On success, returns a dock widget found and the target rectangle; 
the widget is never docked though. On failure returns an empty array.
.Sp
This method is used by the dragging routine to provide a visual feedback to
the user, to indicate that a shuttle may or may not land in a particular 
area.
.IP "frame2client X1, Y1, X2, Y2" 4
.IX Item "frame2client X1, Y1, X2, Y2"
Returns a rectangle that the client would occupy if
the shuttle rectangle is assigned to X1, Y1, X2, Y2 
rectangle.
.IP "redock" 4
.IX Item "redock"
If docked, undocks form the dock widget and docks back.
If not docked, does not perform anything.
.SS "Events"
.IX Subsection "Events"
.IP "Dock" 4
.IX Item "Dock"
Called when shuttle is docked.
.IP "EDSClose" 4
.IX Item "EDSClose"
Triggered when the user presses close button or otherwise activates the
\&\f(CW\*(C`close\*(C'\fR function of the \s-1EDS \s0( external docker shuttle ). To cancel
the closing, \f(CW\*(C`clear_event\*(C'\fR must be called inside the event handler.
.IP "FailDock X, Y" 4
.IX Item "FailDock X, Y"
Called after the dragging session in the non-docked stage is finished,
but did not result in docking. X and Y are the coordinates
of the new external shuttle position.
.IP "GetCaps \s-1DOCK, PROFILE\s0" 4
.IX Item "GetCaps DOCK, PROFILE"
Called before the shuttle opens a docking session with \s-1DOCK\s0
widget. \s-1PROFILE\s0 is a hash reference, which is to be filled
inside the event handler. After that \s-1PROFILE\s0 is passed
to \f(CW\*(C`open_session\*(C'\fR call.
.Sp
The default action sets \f(CW\*(C`sizeable\*(C'\fR options according to \f(CW\*(C`x_sizeable\*(C'\fR
and \f(CW\*(C`y_sizeable\*(C'\fR properties.
.IP "Landing \s-1DOCK, X1, Y1, X2, Y2\s0" 4
.IX Item "Landing DOCK, X1, Y1, X2, Y2"
Called inside the docking session, after an appropriate dock
widget is selected and the landing area is defined as
X1, Y1, X2, Y2. To reject the landing on either \s-1DOCK\s0 or
area, \f(CW\*(C`clear_event\*(C'\fR must be called.
.IP "Undock" 4
.IX Item "Undock"
Called when shuttle is switched to the non-docked state.
.SH "Prima::ExternalDockerShuttle"
.IX Header "Prima::ExternalDockerShuttle"
A shuttle class, used to host a client of \f(CW\*(C`Prima::InternalDockerShuttle\*(C'\fR
widget when it is in the non-docked state. The class represents an
emulation of a top-level window, which can be moved, resized ( this
feature is not on by default though ), and closed.
.PP
\&\f(CW\*(C`Prima::ExternalDockerShuttle\*(C'\fR is inherited from \f(CW\*(C`Prima::MDI\*(C'\fR class, and
its window emulating functionality is a subset of its ascendant.
See also Prima::MDI.
.SS "Properties"
.IX Subsection "Properties"
.IP "shuttle \s-1WIDGET\s0" 4
.IX Item "shuttle WIDGET"
Contains reference to the dockable \s-1WIDGET\s0
.SH "Prima::LinearDockerShuttle"
.IX Header "Prima::LinearDockerShuttle"
A simple descendant of \f(CW\*(C`Prima::InternalDockerShuttle\*(C'\fR, used
for toolbars. Introduces orientation and draws a tiny header along
the minor shuttle axis. All its properties concern only
the way the shuttle draws itself.
.SS "Properties"
.IX Subsection "Properties"
.IP "headerBreadth \s-1INTEGER\s0" 4
.IX Item "headerBreadth INTEGER"
Breadth of the header in pixels.
.Sp
Default value: 8
.IP "indent \s-1INTEGER\s0" 4
.IX Item "indent INTEGER"
Provides a wrapper to \f(CW\*(C`indents\*(C'\fR property; besides the
space for the header, all indents are assigned to \f(CW\*(C`indent\*(C'\fR
property value.
.IP "vertical \s-1BOOLEAN\s0" 4
.IX Item "vertical BOOLEAN"
If 1, the shuttle is drawn as a vertical bar. 
If 0, the shuttle is drawn as a horizontal bar.
.Sp
Default value: 0
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Widget, Prima::MDI, Prima::DockManager, \fIexamples/dock.pl\fR
