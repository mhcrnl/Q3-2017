.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::gp-problems 3"
.TH pod::Prima::gp-problems 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::gp\-problems \- Problems, questionable or intricate topics in 2\-D Graphics
.SH "Introduction"
.IX Header "Introduction"
One of the most important goals of the Prima project
is portability between different operating systems. Independently to
efforts in keeping Prima internal code that
it behaves more or less identically on different platforms, it is always possible
to write non-portable and platform-dependent code. 
Here are some guidelines and suggestions for 2\-D graphics
programming.
.SH "Minimal display capabilities"
.IX Header "Minimal display capabilities"
A compliant display is expected to have minimal set
of capabilities, that programmer can rely upon. 
Following items are guaranteedly supported by Prima:
.IP "Minimal capabilities" 4
.IX Item "Minimal capabilities"
Distinct black and white colors
.Sp
Line widths 0 and 1
.Sp
One monospaced font
.Sp
Solid fill
.Sp
rop::Copy and rop::NoOper
.IP "Plotting primitives" 4
.IX Item "Plotting primitives"
SetPixel,GetPixel
.Sp
Line,PolyLine,PolyLines
.Sp
Ellipse,Arc,Chord,Sector
.Sp
Rectangle
.Sp
FillPoly
.Sp
FillEllipse,FillChord,FillSector
.Sp
TextOut
.Sp
PutImage,GetImage
.IP "Information services" 4
.IX Item "Information services"
GetTextWidth,GetFontMetrics,GetCharacterABCWidths
.Sp
GetImageBitsLayout
.IP "Properties" 4
.IX Item "Properties"
color
.Sp
backColor
.Sp
rop
.Sp
backRop
.Sp
lineWidth
.Sp
lineJoin
.Sp
lineStyle
.Sp
fillPattern
.Sp
fillPolyWinding
.Sp
textOpaque
.Sp
clipRect
.Sp
All these properties must be present, however it is not
required for them to be changeable. Even if an underlying platform-specific code 
can only support one mode for a property, it have to follow all 
obligations for the mode. For example, if platform supports
full functionality for black color but limited functionality for the other colors,
the wrapping code should not allow color property to be writable then.
.SH "Inevident issues"
.IX Header "Inevident issues"
.SS "Colors"
.IX Subsection "Colors"
.IP "Black and white colors on paletted displays" 4
.IX Item "Black and white colors on paletted displays"
Due the fact that paletted displays employ indexed color 
representation, 'black' and 'white' indices are not always
0 and 2^n\-1, so result of raster image operations may look garbled (X).
Win32 protects themselves from this condition by 
forcing white to be the last color in the system palette.
.Sp
Example: if white color on 8\-bit display occupies palette index 15 
then desired masking effect wouldn't work 
for xoring transparent areas with cl::White.
.Sp
Workaround: Use two special color constants
cl::Clear and cl::Set, that represent all zeros and all ones values
for bit-sensitive raster operations.
.IP "Black might be not 0, and white not 0xffffff" 4
.IX Item "Black might be not 0, and white not 0xffffff"
This inevident issue happens mostly on 15\- and 16\-bits
pixel displays. Internal color representation for the white color 
on a 15\-color display ( assuming R,G and B are 5\-bits fields) is
.Sp
.Vb 2
\& 11111000 11111000 11111000
\& \-\-R\-\-\-\-\- \-\-G\-\-\-\-\- \-\-B\-\-\-\-\-
.Ve
.Sp
that equals to 0xf8f8f8. (All)
.Sp
Advise: do not check for 'blackness' and 'whiteness'
merely by comparing a pixel value.
.IP "Pixel value coding" 4
.IX Item "Pixel value coding"
Status: internal
.Sp
It is not checked how does Prima behave when a pixel value and 
a platform integer use different bit and/or byte priority (X).
.SS "Filled shapes"
.IX Subsection "Filled shapes"
.IP "Dithering" 4
.IX Item "Dithering"
If a non-solid pattern is
selected and a background and/or a foreground color
cannot be drawn as a solid, the correct rendering requires 
correspondingly 3 or 4 colors.  Some rendering engines (Win9X)
fail to produce correct results.
.IP "Pattern offset" 4
.IX Item "Pattern offset"
For a widget that contains a pattern-filled shape, 
its picture will be always garbled after scrolling, 
because it is impossible to provide an algorithm
for a correct rendering without a prior knowledge of the
widget nature. (All)
.Sp
Workaround: Do not use patterned backgrounds. 
Since the same effect is visible on dithered 
backgrounds, routine check for pure color might be applied.
.SS "Lines"
.IX Subsection "Lines"
.IP "Line caps over patterned styles" 4
.IX Item "Line caps over patterned styles"
It is not clear, whether
gaps between dashes should be a multiple to a line width or
not. For example, lp::DotDot looks almost as a solid line when
lineWidth is over 10 if the first (non-multiple) tactic is chosen.
From the other hand it is hardly possible to predict the plotting 
strategy from a high-level code. The problem is related more to Prima 
design rather than to a platform-specific code. (All)
.Sp
Workaround: use predefined patterns (lp::XXX)
.IP "Dithering" 4
.IX Item "Dithering"
Dithering might be not used for line plotting. (Win9X)
.IP "Arcs and circles" 4
.IX Item "Arcs and circles"
Drawing is dependent in X11 on an X servers \- different X servers do different plotting
strategies on small (less than 3 pixels) diameters. Current version is adapted best to the
latest (2010) Xorg capabilities. See discussion on \s-1CPAN\s0 bug https://rt.cpan.org/Ticket/Display.html?id=62972 .
.SS "Fonts"
.IX Subsection "Fonts"
.IP "Font metric inconsistency" 4
.IX Item "Font metric inconsistency"
A font is loaded by request with one size,
but claims another afterwards.(X).
.Sp
Impact: system-dependent font description may not match
to Prima's.
.Sp
Advise: do not try to deduce Prima font metrics from
system-dependent ones and vice versa.
.IP "Transparent plotting" 4
.IX Item "Transparent plotting"
No internal function for drawing transparent bitmaps (like fonts).
Therefore, if a font emulation is desired, special ROPs cannot be
reproduced. (Win9X, WinNT)
.Sp
Impact: font emulation is laborsome, primarily because the glyphs 
have to be plotted by consequential anding and xoring a bitmap.
Full spectrum of the raster operations cannot be achieved with this
approach.
.IP "Kerning" 4
.IX Item "Kerning"
Prima do not use text kernings, nor
encourages underlying platform-specific code to use it \- primarily
because of its complexity.
From the other hand, sometimes glyph position cannot be 
determined correctly if no information for the text kerning 
is provided. (Win9X)
.IP "Text background" 4
.IX Item "Text background"
If a text is drawn with non-CopyPut raster operation, text background 
is not expected to be mixed with symbols \- however this is hardly reachable,
so results differs for different platforms.
.Sp
Text background may be only drawn with pure ( non-dithered ) color
(Win9X,WinNT) \- but this is (arguably) a more correct behavior.
.Sp
Advise: Do not use ::rop2 and text background for special effects
.IP "Internal platform features" 4
.IX Item "Internal platform features"
Font change notification is not provided. (X)
.Sp
Raster fonts cannot be synthesized (partly X)
.SS "Raster operations ( ROPs)"
.IX Subsection "Raster operations ( ROPs)"
Background raster operations are not supported (X,Win9X,WinNT) and
foreground ROPs have limited number of modes (X). Not all ROPs
can be emulated for certain primitives, like fonts,
complex shapes, and patterned shapes.
.PP
It is yet unclear which primitives have to support ROPs, \-
like FloodFill and SetPixel. Behavior of the current implementation 
is that they do not.
.SS "Arcs"
.IX Subsection "Arcs"
Platforms tend to produce different results for 
angles outside 0 and 2pi. Although Prima assures that 
correct plotting would be performed for any angle,
minor inconsistencies may be noticed.
If emulating, note that 2 and 4\-pi arcs
are not the same \- for example, they look differently 
with rop::Xor.
.SS "Palettes"
.IX Subsection "Palettes"
.IP "Static palettes" 4
.IX Item "Static palettes"
Some displays are unable to change their hardware palette,
so detecting 8\- or 4\- bits display doesn't automatically mean that
palette is writable.(X)
.IP "Widget::palette" 4
.IX Item "Widget::palette"
Widget::palette property is used for explicit declaration of extra 
color needs for a widget. The request might be satisfacted in different
ways, or might not at all. It is advisable not to rely onto platform
behavior for the palette operations.
.IP "Dynamic palette change" 4
.IX Item "Dynamic palette change"
It is possible (usually on 8\-bits displays) for a display to
change asynchronously its hardware palette in order to process 
different color requests. All platforms behave differently.
.Sp
Win9X/WinNT \- only one top-level window at a time 
and its direct children ( not ::\fIclipOwner\fR\|(0)) can benefit
from using Widget::palette. System palette is switched every time 
as different windows moved to the front.
.Sp
X \- Any application can easily ruin system color table.
Since this behavior is such by design, no workaround can be
applied here.
.SS "Bitmaps"
.IX Subsection "Bitmaps"
.IP "Invalid scaling" 4
.IX Item "Invalid scaling"
Scaling is invalid (Win9X) or not supported (X). Common mistake
is to not take into an account the fractional pixels that appear when
the scaling factor is more than 1. This mistake can be observed in Win9X.
.Sp
Workaround: none
.IP "Large scale factors" 4
.IX Item "Large scale factors"
Request for drawing a bitmap might fail 
if large scaling factor is selected. (Win9X,WinNT).
This effect is obviously due that fact that these platforms
scale the bitmap into a memory before the plotting takes place.
.SH "Platform-specific peculiarities"
.IX Header "Platform-specific peculiarities"
.SS "Windows 9X"
.IX Subsection "Windows 9X"
Amount of \s-1GDI\s0 objects can not exceed some unknown
threshold \- experiments show that 128 objects
is safe enough.
.PP
No transformations.
.PP
Color cursor creation routine is broken.
.PP
Filled shapes are broken.
.SS "X"
.IX Subsection "X"
No transformations
.PP
No bitmap scaling
.PP
No font rotation
.PP
No GetPixel, FloodFill ( along with some other primitives)
.PP
White is not 2^n\-1 on n\-bit paletted displays (tested on XFree86).
.PP
Filled shapes are broken.
.PP
Color bitmaps cannot be drawn onto mono bitmaps.
.SH "Implementation notes"
.IX Header "Implementation notes"
.SS "Win32"
.IX Subsection "Win32"
Plotting speed of DeviceBitmaps is somewhat less on 8\-bit displays
than Images and Icons. It is because DeviceBitmaps are bound
to their original palette, so putting a DeviceBitmap onto
different palette drawable employs inefficient algorithms in
order to provide correct results.
.SS "X"
.IX Subsection "X"
Image that was first drawn on a paletted
Drawable always seen in 8 colors if drawn afterwards on a Drawable with the
different palette. That is because the image has special cache in display
pixel format, but cache refresh on every PutImage call is absolutely
inappropriate (although technically possible).
It is planned to fix the problem by checking
the palette difference for every PutImage invocation.
\&\s-1NB \-\s0 the effect is seen on dynamic color displays only.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima
