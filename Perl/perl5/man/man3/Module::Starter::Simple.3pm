.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::Starter::Simple 3"
.TH Module::Starter::Simple 3 "2015-01-30" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Starter::Simple \- a simple, comprehensive Module::Starter plugin
.SH "VERSION"
.IX Header "VERSION"
Version 1.71
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Module::Starter qw(Module::Starter::Simple);
\&
\&    Module::Starter\->create_distro(%args);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Module::Starter::Simple is a plugin for Module::Starter that will perform all
the work needed to create a distribution.  Given the parameters detailed in
Module::Starter, it will create content, create directories, and populate
the directories with the required files.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.ie n .SS """new(%args)"""
.el .SS "\f(CWnew(%args)\fP"
.IX Subsection "new(%args)"
This method is called to construct and initialize a new Module::Starter object.
It is never called by the end user, only internally by \f(CW\*(C`create_distro\*(C'\fR, which
creates ephemeral Module::Starter objects.  It's documented only to call it to
the attention of subclass authors.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
All the methods documented below are object methods, meant to be called
internally by the ephemeral objects created during the execution of the class
method \f(CW\*(C`create_distro\*(C'\fR above.
.SS "postprocess_config"
.IX Subsection "postprocess_config"
A hook to do any work after the configuration is initially processed.
.SS "pre_create_distro"
.IX Subsection "pre_create_distro"
A hook to do any work right before the distro is created.
.ie n .SS """create_distro(%args)"""
.el .SS "\f(CWcreate_distro(%args)\fP"
.IX Subsection "create_distro(%args)"
This method works as advertised in Module::Starter.
.SS "post_create_distro"
.IX Subsection "post_create_distro"
A hook to do any work after creating the distribution.
.SS "pre_exit"
.IX Subsection "pre_exit"
A hook to do any work right before exit time.
.SS "create_basedir"
.IX Subsection "create_basedir"
Creates the base directory for the distribution.  If the directory already
exists, and \fI\f(CI$force\fI\fR is true, then the existing directory will get erased.
.PP
If the directory can't be created, or re-created, it dies.
.ie n .SS "create_modules( @modules )"
.el .SS "create_modules( \f(CW@modules\fP )"
.IX Subsection "create_modules( @modules )"
This method will create a starter module file for each module named in
\&\fI\f(CI@modules\fI\fR.
.ie n .SS "module_guts( $module, $rtname )"
.el .SS "module_guts( \f(CW$module\fP, \f(CW$rtname\fP )"
.IX Subsection "module_guts( $module, $rtname )"
This method returns the text which should serve as the contents for the named
module.  \fI\f(CI$rtname\fI\fR is the email suffix which rt.cpan.org will use for bug
reports.  (This should, and will, be moved out of the parameters for this
method eventually.)
.ie n .SS "create_Makefile_PL( $main_module )"
.el .SS "create_Makefile_PL( \f(CW$main_module\fP )"
.IX Subsection "create_Makefile_PL( $main_module )"
This will create the Makefile.PL for the distribution, and will use the module
named in \fI\f(CI$main_module\fI\fR as the main module of the distribution.
.ie n .SS "create_MI_Makefile_PL( $main_module )"
.el .SS "create_MI_Makefile_PL( \f(CW$main_module\fP )"
.IX Subsection "create_MI_Makefile_PL( $main_module )"
This will create a Module::Install Makefile.PL for the distribution, and will
use the module named in \fI\f(CI$main_module\fI\fR as the main module of the distribution.
.ie n .SS "Makefile_PL_guts( $main_module, $main_pm_file )"
.el .SS "Makefile_PL_guts( \f(CW$main_module\fP, \f(CW$main_pm_file\fP )"
.IX Subsection "Makefile_PL_guts( $main_module, $main_pm_file )"
This method is called by create_Makefile_PL and returns text used to populate
Makefile.PL; \fI\f(CI$main_pm_file\fI\fR is the filename of the distribution's main
module, \fI\f(CI$main_module\fI\fR.
.ie n .SS "MI_Makefile_PL_guts( $main_module, $main_pm_file )"
.el .SS "MI_Makefile_PL_guts( \f(CW$main_module\fP, \f(CW$main_pm_file\fP )"
.IX Subsection "MI_Makefile_PL_guts( $main_module, $main_pm_file )"
This method is called by create_MI_Makefile_PL and returns text used to populate
Makefile.PL; \fI\f(CI$main_pm_file\fI\fR is the filename of the distribution's main
module, \fI\f(CI$main_module\fI\fR.
.ie n .SS "create_Build_PL( $main_module )"
.el .SS "create_Build_PL( \f(CW$main_module\fP )"
.IX Subsection "create_Build_PL( $main_module )"
This will create the Build.PL for the distribution, and will use the module
named in \fI\f(CI$main_module\fI\fR as the main module of the distribution.
.ie n .SS "Build_PL_guts( $main_module, $main_pm_file )"
.el .SS "Build_PL_guts( \f(CW$main_module\fP, \f(CW$main_pm_file\fP )"
.IX Subsection "Build_PL_guts( $main_module, $main_pm_file )"
This method is called by create_Build_PL and returns text used to populate
Build.PL; \fI\f(CI$main_pm_file\fI\fR is the filename of the distribution's main module,
\&\fI\f(CI$main_module\fI\fR.
.SS "create_Changes( )"
.IX Subsection "create_Changes( )"
This method creates a skeletal Changes file.
.SS "Changes_guts"
.IX Subsection "Changes_guts"
Called by create_Changes, this method returns content for the Changes file.
.ie n .SS "create_README( $build_instructions )"
.el .SS "create_README( \f(CW$build_instructions\fP )"
.IX Subsection "create_README( $build_instructions )"
This method creates the distribution's \s-1README\s0 file.
.SS "README_guts"
.IX Subsection "README_guts"
Called by create_README, this method returns content for the \s-1README\s0 file.
.ie n .SS "create_t( @modules )"
.el .SS "create_t( \f(CW@modules\fP )"
.IX Subsection "create_t( @modules )"
This method creates a bunch of *.t files.  \fI\f(CI@modules\fI\fR is a list of all modules
in the distribution.
.ie n .SS "t_guts( @modules )"
.el .SS "t_guts( \f(CW@modules\fP )"
.IX Subsection "t_guts( @modules )"
This method is called by create_t, and returns a description of the *.t files
to be created.
.PP
The return value is a hash of test files to create.  Each key is a filename and
each value is the contents of that file.
.ie n .SS "xt_guts( @modules )"
.el .SS "xt_guts( \f(CW@modules\fP )"
.IX Subsection "xt_guts( @modules )"
This method is called by create_t, and returns a description of the author
only *.t files to be created in the xt directory.
.PP
The return value is a hash of test files to create.  Each key is a filename and
each value is the contents of that file.
.SS "create_MB_MANIFEST"
.IX Subsection "create_MB_MANIFEST"
This methods creates a \s-1MANIFEST\s0 file using Module::Build's methods.
.SS "create_MI_MANIFEST"
.IX Subsection "create_MI_MANIFEST"
This method creates a \s-1MANIFEST\s0 file using Module::Install's methods.
.PP
Currently runs ExtUtils::MakeMaker's methods.
.SS "create_EUMM_MANIFEST"
.IX Subsection "create_EUMM_MANIFEST"
This method creates a \s-1MANIFEST\s0 file using ExtUtils::MakeMaker's methods.
.ie n .SS "create_MANIFEST( $method )"
.el .SS "create_MANIFEST( \f(CW$method\fP )"
.IX Subsection "create_MANIFEST( $method )"
This method creates the distribution's \s-1MANIFEST\s0 file.  It must be run last,
because all the other create_* functions have been returning the functions they
create.
.PP
It receives a method to run in order to create the \s-1MANIFEST\s0 file. That way it
can create a \s-1MANIFEST\s0 file according to the builder used.
.SS "get_builders( )"
.IX Subsection "get_builders( )"
This methods gets the correct builder(s).
.PP
It is called by \f(CW\*(C`create_build\*(C'\fR, and returns an arrayref with the builders.
.SS "create_build( )"
.IX Subsection "create_build( )"
This method creates the build file(s) and puts together some build
instructions.  The builders currently supported are:
.PP
ExtUtils::MakeMaker
Module::Build
Module::Install
.SS "\fIcreate_ignores()\fP"
.IX Subsection "create_ignores()"
This creates a text file for use as \s-1MANIFEST.SKIP, \s0.cvsignore,
\&.gitignore, or whatever you use.
.SS "\fIignores_guts()\fP"
.IX Subsection "ignores_guts()"
Called by \f(CW\*(C`create_ignores\*(C'\fR, this method returns the contents of the
ignore file.
.SH "HELPER METHODS"
.IX Header "HELPER METHODS"
.SS "verbose"
.IX Subsection "verbose"
\&\f(CW\*(C`verbose\*(C'\fR tells us whether we're in verbose mode.
.ie n .SS "create_file( $fname, @content_lines )"
.el .SS "create_file( \f(CW$fname\fP, \f(CW@content_lines\fP )"
.IX Subsection "create_file( $fname, @content_lines )"
Creates \fI\f(CI$fname\fI\fR, dumps \fI\f(CI@content_lines\fI\fR in it, and closes it.
Dies on any error.
.ie n .SS "progress( @list )"
.el .SS "progress( \f(CW@list\fP )"
.IX Subsection "progress( @list )"
\&\f(CW\*(C`progress\*(C'\fR prints the given progress message if we're in verbose mode.
.ie n .SS "filter_lines_in_file( $filename, @compiled_regexes )"
.el .SS "filter_lines_in_file( \f(CW$filename\fP, \f(CW@compiled_regexes\fP )"
.IX Subsection "filter_lines_in_file( $filename, @compiled_regexes )"
\&\f(CW\*(C`filter_lines_in_file\*(C'\fR goes over a file and removes lines with the received
regexes.
.PP
For example, removing t/boilerplate.t in the \s-1MANIFEST.\s0
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to the bugtracker for this project
on GitHub at: <https://github.com/xsawyerx/module\-starter/issues>. I will be
notified, and then you'll automatically be notified of progress on your bug
as I make changes.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sawyer X, \f(CW\*(C`<xsawyerx@cpan.org>\*(C'\fR
.PP
Andy Lester, \f(CW\*(C`<andy@petdance.com>\*(C'\fR
.PP
C.J. Adams-Collier, \f(CW\*(C`<cjac@colliertech.org>\*(C'\fR
.SH "Copyright & License"
.IX Header "Copyright & License"
Copyright 2005\-2009 Andy Lester and C.J. Adams-Collier, All Rights Reserved.
.PP
Copyright 2010 Sawyer X, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Please note that these modules are not products of or supported by the
employers of the various contributors to the code.
