.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::internals 3"
.TH pod::Prima::internals 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::internals \- Prima internal architecture
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This documents elucidates the internal structures
of the Prima toolkit, its loading considerations,
object and class representation and C coding style.
.SH "Bootstrap"
.IX Header "Bootstrap"
.SS "Initializing"
.IX Subsection "Initializing"
For a perl script, Prima is no more but an average module
that uses DynaLoader. As 'use Prima' code gets executed, a bootstrap
procedure \fIboot_Prima()\fR is called. This procedure initializes
all internal structures and built-in Prima classes. It also
initializes all system-dependent structures, calling
\&\fIwindow_subsystem_init()\fR. After that point Prima module
is ready to use. All wrapping code for built-in functionality 
that can be seen from perl is located into two modules \-
Prima::Const and Prima::Classes.
.SS "Constants"
.IX Subsection "Constants"
Prima defines lot of constants for different purposes 
( e.g. colors, font styles etc). Prima does not
follow perl naming conventions here, on the reason of simplicity.
It is ( arguably ) easier to write cl::White rather than Prima::cl::White.
As perl constants are functions to be called once ( that means that a constant's
value is not defined until it used first ), Prima registers these functions
during boot_Prima stage. As soon as perl code tries to get a constant's value,
an \s-1AUTOLOAD\s0 function is called, which is binded inside Prima::Const.
Constants are widely used both in C and perl code, and are defined in apricot.h
in that way so perl constant definition comes along with C one.
As an example file event constants set is described here.
.PP
.Vb 11
\& apricot.h:
\&   #define FE(const_name) CONSTANT(fe,const_name)
\&   START_TABLE(fe,UV)
\&   #define feRead      1
\&   FE(Read)
\&   #define feWrite     2
\&   FE(Write)
\&   #define feException 4
\&   FE(Exception)
\&   END_TABLE(fe,UV)
\&   #undef FE
\&
\& Const.pm:
\&   package fe; *AUTOLOAD = \e&Prima::Const::AUTOLOAD;
.Ve
.PP
This code creates a structure of \s-1UV\s0's ( unsigned integers ) and
a \fIregister_fe_constants()\fR function, which should be called at
boot_Prima stage. This way feRead becomes C analog to
fe::Read in perl.
.SH "Classes and methods"
.IX Header "Classes and methods"
.SS "Virtual method tables"
.IX Subsection "Virtual method tables"
Prima implementation of classes uses virtual method tables, or VMTs, in order to
make the classes inheritable and their methods overrideable. The VMTs are
usual C structs, that contain pointers to functions.
Set of these functions represents a class. This chapter is not about \s-1OO \s0
programming, you have to find a good book on it if you are not familiar with 
the \s-1OO\s0 concepts, but in short, because Prima is written in C, not in \*(C+,
it uses its own classes and objects implementation, so all object syntax
is devised from scratch.
.PP
Built-in classes already contain all information needed for method 
overloading, but when a new class is derived from existing one, 
new \s-1VMT\s0 is have to be created as well. The actual sub-classing
is performed inside \fIbuild_dynamic_vmt()\fR and \fIbuild_static_vmt()\fR. 
\&\fIgimme_the_vmt()\fR function creates new \s-1VMT\s0 instance on the fly and 
caches the result for every new class that is derived from Prima class.
.SS "C to Perl and Perl to C calling routines"
.IX Subsection "C to Perl and Perl to C calling routines"
Majority of Prima methods is written in C using \s-1XS\s0 perl 
routines, which represent a natural ( from a perl programmer's view ) way 
of C to Perl communication.
perlguts manpage describes these functions and macros.
.PP
\&\s-1NB \-\s0 Do not mix \s-1XS\s0 calls to xs language ( perlxs manpage) \- the latter
is a meta-language for simplification of coding tasks and is not used
in Prima implementation.
.PP
It was decided not to code every function with \s-1XS\s0 calls, but instead
use special wrapper functions ( also called \*(L"thunks\*(R") for every function 
that is called from within perl. Thunks are generated automatically
by gencls tool ( gencls manpage ), and typical Prima method
consists of three functions, two of which are thunks.
.PP
First function, say Class_init(char*), would initialize a class ( for example).
It is written fully in C, so in order to be called from perl code 
a registration step must be taken for a second function,
\&\fIClass_init_FROMPERL()\fR, that would look like
.PP
.Vb 1
\&   newXS( "Prima::Class::init", Class_init_FROMPERL, "Prima::Class");
.Ve
.PP
\&\fIClass_init_FROMPERL()\fR is a first thunk, that translates the parameters
passed from perl to C and the result back from C function to perl.
This step is almost fully automatized, so one never bothers about writing
\&\s-1XS\s0 code, the gencls utility creates the thunks code automatically.
.PP
Many C methods are called from within Prima C code using VMTs, but
it is possible to override these methods from perl code. The
actions for such a situation when a function is called from C but is
an overridden method therefore must be taken. On that occasion the third function
\&\fIClass_init_REDEFINED()\fR is declared. Its task is a reverse from \fIClass_init_FROMPERL()\fR \-
it conveys all C parameters to perl and return values from a perl function
back to C. This thunk is also generated automatically by gencls tool.
.PP
As one can notice, only basic data types can be converted between C and perl,
and at some point automated routines do not help. In such a situation
data conversion code is written manually and is included into core C files.
In the class declaration files these methods are prepended with 'public' or 'weird'
modifiers, when methods with no special data handling needs use 'method' or
\&'static' modifiers.
.PP
\&\s-1NB \-\s0 functions that are not allowed to be seen from perl have 'c_only' modifier,
and therefore do not need thunk wrapping. These functions can nevertheless 
be overridden from C.
.SS "Built-in classes"
.IX Subsection "Built-in classes"
Prima defines the following built-in classes: (in hierarchy order)
.PP
.Vb 10
\&    Object
\&        Component
\&                AbstractMenu
\&                        AccelTable
\&                        Menu
\&                        Popup
\&                Clipboard
\&                Drawable
\&                        DeviceBitmap
\&                        Printer
\&                        Image
\&                                Icon
\&                File
\&                Timer
\&                Widget
\&                        Application
\&                        Window
.Ve
.PP
These classes can be seen from perl with Prima:: prefix.
Along with these, Utils class is defined. Its only 
difference is that it cannot be used as a prototype for an
object, and used merely as a package that binds functions.
Classes that are not intended to be an object prototype
marked with 'package' prefix, when others are marked with 'object'
(see prima-gencls manpage).
.SH "Objects"
.IX Header "Objects"
This chapter deals only with Prima::Object descendants, pure
perl objects are not of interest here, so the 'object' term is
thereafter referenced to Prima::Object descendant object.
Prima employs blessed hashes for its objects.
.SS "Creation"
.IX Subsection "Creation"
All built-in object classes and their descendants can be used for
creating objects with perl semantics. Perl objects are created
by calling \fIbless()\fR, but it is not enough to create
Prima objects. Every Prima::Object descendant class therefore is 
equipped with \fIcreate()\fR method, that allocates object instance 
and calls \fIbless()\fR itself. Parameters that come with \fIcreate()\fR call
are formed into a hash and passed to \fIinit()\fR method, that is also
present on every object. Note the fact that although perl-coded \fIinit()\fR
returns the hash, it not seen in C code. This is a special 
consideration for the methods that have '\s-1HV\s0 * profile' as a last 
parameter in their class declaration. The corresponding thunk 
copies the hash content back to perl stack, using \fIparse_hv()\fR 
and \fIpush_hv()\fR functions.
.PP
Objects can be created from perl by using following code example:
.PP
.Vb 4
\&   $obj = Prima::SampleObject\-> create( 
\&       name  => "Sample",
\&       index => 10,
\&   );
.Ve
.PP
and from C:
.PP
.Vb 6
\&   Handle obj;
\&   HV * profile = newHV();
\&   pset_c( name, "Sample");
\&   pset_i( index, 10);
\&   obj = Object_create("SampleObject", profile);
\&   sv_free(( SV*) profile);
.Ve
.PP
Convenience pset_XX macros assign a value of \s-1XX\s0 type to 
the hash key given as a first parameter, to a hash variable
named profile. \f(CW\*(C`pset_i\*(C'\fR works with integers, \f(CW\*(C`pset_c\*(C'\fR \- with strings, etc.
.SS "Destruction"
.IX Subsection "Destruction"
As well as \fIcreate()\fR method, every object class has \fIdestroy()\fR method.
Object can be destroyed either from perl
.PP
.Vb 1
\&   $obj\-> destroy
.Ve
.PP
or from C
.PP
.Vb 1
\&   Object_destroy( obj);
.Ve
.PP
An object can be automatically destroyed when its reference count
reaches 0. Note that the auto destruction would never happen
if the object's reference count is not lowered after its
creation. The code
.PP
.Vb 1
\&   \-\-SvREFCNT( SvRV( PAnyObject(object)\-> mate));
.Ve
.PP
is required if the object is to be returned to perl.
If that code is not called, the object still could be 
destroyed explicitly, but its reference would still live, 
resulting in memory leak problem.
.PP
For user code it is sufficient to overload \fIdone()\fR and/or \fIcleanup()\fR
methods, or just onDestroy notifications. It is highly recommended
to avoid overloading destroy method, since it can be called 
in re-entrant fashion. When overloading \fIdone()\fR, be prepared that
it may be called inside \fIinit()\fR, and deal with the 
semi-initialized object.
.SS "Data instance"
.IX Subsection "Data instance"
All object data after their creation represent an object instance.
All Prima objects are blessed hashes, and the hash key
_\|_CMATE_\|_ holds a C pointer to a memory which is occupied
by C data instance, or a \*(L"mate\*(R". It keeps all object variables
and a pointer to \s-1VMT.\s0 Every object has its own copy of data instance,
but the VMTs can be shared. In order to reach to C data instance
\&\fIgimme_the_mate()\fR function is used. As a first parameter it accepts
a scalar (SV*), which is expected to be a reference to a hash, and 
returns the C data instance if the scalar is a Prima object.
.SS "Object life stages"
.IX Subsection "Object life stages"
It was decided to divide object life stage in several steps.
Every stage is mirrored into PObject(self)\-> stage integer variable,
which can be one of csXXX constants.
Currently it has six:
.IP "csConstructing" 4
.IX Item "csConstructing"
Initial stage, is set until \fIcreate()\fR is finished.
Right after \fIinit()\fR is completed, \fIsetup()\fR method 
is called.
.IP "csNormal" 4
.IX Item "csNormal"
After \fIcreate()\fR is finished and before \fIdestroy()\fR started.
If an object is csNormal and csConstructing stage,
\&\fIObject_alive()\fR result would be non-zero.
.IP "csDestroying" 4
.IX Item "csDestroying"
\&\fIdestroy()\fR started. This stage includes calling of \fIcleanup()\fR
and \fIdone()\fR routines.
.IP "csFrozen" 4
.IX Item "csFrozen"
\&\fIcleanup()\fR started.
.IP "csFinalizing" 4
.IX Item "csFinalizing"
\&\fIdone()\fR started
.IP "csDead" 4
.IX Item "csDead"
Destroy finished
.SH "Coding techniques"
.IX Header "Coding techniques"
.SS "Accessing object data"
.IX Subsection "Accessing object data"
C coding has no specific conventions, except
when a code is an object method. Object syntax
for accessing object instance data is also fairly standard.
For example, accessing component's field called 'name'
can be done in several ways:
.PP
.Vb 3
\& ((PComponent) self)\-> name; // classic C
\& PComponent(self)\-> name;    // using PComponent() macro from apricot.h
\& var\-> name;                 // using local var() macro
.Ve
.PP
Object code could to be called also in several ways:
.PP
.Vb 3
\& (((PComponent) self)\-> self)\-> get_name( self); // classic C
\& CComponent(self)\-> get_name( self);             // using CComponent() macro from apricot.h
\& my\-> get_name( self);                           // using local my() macro
.Ve
.PP
This calling is preferred, comparing to direct call
of \fIComponent_get_name()\fR, primarily because \fIget_name()\fR is
a method and can be overridden from user code.
.SS "Calling perl code"
.IX Subsection "Calling perl code"
\&\fIcall_perl_indirect()\fR function accepts object, its method name
and parameters list with parameter format string. It has several
wrappers for easier use, which are:
.PP
.Vb 3
\&   call_perl( Handle self, char * method, char * format, ...)
\&   sv_call_perl( SV * object, char * method, char * format, ...)
\&   cv_call_perl( SV * object, SV * code_reference, char * format, ...)
.Ve
.PP
each character of format string represents a parameters type,
and characters can be:
.PP
.Vb 7
\&   \*(Aqi\*(Aq \- integer
\&   \*(Aqs\*(Aq \- char *
\&   \*(Aqn\*(Aq \- float
\&   \*(AqH\*(Aq \- Handle
\&   \*(AqS\*(Aq \- SV *
\&   \*(AqP\*(Aq \- Point
\&   \*(AqR\*(Aq \- Rect
.Ve
.PP
The format string can be prepended with '<' character, in which
case \s-1SV\s0 * scalar ( always scalar, even if code returns nothing
or array ) value is returned. The caller is responsible for
freeing the return value.
.SS "Exceptions"
.IX Subsection "Exceptions"
As descriped in perlguts manpage, G_EVAL flag is used
in \fIperl_call_sv()\fR and \fIperl_call_method()\fR to indicate that
an eventual exception should never be propagated automatically.
The caller checks if the exception was taken place by
evaluating
.PP
.Vb 1
\&        SvTRUE( GvSV( errgv))
.Ve
.PP
statement. It is guaranteed to be false if there was no
exception condition. But in some situations, namely,
when no perl_call_* functions are called or error value
is already assigned before calling code, there is a wrapping
technique that keeps previous error message and looks like:
.PP
.Vb 12
\&    dG_EVAL_ARGS;                       // define arguments
\&    ....
\&    OPEN_G_EVAL;                        // open brackets
\&    // call code
\&    perl_call_method( ... | G_EVAL);    // G_EVAL is necessary
\&    if ( SvTRUE( GvSV( errgv)) {
\&        CLOSE_G_EVAL;                   // close brackets
\&        croak( SvPV_nolen( GvSV( errgv)));// propagate exception
\&        // no code is executed after croak
\&    }
\&    CLOSE_G_EVAL;                       // close brackets
\&    ...
.Ve
.PP
This technique provides workaround to a \*(L"false alarm\*(R" situation, if
SvTRUE( GvSV( errgv)) is true before \fIperl_call_method()\fR.
.SS "Object protection"
.IX Subsection "Object protection"
After the object destroy stage is completed, it is possible 
that object's data instance is gone,
and even simple stage check might cause segmentation fault.
To avoid this, bracketing functions called \f(CW\*(C`protect_object()\*(C'\fR 
and \f(CW\*(C`unprotect_object()\*(C'\fR are used.
\&\fIprotect_object()\fR increments reference count to the object instance,
thus delaying its freeing until decrementing \fIunprotect_object()\fR is called.
.PP
All C code that references to an object must check for its stage
after every routine that switches to perl code, because the object might 
be destroyed inside the call. Typical code example would be like:
.PP
.Vb 3
\&   function( Handle object) {
\&        int stage;
\&        protect_object( object);
\&
\&        // call some perl code
\&        perl_call_method( object, "test", ...);
\&
\&        stage = PObject(object)\-> stage;
\&        unprotect_object( object);
\&        if ( stage == csDead) return;
\&
\&        // proceed with the object
\&   }
.Ve
.PP
Usual C code never checks for object stage before
the call, because \fIgimme_the_mate()\fR function returns \s-1NULL\s0
if object's stage is csDead, and majority of Prima C code
is prepended with this call, thus rejecting invalid references 
on early stage. If it is desired to get the
C mate for objects that are in csDead stage, use \f(CW\*(C`gimme_the_real_mate()\*(C'\fR
function instead.
.SS "init"
.IX Subsection "init"
Object's method \fIinit()\fR is responsible for setting all its initial properties to 
the object, but all code that is executed inside init must be aware that
the object's stage is csConstructing. \fIinit()\fR consists of two parts:
calling of ancestor's \fIinit()\fR and setting properties. Examples are
many in both C and perl code, but in short it looks like:
.PP
.Vb 7
\&   void
\&   Class_init( Handle self, HV * profile)
\&   {
\&      inherited init( self, profile);
\&      my\-> set_index( pget_i( index));
\&      my\-> set_name( pget_c( name));
\&   }
.Ve
.PP
pget_XX macros call \fIcroak()\fR if the profile key is not
present into profile, but the mechanism guarantees that
all keys that are listed in \fIprofile_default()\fR are conveyed to
\&\fIinit()\fR. For explicit checking of key presence \fIpexists()\fR macro
is used, and \fIpdelete()\fR is used for key deletion, although is it not
recommended to use \fIpdelete()\fR inside \fIinit()\fR.
.SS "Object creation and returning"
.IX Subsection "Object creation and returning"
As described is previous sections, there are some
precautions to be taken into account when an object is created inside C code.
A piece of real code from DeviceBitmap.c would serve as an example:
.PP
.Vb 6
\&   static 
\&   Handle xdup( Handle self, char * className)
\&   {
\&      Handle h;
\&      Point s;
\&      PDrawable i;
\&
\&      // allocate a parameters hash
\&      HV * profile = newHV();
\&
\&      // set all necessary arguments
\&      pset_H( owner,        var\-> owner);
\&      pset_i( width,        var\-> w);
\&      pset_i( height,       var\-> h);
\&      pset_i( type,         var\-> monochrome ? imBW : imRGB);
\&
\&      // create object
\&      h = Object_create( className, profile);
\&
\&      // free profile, do not need it anymore
\&      sv_free(( SV *) profile);
\&
\&      i = ( PDrawable) h;
\&      s = i\-> self\-> get_size( h);
\&      i\-> self\-> begin_paint( h);
\&      i\-> self\-> put_image_indirect( h, self, 0, 0, 0, 0, s.x, s.y, s.x, s.y, ropCopyPut);
\&      i\-> self\-> end_paint( h);
\&
\&      // decrement reference count
\&      \-\-SvREFCNT( SvRV( i\-> mate));
\&      return h;
\&   }
.Ve
.PP
Note that all code that would use this \fIxdup()\fR, have to
increase and decrease object's reference count if some perl
functions are to be executed before returning object to perl,
otherwise it might be destroyed before its time.
.PP
.Vb 5
\&       Handle x = xdup( self, "Prima::Image");
\&       ++SvREFCNT( SvRV( PAnyObject(x)\-> mate)); // Code without these
\&       CImage( x)\-> type( x, imbpp1);
\&       \-\-SvREFCNT( SvRV( PAnyObject(x)\-> mate)); // brackets is unsafe
\&       return x;
.Ve
.SS "Attaching objects"
.IX Subsection "Attaching objects"
The newly created object returned from C would be destroyed
due perl's garbage cleaning mechanism right away, unless the
object value would be assigned to a scalar, for example.
.PP
Thus
.PP
.Vb 1
\&    $c = Prima::Object\-> create();
.Ve
.PP
and
    Prima::Object\-> create;
.PP
have different results. But for some classes, namely Widget
ant its descendants, and also for Timer, AbstractMenu, Printer
and Clipboard the code above would have same result \- the 
objects would not be killed. That is because these objects
call \fIComponent_attach()\fR during init-stage, automatically
increasing their reference count. \fIComponent_attach()\fR and 
its reverse \fIComponent_detach()\fR account list of objects, 
attributed to each other. Object can be attached to multiple
objects, but cannot be attached more that once to another object.
.SS "Notifications"
.IX Subsection "Notifications"
All Prima::Component descendants are equipped with the mechanism 
that allows multiple user callbacks routines to be called on 
different events. This mechanism is used heavily in event-driven
programming. \fIComponent_notify()\fR is used to call user notifications,
and its format string has same format as accepted by \fIperl_call_indirect()\fR.
The only difference that it always has to be prepended with '<s', \- 
this way the call success flag is set, and first parameter have to 
be the name of the notification.
.PP
.Vb 2
\&    Component_notify( self, "<sH", "Paint", self);
\&    Component_notify( self, "<sPii", "MouseDown", self, point, int, int);
.Ve
.PP
Notifications mechanism accounts the reference list, similar
to attach-detach mechanism, because all notifications can
be attributed to different objects. The membership in this
list does not affect the reference counting.
.SS "Multiple property setting"
.IX Subsection "Multiple property setting"
Prima::Object method \fIset()\fR is designed to assign
several properties at one time. Sometimes it is
more convenient to write
.PP
.Vb 1
\&   $c\-> set( index => 10, name  => "Sample" );
.Ve
.PP
than to invoke several methods one by one. \fIset()\fR
performs this calling itself, but for performance reasons
it is possible to overload this method and code special 
conditions for multiple assignment. As an example, Prima::Image
type conversion code is exemplified:
.PP
.Vb 10
\&   void
\&   Image_set( Handle self, HV * profile)
\&   {
\&      ...
\&      if ( pexist( type))
\&      {
\&         int newType = pget_i( type);
\&         if ( !itype_supported( newType))
\&            warn("Invalid image type requested (%08x) in Image::set_type", 
\&               newType);
\&         else 
\&            if ( !opt_InPaint)
\&               my\-> reset( self, newType, pexist( palette) ? 
\&                  pget_sv( palette) : my\->get_palette( self));
\&         pdelete( palette);
\&         pdelete( type);
\&      }
\&      ...
\&      inherited set ( self, profile);
\&   }
.Ve
.PP
If type conversion is performed along with palette change, some efficiency
is gained by supplying both 'type' and 'palette' parameters at a time.
Moreover, because ordering of the fields is not determined by default
( although that be done by supplying '_\|_ORDER_\|_' hash key to \fIset()\fR }, it
can easily be discovered that
.PP
.Vb 2
\&    $image\-> type( $a);
\&    $image\-> palette( $b);
.Ve
.PP
and
.PP
.Vb 2
\&    $image\-> palette( $b);
\&    $image\-> type( $a);
.Ve
.PP
produce different results. Therefore it might be only solution to
code \fIClass_set()\fR explicitly.
.PP
If it is desired to specify exact order how atomic properties have to be called,
_\|_ORDER_\|_ anonymous array have to be added to \fIset()\fR parameters.
.PP
.Vb 5
\&   $image\-> set(
\&      owner => $xxx,
\&      type  => 24,
\&      _\|_ORDER_\|_ => [qw( type owner)],
\&   );
.Ve
.SH "API reference"
.IX Header "API reference"
.SS "Variables"
.IX Subsection "Variables"
.IP "primaObjects, PHash" 4
.IX Item "primaObjects, PHash"
Hash with all prima objects, where keys are their data instances
.IP "application, Handle" 4
.IX Item "application, Handle"
Pointer to an application. There can be only one Application
instance at a time, or none at all.
.SS "Macros and functions"
.IX Subsection "Macros and functions"
.IP "dG_EVAL_ARGS" 4
.IX Item "dG_EVAL_ARGS"
Defines variable for $@ value storage
.IP "\s-1OPEN_G_EVAL, CLOSE_G_EVAL\s0" 4
.IX Item "OPEN_G_EVAL, CLOSE_G_EVAL"
Brackets for exception catching
.IP "build_static_vmt" 4
.IX Item "build_static_vmt"
.Vb 1
\& Bool(void * vmt)
.Ve
.Sp
Caches pre-built \s-1VMT\s0 for further use
.IP "build_dynamic_vmt" 4
.IX Item "build_dynamic_vmt"
.Vb 1
\& Bool( void * vmt, char * ancestorName, int ancestorVmtSize)
.Ve
.Sp
Creates a subclass from vmt and caches result under ancestorName key
.IP "gimme_the_vmt" 4
.IX Item "gimme_the_vmt"
.Vb 1
\& PVMT( const char *className);
.Ve
.Sp
Returns \s-1VMT\s0 pointer associated with class by name.
.IP "gimme_the_mate" 4
.IX Item "gimme_the_mate"
.Vb 1
\& Handle( SV * perlObject)
.Ve
.Sp
Returns a C pointer to an object, if perlObject is a reference to a
Prima object. returns nilHandle if object's stage is csDead
.IP "gimme_the_real_mate" 4
.IX Item "gimme_the_real_mate"
.Vb 1
\& Handle( SV * perlObject)
.Ve
.Sp
Returns a C pointer to an object, if perlObject is a reference to a
Prima object. Same as \f(CW\*(C`gimme_the_mate\*(C'\fR, but does not check for
the object stage.
.IP "alloc1" 4
.IX Item "alloc1"
.Vb 1
\& alloc1(type)
.Ve
.Sp
To be used instead (type*)(malloc(sizeof(type))
.IP "allocn" 4
.IX Item "allocn"
.Vb 1
\& allocn(type,n)
.Ve
.Sp
To be used instead (type*)(malloc((n)*sizeof(type))
.IP "alloc1z" 4
.IX Item "alloc1z"
Same as \f(CW\*(C`alloc1\*(C'\fR but fills the allocated memory with zeros
.IP "allocnz" 4
.IX Item "allocnz"
Same as \f(CW\*(C`allocn\*(C'\fR but fills the allocated memory with zeros
.IP "prima_mallocz" 4
.IX Item "prima_mallocz"
Same as \fImalloc()\fR but fills the allocated memory with zeros
.IP "prima_hash_create" 4
.IX Item "prima_hash_create"
.Vb 1
\& PHash(void)
.Ve
.Sp
Creates an empty hash
.IP "prima_hash_destroy" 4
.IX Item "prima_hash_destroy"
.Vb 1
\& void(PHash self, Bool killAll);
.Ve
.Sp
Destroys a hash. If killAll is true, assumes that
every value in the hash is a dynamic memory pointer
and calls \fIfree()\fR on each.
.IP "prima_hash_fetch" 4
.IX Item "prima_hash_fetch"
.Vb 1
\& void*( PHash self, const void *key, int keyLen);
.Ve
.Sp
Returns pointer to a value, if found, nil otherwise
.IP "prima_hash_delete" 4
.IX Item "prima_hash_delete"
.Vb 1
\& void*( PHash self, const void *key, int keyLen, Bool kill);
.Ve
.Sp
Deletes hash key and returns associated value.
if kill is true, calls \fIfree()\fR on the value and returns nil.
.IP "prima_hash_store" 4
.IX Item "prima_hash_store"
.Vb 1
\& void( PHash self, const void *key, int keyLen, void *val);
.Ve
.Sp
Stores new value into hash. If the key is already present, old
value is overwritten.
.IP "prima_hash_count" 4
.IX Item "prima_hash_count"
.Vb 1
\& int(PHash self)
.Ve
.Sp
Returns number of keys in the hash
.IP "prima_hash_first_that" 4
.IX Item "prima_hash_first_that"
.Vb 1
\& void * ( PHash self, void *action, void *params, int *pKeyLen, void **pKey);
.Ve
.Sp
Enumerates all hash entries, calling action procedure on each.
If the action procedure returns true, enumeration stops and the last processed
value is returned. Otherwise nil is returned. action have to be function declared as
.Sp
.Vb 1
\& Bool action_callback( void * value, int keyLen, void * key, void * params);
.Ve
.Sp
params is a pointer to an arbitrary user data
.IP "kind_of" 4
.IX Item "kind_of"
.Vb 1
\& Bool( Handle object, void *cls);
.Ve
.Sp
Returns true, if the object is an exemplar of class cls or its descendant
.IP "\s-1PERL_CALL_METHOD, PERL_CALL_PV\s0" 4
.IX Item "PERL_CALL_METHOD, PERL_CALL_PV"
To be used instead of perl_call_method and perl_call_pv, 
described in perlguts manpage. These functions aliased to a code 
with the workaround of perl bug which emerges when
G_EVAL flag is combined with G_SCALAR.
.IP "eval" 4
.IX Item "eval"
.Vb 1
\& SV *( char *string)
.Ve
.Sp
Simplified \fIperl_eval_pv()\fR call.
.IP "sv_query_method" 4
.IX Item "sv_query_method"
.Vb 1
\& CV * ( SV * object, char *methodName, Bool cacheIt);
.Ve
.Sp
Returns perl pointer to a method searched by a scalar and a name
If cacheIt true, caches the hierarchy traverse result for a speedup.
.IP "query_method" 4
.IX Item "query_method"
.Vb 1
\& CV * ( Handle object, char *methodName, Bool cacheIt);
.Ve
.Sp
Returns perl pointer to a method searched by an object and a name
If cacheIt true, caches the hierarchy traverse result for a speedup.
.IP "call_perl_indirect" 4
.IX Item "call_perl_indirect"
.Vb 2
\& SV * ( Handle self, char *subName, const char *format, Bool cdecl, 
\&        Bool coderef, va_list params);
.Ve
.Sp
Core function for calling Prima methods. Is used by the following three 
functions, but is never called directly. Format is described in \f(CW\*(C`Calling perl code\*(C'\fR
section.
.IP "call_perl" 4
.IX Item "call_perl"
.Vb 1
\& SV * ( Handle self, char *subName, const char *format, ...);
.Ve
.Sp
Calls method of an object pointer by a Handle
.IP "sv_call_perl" 4
.IX Item "sv_call_perl"
.Vb 1
\& SV * ( SV * mate, char *subName, const char *format, ...);
.Ve
.Sp
Calls method of an object pointed by a SV*
.IP "cv_call_perl" 4
.IX Item "cv_call_perl"
.Vb 1
\& SV * ( SV * mate, Sv * coderef, const char *format, ...);
.Ve
.Sp
Calls arbitrary perl code with mate as first parameter.
Used in notifications mechanism.
.IP "Object_create" 4
.IX Item "Object_create"
.Vb 1
\& Handle( char * className, HV * profile);
.Ve
.Sp
Creates an exemplar of className class with parameters 
in profile. Never returns nilHandle, throws an exception
instead.
.IP "create_object" 4
.IX Item "create_object"
.Vb 1
\& void*( const char *objClass, const char *format, ...);
.Ve
.Sp
Convenience wrapper to Object_create. Uses format 
specification that is described in \f(CW\*(C`Calling perl code\*(C'\fR.
.IP "create_instance" 4
.IX Item "create_instance"
.Vb 1
\& Handle( const char * className)
.Ve
.Sp
Convenience call to \f(CW\*(C`Object_create\*(C'\fR with parameters in hash 'profile'.
.IP "Object_destroy" 4
.IX Item "Object_destroy"
.Vb 1
\& void( Handle self);
.Ve
.Sp
Destroys object. One of few Prima function that can be called in 
re-entrant fashion.
.IP "Object_alive" 4
.IX Item "Object_alive"
.Vb 1
\& void( Handle self);
.Ve
.Sp
Returns non-zero is object is alive, 0 otherwise.
In particular, current implementation returns 1 if
object's stage is csNormal and 2 if it is csConstructing.
Has virtually no use in C, only used in perl code.
.IP "protect_object" 4
.IX Item "protect_object"
.Vb 1
\& void( Handle obj);
.Ve
.Sp
restricts object pointer from deletion after \fIObject_destroy()\fR.
Can be called several times on an object. 
Increments Object. protectCount.
.IP "unprotect_object" 4
.IX Item "unprotect_object"
.Vb 1
\& void( Handle obj);
.Ve
.Sp
Frees object pointer after Object. protectCount hits zero.
Can be called several times on an object.
.IP "parse_hv" 4
.IX Item "parse_hv"
.Vb 1
\& HV *( I32 ax, SV **sp, I32 items, SV **mark, int expected, const char *methodName);
.Ve
.Sp
Transfers arguments in perl stack to a newly created \s-1HV\s0 and returns it.
.IP "push_hv" 4
.IX Item "push_hv"
.Vb 1
\& void ( I32 ax, SV **sp, I32 items, SV **mark, int callerReturns, HV *hv);
.Ve
.Sp
Puts all hv contents back to perl stack.
.IP "push_hv_for_REDEFINED" 4
.IX Item "push_hv_for_REDEFINED"
.Vb 1
\& SV **( SV **sp, HV *hv);
.Ve
.Sp
Puts hv content as arguments to perl code to be called
.IP "pop_hv_for_REDEFINED" 4
.IX Item "pop_hv_for_REDEFINED"
.Vb 1
\& int ( SV **sp, int count, HV *hv, int shouldBe);
.Ve
.Sp
Reads result of executed perl code and stores them into hv.
.IP "pexist" 4
.IX Item "pexist"
.Vb 1
\& Bool(char*key)
.Ve
.Sp
Return true if a key is present into hash 'profile'
.IP "pdelete" 4
.IX Item "pdelete"
.Vb 1
\& void(char*key)
.Ve
.Sp
Deletes a key in hash 'profile'
.IP "pget_sv, pget_i, pget_f, pget_c, pget_H, pget_B" 4
.IX Item "pget_sv, pget_i, pget_f, pget_c, pget_H, pget_B"
.Vb 1
\& TYPE(char*key)
.Ve
.Sp
Returns value of ( SV*, int, float, char*, Handle or Bool)
that is associated to a key in hash 'profile'. Calls \fIcroak()\fR
if the key is not present.
.IP "pset_sv, pset_i, pset_f, pset_c, pset_H" 4
.IX Item "pset_sv, pset_i, pset_f, pset_c, pset_H"
.Vb 1
\& void( char*key, TYPE value)
.Ve
.Sp
Assigns a value to a key in hash 'profile' and increments
reference count to a newly created scalar.
.IP "pset_b" 4
.IX Item "pset_b"
.Vb 1
\& void( char*key, void* data, int length)
.Ve
.Sp
Assigns binary data to a key in hash 'profile' and increments
reference count to a newly created scalar.
.IP "pset_sv_noinc" 4
.IX Item "pset_sv_noinc"
.Vb 1
\& void(char* key, SV * sv)
.Ve
.Sp
Assigns scalar value to a key  in hash 'profile' without
reference count increment.
.IP "duplicate_string" 4
.IX Item "duplicate_string"
.Vb 1
\& char*( const char *)
.Ve
.Sp
Returns copy of a string
.IP "list_create" 4
.IX Item "list_create"
.Vb 1
\& void ( PList self, int size, int delta);
.Ve
.Sp
Creates a list instance with a static List structure.
.IP "plist_create" 4
.IX Item "plist_create"
.Vb 1
\& PList( int size, int delta);
.Ve
.Sp
Created list instance and returns newly allocated List structure.
.IP "list_destroy" 4
.IX Item "list_destroy"
.Vb 1
\& void( PList self);
.Ve
.Sp
Destroys list data.
.IP "plist_destroy" 4
.IX Item "plist_destroy"
.Vb 1
\& void ( PList self);
.Ve
.Sp
Destroys list data and frees list instance.
.IP "list_add" 4
.IX Item "list_add"
.Vb 1
\& int( PList self, Handle item);
.Ve
.Sp
Adds new item into a list, returns its index or \-1
on error.
.IP "list_insert_at" 4
.IX Item "list_insert_at"
.Vb 1
\& int ( PList self, Handle item, int pos);
.Ve
.Sp
Inserts new item into a list at a given position, returns
its position or \-1 on error.
.IP "list_at" 4
.IX Item "list_at"
.Vb 1
\& Handle ( PList self, int index);
.Ve
.Sp
Returns items that is located at given index or nilHandle 
if the index is out of range.
.IP "list_delete" 4
.IX Item "list_delete"
.Vb 1
\& void( PList self, Handle item);
.Ve
.Sp
Removes the item from list.
.IP "list_delete_at" 4
.IX Item "list_delete_at"
.Vb 1
\& void( PList self, int index);
.Ve
.Sp
Removes the item located at given index from a list.
.IP "list_delete_all" 4
.IX Item "list_delete_all"
.Vb 1
\& void ( PList self, Bool kill);
.Ve
.Sp
Removes all items from the list. If kill is true,
calls \fIfree()\fR on every item before.
.IP "list_first_that" 4
.IX Item "list_first_that"
.Vb 1
\& int( PList self, void * action, void * params);
.Ve
.Sp
Enumerates all list entries, calling action procedure on each.
If action returns true, enumeration stops and the index is returned.
Otherwise \-1 is returned. action have to be a function declared as
.Sp
.Vb 1
\& Bool action_callback( Handle item, void * params);
.Ve
.Sp
params is a pointer to an arbitrary user data
.IP "list_index_of" 4
.IX Item "list_index_of"
.Vb 1
\& int( PList self, Handle item);
.Ve
.Sp
Returns index of an item, or \-1 if the item is not in the list.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima
