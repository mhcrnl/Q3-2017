.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDL::Graphics::Prima::Axis 3"
.TH PDL::Graphics::Prima::Axis 3 "2015-11-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Graphics::Prima::Axis \- class for axis handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use PDL::Graphics::Prima::Simple;
\& 
\& # Specify details for an axis during plot construction:
\& plot(
\&     \-data => ds::Pair($x, $y),
\&     
\&     # Details for x\-axis:
\&     x => {
\&         # Scaling can be either sc::Log or sc::Linear (the default)
\&         scaling => sc::Log,
\&         # Labels are optional:
\&         label => \*(AqTime [s]\*(Aq,
\&         format_tick => sub {
\&            sprintf("%lf", $_[0])
\&         },
\&     },
\&     # Details for y\-axis:
\&     y => {
\&         # explicitly specify min/max if you like
\&         min => 0,
\&         max => 100,
\&         onChangeLabel => sub {
\&             my $self = shift;
\&             print "You changed the label to ", $self\->label, "\en";
\&         },
\&     },
\& );
\& 
\& # Get the current x\-min:
\& my $x_min = $plot\->x\->min;
\& # Get the x\-max and inquire if it\*(Aqs autoscaling:
\& my ($x_min, $is_auto) = $plot\->x\->min;
\& # Set the current y\-min to \-5:
\& $plot\->y\->min(\-5);
\& # Turn on x min autoscaling:
\& $plot\->x\->min(lm::Auto);
\& # Stop autoscaling, use the current max (deprecated):
\& $plot\->x\->max($plot\->x\->max);
\& 
\& # Note: All changes to min/max values
\& # fire the ChangeBounds notification
\& 
\& # Get the x\-label:
\& my $x_label = $plot\->x\->label;
\& # Set the x\-label:
\& $plot\->x\->label($new_label);
\& 
\& # Note: All changes to the label
\& # fire the ChangeLabel notification
\& 
\& # Conversion among real, relative, and pixel positions,
\& # useful for plotType drawing operations
\& $x_rels = $plot\->x\->reals_to_relatives($xs);
\& $xs = $plot\->x\->relatives_to_reals($x_rels);
\& $x_pixels = $plot\->x\->relatives_to_pixels($x_rels);
\& $x_rels = $plot\->x\->pixels_to_relatives($x_pixels);
\& $x_pixels = $plot\->x\->reals_to_pixels($xs);
\& $xs = $plot\->x\->pixels_to_reals($x_pixels);
\& 
\& # Get the current scaling object/class:
\& $x_scaling = $plot\->x\->scaling;
\& # Set the current scaling object/class:
\& $plot\->x\->scaling(sc::Log);
\&
\& # Note: All changes to the scaling
\& # fire the ChangeScaling notification
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`PDL::Graphics::Prima\*(C'\fR handles the axes with full Prima objects for both the
x\- and the y\-axes. Although the current implementation is not terribly
flexible, it is still quite useful and poweful, and ripe for extensions and
improvements.
.PP
The axis objects manage a number of different functions and capabilities.
They keep track of their own minimum and maximum values, for example, as
well as the axis labels. They are also responsible for drawing tick marks,
tick labels, and axis labels during plot drawing operations. It should be
noted, however, that the scaling object or class
is responsible for determining the tick locations.
.PP
Axes provide the mechanism for converting data coordinates to pixel
coordinates, and vice versa.
.PP
One of the more subtle issues involved with axes is that they are responsible
for reporting the space they need for their tick and axis labels. These
calculations help ensure that numbers do not get clipped simply because they
do not have enough space (although the functionality could be improved).
.SH "Properties"
.IX Header "Properties"
.SS "min, max"
.IX Subsection "min, max"
Gets/sets the the individual extrema. The return value depends upon the calling
context. If requested in scalar context, you simply get the current calculated
extreme value. If requested in list context, you get two return values,
the first being the extremum and the second being a boolean value
indicating whether or not the Auto flag is set.
.SS "minmax"
.IX Subsection "minmax"
Pair accessor. You can set the min/max values in one shot with this function,
and you will get a two-element list if you call it as a getter. For example:
.PP
.Vb 2
\& my $piddle = get_data;
\& $graph_widget\->x\->minmax($piddle\->minmax);
\& 
\& # ...
\& 
\& print "The x min/max values are ", join(\*(Aq, \*(Aq, $graph_widget\->x\->minmax), "\en";
.Ve
.PP
Note that if you are setting both the min and the max to autoscaling, 
calling minmax(lm::Auto, lm::Auto) is faster than calling min(lm::Auto)
followed by max(lm::Auto).
.SS "scaling"
.IX Subsection "scaling"
Gets or returns the axis' scaling object. You can change the scaling using
this example with something like this:
.PP
.Vb 2
\& # Switch to logarithmic scaling:
\& $widget\->x\->scaling(sc::Log);
.Ve
.PP
Note, however, that some scalings allow values that are not permissible in
others. For example, Linear scaling allows negative values but Logarithmic
scaling does not. At the moment, if you try to switch to Logarithmic scaling
without ensuring that the current min and max are positive, this will die
telling you that negative values are not allowed.
.PP
For more details about scaling, see PDL::Graphics::Prima::Scaling.
.SS "label"
.IX Subsection "label"
Gets or sets the axis' label. You can remove the label by passing an empty
string or by explicitly passing an undefined value. Adding a label will cause
the viewing rectangle to shrink so that your widget can accomodate the label
dimensions.
.SH "NOTIFICATIONS"
.IX Header "NOTIFICATIONS"
Axis widgets provide a handful of notifications that are useful for handling
user or other interaction.
.SS "ChangeBounds"
.IX Subsection "ChangeBounds"
This event is fired immediately after the bounds are changed, whether the
change is due to the user's mouse interaction or by a setter call of \*(L"min\*(R",
\&\*(L"max\*(R", or \*(L"minmax\*(R".
.SS "ChangeScaling"
.IX Subsection "ChangeScaling"
This event is fired immediately after the axis' scaling type is changed
(i.e. from linear to logarithmic).
.SS "ChangeLabel"
.IX Subsection "ChangeLabel"
This event is fired immediately after setting, changing, or removing the
axis' label.
.SH "METHODS"
.IX Header "METHODS"
.SS "reals_to_relatives, relatives_to_reals"
.IX Subsection "reals_to_relatives, relatives_to_reals"
.Vb 1
\& Signature: $axis\->reals_to_relatives($data, [$min, $max])
.Ve
.PP
Converts real values (i.e. numbers in the set of reals, as opposed to the set
of complex numbers, or integers) to their relative pixel positions within the
plot window, where by relative, I mean the result is a number between 0 and 1.
This takes the scaling (logarithmic, linear, etc) into account. The min and
the max are optional and the axis's min and max values will be used if a min
and max are not supplied.
.PP
Actually, it can be less than 0 or greater than 1. If you have a real number
that is less than the plot's minimum value, it will have a negative relative
value, and if you have a real number that is greater than the plot's maximum
value, it will have a relative number greater than 1. This is probably better
understood through a few examples.
.PP
Suppose your graph has a min/max of 0 and 100. For linear scaling, a value
of 50 would have a relative position of 0.5, a value of 10 would have a relative
position of 0.1, 200 would have a relative position of 2, and \-10 would have a
relative position of \-0.1.
.PP
If you do not provide a min or a max value, the axis's current min and max
are used by default.
.SS "pixels_to_relatives, relatives_to_pixels"
.IX Subsection "pixels_to_relatives, relatives_to_pixels"
Converts relative plot positions to their on-widget pixel locations. The
widget's pixel origin is taken to be zero at the lower left corner of the
widget, so this both rescales the numbers and includes the appropriate offset.
.SS "reals_to_pixels, pixels_to_reals"
.IX Subsection "reals_to_pixels, pixels_to_reals"
A convenience function to convert real values directly to on-widget pixel
locations. This simply combines the previous two documented functions.
.SS "draw"
.IX Subsection "draw"
Draws the axis, including the bounding box, ticks, and tick labels
.SS "update_edges"
.IX Subsection "update_edges"
Updates the cached edge data and initiates a recomputation
of the autoscaling, if appropriate. This is usually triggered by a window
resize, a new or modified dataset, or a label change, and it does not change
.PP
This function's semantics (or even its presence) is likely to
change in the future, so do not depend on its behavior unless you are willing
to keep on top of updates to this library.
.SS "recalculate_edge_requirements"
.IX Subsection "recalculate_edge_requirements"
Calculates the edge requirements to draw tick labels based on the current
min/max. This \fBdoes not\fR initiate an autoscaling recalculation, precisely
because it is meant to be used \fBwithin\fR that calculation. An identical
calculation is performed during drawing operations (though that may change
in the future).
.SH "TODO"
.IX Header "TODO"
.IP "better autoscaling for function datasets" 4
.IX Item "better autoscaling for function datasets"
The ds::Func dataset does not get proper y\-axis spacing. This needs to be
figured out an fixed.
.IP "tick customization" 4
.IX Item "tick customization"
Lots more customization, including inward vs outward tick marks, more automatic
tick algorithms (including customizable ticks), or even no ticks. Actually,
the tick algorithms are controlled by the Scaling object/class, not the Axis
class. But still. Other tick properties, like the font size and style, need to
be adjustable.
.IP "hard minima/maxima" 4
.IX Item "hard minima/maxima"
Add abs_min, abs_max, etc, which means "*Never* make this axis less than than
(or greater than) specified value.
.IP "multiple axes" 4
.IX Item "multiple axes"
Allow for multiple x\- and y\-axes. This is likely to impact PDL::Graphics::Prima
more than this module, but the upshot is that instead of calling an axis \f(CW\*(C`x\*(C'\fR
or \f(CW\*(C`y\*(C'\fR, any key prefixed with \f(CW\*(C`x\*(C'\fR or \f(CW\*(C`y\*(C'\fR would be assumed to be an axis
specification. This way, you could have:
.Sp
.Vb 10
\& plot(
\&     ...
\&     x_power => axis::log(\*(Aqx\*(Aq
\&         , on => \*(Aqbottom\*(Aq
\&         , label => \*(AqPower (W)\*(Aq
\&         , x_decibels => sub {
\&             # computes the decibels when the min/max Power is changed:
\&             my ($self, $power) = @_;
\&             # Assume a normalizatin of 1 Watt:
\&             return log($power)/log(10);
\&         },
\&     ),
\&     x_decibels => axis::linear(\*(Aqx\*(Aq
\&         , on => \*(Aqtop\*(Aq
\&         , label => \*(AqDecibels (dB)\*(Aq
\&         , x_intensity => sub {
\&             # Computes the power when the min/max decibels are changed:
\&             my ($self, $decibels) = @_;
\&             return 10**$decibels;
\&         },
\&     ),
\& );
.Ve
.Sp
This would have logarithmic Power scaling tick marks on the bottom axis and
linear Decibel scaling tick marks on the top, with proper conversion functions
so that if the min or max of one changes, the min/max of the other is properly
changed as well. However, this code sketch suggests an interface that is far
from finalized, and the implementation details (especially regarding autoscaling
and collation) will require some major work in order to make this function
correctly.
.IP "special drawing" 4
.IX Item "special drawing"
When drawing, I need to have the axes query the Scaling to see if any special
drawing needs to happen. I am thinking at the moment about broken axes.
.IP "better high-zoom handling" 4
.IX Item "better high-zoom handling"
Right now when a user zooms in very narrowly on some nonzero region, the tick
labels get longer and longer. It would be nice to have some graceful way of
only displaying the significant digits. For example, rather than tick labels
of 12.279850. 12.279855, 12.279860, 12.279865, and 12.279870, perhaps the *axis*
label could say \*(L"<thing> as 12.2798xx <units>\*(R" and then the tick labels would
just be 50, 55, 60, 65, and 70. This, again, would require some interaction with
the scaling to know what to do. Also, it would be difficult to get this to play
nicely with the format_tick capabilities just added.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Mertens (dcmertens.perl@gmail.com)
.SH "ADDITIONAL MODULES"
.IX Header "ADDITIONAL MODULES"
Here is the full list of modules in this distribution:
.IP "PDL::Graphics::Prima" 4
.IX Item "PDL::Graphics::Prima"
Defines the Plot widget for use in Prima applications
.IP "PDL::Graphics::Prima::Axis" 4
.IX Item "PDL::Graphics::Prima::Axis"
Specifies the behavior of axes (but not the scaling)
.IP "PDL::Graphics::Prima::DataSet" 4
.IX Item "PDL::Graphics::Prima::DataSet"
Specifies the behavior of DataSets
.IP "PDL::Graphics::Prima::Limits" 4
.IX Item "PDL::Graphics::Prima::Limits"
Defines the lm:: namespace
.IP "PDL::Graphics::Prima::Palette" 4
.IX Item "PDL::Graphics::Prima::Palette"
Specifies a collection of different color palettes
.IP "PDL::Graphics::Prima::PlotType" 4
.IX Item "PDL::Graphics::Prima::PlotType"
Defines the different ways to visualize your data
.IP "PDL::Graphics::Prima::ReadLine" 4
.IX Item "PDL::Graphics::Prima::ReadLine"
Encapsulates all interaction with the Term::ReadLine family of
modules.
.IP "PDL::Graphics::Prima::Scaling" 4
.IX Item "PDL::Graphics::Prima::Scaling"
Specifies different kinds of scaling, including linear and logarithmic
.IP "PDL::Graphics::Prima::Simple" 4
.IX Item "PDL::Graphics::Prima::Simple"
Defines a number of useful functions for generating simple and not-so-simple
plots
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Unless otherwise stated, all contributions in code and documentation are
copyright (c) their respective authors, all rights reserved.
.PP
Portions of this module's code are copyright (c) 2011 The Board of
Trustees at the University of Illinois.
.PP
Portions of this module's code are copyright (c) 2011\-2013 Northwestern
University.
.PP
Portions of this module's code are copyright (c) 2013\-2014 Dickinson
College.
.PP
This module's documentation is copyright (c) 2011\-2014 David Mertens.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
