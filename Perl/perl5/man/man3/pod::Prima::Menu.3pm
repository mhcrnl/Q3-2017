.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Prima::Menu 3"
.TH pod::Prima::Menu 3 "2015-09-13" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::Menu \- pull\-down and pop\-up menu objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Prima;
\&   use Prima::Application;
\&
\&   my $window = Prima::Window\-> new(
\&        menuItems => [
\&           [ \*(Aq~File\*(Aq => [
\&              [ \*(Aq~Open\*(Aq, \*(AqCtrl+O\*(Aq, \*(Aq^O\*(Aq, \e&open_file ],
\&              [ \*(Aq\-save_file\*(Aq, \*(Aq~Save\*(Aq, km::Ctrl | ord(\*(Aqs\*(Aq), sub { save_file() } ],
\&              [],
\&              [ \*(Aq~Exit\*(Aq, \*(AqAlt+X\*(Aq, \*(Aq@X\*(Aq, sub { exit } ],
\&           ]],
\&           [ \*(Aq~Options\*(Aq => [
\&              [ \*(Aq*option1\*(Aq  => \*(AqCheckable option\*(Aq => sub { $_[0]\-> menu\-> toggle( $_[1]) }],
\&              [ \*(Aq*@option2\*(Aq => \*(AqCheckable option\*(Aq => sub {}], # same
\&           ]],
\&           [],
\&           [ \*(Aq~Help\*(Aq => [
\&              [ \*(AqShow help\*(Aq => sub { $::application\-> open_help($0); }],
\&           ]],
\&        ],
\&    );
\&
\&    sub open_file 
\&    {
\&        # enable \*(Aqsave\*(Aq menu item
\&        $window\-> menu\-> save_file\-> enable;
\&    }
\&
\&    $window\-> popupItems( $window\-> menuItems);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The document describes interfaces of Prima::AbstractMenu
class, and its three descendants \- Prima::Menu, Prima::Popup,
and Prima::AccelTable, all aimed at different targets.
Prima::AbstractMenu is a descendant of Prima::Component class,
and its specialization is handling of menu items, held in
a tree-like structure. Descendants of Prima::AbstractMenu
are designed to be attached to widgets and windows, to serve
as hints for the system-dependent pop-up and pull-down menus.
.SH "USAGE"
.IX Header "USAGE"
.SS "Menu items"
.IX Subsection "Menu items"
The central point of functionality in Prima::AbstractMenu\-derived classes 
and their object instances ( further referred as 'menu classes' 
and 'menu objects'), is handling of a complex structure, contained in
\&\f(CW\*(C`::items\*(C'\fR property. This property is special in that its structure
is a tree-like array of scalars, each of whose is either a description of
a menu item or a reference to an array.
.PP
Parameters of an array must follow a special syntax, so the property
input can be parsed and assigned correctly. In general, the syntax is
.PP
.Vb 5
\&   $menu\-> items( [
\&      [ menu item description ],
\&      [ menu item description ],
\&      ...
\&   ]);
.Ve
.PP
where 'menu item description' is an array of scalars,
that can hold from 0 up to 6 elements. Each menu item has six fields, 
that qualify a full description of a menu item; 
the shorter arrays are shortcuts,
that imply default or special cases. These base six fields are:
.IP "Menu item name" 4
.IX Item "Menu item name"
A string identifier.  Menu items can be accessed individually by their names,
and the following fields can be managed by calling elemental properties, that
require an item name. If not given, or empty, item name is assigned a string in
a form '#ID' where \s-1ID\s0 is the unique integer value within the menu object.
.Sp
IDs are set for each menu item, disregarding whether they have names or not.
Any menu item can be uniquely identifed by its \s-1ID\s0 value, by supplying the '#ID'
string, in the same fashion as named menu items.  When creating or copying menu
items, names in format '#ID' are not accepted, and treated as if an empty
string is passed. When copying menu items to another menu object, all menu
items to be copied change their IDs, but explicitly set names are preserved.
Since the anonymous menu items do not have name, their auto-generated names
change also.
.Sp
If the name is prepended by '\-', '*', or '@' characters, the characters are not
treated as part of the name but as indicator that the item is disabled  ( '\-'
character ), checked ( '*' character ), or has an auto-toggle flag ('@').
This syntax is valid only for \f(CW\*(C`::items\*(C'\fR and \f(CW\*(C`insert()\*(C'\fR functions, not for
\&\f(CW\*(C`set_variable()\*(C'\fR method.
.IP "Menu text / menu image" 4
.IX Item "Menu text / menu image"
A non-separator menu item can be visualized either as a 
text string or an image. These options are exclusive to each other, 
and therefore occupy same field. Menu text is an arbitrary string,
with with ~ ( tilde ) quoting for a shortcut character, that the
system uses as a hot key during menu navigation.
Menu image is a Prima::Image object of no particular color
space and dimensions.
.Sp
Menu text in menu item is accessible via the \f(CW\*(C`::text\*(C'\fR property,
and menu image via the \f(CW\*(C`::image\*(C'\fR property. These can not accept
or return sensible arguments simultaneously.
.IP "Accelerator text" 4
.IX Item "Accelerator text"
An alternate text string, appearing together with a menu item 
or a menu image, usually serving as a description to the hot key,
associated with a menu item. For example, if a hot key to
a menu item is combination of 'enter' and 'control' keys, then
usually accelerator text is 'Ctrl+Enter' string.
.Sp
Accelerator text in menu item is accessible via \f(CW\*(C`::accel\*(C'\fR
property.
.Sp
\&\s-1NB:\s0 There is \f(CW\*(C`Prima::KeySelector::describe\*(C'\fR function, that converts
a key value to a string in human-readable format.
.IP "Hot key" 4
.IX Item "Hot key"
An integer value, combined from either \f(CW\*(C`kb::XXX\*(C'\fR constant or
a character index with modificator key values ( \f(CW\*(C`km::XXX\*(C'\fR constant ).
This representation format is not that informative as three-integer
key event format (\s-1CODE,KEY,MOD\s0), described in Prima::Widget.
However, these formats are easily converted to each other:
\&\s-1CODE,KEY,MOD\s0 is translated to \s-1INTEGER\s0 format by \f(CW\*(C`translate_key()\*(C'\fR
method. The reverse operation is not needed for \f(CW\*(C`Prima::AbstractMenu\*(C'\fR
functionality and is performed by \f(CW\*(C`Prima::KeySelector::translate_codes\*(C'\fR
method.
.Sp
The integer value can be given in a some more readable format 
when submitting to \f(CW\*(C`::items\*(C'\fR. Character and F\-keys (from F1 to F16)
can be used literally, without \f(CW\*(C`kb::\*(C'\fR prepending, and the modificator
keys can be hinted as prefix characters: km::Shift as '#',
km::Ctrl as '^' and km::Alt as '@'. This way, combination of 
\&'control' and 'G' keys can be expressed as \f(CW\*(Aq^G\*(Aq\fR literal,
and 'control'+'shift'+'F10' \- as \f(CW\*(Aq^#F10\*(Aq\fR.
.Sp
Hot key in menu item is accessible via \f(CW\*(C`::key\*(C'\fR
property. The property does accept literal key format,
described above.
.Sp
A literal key string can be converted to 
an integer value by \f(CW\*(C`translate_shortcut\*(C'\fR method.
.Sp
When the user presses the key combination, that matches to hot key
entry in a menu item, its action is triggered.
.IP "Action" 4
.IX Item "Action"
Every non-separator and non-submenu item is destined to perform an action. The
action can be set either as an anonymous sub, or as string with name of a
method on the owner of a menu object. Both have their niche of usage, and both
are supplied with three parameters, when called \- the owner of a menu object, 
the name of a menu item, that triggered the action, and the menu checked status:
.Sp
.Vb 12
\&   Prima::MainWindow\-> new(
\&        menuItems => [
\&                [\*(Aq@item\*(Aq, \*(AqTest\*(Aq, 
\&                sub {
\&                    my ( 
\&                       $window,  # MainWindow
\&                       $item,    # \*(Aqitem\*(Aq
\&                       $checked  # MainWindow\->men(\*(Aqitem\*(Aq)\->checked
\&                    ) = @_;
\&                }],
\&        ]
\&   );
.Ve
.Sp
Action scalar in menu item is accessible via \f(CW\*(C`::action\*(C'\fR
property.
.Sp
A special built-in action can automatically toggle a menu item, instead of
an explicit call
.Sp
.Vb 1
\&   $window\->menu\->toggle($item)
.Ve
.Sp
To achieve this, add '@' character to the menu item name (see \*(L"Menu item name\*(R").
.IP "User data" 4
.IX Item "User data"
At last, a non-separator and non-submenu menu item can hold
an arbitrary scalar value, the 'user data' field.
The toolkit does not use this field, leaving that to 
the programmer.
.Sp
User data scalar in menu item is accessible via \f(CW\*(C`::data\*(C'\fR
property.
.PP
Syntax of \f(CW\*(C`::items\*(C'\fR does not provide 'disabled' and 'checked'
states for a menu item as separate fields. These states
can be set by using '\-' and '*' prefix characters, as described above,
in \*(L"Menu item name\*(R". They also can be assigned on per-item
basis via \f(CW\*(C`::enabled\*(C'\fR and \f(CW\*(C`::checked\*(C'\fR properties.
.PP
All these fields qualify a most common menu item, 
that has text, shortcut key and an action \- a 'text item'.
However, there are also two other types of menu items \-
a sub-menu and separator. The type of a menu items
can not be changed except by full menu item tree change 
functions ( \f(CW\*(C`::items\*(C'\fR, \f(CW\*(C`remove()\*(C'\fR, \f(CW\*(C`insert()\*(C'\fR.
.PP
Sub-menu item can hold same references as text menu item does,
except the action field. Instead, the action field is used for
a sub-menu reference scalar, pointing to another set of
menu item description arrays. From that point of view, syntax of \f(CW\*(C`::items\*(C'\fR
can be more elaborated and shown as
.PP
.Vb 3
\&   $menu\-> items( [
\&      [ text menu item description ],
\&      [ sub\-menu item description [
\&
\&         [ text menu item description ],
\&         [ sub\-menu item description [
\&             [ text menu item description ],
\&             ...
\&         ]
\&         [ text menu item description ],
\&         ...
\&      ] ],
\&      ...
\&   ]);
.Ve
.PP
Separator items do not hold any fields, except name.
Their purpose is to hint a logical division of menu items
by the system, which visualizes them usually as non-selectable
horizontal lines.
.PP
In menu bars, the first separator item met by parser is
treated differently. It serves as a hint, that the following 
items must be shown in the right corner of a menu bar, contrary
to the left-adjacent default layout. Subsequent separator items
in a menu bar declaration can be either shown as a vertical 
division bars, or ignored.
.PP
With these menu items types and fields, it is possible 
to construct the described above menu description arrays.
An item description array can hold from 0 to 6 scalars,
and each combination is treated differently.
.IP "six \- [ \s-1NAME, TEXT/IMAGE, ACCEL, KEY, ACTION/SUBMENU, DATA \s0]" 4
.IX Item "six - [ NAME, TEXT/IMAGE, ACCEL, KEY, ACTION/SUBMENU, DATA ]"
Six-scalar array is a fully qualified text-item description.
All fields correspond to the described above scalars.
.IP "five [ \s-1NAME, TEXT/IMAGE, ACCEL, KEY, ACTION/SUBMENU \s0]" 4
.IX Item "five [ NAME, TEXT/IMAGE, ACCEL, KEY, ACTION/SUBMENU ]"
Same as six-scalar syntax, but without \s-1DATA\s0 field.
If \s-1DATA\s0 is skipped it is \f(CW\*(C`undef\*(C'\fR by default.
.IP "four [ \s-1TEXT/IMAGE, ACCEL, KEY, ACTION/SUBMENU \s0]" 4
.IX Item "four [ TEXT/IMAGE, ACCEL, KEY, ACTION/SUBMENU ]"
Same as five-scalar syntax, but without \s-1NAME\s0 field.
When \s-1NAME\s0 is skipped it is assigned to an unique string
within menu object.
.IP "three [ \s-1NAME, TEXT/IMAGE, ACTION/SUBMENU \s0]" 4
.IX Item "three [ NAME, TEXT/IMAGE, ACTION/SUBMENU ]"
Same as five-scalar syntax, but without \s-1ACCEL\s0 and \s-1KEY\s0 fields.
\&\s-1KEY\s0 is \f(CW\*(C`kb::NoKey\*(C'\fR by default, so no keyboard combination
is bound to the item. Default \s-1ACCEL\s0 value is an empty string.
.IP "two [ \s-1TEXT/IMAGE, ACTION/SUBMENU \s0]" 4
.IX Item "two [ TEXT/IMAGE, ACTION/SUBMENU ]"
Same as three-scalar syntax, but without \s-1NAME\s0 field.
.IP "one and zero [ ]" 4
.IX Item "one and zero [ ]"
Both empty and 1\-scalar arrays indicate a separator
menu item. In case of 1\-scalar syntax, the scalar value
is ignored.
.PP
As an example of all above said, a real-life piece of code
is exemplified:
.PP
.Vb 10
\&   $img = Prima::Image\-> create( ... ); 
\&   ...
\&   $menu\-> items( [
\&      [ "~File" => [
\&          [ "Anonymous" => "Ctrl+D" => \*(Aq^d\*(Aq => sub { print "sub\en";}],   # anonymous sub
\&          [ $img => sub {
\&             my $img = $_[0]\-> menu\-> image( $_[1]);
\&             my @r = @{$img\-> palette};
\&             $img\-> palette( [reverse @r]);
\&             $_[0]\->menu\->image( $_[1], $img);
\&          }],                         # image
\&          [],                         # division line
\&          [ "E~xit" => "Exit"    ]    # calling named function of menu owner
\&      ]],
\&      [ ef => "~Edit" => [                  # example of system commands usage
\&         ... 
\&         [ "Pa~ste" => sub { $_[0]\->foc_action(\*(Aqpaste\*(Aq)} ],
\&         ...
\&         ["~Duplicate menu"=>sub{ TestWindow\->create( menu=>$_[0]\->menu)}],
\&      ]],
\&      ...
\&      [],                             # divisor in main menu opens
\&      [ "~Clusters" => [              # right\-adjacent part
\&        [ "*".checker =>  "Checking Item"   => "Check"     ],
\&        [],
\&        [ "\-".slave   =>  "Disabled state"   => "PrintText"],
\&        ...
\&      ]]
\&   ] );
.Ve
.PP
The code is stripped from 'menu.pl' from 'examples' directory 
in the toolkit installation. The reader is advised to
run the example and learn the menu mechanics.
.SS "Prima::MenuItem"
.IX Subsection "Prima::MenuItem"
As described above, text and sub-menu items can be managed
by elemental properties \- \f(CW\*(C`::accel\*(C'\fR, \f(CW\*(C`::text\*(C'\fR, \f(CW\*(C`::image\*(C'\fR,
\&\f(CW\*(C`::checked\*(C'\fR, \f(CW\*(C`::enabled\*(C'\fR, \f(CW\*(C`::action\*(C'\fR, \f(CW\*(C`::data\*(C'\fR.
All these, plus some other methods can be called in an 
alternative way, resembling name-based component calls
of Prima::Object. A code
.PP
.Vb 1
\&  $menu\-> checked(\*(AqCheckerMenuItem\*(Aq, 1);
.Ve
.PP
can be re-written as
.PP
.Vb 1
\&  $menu\-> CheckerMenuItem\-> checked(1);
.Ve
.PP
Name-based call substitutes Prima::MenuItem object,
created on the fly. Prima::MenuItem class shares
same functions of Prima::AbstractMenu, that handle
individual menu items.
.SS "Prima::Menu"
.IX Subsection "Prima::Menu"
Objects, derived from Prima::Menu class are
used to tandem Prima::Window objects, and their
items to be shown as menu bar on top of the window.
.PP
Prima::Menu is special in that its top-level items
visualized horizontally, and in behavior of the top-level
separator items ( see above, \*(L"Menu items\*(R" ).
.PP
If \f(CW\*(C`::selected\*(C'\fR is set to 1, then a menu object
is visualized in a window, otherwise it is not.
This behavior allows window to host multiple
menu objects without clashing. 
When a Prima::Menu object gets 'selected', it displaces
the previous 'selected' menu Prima::Menu object, and its items
are installed into the visible menu bar. Prima::Window
property \f(CW\*(C`::menu\*(C'\fR then points to the menu object, and
\&\f(CW\*(C`::menuItems\*(C'\fR is an alias for \f(CW\*(C`::items\*(C'\fR menu class property.
Prima::Window's properties \f(CW\*(C`::menuFont\*(C'\fR and \f(CW\*(C`::menuColorIndex\*(C'\fR
are used as visualization hints.
.PP
Prima::Menu provide no new methods or properties.
.SS "Prima::Popup"
.IX Subsection "Prima::Popup"
Objects, derived from Prima::Popup class are
used together with Prima::Widget objects.
Menu items are visualized when the user pressed
the pop-up key or mouse buttons combination,
in response to Prima::Widget's \f(CW\*(C`Popup\*(C'\fR notification.
.PP
If \f(CW\*(C`::selected\*(C'\fR is set to 1, then a menu object
is visualized in the system pop-up menu, otherwise it is not.
This behavior allows widget to host multiple
menu objects without clashing.
When a Prima::Popup object gets 'selected', it displaces
the previous 'selected' menu Prima::Popup object.
Prima::Widget
property \f(CW\*(C`::popup\*(C'\fR then points to the menu object, and
\&\f(CW\*(C`::popupItems\*(C'\fR is an alias for \f(CW\*(C`::items\*(C'\fR menu class property.
Prima::Widget's properties \f(CW\*(C`::popupFont\*(C'\fR and \f(CW\*(C`::popupColorIndex\*(C'\fR
are used as visualization hints.
.PP
A Prima::Popup object can be visualized
explicitly, by means of \f(CW\*(C`popup\*(C'\fR method. The
implicit visualization by the user is happened only
if the \f(CW\*(C`::autoPopup\*(C'\fR property is set to 1.
.PP
Prima::Popup provides new \f(CW\*(C`popup\*(C'\fR method
and new \f(CW\*(C`::autoPopup\*(C'\fR property.
.SS "Prima::AccelTable"
.IX Subsection "Prima::AccelTable"
This class is destined for a more limited functionality than Prima::Menu and Prima::Popup,
primarily for mapping key strokes to predefined actions.
Prima::AccelTable objects are never visualized, and
consume no system resources, although full menu
item management syntax is supported.
.PP
If \f(CW\*(C`::selected\*(C'\fR is set to 1, then it displaces
the previous 'selected' menu Prima::AccelTable object.
Prima::Widget property \f(CW\*(C`::accelTable\*(C'\fR then points to 
the menu object, and \f(CW\*(C`::accelItems\*(C'\fR is an alias for 
\&\f(CW\*(C`::items\*(C'\fR menu class property.
.PP
Prima::AccelTable provide no new methods or properties.
.SH "API"
.IX Header "API"
.SS "Properties"
.IX Subsection "Properties"
.IP "accel \s-1NAME, STRING /\s0 Prima::MenuItem::accel \s-1STRING\s0" 4
.IX Item "accel NAME, STRING / Prima::MenuItem::accel STRING"
Manages accelerator text for a menu item.
\&\s-1NAME\s0 is name of the menu item.
.IP "action \s-1NAME, SCALAR /\s0 Prima::MenuItem::action \s-1SCALAR.\s0" 4
.IX Item "action NAME, SCALAR / Prima::MenuItem::action SCALAR."
Manages action for a menu item.  
\&\s-1NAME\s0 is name of the menu item.
\&\s-1SCALAR\s0 can be either an anonymous sub or a method name,
defined in the menu object owner's name space.
Both called with three parameters \-
the owner of a menu object, the menu object itself and
the name of the menu item.
.IP "autoPopup \s-1BOOLEAN\s0" 4
.IX Item "autoPopup BOOLEAN"
Only in Prima::Popup
.Sp
If set to 1 in selected state, calls \f(CW\*(C`popup()\*(C'\fR action
in response to \f(CW\*(C`Popup\*(C'\fR notification, when the user
presses the default key or mouse button combination.
.Sp
If 0, the pop-up menu can not be executed implicitly.
.Sp
Default value: 1
.IP "checked \s-1NAME, BOOLEAN /\s0 Prima::MenuItem::checked \s-1BOOLEAN \s0" 4
.IX Item "checked NAME, BOOLEAN / Prima::MenuItem::checked BOOLEAN "
Manages 'checked' state of a menu item. If 'checked',
a menu item visualized with a distinct check-mark near
the menu item text or image. Its usage with sub-menu
items is possible, although discouraged.
.Sp
\&\s-1NAME\s0 is name of the menu item.
.IP "data \s-1NAME, SCALAR /\s0 Prima::MenuItem::data \s-1SCALAR\s0" 4
.IX Item "data NAME, SCALAR / Prima::MenuItem::data SCALAR"
Manages the user data scalar.
.Sp
\&\s-1NAME\s0 is name of the menu item.
\&\s-1SCALAR\s0 can be any scalar value, the toolkit does
not use this property internally.
.IP "enabled \s-1NAME, BOOLEAN /\s0 Prima::MenuItem::enabled \s-1BOOLEAN \s0" 4
.IX Item "enabled NAME, BOOLEAN / Prima::MenuItem::enabled BOOLEAN "
Manages 'enabled' state of a menu item. If 'enabled' is 0,
a menu item visualized with grayed or otherwise dimmed color
palette. If a sub-menu item is disabled, whole sub-menu
is inaccessible.
.Sp
\&\s-1NAME\s0 is name of the menu item.
.IP "image \s-1NAME, OBJECT /\s0 Prima::MenuItem::image \s-1OBJECT\s0" 4
.IX Item "image NAME, OBJECT / Prima::MenuItem::image OBJECT"
Manages the image, bound with a menu item. \s-1OBJECT\s0
is a non-null Prima::Image object reference, with
no particular color space or dimensions ( because
of dimensions, its usage in top-level Prima::Menu
items is discouraged ).
.Sp
\&\f(CW\*(C`::image\*(C'\fR and \f(CW\*(C`::text\*(C'\fR are mutually exclusive menu
item properties, and can not be set together, but
a menu item can change between image and text representation
at run time by calling these properties.
.Sp
\&\s-1NAME\s0 is name of the menu item.
.IP "items \s-1SCALAR\s0" 4
.IX Item "items SCALAR"
Manages the whole menu items tree. \s-1SCALAR\s0 is
a multi-level anonymous array structure, with
syntax described in \*(L"Menu items\*(R".
.Sp
\&\f(CW\*(C`::items\*(C'\fR is an ultimate tool for reading
and writing the menu items tree, but often
it is too powerful, so there are elemental
properties \f(CW\*(C`::accel\*(C'\fR, \f(CW\*(C`::text\*(C'\fR, \f(CW\*(C`::image\*(C'\fR,
\&\f(CW\*(C`::checked\*(C'\fR, \f(CW\*(C`::enabled\*(C'\fR, \f(CW\*(C`::action\*(C'\fR, 
\&\f(CW\*(C`::data\*(C'\fR declared, that handle menu items
individually.
.IP "key \s-1NAME, KEY /\s0 Prima::MenuItem::key \s-1KEY\s0" 4
.IX Item "key NAME, KEY / Prima::MenuItem::key KEY"
Manages the hot key combination, bound with a menu item.
Internally \s-1KEY\s0 is kept as an integer value, and get-mode
call returns integers only, but set-mode accepts
the literal key format \- like, '^C', 'F5' strings.
.Sp
\&\s-1NAME\s0 is name of the menu item, \s-1KEY\s0 is an integer value.
.IP "selected \s-1BOOLEAN\s0" 4
.IX Item "selected BOOLEAN"
If set to 1, menu object is granted extra functionality
from a window or widget owner object. Different Prima::AbstractMenu
descendant provided with different extra functionalities.
In \fIUsage\fR section, see Prima::Menu, Prima::Popup
and Prima::AccelTable.
.Sp
Within each menu class, only one menu object can be selected
for its owner.
.Sp
If set to 0, the only actions performed are
implicit hot-key lookup when on \f(CW\*(C`KeyDown\*(C'\fR event.
.Sp
Default value: 1
.IP "text \s-1NAME, STRING /\s0 Prima::MenuItem::text \s-1STRING\s0" 4
.IX Item "text NAME, STRING / Prima::MenuItem::text STRING"
Manages the text, bound with a menu item. \s-1STRING\s0
is an arbitrary string, with '~' ( tilde ) quotation
of a hot key character. The hot key character is only used
when keyboard navigation of a pop-up or a pull-down menu
is performed; it has no influence outside menu sessions.
.Sp
\&\f(CW\*(C`::text\*(C'\fR and \f(CW\*(C`::image\*(C'\fR are mutually exclusive menu
item properties, and can not be set together, but
a menu item can change between image and text representation
at run time by calling these properties.
.SS "Methods"
.IX Subsection "Methods"
.IP "check \s-1NAME /\s0 Prima::MenuItem::check" 4
.IX Item "check NAME / Prima::MenuItem::check"
Alias for \f(CWchecked(1)\fR. 
Sets menu item in checked state.
.IP "disable \s-1NAME /\s0 Prima::MenuItem::disable" 4
.IX Item "disable NAME / Prima::MenuItem::disable"
Alias for \f(CWenabled(0)\fR.
Sets menu item in disabled state.
.IP "enabled \s-1NAME /\s0 Prima::MenuItem::enabled" 4
.IX Item "enabled NAME / Prima::MenuItem::enabled"
Alias for \f(CWenabled(1)\fR.
Sets menu item in enabled state.
.IP "get_handle" 4
.IX Item "get_handle"
Returns a system-dependent menu handle.
.Sp
\&\s-1NB:\s0 Prima::AccelTable use no system resources, and
this method returns its object handle instead.
.IP "has_item \s-1NAME\s0" 4
.IX Item "has_item NAME"
Returns boolean value, whether the menu object has
a menu item with name \s-1NAME.\s0
.IP "insert \s-1ITEMS, ROOT_NAME, INDEX\s0" 4
.IX Item "insert ITEMS, ROOT_NAME, INDEX"
Inserts menu item inside existing item tree.
\&\s-1ITEMS\s0 has same syntax as \f(CW\*(C`::items\*(C'\fR.
\&\s-1ROOT_NAME\s0 is the name of a menu item, where the insertion
must take place; if \s-1ROOT_NAME\s0 is an empty string, the
insertion is performed to the top level items.
\&\s-1INDEX\s0 is an offset, which the newly inserted items
would possess after the insertion. \s-1INDEX 0\s0 indicates
the beginning, thus.
.Sp
Returns no value.
.IP "popup X_OFFSET, Y_OFFSET, [ \s-1LEFT\s0 = 0, \s-1BOTTOM\s0 = 0, \s-1RIGHT\s0 = 0, \s-1TOP\s0 = 0 ]" 4
.IX Item "popup X_OFFSET, Y_OFFSET, [ LEFT = 0, BOTTOM = 0, RIGHT = 0, TOP = 0 ]"
Only in Prima::Popup
.Sp
Executes the system-driven pop-up menu, in location near 
(X_OFFSET,Y_OFFSET) pixel on the screen, with items from \f(CW\*(C`::items\*(C'\fR
tree. The pop-up menu is hinted to be positioned so that
the rectangle, defined by (\s-1LEFT,BOTTOM\s0) \- (\s-1RIGHT,TOP\s0) coordinates
is not covered by the first-level menu. This is useful when a pop-up
menu is triggered by a button widget, for example.
.Sp
If during the execution the user selects a menu item,
then its associated action is executed ( see \f(CW\*(C`action\*(C'\fR ).
.Sp
The method returns immediately and returns no value.
.IP "remove \s-1NAME /\s0 Prima::MenuItem::remove" 4
.IX Item "remove NAME / Prima::MenuItem::remove"
Deletes a menu item from the items tree, and
its sub-menus if the item is a sub-menu item.
.IP "select" 4
.IX Item "select"
Alias for \f(CWselected(1)\fR.
Sets menu object in selected state.
.IP "set_command \s-1KEY, ENABLED\s0" 4
.IX Item "set_command KEY, ENABLED"
Disables or enables menu items, associated with
key combinations \s-1KEY.\s0
.IP "set_variable \s-1NAME, NEW_NAME\s0" 4
.IX Item "set_variable NAME, NEW_NAME"
Changes the name of a menu item with \s-1NAME\s0 to \s-1NEW_NAME.
NEW_NAME\s0 must not be an empty string and must not be in a
\&'#integer' form.
.IP "toggle \s-1NAME /\s0 Prima::MenuItem::toggle" 4
.IX Item "toggle NAME / Prima::MenuItem::toggle"
Toggles the checked state of a menu item
and returns the new state.
.IP "translate_accel \s-1TEXT\s0" 4
.IX Item "translate_accel TEXT"
Locates a '~' ( tilde ) \- escaped character in a \s-1TEXT\s0
string and returns its index ( as ord(\fIlc()\fR)), or 0
if no escaped characters were found.
.Sp
The method can be called with no object.
.IP "translate_key \s-1CODE, KEY, MOD\s0" 4
.IX Item "translate_key CODE, KEY, MOD"
Translates three-integer key representation into
the one-integer format and returns the integer value. 
The three-integer format is used in
\&\f(CW\*(C`KeyDown\*(C'\fR and \f(CW\*(C`KeyUp\*(C'\fR notifications for Prima::Widget.
.Sp
See Prima::Widget
.Sp
The method can be called with no object.
.IP "translate_shortcut \s-1KEY\s0" 4
.IX Item "translate_shortcut KEY"
Converts literal-represented \s-1KEY\s0 string
into the integer format and returns the integer value.
.Sp
The method can be called with no object.
.IP "uncheck \s-1NAME /\s0 Prima::MenuItem::uncheck" 4
.IX Item "uncheck NAME / Prima::MenuItem::uncheck"
Alias for \f(CWchecked(0)\fR.
Sets menu item in unchecked state.
.SH "BUGS"
.IX Header "BUGS"
Menu colors and fonts don't work on Windows and probably never will.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Object, Prima::Widget,
Prima::Window
