.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Prima::ImageViewer 3"
.TH Prima::ImageViewer 3 "2015-01-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prima::ImageViewer \- standard image, icon, and bitmap viewer class.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module contains \f(CW\*(C`Prima::ImageViewer\*(C'\fR class, which provides
image displaying functionality, including different zoom levels.
.PP
\&\f(CW\*(C`Prima::ImageViewer\*(C'\fR is a descendant of \f(CW\*(C`Prima::ScrollWidget\*(C'\fR
and inherits its document scrolling behavior and programming interface.
See Prima::ScrollWidget for details.
.SH "API"
.IX Header "API"
.SS "Properties"
.IX Subsection "Properties"
.IP "alignment \s-1INTEGER\s0" 4
.IX Item "alignment INTEGER"
One of the following \f(CW\*(C`ta::XXX\*(C'\fR constants:
.Sp
.Vb 3
\&        ta::Left
\&        ta::Center 
\&        ta::Right
.Ve
.Sp
Selects the horizontal image alignment.
.Sp
Default value: \f(CW\*(C`ta::Left\*(C'\fR
.IP "autoZoom \s-1BOOLEAN\s0" 4
.IX Item "autoZoom BOOLEAN"
When set, the image is automatically stretched while keeping aspects to the best available fit,
given the \f(CW\*(C`zoomPrecision\*(C'\fR. Scrollbars are turned off if \f(CW\*(C`autoZoom\*(C'\fR is set to 1.
.IP "image \s-1OBJECT\s0" 4
.IX Item "image OBJECT"
Selects the image object to be displayed. \s-1OBJECT\s0 can be
an instance of \f(CW\*(C`Prima::Image\*(C'\fR, \f(CW\*(C`Prima::Icon\*(C'\fR, or \f(CW\*(C`Prima::DeviceBitmap\*(C'\fR class.
.IP "imageFile \s-1FILE\s0" 4
.IX Item "imageFile FILE"
Set the image \s-1FILE\s0 to be loaded and displayed. Is rarely used since does not return
a loading success flag.
.IP "stretch \s-1BOOLEAN\s0" 4
.IX Item "stretch BOOLEAN"
If set, the image is simply stretched over the visual area,
without keeping the aspect. Scroll bars, zooming and
keyboard navigation become disabled.
.IP "quality \s-1BOOLEAN\s0" 4
.IX Item "quality BOOLEAN"
A boolean flag, selecting if the palette of \f(CW\*(C`image\*(C'\fR is to be 
copied into the widget palette, providing higher visual
quality on paletted displays. See also \*(L"palette\*(R" in Prima::Widget.
.Sp
Default value: 1
.IP "valignment \s-1INTEGER\s0" 4
.IX Item "valignment INTEGER"
One of the following \f(CW\*(C`ta::XXX\*(C'\fR constants:
.Sp
.Vb 3
\&        ta::Top
\&        ta::Middle or ta::Center
\&        ta::Bottom
.Ve
.Sp
Selects the vertical image alignment.
.Sp
\&\s-1NB: \s0\f(CW\*(C`ta::Middle\*(C'\fR value is not equal to \f(CW\*(C`ta::Center\*(C'\fR's, however
the both constants produce equal effect here.
.Sp
Default value: \f(CW\*(C`ta::Bottom\*(C'\fR
.IP "zoom \s-1FLOAT\s0" 4
.IX Item "zoom FLOAT"
Selects zoom level for image display. The acceptable value range is between
0.01 and 100. The zoom value is rounded to the closest value divisible by
1/\f(CW\*(C`zoomPrecision\*(C'\fR. For example, is \f(CW\*(C`zoomPrecision\*(C'\fR is 100, the zoom values
will be rounded to the precision of hundredth \- to fiftieth and twentieth
fractional values \- .02, .04, .05, .06, .08, and 0.1 . When \f(CW\*(C`zoomPrecision\*(C'\fR
is 1000, the precision is one thousandth, and so on.
.Sp
Default value: 1
.IP "zoomPrecision \s-1INTEGER\s0" 4
.IX Item "zoomPrecision INTEGER"
Zoom precision of \f(CW\*(C`zoom\*(C'\fR property. Minimal acceptable value is 10, where zoom
will be rounded to 0.2, 0.4, 0.5, 0.6, 0.8 and 1.0 .
.Sp
The reason behind this arithmetics is that when image of arbitrary zoom factor
is requested to be displayed, the image sometimes must begin to be drawn from
partial pixel \- for example, 10x zoomed image shifted 3 pixels left, must be
displayed so the first image pixel from the left occupies 7 screen pixels, and
the next ones \- 10 screen pixels.  That means, that the correct image display
routine must ask the system to draw the image at offset \-3 screen pixels, where
the first pixel column would correspond to that pixel.
.Sp
When zoom factor is fractional, the picture is getting more complex. For
example, with zoom factor 12.345, and zero screen offset, first image pixel
begins at 12th screen pixel, the next \- 25th ( because of the roundoff ), then
37th etc etc. Also, for example the image is 2000x2000 pixels wide, and is
asked to be drawn so that the image appears shifted 499 screen image pixels
left, beginning to be drawn from ~ 499/12.3456=40.42122 image pixel. Is might
seem that indeed it would be enough to ask system to begin drawing from image
pixel 40, and offset int(0.42122*12.345)=5 screen pixels to the left, however,
that procedure will not account for the correct fixed point roundoff that
accumulates as system scales the image. For zoom factor 12.345 this roundoff
sequence is, as we seen before, (12,25,37,49,62,74,86,99,111,123) for first 10
pixels displayed, that occupy (12,13,12,12,13,12,12,13,12,12) screen pixels.
For pixels starting at 499, this sequence is
(506,519,531,543,556,568,580,593,605,617) offsets or
(13,12,12,13,13,12,12,13,12,12) widths \*(-- note the two subsequent 13s there.
This sequence begins to repeat itself after 200 iterations
(12.345*200=2469.000), which means that in order to achieve correct display
results, the image must be asked to be displayed from image pixel 0 if image's
first pixel on the screen is between 0 and 199 ( or for screen pixels 0\-2468),
from image pixel 200 for offsets 200\-399, ( screen pixels 2469\-4937), and so
on.
.Sp
Since system internally allocate memory for image scaling, that means that up
to 2*200*min(window_width,image_width)*bytes_per_pixel unneccessary bytes will
be allocated for each image drawing call (2 because the calculations are valid
for both the vertical and horizontal strips), and this can lead to slowdown or
even request failure when image or window dimensions are large. The proposed
solution is to roundoff accepted zoom factors, so these offsets are kept small
\&\- for example, N.25 zoom factors require only max 1/.25=4 extra pixels. When
\&\f(CW\*(C`zoomPrecision\*(C'\fR value is 100, zoom factors are rounded to 0.X2, 0.X4, 0.X5,
0.X6, 0.X8, 0.X0, thus requiring max 50 extra pixels.
.Sp
\&\s-1NB.\s0 If, despite the efforts, the property gets in the way, increase it to
1000 or even 10000, but note that this may lead to problems.
.Sp
Default value: 100
.SS "Methods"
.IX Subsection "Methods"
.IP "on_paint \s-1SELF, CANVAS\s0" 4
.IX Item "on_paint SELF, CANVAS"
The \f(CW\*(C`Paint\*(C'\fR notification handler is mentioned here for the specific case
of its return value, that is the return value of internal \f(CW\*(C`put_image\*(C'\fR call.
For those who might be interested in \f(CW\*(C`put_image\*(C'\fR failures, that mostly occur
when trying to draw an image that is too big, the following code might be 
useful:
.Sp
.Vb 5
\&    sub on_paint 
\&    {
\&        my ( $self, $canvas) = @_;
\&        warn "put_image() error:$@" unless $self\-> SUPER::on_paint($canvas);
\&    }
.Ve
.IP "screen2point X, Y, [ X, Y, ... ]" 4
.IX Item "screen2point X, Y, [ X, Y, ... ]"
Performs translation of integer pairs integers as (X,Y)\-points from widget coordinates 
to pixel offset in image coordinates. Takes in account zoom level,
image alignments, and offsets. Returns array of same length as the input.
.Sp
Useful for determining correspondence, for example, of a mouse event
to a image point.
.Sp
The reverse function is \f(CW\*(C`point2screen\*(C'\fR.
.IP "point2screen   X, Y, [ X, Y, ... ]" 4
.IX Item "point2screen X, Y, [ X, Y, ... ]"
Performs translation of integer pairs as (X,Y)\-points from image pixel offset
to widget image coordinates. Takes in account zoom level,
image alignments, and offsets. Returns array of same length as the input.
.Sp
Useful for determining a screen location of an image point.
.Sp
The reverse function is \f(CW\*(C`screen2point\*(C'\fR.
.IP "watch_load_progress \s-1IMAGE\s0" 4
.IX Item "watch_load_progress IMAGE"
When called, image viewer watches as \s-1IMAGE\s0 is being loaded ( see \*(L"load\*(R" in Prima::Image )
and displays the progress. As soon as \s-1IMAGE\s0 begins to load, it replaces the existing \f(CW\*(C`image\*(C'\fR
property. Example:
.Sp
.Vb 4
\&    $i = Prima::Image\-> new;
\&    $viewer\-> watch_load_progress( $i);
\&    $i\-> load(\*(Aqhuge.jpg\*(Aq);
\&    $viewer\-> unwatch_load_progress;
.Ve
.Sp
Similar functionality is present in Prima::ImageDialog.
.IP "unwatch_load_progress CLEAR_IMAGE=1" 4
.IX Item "unwatch_load_progress CLEAR_IMAGE=1"
Stops monitoring of image loading progress. If \s-1CLEAR_IMAGE\s0 is 0, the leftovers of the
incremental loading stay intact in \f(CW\*(C`image\*(C'\fR propery. Otherwise, \f(CW\*(C`image\*(C'\fR is set to \f(CW\*(C`undef\*(C'\fR.
.IP "zoom_round \s-1ZOOM\s0" 4
.IX Item "zoom_round ZOOM"
Rounds the zoom factor to \f(CW\*(C`zoomPrecision\*(C'\fR precision, returns
the rounded zoom value. The algorithm is the same as used internally
in \f(CW\*(C`zoom\*(C'\fR property.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitry Karasik, <dmitry@karasik.eu.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Prima, Prima::Image, Prima::ScrollWidget, Prima::ImageDialog, \fIexamples/iv.pl\fR.
