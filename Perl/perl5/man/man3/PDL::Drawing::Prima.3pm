.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDL::Drawing::Prima 3"
.TH PDL::Drawing::Prima 3 "2015-11-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Drawing::Prima \- PDL\-aware drawing functions for Prima widgets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Each of the methods comes with a small sample snippet. To see how it
looks, copy this synopsis and replace the code in the
\&\f(CW\*(C`Example code goes here\*(C'\fR block with the example code.
.PP
.Vb 5
\& use strict;
\& use warnings;
\& use PDL;
\& use PDL::Drawing::Prima;
\& use Prima qw(Application);
\& 
\& my $window = Prima::MainWindow\->create(
\&     text    => \*(AqPDL::Drawing::Prima Test\*(Aq,
\&     onPaint => sub {
\&         my ( $self, $canvas) = @_;
\& 
\&         # wipe the canvas:
\&         $canvas\->clear;
\&         
\&         ### Example code goes here ###
\&         
\&         # Draw a sine curve on the widget:
\&         my ($width, $height) = $canvas\->size;
\&         my $x = sequence($width);
\&         my $y = ( sin($x / 20) + 1 ) * $height/2;
\&         $canvas\->pdl_polylines($x, $y, lineWidths => 2);
\&         
\&         ### Example code ends here ###
\&     },
\&     backColor => cl::White,
\& );
\& 
\& run Prima;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a number of PDL-threaded functions and bindings for use
with the Prima toolkit. Many of the functions are \s-1PDL\s0 bindings for the
standard Prima drawing functions. Others are useful functions for color
manipulation, or getting data into a form that \s-1PDL\s0 knows how to handle.
I generally divide the subroutines of this module into two categories:
\&\fBmethods\fR and \fBfunctions\fR. The methods are subroutines that operate on a
Prima widget; the functions are subroutines that act on or return piddles.
.PP
Most of the methods given here are PDLified versions of the Prima drawing \s-1API\s0
functions, which are documented under Prima::Drawable. In general, where the
Prima \s-1API\s0 uses singular nouns, I here use plural nouns. A few of the methods
are only available in this module, mostly added to accomodate the needs of
PDL::Graphics::Prima, the plotting library built on these bindings.
.PP
This bindings can be applied to \fBany\fR object whose class is derived from
Prima::Drawable, including displayed widgets and abstract canvases such
as Prima::PS::Drawable. If you create your own derived canvas, these
methods should Just Work. (I wish I could take credit for this, but it's
really due to the fact that Prima's internals are very well engineered.)
.SH "COORDINATE ORIGIN"
.IX Header "COORDINATE ORIGIN"
The Prima image coordinate origin is located in lower left corner, which is
where you would expect to find it when creating plots. However, it is different
from the way that many graphics libraries do their coordinates.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "piddle_of_patterns_for"
.IX Subsection "piddle_of_patterns_for"
If you want \s-1PDL\s0 to thread over line patterns, but you want to use the standard
Prima line patterns, you'll need to convert them line patterns to a piddle.
This works very simply like this:
.PP
.Vb 1
\& my $patterns = piddle_of_patterns_for(lp::Solid, lp::Dash);
.Ve
.PP
This creates a piddle with the two patterns so that you could have \s-1PDL\s0 thread
over them.
.PP
You can also create your own line pattern piddles by hand. I recommend you use
byte array, since otherwise it will be converted to byte arrays for you.
The first element of a row in your byte array
specifies the number of pixels to be \*(L"on\*(R", the second specifies the number to be
\&\*(L"off\*(R", the third specifies the number to be \*(L"on\*(R" again, the fourth \*(L"off\*(R", the
fifth \*(L"on\*(R", etc. If that doesn't make sense, hopefully a couple of examples will
help clarify.
.PP
This example creates the equivalent of lp::Dash:
.PP
.Vb 1
\& my $dash_pattern = byte (9, 3);
.Ve
.PP
This example creates a piddle with four line types: lp::Solid, lp::Dash,
lp::ShortDash, and lp::DashDot:
.PP
.Vb 1
\& my $patterns = byte q[ 1; 9 3; 3 3; 9 3 1 3];
.Ve
.PP
and should be identical to
.PP
.Vb 2
\& my $patterns = piddle_of_patterns_for(
\&     lp::Solid, lp::Dash, lp::ShortDash, lp::DashDot);
.Ve
.PP
When you create a byte piddle, all of the patterns must have the same number of
bytes in their specification. Of course, different patterns have different
lengths, so in that case simply pad the shorter specifications with zeroes.
.SS "piddle_of_handles_for"
.IX Subsection "piddle_of_handles_for"
\&\s-1THIS FUNCTION IS DEPRECATED AND NOW DIES IF YOU TRY TO USE IT.\s0 Performing
the same \s-1PDL\s0 drawing operation on different widgets via \s-1PDL\s0 threading
makes atomic behavior very difficult, so this functionality has been removed.
If you think you'd like this behavior back, please let me know.
.SH "METHODS"
.IX Header "METHODS"
The methods described below are a bit unusual for \s-1PDL\s0 functions. First, they are
not actually \s-1PDL\s0 functions at all but are methods for \f(CW\*(C`Prima::Drawable\*(C'\fR
objects. Second, their signatures will look a bit funny. Don't worry too much
about that, though, because they will resemble normal signatures close enough
that you should be able to understand them, I hope.
.SS "pdl_arcs"
.IX Subsection "pdl_arcs"
.Vb 2
\&  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
\&                     start_angle(); end_angle(); properties)
.Ve
.PP
Draws arcs, i.e. incomplete ellipses.
.PP
Applicable properties include colors, backColors,
lineEnds, linePatterns, lineWidths, rops, rop2s, and translates.
.PP
The arcs go from the \f(CW\*(C`start_angle\*(C'\fRs to the \f(CW\*(C`end_angle\*(C'\fRs along the
ellipses centered at the \f(CW\*(C`x\*(C'\fRs and \f(CW\*(C`y\*(C'\fRs, with the specified x\- and
y\-diameters. The angles are measured in degrees, not radians.
The difference between this command and \*(L"chords\*(R" or \*(L"sectors\*(R" is that
\&\f(CW\*(C`arcs\*(C'\fR does not connect the dangling ends.
.PP
Here's a simple example:
.PP
.Vb 9
\& # Draw a bunch of random arcs on $canvas:
\& my $N_arcs = 20;
\& my ($x_max, $y_max) = $canvas\->size;
\& my $xs = zeroes($N_arcs)\->random * $x_max;
\& my $ys = $xs\->random * $y_max;
\& my $dxs = $xs\->random * $x_max / 4;
\& my $dys = $xs\->random * $y_max / 4;
\& my $th_starts = $xs\->random * 360;
\& my $th_stops = $xs\->random * 360;
\& 
\& # Now that we\*(Aqve generated the data, call the command:
\& $canvas\->pdl_arcs($xs, $ys, $dxs
\&                , $dys, $th_starts, $th_stops);
.Ve
.PP
If you put that snippet of code in the \f(CW\*(C`onPaint\*(C'\fR method, as
suggested in the synopsis, a completely new set of arcs will get
redrawn whenever you resize your window.
.PP
Compare to the Prima method \*(L"arc\*(R" in Prima::Drawable. Closely related
routines include \*(L"pdl_chords\*(R" and \*(L"pdl_sectors\*(R". See also
\&\*(L"pdl_fill_chords\*(R", and \*(L"pdl_fill_sectors\*(R", \*(L"pdl_ellipses\*(R", and
\&\*(L"pdl_fill_ellipses\*(R".
.PP
Spline drawing provides a similar functionality, though more complex and
more powerful. There are no \s-1PDL\s0 bindings for the spline functions yet.
See \*(L"spline\*(R" in Prima::Drawable for more information.
.PP
pdl_arcs does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_bars"
.IX Subsection "pdl_bars"
.Vb 1
\&  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)
.Ve
.PP
Draws filled rectangles from corners (x1, y1) to (x2, y2).
.PP
Applicable properties include colors, backColors, clipRects,
fillPatterns, rops, rop2s, and translates.
.PP
.Vb 8
\& # Draw 20 random filled rectangles on $canvas:
\& my $N_bars = 20;
\& my ($x_max, $y_max) = $canvas\->size;
\& my $x1s = zeroes($N_bars)\->random * $x_max;
\& my $y1s = $x1s\->random * $y_max;
\& my $x2s = $x1s + $x1s\->random * ($x_max \- $x1s);
\& my $y2s = $y1s + $x1s\->random * ($y_max \- $y1s);
\& my $colors = $x1s\->random * 2**24;
\& 
\& # Now that we\*(Aqve generated the data, call the command:
\& $canvas\->pdl_bars($x1s, $y1s, $x2s, $y2s
\&         , colors => $colors);
.Ve
.PP
If you put that snippet of code in the \f(CW\*(C`onPaint\*(C'\fR method, as
suggested in the synopsis, a completely new set of filled rectangles
will get redrawn whenever you resize your window.
.PP
Compare to the Prima method \*(L"bar\*(R" in Prima::Drawable. See also
\&\*(L"pdl_rectangles\*(R", which is the unfilled equivalent, and \*(L"pdl_clears\*(R",
which is sorta the opposite of this.
.PP
pdl_bars does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_chords"
.IX Subsection "pdl_chords"
.Vb 2
\&  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
\&                           start_angle(); end_angle(); properties)
.Ve
.PP
Draws arcs (i.e. incomplete ellipses) whose ends are connected by a line.
.PP
The chord starts at \f(CW\*(C`start_angle\*(C'\fR and runs to \f(CW\*(C`end_angle\*(C'\fR along the ellipse
centered at \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR, with their specified diameters \f(CW\*(C`x_diameter\*(C'\fR,
\&\f(CW\*(C`y_diameter\*(C'\fR. Unlike \*(L"arcs\*(R" or \*(L"sectors\*(R", it connects
the ends of the arc with a straight line. The angles are
measured in degrees, not radians.
.PP
Applicable properties include colors, backColors, clipRects,
lineEnds, linePatterns, lineWidths, rops, rop2s, and translates.
.PP
.Vb 2
\& # For this example, you will need:
\& use PDL::Char;
\& 
\& # Draw a bunch of random arcs on $canvas:
\& my $N_chords = 20;
\& my ($x_max, $y_max) = $canvas\->size;
\& my $xs = zeroes($N_chords)\->random * $x_max;
\& my $ys = $xs\->random * $y_max;
\& my $dxs = $xs\->random * $x_max / 4;
\& my $dys = $xs\->random * $y_max / 4;
\& my $th_starts = $xs\->random * 360;
\& my $th_stops = $xs\->random * 360;
\& 
\& # make a small list of patterns:
\& my $patterns_list = PDL::Char\->new(
\&          [lp::Solid, lp::Dash, lp::DashDot]);
\& 
\& # Randomly select 20 of those patterns:
\& my $rand_selections = ($xs\->random * 3)\->byte;
\& use PDL::NiceSlice;
\& my $patterns = $patterns_list($rand_selections)\->transpose;
\& 
\& # Now that we\*(Aqve generated the data, call the command:
\& $canvas\->pdl_chords($xs, $ys, $dxs
\&                , $dys, $th_starts, $th_stops
\&                , linePatterns => $patterns);
.Ve
.PP
If you put that snippet of code in the onPaint method, as
suggested in the synopsis, a completely new set of chords
will get redrawn whenever you resize your window.
.PP
Compare to the Prima method \*(L"chord\*(R" in Prima::Drawable. The filled
equivalent is \*(L"pdl_fill_chords\*(R". Closely related routines are
\&\*(L"pdl_arcs\*(R" and \*(L"pdl_sectors\*(R". See also \*(L"pdl_fill_sectors\*(R",
\&\*(L"pdl_ellipses\*(R", and \*(L"pdl_fill_ellipses\*(R", as well as
\&\*(L"spline\*(R" in Prima::Drawable.
.PP
pdl_chords does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_clears"
.IX Subsection "pdl_clears"
.Vb 1
\&  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)
.Ve
.PP
Clears the specified rectangle(s).
.PP
Applicable properties include backColors, rop2s, and translates.
.PP
.Vb 4
\& my ($width, $height) = $canvas\->size;
\& # Begin by drawing a filled rectangle:
\& $canvas\->color(cl::Blue);
\& $canvas\->bar(0, 0, $width, $height);
\& 
\& # Now cut random rectangles out of it:
\& my $N_chunks = 20;
\& my $x1 = random($N_chunks) * $width;
\& my $x2 = random($N_chunks) * $width;
\& my $y1 = random($N_chunks) * $width;
\& my $y2 = random($N_chunks) * $width;
\& $canvas\->pdl_clears($x1, $y1, $x2, $y2);
.Ve
.PP
Like the other examples, this will give you something new whenever you
resize the window if you put the code in the onPaint method, as the
Synopsis suggests.
.PP
Compare to the Prima method \*(L"clear\*(R" in Prima::Drawable. In practice I
suppose this might be considered the opposite of \*(L"pdl_bars\*(R", though
technically this is meant for erasing, not drawing.
.PP
pdl_clears does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_ellipses"
.IX Subsection "pdl_ellipses"
.Vb 2
\&  Prima Signature: (widget; x(); y(); x_diameter();
\&                          y_diameter(); properties)
.Ve
.PP
Draws ellipses centered at \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR with diameters \f(CW\*(C`x_diameter\*(C'\fR and
\&\f(CW\*(C`y_diameter\*(C'\fR.
.PP
Applicable properties include colors, backColors, clipRects,
linePatterns, lineWidths, rops, rop2s, and translates.
.PP
To draw circles, just use the same x\- and y\-diameter.
.PP
.Vb 11
\& # Draw increasingly taller ellipses along the center line
\& my $N_ellipses = 10;
\& my ($width, $height) = $canvas\->size;
\& # horizontal positions evenly spaced
\& my $x = (sequence($N_ellipses) + 0.5) * $width / $N_ellipses;
\& # Vertically, right in the middle of the window
\& my $y = $height/2;
\& # Use the same x\-diameter
\& my $x_diameter = 15;
\& # Increase the y\-diameter
\& my $y_diameter = $x\->xlinvals(10, $height/1.3);
\& 
\& # Use the pdl_ellipses method to draw!
\& $canvas\->pdl_ellipses($x, $y, $x_diameter, $y_diameter, lineWidths => 2);
.Ve
.PP
For this example, if you resize the window, the distance between the ellipses
and the ellipse heights will adjust automatically.
.PP
Compare to the Prima method \*(L"ellipse\*(R" in Prima::Drawable. The filled
equivalent is \*(L"pdl_fill_ellipses\*(R". See also \*(L"pdl_arcs\*(R", \*(L"pdl_chords\*(R",
and \*(L"pdl_sectors\*(R" as well as \*(L"pdl_fill_chords\*(R" and
\&\*(L"pdl_fill_sectors\*(R". You may also be interested in \*(L"spline\*(R" in Prima::Drawable,
which does not yet have a \s-1PDL\s0 interface.
.PP
pdl_ellipses does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_fill_chords"
.IX Subsection "pdl_fill_chords"
.Vb 2
\&  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
\&                          start_angle(); end_angle(); properties)
.Ve
.PP
Draws filled chords (see \*(L"pdl_chords\*(R").
.PP
Applicable properties include colors, backColors, clipRects,
fillPatterns, rops, rop2s, and translates.
.PP
Chords are partial elipses that run from \f(CW\*(C`start_angle\*(C'\fR to \f(CW\*(C`end_angle\*(C'\fR
along the ellipse centered at \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR, each with their specified diameters.
The ends are connected with a line and the interior is filled. Use this to
draw the open-mouth part of a smiley face.
.PP
.Vb 2
\& # working here:
\& $canvas\->pdl_fill_chords($x, $y, $xd, $yd, $ti, $tf);
.Ve
.PP
Compare to the Prima method \*(L"fill_chord\*(R" in Prima::Drawable. The unfilled
equivalent is \*(L"pdl_chords\*(R". Closely related to \*(L"pdl_fill_ellipses\*(R"
and \*(L"pdl_fill_sectors\*(R". See also \*(L"pdl_arcs\*(R", \*(L"pdl_ellipses\*(R",
and \*(L"pdl_sectors\*(R".
.PP
pdl_fill_chords does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_fill_ellipses"
.IX Subsection "pdl_fill_ellipses"
.Vb 2
\&  Prima Signature: (widget; x(); y(); x_diameter();
\&                          y_diameter(); properties)
.Ve
.PP
Draws filled ellipses (see \*(L"pdl_ellipses\*(R").
.PP
Applicable properties include colors, backColors, clipRects,
fillPatterns, rops, rop2s, and translates.
.PP
.Vb 11
\& # Draw increasingly taller ellipses along the center line
\& my $N_ellipses = 10;
\& my ($width, $height) = $canvas\->size;
\& # horizontal positions evenly spaced
\& my $x = (sequence($N_ellipses) + 0.5) * $width / $N_ellipses;
\& # Vertically, right in the middle of the window
\& my $y = $height/2;
\& # Use the same x\-diameter
\& my $x_diameter = 15;
\& # Increase the y\-diameter
\& my $y_diameter = $x\->xlinvals(10, $height/1.3);
\& 
\& # Use the pdl_ellipses method to draw!
\& $canvas\->pdl_fill_ellipses($x, $y, $x_diameter, $y_diameter);
.Ve
.PP
If you resize the window the distance between the ellipses
and the ellipse heights will adjust automatically.
.PP
Compare to the Prima method \*(L"fill_ellipse\*(R" in Prima::Drawable. The unfilled
equivalent is \*(L"pdl_ellipses\*(R". Closely related to \*(L"pdl_fill_chords\*(R" and
\&\*(L"pdl_fill_ellipses\*(R", and \*(L"pdl_fill_sectors\*(R".
See also \*(L"pdl_arcs\*(R", \*(L"pdl_ellipses\*(R", and \*(L"pdl_sectors\*(R". Also,
check out \*(L"fill_spline\*(R" in Prima::Drawable, which does not yet have
\&\s-1PDL\s0 bindings.
.PP
pdl_fill_ellipses does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_fillpolys"
.IX Subsection "pdl_fillpolys"
.Vb 1
\&  Prima Signature: (widget; x(n); y(n); properties)
.Ve
.PP
Draws and fills a polygon with (mostly) arbitrary edge vertices.
.PP
Applicable properties include colors, backColors, clipRects,
fillPatterns, fillWindings, rops, rop2s, and translates.
.PP
\&\s-1NOTE:\s0 there is \fBno\fR underscore between \f(CW\*(C`fill\*(C'\fR and \f(CW\*(C`poly\*(C'\fR, which is
different from the other \f(CW\*(C`fill\*(C'\fR methods!
.PP
This is useful for drawing arbitrary filled shapes and for visualizing
integrals. Splines would be the better choice if you want to draw curves, but
a \s-1PDL\s0 interface to splines is not (yet) implemented.
.PP
Unlike most of the other methods, this one actually makes a half-hearted
effort to process bad values. In addition to the \s-1IEEE\s0 bad values of \f(CW\*(C`nan\*(C'\fR
and \f(CW\*(C`inf\*(C'\fR, \s-1PDL\s0 has support for bad values. Unlike in \f(CW\*(C`pdl_polys\*(C'\fR,
\&\f(CW\*(C`pdl_fillpolys\*(C'\fR will simply skip any point that is marked as bad, but drawing
the rest of the polygon. In other words, it reduces the degree of your polygon
by one. If you sent it four points and one of them was bad, you would get a
triangle instead of a quadralaters.
.PP
Infinities are also handled, though not perfectly. There are a few
situations where \f(CW\*(C`pdl_polys\*(C'\fR will correctly draw what you mean but
\&\f(CW\*(C`pdl_fillpolys\*(C'\fR will not.
.PP
Because this skips bad data altogether, if you have too much bad data
(i.e. fewer than three good points), the routine will simply not draw
anything. I'm debating if this should croak, or at least give a warning.
(Of course, a warning to \s-1STDOUT\s0 is rather silly for a \s-1GUI\s0 toolkit.)
.PP
For example:
.PP
.Vb 4
\& # Create a poorly sampled sine\-wave
\& my ($width, $height) = $canvas\->size;
\& my $x = sequence(23)/4;
\& my $y = $x\->sin;
\& 
\& # Draw it in such a way that it fits the canvas nicely
\& $canvas\->pdl_fillpolys($x * $width / $x\->max,
\&     ($y + 1) * $height / 2, fillWindings => 1
\& );
.Ve
.PP
Resizing the window will result in a similar rendering that fits the aspect
ratio of your (resized) window.
.PP
Compare to the Prima method \*(L"fillpoly\*(R" in Prima::Drawable. See also
\&\*(L"pdl_bars\*(R" and pdl_polylines.
.PP
pdl_fillpolys processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_fill_sectors"
.IX Subsection "pdl_fill_sectors"
.Vb 2
\&  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
\&                          start_angle(); end_angle(); properties)
.Ve
.PP
Draws filled sectors, i.e. a pie-slices or Pac-Mans.
.PP
Applicable properties include colors, backColors, clipRects,
fillPatterns, rops, rop2s, and translates.
.PP
More specifically, this draws an arc from \f(CW\*(C`start_angle\*(C'\fR to \f(CW\*(C`end_angle\*(C'\fR
along the ellipse centered at \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR, with specified x\- and y\-diameters.
Like \*(L"fill_chords\*(R", this command connects the end points of the arc, but
unlike \*(L"fill_chords\*(R", it does so by drawing two lines, both of which
also connect to the ellipse's center. This results in shapes that look
like pie pieces or pie remnants, depending of whether you're a glass-half-full
or glass-half-empty sort of person.
.PP
.Vb 9
\& # Draw a bunch of random arcs on $canvas:
\& my $N_chords = 20;
\& my ($x_max, $y_max) = $canvas\->size;
\& my $xs = zeroes($N_chords)\->random * $x_max;
\& my $ys = $xs\->random * $y_max;
\& my $dxs = $xs\->random * $x_max / 4;
\& my $dys = $xs\->random * $y_max / 4;
\& my $th_starts = $xs\->random * 360;
\& my $th_stops = $xs\->random * 360;
\& 
\& # Now that we\*(Aqve generated the data, call the command:
\& $canvas\->pdl_fill_sectors($xs, $ys, $dxs
\&                , $dys, $th_starts, $th_stops);
.Ve
.PP
Compare to the Prima method \*(L"fill_sector\*(R" in Prima::Drawable. The unfilled
equivalent is \*(L"pdl_sectors\*(R". This is closely related to \f(CW\*(C`/pdl_fill_chords\*(C'\fR
and \f(CW\*(C`/pdl_fill_ellipses\*(C'\fR. See also \*(L"pdl_arcs\*(R", \*(L"pdl_chords\*(R", and
\&\*(L"pdl_ellipses\*(R".
.PP
pdl_fill_sectors does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_flood_fills"
.IX Subsection "pdl_flood_fills"
.Vb 2
\&  Prima Signature: (widget; x(); y(); fill_color();
\&                   singleborder(); properties)
.Ve
.PP
Fill a contiguous region.
.PP
\&\s-1NOTE THIS MAY NOT WORK ON MACS\s0! There seems to be a bug in either Prima or
in Mac's X\-windows library that prevents this function from doing its job as
described. That means that flood filling is not cross-platform, at least not
at the moment. This notice will be removed from the latest version of this
documentation as soon as the item is addressed, and it may be that your
version of Prima has a work-around for this problem. At any rate, it only
effects Mac users.
.PP
Applicable properties include colors, backColors, clipRects,
fillPatterns, rops, rop2s, and translates.
.PP
Note that \f(CW\*(C`fill_color\*(C'\fR is probably \fBnot\fR what you think it is. The
color of the final fill is determined by your \f(CW\*(C`colors\*(C'\fR property. What,
then, does \f(CW\*(C`fill_color\*(C'\fR specify? It indicates how Prima is supposed to
perform the fill. If \f(CW\*(C`singleborder\*(C'\fR is zero, then \f(CW\*(C`fill_color\*(C'\fR is the
color of the \fBboundary\fR to which Prima is to fill. In other words, if you had
a bunch of intersecting lines that were all red and you wanted the interior
of those intersecting lines to be blue, you would say something like
.PP
.Vb 1
\& $widget\->pdl_flood_fills($x, $y, cl::Red, 0, colors => cl::Blue);
.Ve
.PP
On the other hand, if \f(CW\*(C`singleborder\*(C'\fR is 1, then the value of \f(CW\*(C`fill_color\*(C'\fR
tells Prima to replace every contiguous pixel \fBof color\fR \f(CW\*(C`fill_color\*(C'\fR with
the new color specified by \f(CW\*(C`colors\*(C'\fR (or the current color, if no \f(CW\*(C`colors\*(C'\fR
piddle is given).
.PP
.Vb 8
\& # Generate a collection of intersecting
\& # circles and triangles
\& my ($width, $height) = $canvas\->size;
\& my $N_items = 20;
\& my $x = random($N_items) * $width;
\& my $y = random($N_items) * $width;
\& $canvas\->pdl_ellipses($x, $y, 20, 20, lineWidths => 3);
\& $canvas\->pdl_symbols($x, $y, 3, 0, 0, 10, 1, lineWidths => 3);
\& 
\& # Fill the interior of those circle/triangle intersections
\& $canvas\->pdl_flood_fills($x, $y, cl::Black, 0);
.Ve
.PP
If you put that snippet of code in the example from the synopsis, you should
see a number of narrow rectangles intersecting circles, with the interior of
both shapes filled. Resizing the window will lead to randomly changed
positions for those space-ship looking things.
.PP
Compare to the Prima method \*(L"flood_fill\*(R" in Prima::Drawable. See also
pdl_clears and the various fill-based drawing methods.
.PP
pdl_flood_fills does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_lines"
.IX Subsection "pdl_lines"
.Vb 1
\&  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)
.Ve
.PP
Draws a line from (x1, y1) to (x2, y2).
.PP
Applicable properties include colors, backColors, clipRects,
lineEnds, lineJoins, linePatterns, lineWidths, rops, rop2s, and translates.
.PP
In contrast to polylines, which are supposed to be connected, these
lines are meant to be independent. Also note that this method does make an
effort to handle bad values, both the \s-1IEEE\s0 sort (nan, inf) and the official
\&\s-1PDL\s0 bad values. See pdl_polylines for a discussion of what might constitute
proper bad value handling.
.PP
.Vb 1
\& working here
.Ve
.PP
Compare to the Prima methods \*(L"lines\*(R" in Prima::Drawable and
\&\*(L"lines\*(R" in Prima::Drawable. See also pdl_polylines.
.PP
pdl_lines processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_polylines"
.IX Subsection "pdl_polylines"
.Vb 1
\&  Prima Signature: (widget; x(n); y(n); properties)
.Ve
.PP
Draws a multi-segment line with the given x\- and y\-coordinates.
.PP
Applicable properties include colors, backColors, clipRects,
lineEnds, lineJoins, linePatterns, lineWidths, rops, rop2s, and translates.
.PP
This method goes to great lengths to Do What You Mean, which is actually
harder than you might have expected. This is the backbone for the Lines
plot type of PDL::Graphics::Prima, so it needs to be able to handle all
manner of strange input. Here is what happens when you specify strange
values:
.IP "\s-1IEEE\s0 nan or \s-1PDL\s0 Bad Value" 4
.IX Item "IEEE nan or PDL Bad Value"
If either of these values are specified in the middle of a line drawing, the
polyline will completely skip this point and begin drawing a new polyline at
the next point.
.IP "both x and y are inf and/or \-inf" 4
.IX Item "both x and y are inf and/or -inf"
There is no sensible way of interpreting what it means for both x and y to
be infinite, so any such point is skipped, just like nan and Bad.
.IP "either x or y is inf or \-inf" 4
.IX Item "either x or y is inf or -inf"
If an x value is infinite (but the paired y value is not), a horizontal line
is drawn from the previous x/y pair out to the edge of a widget; another line
is drawn from the edge to the next x/y pair. The behavior for an infinite y
value is similar, except that the line is drawn vertically.
.Sp
For example, the three points (0, 1), (1, 1), (2, inf), (3, 1), (4, 1) would
be rendered as a line from (0, 1) to (1, 1), then a vertical line straight
up from (1, 1) to the upper edge of the widget or clipping rectangle, then
a vertical line straight down to (3, 1) from the upper edge of the widget or
clipping rectangle, then a horizontal line from (3, 1) to (4, 1).
.IP "x and/or y is a large value" 4
.IX Item "x and/or y is a large value"
If x or y is a large value (say, both x and y are 5e27 when the rest of your
numbers are of the order of 100), it will not be possible to actually show a
renderin of a line to that point. However, it is possible to correctly render
the slope of that point out to the edge of the clipping rectangle. Thus the
slope of the line from within-clip points to large values is faithfully
rendered.
.PP
Here's an example of how to plot data using \f(CW\*(C`pdl_polylines\*(C'\fR (though you'd
do better to use PDL::Graphics::Prima to create plots):
.PP
.Vb 4
\& # Draw a sine curve on the widget:
\& my $x = sequence(200);
\& my $y = ( sin($x / 20) + 1 ) * 50;
\& $canvas\->pdl_polylines($x, $y);
.Ve
.PP
Compare to the Prima method \*(L"polyline\*(R" in Prima::Drawable. See also pdl_lines
and pdl_fillpolys.
.PP
pdl_polylines processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_rectangles"
.IX Subsection "pdl_rectangles"
.Vb 1
\&  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)
.Ve
.PP
Draws a rectangle from corner (x1, y1) to corner (x2, y2).
.PP
Applicable properties include colors, backColors, clipRects,
linePatterns, lineWidths, rops, rop2s, and translates.
.PP
.Vb 8
\& # Draw 20 random rectangles on $canvas:
\& my $N_bars = 20;
\& my ($x_max, $y_max) = $canvas\->size;
\& my $x1s = zeroes($N_bars)\->random * $x_max;
\& my $y1s = $x1s\->random * $y_max;
\& my $x2s = $x1s + $x1s\->random * ($x_max \- $x1s);
\& my $y2s = $y1s + $x1s\->random * ($y_max \- $y1s);
\& my $colors = $x1s\->random * 2**24;
\& 
\& # Now that we\*(Aqve generated the data, call the command:
\& $canvas\->pdl_rectangles($x1s, $y1s, $x2s, $y2s
\&         , colors => $colors);
.Ve
.PP
If you put that snippet of code in the \f(CW\*(C`onPaint\*(C'\fR method, as
suggested in the synopsis, a completely new set of rectangles
will get redrawn whenever you resize your window.
.PP
Compare to the Prima method \*(L"rectangle\*(R" in Prima::Drawable. See also
\&\*(L"pdl_bars\*(R", which is the filled equivalent, and \*(L"pdl_lines\*(R", which
draws a line from (x1, y1) to (x2, y2) instead. Also, there is a Prima
method that does not (yet) have a pdl-based equivalent known as
\&\*(L"rects3d\*(R" in Prima::Drawable, which draws beveled edges around a rectangle.
.PP
pdl_rectangles does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pdl_sectors"
.IX Subsection "pdl_sectors"
.Vb 1
\&  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); start_angle(); end_angle(); properties)
.Ve
.PP
Draws the outlines of sectors, i.e. a pie-slices or Pac-Mans.
.PP
Applicable properties include colors, backColors, clipRects,
lineEnds, linePatterns, lineWidths, rops, rop2s, and translates.
.PP
More specifically, this draws an arc from \f(CW\*(C`start_angle\*(C'\fR to \f(CW\*(C`end_angle\*(C'\fR
along the ellipse centered at \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR, with specified x\- and y\-diameters.
Like \*(L"fill_chords\*(R", this command connects the end points of the arc, but
unlike \*(L"fill_chords\*(R", it does so by drawing two lines, both of which
also connect to the ellipse's center. This results in shapes that look
like pie pieces or pie remnants, depending of whether you're a glass-half-full
or glass-half-empty sort of person.
.PP
.Vb 2
\& # For this example, you will need:
\& use PDL::Char;
\& 
\& # Draw a bunch of random sectors on $canvas:
\& my $N_chords = 20;
\& my ($x_max, $y_max) = $canvas\->size;
\& my $xs = zeroes($N_chords)\->random * $x_max;
\& my $ys = $xs\->random * $y_max;
\& my $dxs = $xs\->random * $x_max / 4;
\& my $dys = $xs\->random * $y_max / 4;
\& my $th_starts = $xs\->random * 360;
\& my $th_stops = $xs\->random * 360;
\& 
\& # make a small list of patterns:
\& my $patterns_list = PDL::Char\->new(
\&          [lp::Solid, lp::Dash, lp::DashDot]);
\& 
\& # Randomly select 20 of those patterns:
\& my $rand_selections = ($xs\->random * 3)\->byte;
\& use PDL::NiceSlice;
\& my $patterns = $patterns_list($rand_selections)\->transpose;
\& 
\& # Now that we\*(Aqve generated the data, call the command:
\& $canvas\->pdl_sectors($xs, $ys, $dxs
\&                , $dys, $th_starts, $th_stops
\&                , linePatterns => $patterns);
.Ve
.PP
Compare to the Prima method \*(L"sector\*(R" in Prima::Drawable. The filled equivalent
is \*(L"pdl_fill_sectors\*(R". There is a whole slew of arc-based drawing methods
including \*(L"pdl_arcs\*(R", \*(L"pdl_chords\*(R", and pdl_ellipses along with their
filled equivalents. You may also be interested in \*(L"spline\*(R" in Prima::Drawable,
which does not yet have a \s-1PDL\s0 interface.
.PP
pdl_sectors does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "PDL-ONLY \s-1METHODS\s0"
.IX Subsection "PDL-ONLY METHODS"
These are drawing methods that have no analogous Prima::Drawable function.
.SS "pdl_symbols"
.IX Subsection "pdl_symbols"
.Vb 1
\&  Signature: (widget; x(); y(); N_points(); orientation(); filled(); size(); skip(); properties)
.Ve
.PP
Draws a wide variety of symbols centered at (x, y).
.PP
Applicable properties include colors, backColors, clipRects, fillPatterns,
fillWindings, lineEnds, linePatterns, lineWidths, rops, rop2s, and translates.
.PP
Through various combinations of \f(CW\*(C`N_points\*(C'\fR, \f(CW\*(C`filled\*(C'\fR, and \f(CW\*(C`skip\*(C'\fR, you can
generate many different regular symbols, including dashes, stars, asterisks,
triangles, and diamonds. You can also specify each symbol's \f(CW\*(C`size\*(C'\fR and
\&\f(CW\*(C`orientation\*(C'\fR. The size is the radius of a circle that would circumscribe
the shape. The orientation is... well... just keep reading.
.PP
The shape drawn depends on \f(CW\*(C`N_points\*(C'\fR. If \f(CW\*(C`N_points\*(C'\fR is:
.IP "zero or one" 4
.IX Item "zero or one"
This will draw a circle with a radius of the
given size. The circle will be filled or not based on the value passed for
\&\f(CW\*(C`filled\*(C'\fR, but the \f(CW\*(C`orientation\*(C'\fR and \f(CW\*(C`skip\*(C'\fR parameters are ignored. This
is almost redundant compared with the ellipse functions, except that this
arrangement makes it very easy to thead over filled/not\-filled, and you
cannot specify an eccentricity for your points using \f(CW\*(C`pdl_symbols\*(C'\fR.
.IP "two" 4
.IX Item "two"
This will draw a line centered at (x, y) and with a length of 2*\f(CW\*(C`size\*(C'\fR.
The \f(CW\*(C`orientation\*(C'\fR is measured in degrees, starting from horizontal, with
increasing angles rotating the line counter-clockwise. The value for \f(CW\*(C`skip\*(C'\fR
is ignored.
.Sp
This is particulary useful for visualizing slope-fields (although calculating
the angles for the slope field is surprisingly tricky).
.IP "three or more" 4
.IX Item "three or more"
This will draw a shape related to a regular polygon with the specified
number of sides. Precisely what kind of polygon it draws is based on the
value of \f(CW\*(C`skip\*(C'\fR. For example, a five-sided polygon with a \f(CW\*(C`skip\*(C'\fR of one
would give you a pentagon:
.Sp
.Vb 12
\&                           second point
\&                               _
\&               third   _\|_..\-\-\*(Aq\*(Aq \e
\&               point  |          \e
\&                      |           \e
\&                      |            \e  first
\&                      |            /  point
\&                      |           /
\&                      |_\|_        /
\&              fourth     \`\`\-\-.._/
\&              point
\&                           fifth point
\&
\&                           skip = 1
.Ve
.Sp
In contrast, a five-sided polygon with a skip of 2 will give you a star:
.Sp
.Vb 1
\&                           fourth point
\&                           
\&              second          /|                
\&              point   \e\`~.._/  |            
\&                       \`\e / \`\-\-|._\|_          
\&                         X     | _\|_>  first point       
\&                       ,/ \e_,\-\-|\*(Aq                
\&              fifth   /_~\*(Aq\*(Aq \e  |                 
\&              point           \e|
\&                            
\&                           third point
\& 
\&                           skip = 2
.Ve
.Sp
A skip of three would give visually identical results but the actual order
in which the vertices are drawn is different:
.Sp
.Vb 1
\&                           third point
\&                           
\&              fifth           /|                
\&              point   \e\`~.._/  |            
\&                       \`\e / \`\-\-|._\|_          
\&                         X     | _\|_>  first point       
\&                       ,/ \e_,\-\-|\*(Aq                
\&              second  /_~\*(Aq\*(Aq \e  |                 
\&              point           \e|
\&                            
\&                           fourth point
\& 
\&                           skip = 3
.Ve
.Sp
A skip of zero is a special case, and means \fIdraw lines to each point from
the center.\fR In other words, create an asterisk:
.Sp
.Vb 1
\&                           second point
\&                               
\&               third            /
\&               point   \`.      / 
\&                         \`.   /   
\&                           \`./_\|_\|_\|_\|_\|_\|_  first
\&                           .\*(Aq\e         point
\&                         .\*(Aq   \e
\&                       .\*(Aq      \e
\&              fourth            \e
\&              point
\&                           fifth point
\& 
\&                           skip = 0
.Ve
.Sp
In summary, a \f(CW\*(C`skip\*(C'\fR of zero gives you an N\-asterisk. A \f(CW\*(C`skip\*(C'\fR of one gives
you a regular polygon. A \f(CW\*(C`skip\*(C'\fR of two gives you a star. And so forth.
Higher values of \f(CW\*(C`skip\*(C'\fR are allowed; they simply add to the winding behavior.
.Sp
Specifying the orientation changes the position of the first point and,
therefore, all subsequent points. A positive orientation rotates the first
point counter-clockwise by the specified number of degrees. Obviously, due
to the symmetry of the shapes, rotations of 360 / N_points look identical to
not performing any rotation.
.Sp
For all nonzero values of \f(CW\*(C`skip\*(C'\fR, specifying a fill will end up with
a filled shape instead of a line drawing.
.PP
By default, filled stars and other symbols with odd numbers of points have a
hole in their middle. However, Prima provides a means for indicating that you
want such shapes filled; that is the \f(CW\*(C`fillWinding\*(C'\fR property. As with almost all
graphical properties, you can specify the \f(CW\*(C`fillWinding\*(C'\fR property for each
symbol by specifying the \f(CW\*(C`fillWindings\*(C'\fR piddle.
.PP
This example creates a table of shapes. It uses an argument from the command
line to determine the line width.
.PP
.Vb 1
\& use PDL::NiceSlice;
\& 
\& # Generate a table of shapes:
\& my @dims = (40, 1, 30);
\& my $N_points = xvals(@dims)\->clump(2) + 1;
\& my $orientation = 0;
\& my $filled = yvals(@dims)\->clump(2) + 1;
\& my $size = 10;
\& my $skip = zvals(@dims)\->clump(2);
\& my $x = $N_points\->xvals * 25 + 25;
\& my $y = $N_points\->yvals * 25 + 25;
\& my $lineWidths = $ARGV[0] || 1;
\& 
\& # Draw them:
\& $canvas\->pdl_symbols($x, $y, $N_points, 0, $filled, 10, $skip
.Ve
.PP
Bad values are handled by \f(CW\*(C`pdl_symbols\*(C'\fR. If any of the values you pass in
are bad, the symbol is not drawn at that x/y coordinate.
.PP
pdl_symbols processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SH "ERROR MESSAGE"
.IX Header "ERROR MESSAGE"
These functions may throw the following exception:
.SS "Your widget must be derived from Prima::Drawable"
.IX Subsection "Your widget must be derived from Prima::Drawable"
This means that you tried to draw on something that is not a Prima::Drawable
object, or a class derived from it. I don't know enough about the Prima
internals to know if that has any hope of working, but why do it in the first
place?
.SH "PDL::PP DETAILS"
.IX Header "PDL::PP DETAILS"
Those well versed in \s-1PDL::PP\s0 might ask how I manage to produce pdlified methods
that take variable numbers of arguments. That is a long story, and it is told in
the volumes of comments in pdlprima.pd. Give it a read if you want to know what
goes on behind the scenes.
.SH "TODO"
.IX Header "TODO"
These are all the things I wish to do:
.IP "Full Drawabel \s-1API\s0" 4
.IX Item "Full Drawabel API"
I would like a \s-1PDL\s0 function for every drawable function in the \s-1API.\s0
Prima Drawable functions that currently do not have an equivalent \s-1PDL\s0
implementation include \*(L"draw_text\*(R" in Prima::Drawable,
\&\*(L"fill_spline\*(R" in Prima::Drawable, \*(L"put_image\*(R" in Prima::Drawable,
\&\*(L"put_image_indirect\*(R" in Prima::Drawable, \*(L"rect3d\*(R" in Prima::Drawable,
\&\*(L"rect_focus\*(R" in Prima::Drawable, \*(L"spline\*(R" in Prima::Drawable,
\&\*(L"stretch_image\*(R" in Prima::Drawable, and \*(L"text_out\*(R" in Prima::Drawable
.IP "Bad Value Support" 4
.IX Item "Bad Value Support"
Bad values are handled decently in \*(L"polylines\*(R" and \*(L"fillpolys\*(R", but not for
the other functions. Bad x/y values should be skipped for almost all the drawing
primitives, but what about bad colors for valid coordinates? I could not draw
the primitive, defer to the widget's default color, or use the value associated
with the singular key (i.e. \f(CW\*(C`color\*(C'\fR). But I haven't decided which of these is
best.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Mertens, <dcmertens.perl@gmail.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Some useful PDL/Prima functions are defined in PDL::Drawing::Prima::Utils,
especially for converting among simple color formats.
.PP
This is built as an extension for the Prima toolkit, http://www.prima.eu.org/, Prima.
.PP
This is built using (and targeted at users of) the Perl Data Language, \s-1PDL\s0.
.PP
This is the bedrock for the plotting package PDL::Graphics::Prima.
.PP
Another interface between \s-1PDL\s0 and Prima is <PDL::PrimaImage>. I am indebted to
Dmitry for that module because it gave me a working template for this module,
including a working Makefile.PL. Thanks Dmitry!
