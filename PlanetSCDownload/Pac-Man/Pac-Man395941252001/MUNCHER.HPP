#ifndef _PCMANMUNCHER_
#define _PCMANMUNCHER_
#include"e:\tcc\bin\pcman\eater.hpp"
const char mRight[] = {
0x04,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,
0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x00,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
const char mLeft[] = {
0x04,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x00,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
0x00,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
const char mDown[] = {
0x04,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x00,
0x00,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x0E,0x0E,0x00,0x00,
0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00
};
const char mUp[] = {
0x04,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,
0x00,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x0E,0x0E,0x00,0x00,
0x00,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x00,0x00,
0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,
0x00,0x00,0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00
};

/*void Eater::blastEaters() {
	status = BLASTED;
	count = 1;
}*/
class Muncher{
	int mx,my;
	PicturePtr mu,mr,md,ml;
	public:
		Muncher();
		~Muncher();
		void resetPosition();
		int isPossible(int);
		 int moveUp();
		 int moveLeft();
		 int moveRight();
		 int moveDown();
		void getXY(int&,int&);
};

Muncher::Muncher() {
	mx = 11;
	my = 9;
	mu = new Picture(MUNCHSZ,mUp);
	mr = new Picture(MUNCHSZ,mRight);
	md = new Picture(MUNCHSZ,mDown);
	ml = new Picture(MUNCHSZ,mLeft);
}

Muncher::~Muncher() {
	mx = 0;
	my = 0;
	if(mu) delete mu;
	if(mr) delete mr;
	if(md) delete md;
	if(ml) delete ml;
}

void Muncher::resetPosition() {
//	mr->clearPicture(mx,my);
	mx = 11;
	my = 9;
	mr->displayPicture(mx,my);
}

inline void Muncher::getXY(int& x,int& y) {
	x = mx;
	y = my;
}

int Muncher::isPossible(int dir) {
int returnValue = 1;
      switch(dir) {
	case UPDIR :
		returnValue = (Level::getValue(mx,my-1)!=1);
		break;
	case DOWNDIR:
		returnValue = (Level::getValue(mx,my+1)!=1);
		break;
	case RIGHTDIR:
		returnValue = (Level::getValue(mx+1,my)!=1);
		break;
	case LEFTDIR:
		returnValue = (Level::getValue(mx-1,my)!=1);
		break;
      }
return returnValue;
//to make sure a turning takes place only at the corner (a multiple of PICSIZE)
 //this is true. Think about it till u r sure if you change it.
}

 int Muncher::moveUp(void) {
	switch(Level::getValue(mx,my-1)) {
		case 2:
			Level::decrement();
			Level::setValue(mx,my-1,0);
			sound(200);delay(14);nosound();
			//no break required here.
		case 0:
			mu->clearPicture(mx,my);
			mu->displayPicture(mx,--my);
			break;
		case 5:
			Eater::blastEaters();
			sound(700);delay(60);nosound();
			mu->clearPicture(mx,my);
			mu->displayPicture(mx,--my);
			break;
		case 1: break;
		default : break;
	}
	return (Level::getPixelCount()==0);
}

 int Muncher::moveDown(void) {
	switch(Level::getValue(mx,my+1)) {
		case 2:
			Level::decrement();
			Level::setValue(mx,my+1,0);
			sound(200);delay(4);nosound();
			//no break required here.
		case 0:
			md->clearPicture(mx,my);
			md->displayPicture(mx,++my);
			break;
		case 5:
			Eater::blastEaters();
			sound(700);delay(60);nosound();
			mu->clearPicture(mx,my);
			mu->displayPicture(mx,++my);
			break;
		case 1: break;
		default : break;
	}
	return (Level::getPixelCount()==0);
}

 int Muncher::moveRight(void) {
	switch(Level::getValue(mx+1,my)) {
		case 2:
			Level::decrement();
			Level::setValue(mx+1,my,0);
			sound(200);delay(4);nosound();
			//no break required here.
		case 0:
			mr->clearPicture(mx,my);
			mr->displayPicture(++mx,my);
			break;
		case 5:
			Eater::blastEaters();
			sound(700);delay(60);nosound();
			mu->clearPicture(mx,my);
			mu->displayPicture(++mx,my);
			break;
		case 1: break;
		default : break;
	}
	return (Level::getPixelCount()==0);
}

 int Muncher::moveLeft(void) {
	switch(Level::getValue(mx-1,my)) {
		case 2:
			Level::decrement();
			Level::setValue(mx-1,my,0);
			sound(200);delay(4);nosound();
			//no break required here.
		case 0:
			ml->clearPicture(mx,my);
			ml->displayPicture(--mx,my);
			break;
		case 5:
			Eater::blastEaters();
			sound(700);delay(60);nosound();
			mu->clearPicture(mx,my);
			mu->displayPicture(--mx,my);
			break;
		case 1: break;
		default : break;
	}
	return (Level::getPixelCount()==0);
}

#endif