#ifndef _PCMANEATER_
#define _PCMANEATER_
#include"e:\tcc\bin\pcman\extra.hpp"
#include<stdlib.h>
#define NORMAL  24
#define BLASTED 13
#define EATSZ   12
const char eaterr[] = {
0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,
0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x04,0x04,0x0F,0x0F,0x04,0x04,0x04,0x04,0x0F,0x0F,0x04,0x04,
0x04,0x00,0x00,0x0F,0x0F,0x04,0x04,0x00,0x00,0x0F,0x0F,0x04,
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x04,0x04,0x00,0x04,0x00,0x04,0x04,0x00,0x04,0x00,0x04,0x04,
0x04,0x04,0x00,0x04,0x00,0x04,0x04,0x00,0x04,0x00,0x04,0x04,
0x04,0x00,0x04,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x04,0x00
};
const char eaterg[] = {
0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,
0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x0F,0x0F,0x02,0x02,0x02,0x02,0x0F,0x0F,0x02,0x02,
0x02,0x00,0x00,0x0F,0x0F,0x02,0x02,0x00,0x00,0x0F,0x0F,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x00,0x02,0x00,0x02,0x02,0x00,0x02,0x00,0x02,0x02,
0x02,0x02,0x00,0x02,0x00,0x02,0x02,0x00,0x02,0x00,0x02,0x02,
0x02,0x00,0x02,0x00,0x00,0x02,0x00,0x02,0x00,0x00,0x02,0x00
};
const char eaterb[] = {
0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,
0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x0F,0x0F,0x03,0x03,0x03,0x03,0x0F,0x0F,0x03,0x03,
0x03,0x00,0x00,0x0F,0x0F,0x03,0x03,0x00,0x00,0x0F,0x0F,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x00,0x03,0x00,0x03,0x03,0x00,0x03,0x00,0x03,0x03,
0x03,0x03,0x00,0x03,0x00,0x03,0x03,0x00,0x03,0x00,0x03,0x03,
0x03,0x00,0x03,0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x03,0x00
};
const char eaterdb[] = {
0x00,0x00,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x00,0x00,
0x00,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x00,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x0F,0x0F,0x07,0x07,0x07,0x07,0x0F,0x0F,0x07,0x07,
0x07,0x00,0x00,0x0F,0x0F,0x07,0x07,0x00,0x00,0x0F,0x0F,0x07,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x00,0x07,0x00,0x07,0x07,0x00,0x07,0x00,0x07,0x07,
0x07,0x07,0x00,0x07,0x00,0x07,0x07,0x00,0x07,0x00,0x07,0x07,
0x07,0x00,0x07,0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x07,0x00
};
class Eater{
	int ex,ey;
	int bex,bey;
	int pdir;
	static char status;
	static int count;
	int working;
	static int workCount;
	PicturePtr eater;
	static Picture blastedEater;
	Muncher* target;
	public:
		Eater(const char*,Muncher*);
		~Eater();
		void resetPosition();
		void clearPosition();
		void sendHome(int,int);
		int isPossible(int);
		static void blastEaters();
		int checkGameStatus();
		void move(int);
		void init1();
		void init2();
		 int attack1();
		 int attack2();
		 int attack3();
		void getXY(int&,int&);
};

char Eater::status = NORMAL;
int Eater::count = 0;
int Eater::workCount = 0;
Picture Eater::blastedEater(EATSZ,eaterdb);

Eater::Eater(const char* pptr,Muncher* tgt) {
	eater = new Picture(EATSZ,pptr);
	ex = 0;
	ey = 0;
	pdir = RIGHT;
	target = tgt;
	working = 0;
}

Eater::~Eater() {
	if(eater) delete eater;
	ex = 0;
	ey = 0;
	count = 0;
	pdir = 0;
	eater = 0;
	target = 0;
	working = 0;
}
void Eater::clearPosition() {
	eater->clearPicture(ex,ey);
	Extras::displayExtra(ex,ey);
}

void Eater::sendHome(int a,int b) {
	ex = bex = a;
	ey = bey = b;
	eater->displayPicture(ex,ey);
	working = 0;
}

void Eater::resetPosition() {
	eater->clearPicture(ex,ey);
	ex = 11;
	ey = 5;
//	eater->displayPicture(ex,ey);
	if(status == NORMAL)
		eater->displayPicture(ex,ey);
	else blastedEater.displayPicture(ex,ey);
	working = 1;
}

inline void Eater::getXY(int& x,int& y) {
	x = ex;
	y = ey;
}

int Eater::isPossible(int dir) {
int returnValue = 1;
      switch(dir) {
	case UP :
//		if(ey%PICSIZE == 0)
		returnValue = (Level::getValue(ex,ey-1)!=1);
//		else return 0;
		break;
	case DOWN:
//		if(ey%PICSIZE == 0)
		returnValue = (Level::getValue(ex,ey+1)!=1);
//		else return 0;
		break;
	case RIGHT:
//		if(ex%PICSIZE == 0)
		returnValue = (Level::getValue(ex+1,ey)!=1);
//		else return 0;
		break;
	case LEFT:
//		if(ex%PICSIZE == 0)
		returnValue = (Level::getValue(ex-1,ey)!=1);
//		else return 0;
		break;
      }
//to make sure a turning takes place only at the corner (a multiple of PICSIZE)
   return returnValue;
//this is true. Think about it till u r sure if you change it.
}

void Eater::blastEaters() {
	status = BLASTED;
	count = 1;
}

void Eater::move(int dir) {
// 65 i.e waiting for approx 8 secs.
if(count == 0 || count == 78) {
       count = 0; status = NORMAL;
}
else count++;
	switch(dir) {
		case UP :
			eater->clearPicture(ex,ey);
			Extras::displayExtra(ex,ey);
			if(status == NORMAL)
			eater->displayPicture(ex,--ey);
			else blastedEater.displayPicture(ex,--ey);
			break;
		case DOWN :
			eater->clearPicture(ex,ey);
			Extras::displayExtra(ex,ey);
			if(status == NORMAL)
			eater->displayPicture(ex,++ey);
			else blastedEater.displayPicture(ex,++ey);
			break;
		case RIGHT :
			eater->clearPicture(ex,ey);
			Extras::displayExtra(ex,ey);
			if(status == NORMAL)
			eater->displayPicture(++ex,ey);
			else blastedEater.displayPicture(++ex,ey);
			break;
		case LEFT :
			eater->clearPicture(ex,ey);
			Extras::displayExtra(ex,ey);
			if(status == NORMAL)
			eater->displayPicture(--ex,ey);
			else blastedEater.displayPicture(--ex,ey);
			break;
	}
}

void Eater::init1() {
	if(pdir == UP || pdir == DOWN) {
		if(isPossible(RIGHT)) pdir = RIGHT;
		if(isPossible(LEFT)) pdir = LEFT;
	}
	else {
		if(isPossible(UP)) pdir = UP;
		if(isPossible(DOWN)) pdir = DOWN;
	}
	this->move(pdir);
}

void Eater::init2() {
	if(pdir == UP || pdir == DOWN) {
		if(isPossible(LEFT)) pdir = LEFT;
		if(isPossible(RIGHT)) pdir = RIGHT;
	}
	else {
		if(isPossible(DOWN)) pdir = DOWN;
		if(isPossible(UP)) pdir = UP;
	}
	this->move(pdir);
}

int Eater::checkGameStatus() {
	int mx,my;
	target->getXY(mx,my);
	if(mx == ex && my == ey) {
		if(status == NORMAL) {
				sound(600);delay(100);sound(350);delay(100);
				sound(200);delay(200);
				nosound();
				return 1;
		}
		else {
			sound(200);delay(200);sound(500);delay(300);nosound();
			sendHome(bex,bey);
		}
	}
	return 0;
}

int Eater::attack1() {
	if(checkGameStatus()) return 1;
	if(working == 0) {
		workCount++;
		if(workCount%40 == 0) { workCount++; resetPosition(); }
		return 0;
	}
	if(random(100)%4 == 0) init1();
	else init2();
	if(checkGameStatus()) return 1;
	return 0;
}

int Eater::attack2() {
	if(checkGameStatus()) return 1;
	if(working == 0) {
		workCount++;
		if(workCount%40 == 0) { workCount++; resetPosition(); }
		return 0;
	}
	int x = random(100)%5;
	if( x == 2 || x == 3) init2();
	else init1();
	if(checkGameStatus()) return 1;
	return 0;
}

int Eater::attack3() {
	if(checkGameStatus()) return 1;
	if(working == 0) {
		workCount++;
		if(workCount%40 == 0) { resetPosition(); workCount++; }
		return 0;
	}
	int x = random(100)%7;
	if(x&1 == 1) init1();
	else init2();
	if(checkGameStatus()) return 1;
	return 0;

#endif